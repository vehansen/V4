/*	V4IMU.C - Internal Module - Utility Modules

	Created 11-Feb-97 by Victor E. Hansen			*/


#define V4IMTags
#define V4IMMods
#include <time.h>
#include <signal.h>
#include "v4imdefs.c"
#ifdef UNIX
#include <unistd.h>
#include <pthread.h>
#endif
#ifdef WINNT
#include <process.h>
#endif

LOGICAL v4rh_FormatSpecToNewV4R(struct V4C__Context *,INDEX,PNTTYPE,struct V4SS__FormatSpec *,INDEX,LOGICAL) ;
V4DEBUG_SETUP


GLOBALDIMSEXTERN
extern struct V4C__ProcessInfo *gpi ;	/* Global process information */
extern struct V4SS__DimToFormatMap *vdfm ;
extern struct V__UnicodeInfo *uci ;	/* Global structure of Unicode Info */
extern int opcodeDE[] ;
extern struct V4DPI__LittlePoint CondEvalRet ;
extern ETYPE traceGlobal ;
#define ISVAL(pt) !((pt->PntType == V4DPI_PntType_Isct) || (pt->PntType == V4DPI_PntType_Special))
#define ONCE(param) if (param != NULL) { ok = FALSE ; v_Msg(ctx,ctx->ErrorMsgAux,"ModArgOnce",intmodx) ; break ; } ;
#define ONCEU(param) if (param >= 0) { ok = FALSE ; v_Msg(ctx,ctx->ErrorMsgAux,"ModArgOnce",intmodx) ; break ; } ;

#define optMax 0x4fff

/*	v4im_ListCache_BuildMap - Builds up a bitmap in vlc->wlbm[]	*/

LOGICAL v4im_ListCache_BuildMap(ctx,vlc,workx,srcx,isct,action)
  struct V4C__Context *ctx ;
  struct V4IM__ListCache *vlc ;
  struct V4DPI__Point *isct ;
  INDEX workx,srcx ;
  ETYPE action ;
{
  struct V4L__ListPoint *lp ;
  struct V4DPI__DimInfo *di ;
  struct V4DPI__Point spnt,lpnt,*tpt ;
  struct V4IM__ListBitMap *wlbm ;
  struct V4IM__ListBitMap *elbm ;
  struct V4IM__ListBitMap *lbm ;
  int i,hash,hx,*hp,x,b,num ;

	vlc->StatBuildMap++ ;
	if (workx < 0 || workx >= V4IM_ListCache_WorkMax || (srcx != UNUSED ? (srcx < 0 || srcx >= V4IM_ListCache_WorkMax) : FALSE))
	 { v_Msg(ctx,ctx->ErrorMsgAux,"ListBuildMap",workx,srcx,V4IM_ListCache_WorkMax-1) ; return(FALSE) ; } ;
	wlbm = vlc->wlbm[workx] ;
	if (action == V4IM_ListCacheAct_Intersect)	/* If intersection then see if wlbm has any bits */
	 { if (wlbm->SetCount == UNUSED)		/* Don't know yet - have to start counting */
	    { vlc->StatNullTest++ ;
	      for(i=0;i<wlbm->BitWCount;i++) { if (wlbm->Bits[i] != 0) break ; } ;
	      wlbm->SetCount = (i < wlbm->BitWCount ? 1 : 0) ;
	    } ;
	   if (wlbm->SetCount == 0) { vlc->StatNullIntersect++ ; return(TRUE) ; } ;	/* If 0 bits in wlbm, then intersect gonna result in 0 */
	 } ;
	if (srcx != UNUSED) { elbm = vlc->wlbm[srcx] ; goto got_elbm ; } ;
/*	Have to do some real work, see if isct in hash table already */
	hp = (int *)isct ;
	for(i=0,hash=0;i<(int)(isct->Bytes/(sizeof (int)));i++) { hash += *(hp++) ; } ;
	if (hash == 0) hash = 1 ;
	hx = (hash & 0x7fffffff) % V4IM_ListCache_EntryMax ;
	for(;;hx=(hx+1)%V4IM_ListCache_EntryMax)
	 { if (vlc->Entry[hx].PtHash == 0) break ;
	   if (vlc->Entry[hx].PtHash != hash) continue ;
	   if (memcmp(vlc->Entry[hx].Pt,isct,isct->Bytes) == 0) break ;
	 } ;
/*	Did we find it - if not then have to load it up */
	if (vlc->Entry[hx].PtHash == 0)
	 { if (++vlc->Count >= V4IM_ListCache_EntryMax - 10)
	    { v_Msg(ctx,ctx->ErrorMsgAux,"ListIntCache",V4IM_ListCache_EntryMax) ; return(FALSE) ; } ;
	   vlc->Entry[hx].PtHash = hash ;
	   vlc->Entry[hx].Pt = (P *)v4mm_AllocChunk(isct->Bytes,FALSE) ; memcpy(vlc->Entry[hx].Pt,isct,isct->Bytes) ;
	   if ((tpt = v4dpi_IsctEval(&spnt,isct,ctx,V4DPI_EM_EvalQuote,NULL,NULL)) == NULL)
	    { v_Msg(ctx,ctx->ErrorMsgAux,"ListEvalFail",isct) ; return(FALSE) ; } ;
	   lp = v4im_VerifyList(NULL,ctx,tpt,0) ;
	   di = (struct V4DPI__DimInfo *)v4dpi_DimInfoGet(ctx,lp->Dim) ;
	   if (di == NULL) { v_Msg(ctx,ctx->ErrorMsgAux,"ListCacheNoDim") ; return(FALSE) ; } ;
	   if (lp->PntType != V4DPI_PntType_Int)
	    { v_Msg(ctx,ctx->ErrorMsgAux,"ListBadPntType",di->DimId) ; return(FALSE) ; } ;
	   num = v4dpi_DimUniqueNumPoints(ctx,di->DimId) ;	/* Get max number of points in dimension */
	   if (num == UNUSED) { v_Msg(ctx,ctx->ErrorMsgAux,"DimExpPoints",di->DimId) ; return(FALSE) ; } ;
	   lbm = (struct V4IM__ListBitMap *)v4mm_AllocChunk(sizeof *lbm,FALSE) ; vlc->Entry[hx].lbm = lbm ;
	   lbm->BitWCount = (num + 31) / 32 ; lbm->MaxBits = lbm->BitWCount * 32 ; lbm->SetCount = 0 ;
	   lbm->Bits = (int *)v4mm_AllocChunk(lbm->BitWCount*4,TRUE) ;
	   lbm->Dim = di->DimId ; lbm->PntType = di->PointType ;
	   for(i=1;v4l_ListPoint_Value(ctx,lp,i,&lpnt) > 0;i++)
	    { if (lpnt.PntType != V4DPI_PntType_Int || lpnt.Value.IntVal < 1 || lpnt.Value.IntVal > lbm->MaxBits)
	       { v_Msg(ctx,ctx->ErrorMsgAux,"ListNotSubSet",&lpnt,lbm->MaxBits) ; return(FALSE) ; } ;
	      x = lpnt.Value.IntVal / 32 ; b = lpnt.Value.IntVal % 32 ;
	      lbm->Bits[x] |= (1 << (b-1)) ; lbm->SetCount++ ;
	    } ;
	   vlc->StatBuildMapLoad ++ ;
	 } ;
	elbm = vlc->Entry[hx].lbm ;
/*	Got entry bitmap (elbm) - merge into working bitmap (wlbm) */
got_elbm:
	if (wlbm != NULL ? wlbm->MaxBits < elbm->MaxBits : FALSE)
	 { v4mm_FreeChunk(wlbm) ; wlbm = NULL ; } ;	/* Maybe have to reallocate map? */
	if (wlbm == NULL)				/* First time? then set up bitmap */
	 { vlc->wlbm[workx] = (struct V4IM__ListBitMap *)v4mm_AllocChunk(sizeof *wlbm,TRUE) ;
	   wlbm = vlc->wlbm[workx] ;
	   wlbm->Bits = (int *)v4mm_AllocChunk((elbm->MaxBits)/8+3,FALSE) ;
	   wlbm->BitWCount = elbm->BitWCount ; wlbm->SetCount = UNUSED ; wlbm->MaxBits = elbm->MaxBits ;
	   wlbm->Dim = elbm->Dim ; wlbm->PntType = elbm->PntType ;
	 } ;
	switch (action)
	 { default:
	   case V4IM_ListCacheAct_Init:
		memcpy(wlbm->Bits,elbm->Bits,elbm->MaxBits/8) ; wlbm->BitWCount = elbm->BitWCount ;
		wlbm->SetCount = elbm->SetCount ; break ;	
	   case V4IM_ListCacheAct_Union:
		if (wlbm->BitWCount != elbm->BitWCount) goto bit_error ;
		for(i=0;i<elbm->BitWCount;i++) wlbm->Bits[i] |= elbm->Bits[i] ; break ;
	   case V4IM_ListCacheAct_Intersect:
		if (wlbm->BitWCount != elbm->BitWCount) goto bit_error ;
		wlbm->SetCount = 0 ;
		for(i=0;i<elbm->BitWCount;i++)
		 { if ((wlbm->Bits[i] &= elbm->Bits[i]) != 0) wlbm->SetCount++ ; } ;
		break ;
	   case V4IM_ListCacheAction_Subtract:
		if (wlbm->BitWCount != elbm->BitWCount) goto bit_error ;
		for(i=0;i<elbm->BitWCount;i++) wlbm->Bits[i] &= ~elbm->Bits[i] ; break ;
	   case V4IM_ListCacheAction_XUnion:
		if (wlbm->BitWCount != elbm->BitWCount) goto bit_error ;
		for(i=0;i<elbm->BitWCount;i++) wlbm->Bits[i] ^= elbm->Bits[i] ; break ;
	 } ;
/*	All is well */
	return(TRUE) ;

bit_error:
	v_Msg(ctx,ctx->ErrorMsgAux,"ListCacheSize",wlbm->BitWCount*32,elbm->BitWCount*32) ;
	return(FALSE) ;
}

/*	v4im_ListCache_BuildList - Creates V4 list based on bitmap in vlc->wlbm[0] */

P *v4im_ListCache_BuildList(ctx,vlc,respnt,intmodx)
  struct V4C__Context *ctx ;
  struct V4IM__ListCache *vlc ;
  struct V4DPI__Point *respnt ;
  INTMODX intmodx ;
{
  struct V4DPI__LittlePoint lpnt ;
  struct V4IM__ListBitMap *lbm ;
  struct V4L__ListPoint *lp ;
  int i,j,w,b ;

	lbm = vlc->wlbm[0] ;
	ZPH(&lpnt) ; lpnt.Dim = lbm->Dim ; lpnt.PntType = lbm->PntType ; lpnt.Bytes = V4PS_Int ;
	INITLP(respnt,lp,Dim_List) ;
	if (lbm->SetCount != 0)			/* If we know it's empty then don't check for bits */
	 { for(i=0;i<lbm->BitWCount;i++)
	    { w = lbm->Bits[i] ;
	      for(j=0;w != 0 && j < 32;j++)
	       { b = (1 << j) ; if ((w & b) == 0) continue ;
	         w &= ~b ;
		 lpnt.Value.IntVal = (i * 32) + j + 1 ;
		 if (!v4l_ListPoint_Modify(ctx,lp,V4L_ListAction_Append,(P *)&lpnt,0)) { v_Msg(ctx,NULL,"LPModFail",intmodx) ; return(NULL) ; } ;
	       } ;
	    } ;
	 } ;
	ENDLP(respnt,lp) ;
	return(respnt) ;
}


#ifdef WANTSET
/*	v4imu_Set - Handles Set() IntMod		*/

P *v4im_DoSet(ctx,respnt,argpnts,argcnt,intmodx,trace)
  struct V4C__Context *ctx ;
  INTMODX intmodx ;
  P *respnt,*argpnts[] ;
  COUNTER argcnt ; VTRACE trace ;
{ P *ipt,pnt,isct,*ept ;
  struct V4L__ListPoint *lp ;
  struct V4DPI__Point_IntMix *pim ;
  static struct V4IM__ListCache *vlc ;
  int ok,i,j,ibytes,t ;

	if (vlc == NULL) { vlc = (struct V4IM__ListCache *)v4mm_AllocChunk(sizeof *vlc,TRUE) ; } ;
	lp = NULL ;
	if (argpnts[1]->PntType != V4DPI_PntType_Isct) { v_Msg(ctx,NULL,"ModArgQIsct",intmodx,1) ; goto fail ; } ;
	for(i=2,ok=TRUE;ok&&i<=argcnt;i++)
	 { 
	   switch (t=v4im_CheckPtArgNew(ctx,argpnts[i],&ipt,&pnt))
	    { default:			v_Msg(ctx,NULL,"TagBadUse",intmodx) ; goto fail ;
	      case V4IM_Tag_Unk:	v_Msg(ctx,NULL,"TagUnknown",intmodx) ; goto fail ;
	      case V4IM_Tag_List:	lp = v4im_VerifyList(NULL,ctx,ipt,intmodx) ; break ;
	    } ;
	 } ;
	if (!ok) { v_Msg(ctx,NULL,"ModInvArg",intmodx,i-1) ; goto fail ; } ;
	if (lp == NULL) { v_Msg(ctx,NULL,"ModNoList",intmodx) ; goto fail ; } ;

	memcpy(&isct,argpnts[1],argpnts[1]->Bytes) ;
	ept = ISCT1STPNT(&isct) ; for(i=1;i<=isct.Grouping;i++) { ADVPNT(ept) ; } ;
	ibytes = argpnts[1]->Bytes ; isct.Grouping ++ ; isct.Bytes += V4PS_Int ;
	pim = (struct V4DPI__Point_IntMix *)&pnt.Value ;
/*	Go thru each point in list, convert to isct & call set/bitmap handler */
	for(i=1;;i++)
	 { if (v4l_ListPoint_Value(ctx,lp,i,&pnt) <= 0) break ;
	   for(j=1;;j++)
	    { if (pnt.Grouping == V4DPI_Grouping_Single)
	       { memcpy(ept,&pnt,pnt.Bytes) ; isct.Bytes = ibytes + pnt.Bytes ; 
	       } else
	       { if (pim->Entry[j-1].BeginInt != pim->Entry[j-1].EndInt)
		  { v_Msg(ctx,NULL,"ListBadRange",intmodx,pim->Entry[j-1].BeginInt,pim->Entry[j-1].EndInt) ; goto fail ; } ;
		 memcpy(ept,&pnt,V4DPI_PointHdr_Bytes) ; ept->Value.IntVal = pim->Entry[j-1].BeginInt ;
		 ept->Grouping = V4DPI_Grouping_Single ; ept->Bytes = V4PS_Int ;
	       } ;
	      if (!v4im_ListCache_BuildMap(ctx,vlc,0,UNUSED,&isct,(i == 1 && j == 1 ? V4IM_ListCacheAct_Init : V4IM_ListCacheAct_Intersect)))
	       { v_Msg(ctx,NULL,"ModFailed2",intmodx) ; goto fail ; } ;
	      if (j >= pnt.Grouping) break ;
	    } ;
	 } ;
/*	All done - return V4 list */
{ static int cnt=0,itime,stime,t ; if (cnt == 0) stime = (itime = time(NULL)) ;
if (((++cnt) % 5000) == 0)
 { t = time(NULL) ;
   printf("%d Builds=%d, Loads=%d, Test=%d, Nulls=%d, Seconds=+%d (%d)\n",cnt,vlc->StatBuildMap,vlc->StatBuildMapLoad,vlc->StatNullTest,vlc->StatNullIntersect,t-itime,t-stime) ;
   itime = t ;
 } ;
}
	respnt = v4im_ListCache_BuildList(ctx,vlc,respnt,intmodx) ; if (respnt == NULL) goto fail ;
	return(respnt) ;

fail:	REGISTER_ERROR(0) ; return(NULL) ;
}
#endif

/*	v4im_PTName - Returns string name of point type		*/

UCCHAR *v4im_PTName(pnttype)
  int pnttype ;
{ static UCCHAR buf[16] ;
  enum DictionaryEntries ex ;

	switch (pnttype)
	 { default:				UCsprintf(buf,sizeof buf,UClit("?%d"),pnttype) ; return(buf) ;
	   case V4DPI_PntType_AggRef:		ex = _AggRef ; break ;
	   case V4DPI_PntType_Char:		ex = _Alpha ; break ;
	   case V4DPI_PntType_BigText:		ex = _BigText ; break ;
	   case V4DPI_PntType_BinObj:		ex = _Binary ; break ;
	   case V4DPI_PntType_Calendar:		ex = _Calendar ; break ;
	   case V4DPI_PntType_CodedRange:	ex = _CodedRange ; break ;
	   case V4DPI_PntType_Color:		ex = _Color ; break ;
	   case V4DPI_PntType_Complex:		ex = _Complexx ; break ;
	   case V4DPI_PntType_Country:		ex = _Country ; break ;
	   case V4DPI_PntType_UDT:		ex = _DateTime ; break ;
	   case V4DPI_PntType_Delta:		ex = _Delta ; break ;
	   case V4DPI_PntType_Dict:		ex = _Dictionary ; break ;
	   case V4DPI_PntType_Drawer:		ex = _Drawer ; break ;
	   case V4DPI_PntType_XDict:		ex = _External ; break ;
	   case V4DPI_PntType_Fixed:		ex = _Fixed ; break ;
	   case V4DPI_PntType_GeoCoord:		ex = _GeoCoord ; break ;
	   case V4DPI_PntType_IMArg:		ex = _IMArg ; break ;
	   case V4DPI_PntType_Int:		ex = _Integer ; break ;
	   case V4DPI_PntType_Int2:		ex = _Int2 ; break ;
	   case V4DPI_PntType_Isct:		ex = _Intersection ; break ;
	   case V4DPI_PntType_IntMod:		ex = _IntMod ; break ;
	   case V4DPI_PntType_List:		ex = _List ; break ;
	   case V4DPI_PntType_Logical:		ex = _Logical ; break ;
	   case V4DPI_PntType_MemPtr:		ex = _MemPtr ; break ;
	   case V4DPI_PntType_ParsedJSON:	ex = _JSON ; break ;
	   case V4DPI_PntType_XDB:		ex = _XDB ; break ;
	   case V4DPI_PntType_OSHandle:		ex = _OSHandle ; break ;
	   case V4DPI_PntType_PntIdx:		ex = _PointReference ; break ;
	   case V4DPI_PntType_Real:		ex = _Real ; break ;
	   case V4DPI_PntType_RegExpPattern:	ex = _RegularExpression ; break ;
	   case V4DPI_PntType_Shell:		ex = _Shell ; break ;
	   case V4DPI_PntType_Special:		ex = _Special ; break ;
	   case V4DPI_PntType_SSVal:		ex = _SSVal ; break ;
	   case V4DPI_PntType_SymDef:		ex = _DollarSym ; break ;
	   case V4DPI_PntType_FrgnStructEl:	ex = _StructEl ; break ;
	   case V4DPI_PntType_TagVal:
	   case V4DPI_PntType_Tag:		ex = _TagVal ; break ;
	   case V4DPI_PntType_TeleNum:		ex = _TelephoneNumber ; break ;
	   case V4DPI_PntType_Time:		ex = _Time ; break ;
	   case V4DPI_PntType_Tree:		ex = _Tree ; break ;
	   case V4DPI_PntType_UDate:		ex = _UDate ; break ;
	   case V4DPI_PntType_UMonth:		ex = _UMonth ; break ;
	   case V4DPI_PntType_UOM:		ex = _UOM ; break ;
	   case V4DPI_PntType_UOMPer:		ex = _UOMPer ; break ;
	   case V4DPI_PntType_UOMPUOM:		ex = _UOMPUOM ; break ;
	   case V4DPI_PntType_UPeriod:		ex = _UPeriod ; break ;
	   case V4DPI_PntType_UQuarter:		ex = _UQuarter ; break ;
	   case V4DPI_PntType_URL:		ex = _URL ; break ;
	   case V4DPI_PntType_UTime:		ex = _UTime ; break ;
	   case V4DPI_PntType_UWeek:		ex = _UWeek ; break ;
	   case V4DPI_PntType_UYear:		ex = _UYear ; break ;
	   case V4DPI_PntType_V4IS:		ex = _V4IS ; break ;
	   case V4DPI_PntType_UCChar:		ex = _UCChar ; break ;
	 } ;

	return(v4im_GetEnumToUCVal(ex)) ;
}

int v4im_PTId(ucid)
  UCCHAR *ucid ;
{ int pt ;

	switch (v4im_GetUCStrToEnumVal(ucid,0))
	 { default:			return(UNUSED) ;
	   case _AggRef:		pt = V4DPI_PntType_AggRef ; break ;
	   case _Alpha:			pt = V4DPI_PntType_Char ; break ;
	   case _BigText:		pt = V4DPI_PntType_BigText ; break ;
	   case _Binary:		pt = V4DPI_PntType_BinObj ; break ;
	   case _Calendar:		pt = V4DPI_PntType_Calendar ; break ;
	   case _CodedRange:		pt = V4DPI_PntType_CodedRange ; break ;
	   case _Color:			pt = V4DPI_PntType_Color ; break ;
	   case _Complexx:		pt = V4DPI_PntType_Complex ; break ;
	   case _Country:		pt = V4DPI_PntType_Country ; break ;
	   case _DateTime:		pt = V4DPI_PntType_UDT ; break ;
	   case _Delta:			pt = V4DPI_PntType_Delta ; break ;
	   case _Dict:			pt = V4DPI_PntType_Dict ; break ;
	   case _Dictionary:		pt = V4DPI_PntType_Dict ; break ;
	   case _External:		pt = V4DPI_PntType_XDict ; break ;
	   case _Fixed:			pt = V4DPI_PntType_Fixed ; break ;
	   case _GeoCoord:		pt = V4DPI_PntType_GeoCoord ; break ;
	   case _IMArg:			pt = V4DPI_PntType_IMArg ; break ;
	   case _Int:			pt = V4DPI_PntType_Int ; break ;
	   case _Int2:			pt = V4DPI_PntType_Int2 ; break ;
	   case _Integer:		pt = V4DPI_PntType_Int ; break ;
	   case _Intersection:		pt = V4DPI_PntType_Isct ; break ;
	   case _IntMod:		pt = V4DPI_PntType_IntMod ; break ;
	   case _List:			pt = V4DPI_PntType_List ; break ;
	   case _Local:			pt = 9999 ; break ;
	   case _Logical:		pt = V4DPI_PntType_Logical ; break ;
	   case _MemPtr:		pt = V4DPI_PntType_MemPtr ; break ;
	   case _JSON:			pt = V4DPI_PntType_ParsedJSON ; break ;
	   case _ODBC:			pt = V4DPI_PntType_XDB ; break ;
	   case _OSHandle:		pt = V4DPI_PntType_OSHandle ; break ;
	   case _PointReference:	pt = V4DPI_PntType_PntIdx ; break ;
	   case _Real:			pt = V4DPI_PntType_Real ; break ;
	   case _RegularExpression:	pt = V4DPI_PntType_RegExpPattern ; break ;
	   case _Shell:			pt = V4DPI_PntType_Shell ; break ;
	   case _Special:		pt = V4DPI_PntType_Special ; break ;
	   case _SSVal:			pt = V4DPI_PntType_SSVal ; break ;
	   case _StructEl:		pt = V4DPI_PntType_FrgnStructEl ; break ;
	   case _Tag:			pt = V4DPI_PntType_Tag ; break ;
	   case _TagVal:		pt = V4DPI_PntType_Tag ; break ;
	   case _Telephone:		pt = V4DPI_PntType_TeleNum ; break ;
	   case _TelephoneNumber:	pt = V4DPI_PntType_TeleNum ; break ;
	   case _Time:			pt = V4DPI_PntType_Time ; break ;
	   case _Tree:			pt = V4DPI_PntType_Tree ; break ;
	   case _UDate:			pt = V4DPI_PntType_UDate ; break ;
	   case _UDT:			pt = V4DPI_PntType_UDT ; break ;
	   case _UMonth:		pt = V4DPI_PntType_UMonth ; break ;
	   case _UOM:			pt = V4DPI_PntType_UOM ; break ;
	   case _UOMPer:		pt = V4DPI_PntType_UOMPer ; break ;
	   case _UOMPUOM:		pt = V4DPI_PntType_UOMPUOM ; break ;
	   case _UPeriod:		pt = V4DPI_PntType_UPeriod ; break ;
	   case _UQuarter:		pt = V4DPI_PntType_UQuarter ; break ;
	   case _URL:			pt = V4DPI_PntType_URL ; break ;
	   case _UTime:			pt = V4DPI_PntType_UTime ; break ;
	   case _UWeek:			pt = V4DPI_PntType_UWeek ; break ;
	   case _UYear:			pt = V4DPI_PntType_UYear ; break ;
	   case _V4IS:			pt = V4DPI_PntType_V4IS ; break ;
	   case _UCChar:		pt = V4DPI_PntType_UCChar ; break ;
	   case _XDB:			pt = V4DPI_PntType_XDB ; break ;
	 } ;
	return(pt) ;
}

/*	v4im_TagValue - Converts string tag to its numeric value */
/*	Call: index = v4im_TagValue( name )
	  where index is tag value (<=0 is error),
		name is name of the tag				*/

int v4im_TagValue(name)
  UCCHAR *name ;
{ INDEX first,last,i,j ;
  UCCHAR ucname[100], ucentry[100] ;
  
	UCcnvupper(ucname,name,UCsizeof(ucname)) ;
	for(first=0,last=V4IMTag_TagCount-1;;)
	 { i = (last + first) / 2 ;
	   UCcnvupper(ucentry,Tags[i].ULName,UCsizeof(ucentry))
	   j = UCstrcmp(ucname,ucentry) ;
	   if (j == 0) return(Tags[i].Value) ; if (j < 0) { last = i - 1 ; } else { first = i + 1 ; } ;
	   if (first > last) { return(0) ; break ; } ;
	 } ;




}

/*	v4im_TagRange - Returns range of valid tag numbers		*/
/*	Call: v4im_TagRange( begin , end )
	  where begin & end are (int *) & updated with range values	*/

void v4im_TagRange(begin,end)
  int *begin, *end ;
{ int i ;

	for(*begin=V4LIM_BiggestPositiveInt,*end=0,i=0;i<V4IMTag_TagCount;i++)
	 { if (Tags[i].Value < *begin) *begin = Tags[i].Value ;
	   if (Tags[i].Value > *end) *end = Tags[i].Value ;
	 } ;
}

/*	v4im_TagName - Converts internal tag value to display name	*/
/*	Call: strptr = v4im_TagName( index )
	  where strptr is pointer to display string,
		index is internal tag number to convert			*/

UCCHAR *v4im_TagName(index)
  int index ;
{ static UCCHAR name[40] ;
  int i,value ;

	value = (index < 0 ? -index : (index & ~(V4DPI_TagFlag_Colon3))) ;
	for(i=0;i<V4IMTag_TagCount;i++) 
	 { if (Tags[i].Value != value) continue ;
	   if (index > 0)
	    { UCstrcpy(name,Tags[i].ULName) ; if (index & V4DPI_TagFlag_Colon3) UCstrcat(name,UClit("(:::)")) ;
	      return(name) ;
	    } ;
	   UCstrcpy(name,Tags[i].ULName) ; UCstrcat(name,UClit("?")) ; return(name) ;
	 } ;
	UCsprintf(name,sizeof name,UClit("?%d?"),index) ; return(name) ;
}

/*	v4im_Accept - Converts string to Internal Module index		*/
/*	Call: index = v4im_Accept( name )
	  where index is internal module index (<=0 is error),
		name is name of the module				*/

INTMODX v4im_Accept(name)
  UCCHAR *name ;
{ 
  UCCHAR ucname[100], ucentry[100] ;
  INDEX first,last,i,j ;
  
	UCcnvupper(ucname,name,UCsizeof(ucname)) ;
	for(first=0,last=V4IM_DictList_Count-1;;)
	 { i = (last + first) / 2 ;
	   UCcnvupper(ucentry,v4im_DictList[i].display,UCsizeof(ucentry))
	   j = UCstrcmp(ucname,ucentry) ;
	   if (j == 0)
	    { if (gpi->lockModuleParse[v4im_DictList[i].value]) return(0) ;	/* If this module name is restricted then pretend it doesn't exists */
	      return(v4im_DictList[i].value) ;
	    } ;
	   if (j < 0) { last = i - 1 ; } else { first = i + 1 ; } ;
	   if (first > last) { return(0) ; break ; } ;
	 } ;
}

/*	v4im_Display - Converts internal module index to string		*/
/*	Call: strptr = v4im_Display( index )
	  where strptr is pointer to display string,
		index is internal module index to be converted		*/

UCCHAR *v4im_Display(index)
  INTMODX index ;
{ static UCCHAR badres[10] ;
  int i ;

	for(i=0;i<V4IM_DictList_Count;i++) { if (v4im_DictList[i].value == index) break ; } ;
	if (i < V4IM_DictList_Count) return(v4im_DictList[i].display) ;
	UCsprintf(badres,sizeof badres,UClit("?%d?"),index) ; return(badres) ;
}

/*	v4im_IntModRange - Returns range of valid IntMod numbers		*/
/*	Call: v4im_IntModRange( begin , end )
	  where begin & end are (int *) & updated with range values	*/

void v4im_IntModRange(begin,end)
  int *begin, *end ;
{ int i ;

	for(*begin=V4LIM_BiggestPositiveInt,*end=0,i=0;i<V4IM_DictList_Count;i++)
	 { if (v4im_DictList[i].value < *begin) *begin = v4im_DictList[i].value ;
	   if (v4im_DictList[i].value > *end) *end = v4im_DictList[i].value ;
	 } ;
}


/*	v4im_ModFailStr - Converts internal module index to "fail" string	*/
/*	Call: strptr = v4im_ModFailStr( index )
	  where strptr is pointer to display string,
		index is internal module index to be converted		*/

UCCHAR *v4im_ModFailStr(index)
  int index ;
{ static UCCHAR failstr[128] ;
  int i ;

	for(i=0;i<V4IM_DictList_Count;i++) { if (v4im_DictList[i].value == index) break ; } ;
	if (i < V4IM_DictList_Count)
	 { v_Msg(NULL,failstr,"@%1U() fail -",v4im_DictList[i].display) ; return(failstr) ; } ;
	UCsprintf(failstr,sizeof failstr,UClit("Module#%d() fail -"),index) ; return(failstr) ;
}

/*	v4im_InitStuff - Initiailize misc junk for V4IM			*/
void v4im_InitStuff(minargs)
  char minargs[] ;
{ int ix ;

	   for(ix=0;ix<V4IM_DictList_Count;ix++)		/* Save min allowed number of arguments by IntMod */
	    { minargs[v4im_DictList[ix].value-1] = v4im_DictList[ix].minargs ; } ;
}

/*	v4im_CouldBeList - Returns TRUE if point is or can be coerced into a list	*/
/*	Call: logical = v4im_CouldBeList( ctx , ipt )
	  where	logical is TRUE if ipt could be list,
		ctx is context,
		ipt is point to be tested						*/

LOGICAL v4im_CouldBeList(ctx,ipt)
  struct V4C__Context *ctx ;
  P *ipt ;
{ 

top:
	switch(ipt->PntType)
	 { default:
		return(ipt->Grouping > 0) ;		/* If point of form dim:a..b or dim:a,b then list */
	   case V4DPI_PntType_SymDef:
	   case V4DPI_PntType_TeleNum:
	   case V4DPI_PntType_Country:
	   case V4DPI_PntType_Int2:
	   case V4DPI_PntType_SegBitMap:
	   case V4DPI_PntType_BigText:
	   case V4DPI_PntType_List:
	   case V4DPI_PntType_Isct:	return(TRUE) ;
	   case V4DPI_PntType_PntIdx:	return(v4im_CouldBeList(ctx,v4dpi_PntIdx_CvtIdxPtr(ipt->Value.IntVal))) ;
	   case V4DPI_PntType_Special:
		if (ipt->Grouping == V4DPI_Grouping_All) return(TRUE) ;	/* dim.. can be converted to list */
		 else if (ipt->Grouping == V4DPI_Grouping_Current)
		 { DIMVAL(ipt,ctx,ipt->Dim) ; if (ipt == NULL) return(FALSE) ; goto top ; } 
		 else if (ipt->Grouping == V4DPI_Grouping_PCurrent)
		 { DIMPVAL(ipt,ctx,ipt->Dim) ; if (ipt == NULL) return(FALSE) ; goto top ; } 
		else return(FALSE) ;
	 } ;
	return(FALSE) ;
}

/*	v4im_VerifyList - verifies argument is a list			*/
/*	Call: lp = v4im_VerifyList(respnt, ctx, ipt , indmodx , )
	  where lp is pointer to list (V4L__ListPoint *),
		respnt is optional point to be used if necessary (NULL for allocation within this routine),
		ipt is point to verify,
		intmodx is intmod function index,
		argnum is argument number (for error msg)		*/

struct V4L__ListPoint *v4im_VerifyList(respnt,ctx,ipt,intmodx)
  P *respnt ;
  struct V4C__Context *ctx ;
  P *ipt ;
  int intmodx ;
{ struct V4L__ListPoint *lp ;
  P *tpt,*cpt,spnt,apnt ;
  struct V4L__ListCmpndRange *lcr ;
  struct V4L__ListBigText *lbt ;
  struct V4L__ListCmpndRangeDBL *lcrd ;
  struct V4L__ListIsct *lisct ;
  struct V4DPI__Point_IntMix *pim ;
  struct V4DPI__Point_AlphaMix *pam ;
  struct V4DPI__Point_RealMix *prm ;
  struct V4DPI__DimInfo *di ;
  struct V4IM__Drawer *drw ;
  struct V4DPI__Value_GCDSV *gcdsv ;
  struct V4Cal__Args cal ;
  static double zuluoffset = UNUSED ;
  int i,val,ok ; double d1,d2,frac ; char *b ;

#define ALLOCLP(upt) \
 if (respnt != NULL) { upt = respnt ; } \
  else { upt = (P *)v4dpi_ScopePnt_Alloc(ctx->rtStackX) ; ctx->HaveScopedPts[ctx->rtStackX] = TRUE ; } ;

top_of_module:
	if (ipt == NULL) { v_Msg(ctx,ctx->ErrorMsgAux,"UndefPoint") ; return(NULL) ; } ;
	if (ipt->PntType == V4DPI_PntType_PntIdx)		/* If point reference, get actual point */
	 ipt = v4dpi_PntIdx_CvtIdxPtr(ipt->Value.IntVal) ;
	if (ipt->PntType == V4DPI_PntType_List)
	 { lp = ALIGNLP(&ipt->Value) ;
	   if (lp->BytesPerEntry > sizeof(*ipt))
	    { v_Msg(ctx,ctx->ErrorMsgAux,"ListMalformed",lp->BytesPerEntry) ; return(NULL) ; } ;
	   return(lp) ;
	 } ;
	if (ipt->PntType == V4DPI_PntType_Special)
	 { switch(ipt->Grouping)
	    { default:
	      case V4DPI_Grouping_None:
		ALLOCLP(tpt) INITLP(tpt,lp,Dim_List)
		v4l_ListPoint_Modify(ctx,lp,V4L_ListAction_Append,ipt,0) ;
		ENDLP(tpt,lp)
		return(ALIGNLP(&tpt->Value)) ;
	      case V4DPI_Grouping_All:
//VEH091231 - changed from &spnt to respnt
//		ipt = v4dpi_DimUniqueToList(&spnt,ctx,ipt->Dim,Dim_List,ipt,TRUE) ;
		if (respnt == NULL) ALLOCLP(respnt) ;	//VEH100112 - Added this to handle numerous places VerifyList called with NULL
		ipt = v4dpi_DimUniqueToList(respnt,ctx,ipt->Dim,Dim_List,ipt,TRUE) ;
		if (ipt == NULL) return(NULL) ;
		if (ipt->PntType == V4DPI_PntType_List) return(lp = ALIGNLP(&ipt->Value)) ;
		memcpy(&spnt,ipt,ipt->Bytes) ;				/* Save the value and ... VEH100411 */
		return(v4im_VerifyList(respnt,ctx,&spnt,intmodx)) ;	/*  recurse down to evaluate this result */
	      case V4DPI_Grouping_Current:
		DIMVAL(ipt,ctx,ipt->Dim)
		if (ipt == NULL) { v_Msg(ctx,ctx->ErrorMsgAux,"CtxNoCurVal2",ipt->Dim) ; return(NULL) ; } ;
		break ;
	      case V4DPI_Grouping_PCurrent:
		DIMPVAL(ipt,ctx,ipt->Dim) ;
		if (ipt == NULL) { v_Msg(ctx,ctx->ErrorMsgAux,"CtxNoPriorVal2",UNUSED,ipt->Dim) ; return(NULL) ; } ;
		break ;
	    } ;
	 } ;
/*	A single point? (remember AggRef uses Grouping for area so all AggRefs are single points) */
	if ((ipt->Grouping == 0 && !(ipt->PntType == V4DPI_PntType_BigText || ipt->PntType == V4DPI_PntType_Drawer)) || ipt->PntType == V4DPI_PntType_AggRef)
	 {
	   switch(intmodx == V4IM_OpCode_Project ? ipt->PntType : UNUSED)
	    { default:


		if (ipt->PntType == V4DPI_PntType_SegBitMap)	/* Segmented BitMap converted to BitMap list */
		 { struct V4L__ListBitMap *lbm ;
		   ALLOCLP(tpt) INITLP(tpt,lp,Dim_List) lp->ListType = V4L_ListType_BitMap ;
		   DIMINFO(di,ctx,ipt->Dim) ; lp->Dim = di->ListDimId ;
		   lbm = (struct V4L__ListBitMap *)&lp->Buffer ;
		   lp->Bytes = (char *)&lp->Buffer[0] - (char *)lp + sizeof *lbm ;
		   memset(lbm,0,sizeof *lbm) ; lbm->LastIndex = UNUSED ;
		   lbm->bm1 = (struct V4L__ListBMData1 *)v4seg_GetSegments(ctx,ipt->Value.IntVal,NULL,TRUE,UNUSED) ;
		   if (lbm->bm1 == NULL) return(NULL) ;
		   i = lbm->bm1->MaxBit ;
		   if (i < 0 || i > 10000000) { v_Msg(ctx,ctx->ErrorMsgAux,"ListBMCorrupt",i) ; return(NULL) ; } ;
		   tpt->Bytes = V4DPI_PointHdr_Bytes + lp->Bytes ;
		   return(lp) ;
		 } ;



		ALLOCLP(tpt) INITLP(tpt,lp,Dim_List)
		v4l_ListPoint_Modify(ctx,lp,V4L_ListAction_Append,ipt,0) ;
		ENDLP(tpt,lp)
		return(ALIGNLP(&tpt->Value)) ;
	      case V4DPI_PntType_AggRef:
		ALLOCLP(tpt) ZPH(tpt) ; INITLP(tpt,lp,Dim_List) ; intPNT(&spnt) ;
		spnt.Value.IntVal = ipt->Grouping+1 ; v4l_ListPoint_Modify(ctx,lp,V4L_ListAction_Append,&spnt,0) ;
		spnt.Value.IntVal = ipt->Value.IntVal ; v4l_ListPoint_Modify(ctx,lp,V4L_ListAction_Append,&spnt,0) ;
		ENDLP(tpt,lp) return(lp) ;
	      case V4DPI_PntType_Int2:
		ALLOCLP(tpt) ZPH(tpt) ; INITLP(tpt,lp,Dim_List) ; intPNT(&spnt) ;
		spnt.Value.IntVal = ipt->Value.Int2Val[0] ; v4l_ListPoint_Modify(ctx,lp,V4L_ListAction_Append,&spnt,0) ;
		spnt.Value.IntVal = ipt->Value.Int2Val[1] ; v4l_ListPoint_Modify(ctx,lp,V4L_ListAction_Append,&spnt,0) ;
		ENDLP(tpt,lp) return(lp) ;
	      case V4DPI_PntType_Complex:
		ALLOCLP(tpt) ZPH(tpt) ; INITLP(tpt,lp,Dim_List) ; dblPNT(&spnt) ;
		PUTREAL(&spnt,ipt->Value.Complex.r) ; v4l_ListPoint_Modify(ctx,lp,V4L_ListAction_Append,&spnt,0) ;
		PUTREAL(&spnt,ipt->Value.Complex.i) ; v4l_ListPoint_Modify(ctx,lp,V4L_ListAction_Append,&spnt,0) ;
		ENDLP(tpt,lp) return(lp) ;
	      case V4DPI_PntType_GeoCoord:
		ALLOCLP(tpt) ZPH(tpt) ; INITLP(tpt,lp,Dim_List) ;
		intPNTv(&spnt,ipt->Value.GeoCoord.GCType) ; v4l_ListPoint_Modify(ctx,lp,V4L_ListAction_Append,&spnt,0) ;
		d1 = GETGEOLAT(&ipt->Value.GeoCoord) ;
		dblPNTv(&spnt,d1) ; v4l_ListPoint_Modify(ctx,lp,V4L_ListAction_Append,&spnt,0) ;
		d1 = (double)ipt->Value.GeoCoord.Coord2 / V4DPI_GeoCoord_Factor ;
		dblPNTv(&spnt,d1) ; v4l_ListPoint_Modify(ctx,lp,V4L_ListAction_Append,&spnt,0) ;
		d1 = GETGEOALT(&ipt->Value.GeoCoord) ;
		dblPNTv(&spnt,d1) ; v4l_ListPoint_Modify(ctx,lp,V4L_ListAction_Append,&spnt,0) ;
		intPNTv(&spnt,ipt->Value.GeoCoord.TimeZone) ; v4l_ListPoint_Modify(ctx,lp,V4L_ListAction_Append,&spnt,0) ;
		switch (ipt->Value.GeoCoord.GCType) 
		 { case V4DPI_GCType_Distance:
			gcdsv = (struct V4DPI__Value_GCDSV *)&ipt->Value ;
			d1 = gcdsv->distInt + gcdsv->distFrac / V4DPI_GeoCoordDist_Factor ;
			dblPNTv(&spnt,d1) ; v4l_ListPoint_Modify(ctx,lp,V4L_ListAction_Append,&spnt,0) ;
			intPNTv(&spnt,gcdsv->distUOM) ; v4l_ListPoint_Modify(ctx,lp,V4L_ListAction_Append,&spnt,0) ;
			intPNTv(&spnt,gcdsv->speedUnit) ; v4l_ListPoint_Modify(ctx,lp,V4L_ListAction_Append,&spnt,0) ;
			intPNTv(&spnt,gcdsv->hgtUOM) ; v4l_ListPoint_Modify(ctx,lp,V4L_ListAction_Append,&spnt,0) ;
			d1 = gcdsv->bearingDeg1 / V4DPI_GeoCoord_Factor ; dblPNTv(&spnt,d1) ; v4l_ListPoint_Modify(ctx,lp,V4L_ListAction_Append,&spnt,0) ;
			d1 = gcdsv->bearingDeg2 / V4DPI_GeoCoord_Factor ; dblPNTv(&spnt,d1) ; v4l_ListPoint_Modify(ctx,lp,V4L_ListAction_Append,&spnt,0) ;
			ZPH(&spnt) ; spnt.Dim = Dim_UCal ; spnt.PntType = V4DPI_PntType_Calendar ; spnt.Bytes = V4PS_Calendar ;
			SETDBL(spnt.Value.RealVal,gcdsv->calDateTime) ; v4l_ListPoint_Modify(ctx,lp,V4L_ListAction_Append,&spnt,0) ;
			break ;
		 } ;
		ENDLP(tpt,lp) return(lp) ;
	      case V4DPI_PntType_UPeriod:
		ALLOCLP(tpt) ZPH(tpt) ; INITLP(tpt,lp,Dim_List) ; intPNT(&spnt) ;
		DIMINFO(di,ctx,ipt->Dim) ;
		{ int ppy = (di->ds.UPeriod.periodsPerYear == 0 ? 13 : di->ds.UPeriod.periodsPerYear) ;
		  spnt.Value.IntVal = UPERIODtoUYEAR(ipt->Value.IntVal,ppy) ; v4l_ListPoint_Modify(ctx,lp,V4L_ListAction_Append,&spnt,0) ;
		  spnt.Value.IntVal = UPERIODtoPERIOD(ipt->Value.IntVal,ppy) ; v4l_ListPoint_Modify(ctx,lp,V4L_ListAction_Append,&spnt,0) ;
		}
		ENDLP(tpt,lp) return(lp) ;
	      case V4DPI_PntType_UMonth:
		ALLOCLP(tpt) ZPH(tpt) ; INITLP(tpt,lp,Dim_List) intPNT(&spnt) ;
		spnt.Value.IntVal = UMONTHtoUYEAR(ipt->Value.IntVal) ; v4l_ListPoint_Modify(ctx,lp,V4L_ListAction_Append,&spnt,0) ;
		spnt.Value.IntVal = UMONTHtoMONTH(ipt->Value.IntVal) ; v4l_ListPoint_Modify(ctx,lp,V4L_ListAction_Append,&spnt,0) ;
		ENDLP(tpt,lp) return(lp) ;
	      case V4DPI_PntType_UQuarter:
		ALLOCLP(tpt) ZPH(tpt) ; INITLP(tpt,lp,Dim_List) intPNT(&spnt) ;
		spnt.Value.IntVal = UQTRtoUYEAR(ipt->Value.IntVal) ; v4l_ListPoint_Modify(ctx,lp,V4L_ListAction_Append,&spnt,0) ;
		spnt.Value.IntVal = UQTRtoQTR(ipt->Value.IntVal) ; v4l_ListPoint_Modify(ctx,lp,V4L_ListAction_Append,&spnt,0) ;
		ENDLP(tpt,lp) return(lp) ;
	      case V4DPI_PntType_UWeek:
		ALLOCLP(tpt) ZPH(tpt) ; INITLP(tpt,lp,Dim_List) intPNT(&spnt) ;
		DIMINFO(di,ctx,ipt->Dim) ;
		if (di->ds.UWeek.baseUDate != VCAL_UDate_None)
		 { spnt.Value.IntVal = ipt->Value.IntVal ; v4l_ListPoint_Modify(ctx,lp,V4L_ListAction_Append,&spnt,0) ;
		 } else
		 {
		   spnt.Value.IntVal = UWEEKtoUYEAR(ipt->Value.IntVal) ; v4l_ListPoint_Modify(ctx,lp,V4L_ListAction_Append,&spnt,0) ;
		   spnt.Value.IntVal = UWEEKtoWEEK(ipt->Value.IntVal) ; v4l_ListPoint_Modify(ctx,lp,V4L_ListAction_Append,&spnt,0) ;
		 } ;
		ENDLP(tpt,lp) return(lp) ;
	      case V4DPI_PntType_UDate:
		ALLOCLP(tpt) ZPH(tpt) ; INITLP(tpt,lp,Dim_List) intPNT(&spnt) ;
		i = mscu_udate_to_yyyymmdd(ipt->Value.IntVal) ;
		spnt.Value.IntVal = i / 10000 ; v4l_ListPoint_Modify(ctx,lp,V4L_ListAction_Append,&spnt,0) ;
		spnt.Value.IntVal = (i / 100) % 100 ; v4l_ListPoint_Modify(ctx,lp,V4L_ListAction_Append,&spnt,0) ;
		spnt.Value.IntVal = i % 100 ; v4l_ListPoint_Modify(ctx,lp,V4L_ListAction_Append,&spnt,0) ;
		ENDLP(tpt,lp) return(lp) ;
	      case V4DPI_PntType_Calendar:
		GETREAL(d1,ipt) ;
		if (zuluoffset == (double)UNUSED) zuluoffset = -(double)mscu_minutes_west() / (24 * 60) ;
		frac = modf(d1,&d2) ;
		if (frac != 0.0) { d1 += zuluoffset ; frac = modf(d1,&d2) ; ; } ;
		GregorianFromFixed((int)d1,&cal) ;
		ALLOCLP(tpt) ZPH(tpt) ; INITLP(tpt,lp,Dim_List) intPNT(&spnt) ;
		spnt.Value.IntVal = cal.Year ; v4l_ListPoint_Modify(ctx,lp,V4L_ListAction_Append,&spnt,0) ;
		spnt.Value.IntVal = cal.Month ; v4l_ListPoint_Modify(ctx,lp,V4L_ListAction_Append,&spnt,0) ;
		spnt.Value.IntVal = cal.Day ; v4l_ListPoint_Modify(ctx,lp,V4L_ListAction_Append,&spnt,0) ;
		if (frac != 0.0)
		 { i = (int)((frac * VCAL_SecsInDay) + 0.5) ;
		   spnt.Value.IntVal = i / 3600 ; v4l_ListPoint_Modify(ctx,lp,V4L_ListAction_Append,&spnt,0) ;
		   spnt.Value.IntVal = (i / 60) % 60 ; v4l_ListPoint_Modify(ctx,lp,V4L_ListAction_Append,&spnt,0) ;
		   spnt.Value.IntVal = i % 60 ; v4l_ListPoint_Modify(ctx,lp,V4L_ListAction_Append,&spnt,0) ;
		 } ;
		ENDLP(tpt,lp) return(lp) ;
	      case V4DPI_PntType_UDT:
		val = ipt->Value.IntVal ;
		ALLOCLP(tpt) ZPH(tpt) ; INITLP(tpt,lp,Dim_List) intPNT(&spnt) ;
		i = mscu_udate_to_yyyymmdd(val/VCAL_SecsInDay+VCAL_UDTUDateOffset) ;
		spnt.Value.IntVal = i / 10000 ; v4l_ListPoint_Modify(ctx,lp,V4L_ListAction_Append,&spnt,0) ;
		spnt.Value.IntVal = (i / 100) % 100 ; v4l_ListPoint_Modify(ctx,lp,V4L_ListAction_Append,&spnt,0) ;
		spnt.Value.IntVal = i % 100 ; v4l_ListPoint_Modify(ctx,lp,V4L_ListAction_Append,&spnt,0) ;
		i = val % VCAL_SecsInDay ;
		spnt.Value.IntVal = i / 3600 ; v4l_ListPoint_Modify(ctx,lp,V4L_ListAction_Append,&spnt,0) ;
		spnt.Value.IntVal = (i / 60) % 60 ; v4l_ListPoint_Modify(ctx,lp,V4L_ListAction_Append,&spnt,0) ;
		spnt.Value.IntVal = i % 60 ; v4l_ListPoint_Modify(ctx,lp,V4L_ListAction_Append,&spnt,0) ;
		ENDLP(tpt,lp) return(lp) ;
	      case V4DPI_PntType_UTime:
		ALLOCLP(tpt) ZPH(tpt) ; INITLP(tpt,lp,Dim_List) intPNT(&spnt) ;
		GETREAL(d1,ipt) ; frac = modf(d1,&d2) ; val = d2 ;
		spnt.Value.IntVal = val / 3600 ; v4l_ListPoint_Modify(ctx,lp,V4L_ListAction_Append,&spnt,0) ;
		spnt.Value.IntVal = (val / 60) % 60 ; v4l_ListPoint_Modify(ctx,lp,V4L_ListAction_Append,&spnt,0) ;
		spnt.Value.IntVal = val % 60 ; v4l_ListPoint_Modify(ctx,lp,V4L_ListAction_Append,&spnt,0) ;
		dblPNTv(&spnt,frac) ; v4l_ListPoint_Modify(ctx,lp,V4L_ListAction_Append,&spnt,0) ;
		ENDLP(tpt,lp) return(lp) ;
	      case V4DPI_PntType_Country:
		ALLOCLP(tpt) ZPH(tpt) ; INITLP(tpt,lp,Dim_List) intPNT(&spnt) ; uccharPNT(&apnt)
		for(i=0;i<gpi->ci->Count;i++) { if (ipt->Value.IntVal == gpi->ci->Cntry[i].UNCode) break ; } ;
		if (i >= gpi->ci->Count)
		 { v_Msg(ctx,ctx->ErrorMsgAux,"CntryBadVal",ipt->Value.IntVal) ; return(NULL) ; } ;
		spnt.Value.IntVal = gpi->ci->Cntry[i].UNCode ; v4l_ListPoint_Modify(ctx,lp,V4L_ListAction_Append,&spnt,0) ;
		UCstrcpy((&apnt.Value.UCVal[1]),gpi->ci->Cntry[i].UNAbbr) ; UCCHARPNTBYTES1(&apnt) ; v4l_ListPoint_Modify(ctx,lp,V4L_ListAction_Append,&apnt,0) ;
		UCstrcpy((&apnt.Value.UCVal[1]),gpi->ci->Cntry[i].iso2) ; UCCHARPNTBYTES1(&apnt) ; v4l_ListPoint_Modify(ctx,lp,V4L_ListAction_Append,&apnt,0) ;
		UCstrcpy(&apnt.Value.UCVal[1],gpi->ci->Cntry[i].UNName) ; UCCHARPNTBYTES1(&apnt) ; v4l_ListPoint_Modify(ctx,lp,V4L_ListAction_Append,&apnt,0) ;
		spnt.Value.IntVal = gpi->ci->Cntry[i].IntDialCode ; v4l_ListPoint_Modify(ctx,lp,V4L_ListAction_Append,&spnt,0) ;
		spnt.Value.IntVal = gpi->ci->Cntry[i].IDD ; v4l_ListPoint_Modify(ctx,lp,V4L_ListAction_Append,&spnt,0) ;
		spnt.Value.IntVal = gpi->ci->Cntry[i].NDD ; v4l_ListPoint_Modify(ctx,lp,V4L_ListAction_Append,&spnt,0) ;
		UCstrcpy(&apnt.Value.UCVal[1],gpi->ci->Cntry[i].ITeleMask) ;
		UCCHARPNTBYTES1(&apnt) ; v4l_ListPoint_Modify(ctx,lp,V4L_ListAction_Append,&apnt,0) ;
		UCstrcpy(&apnt.Value.UCVal[1],gpi->ci->Cntry[i].NTeleMask) ;
		UCCHARPNTBYTES1(&apnt) ; v4l_ListPoint_Modify(ctx,lp,V4L_ListAction_Append,&apnt,0) ;
		UCstrcpy(&apnt.Value.UCVal[1],gpi->ci->Cntry[i].DateMask) ;
		UCCHARPNTBYTES1(&apnt) ; v4l_ListPoint_Modify(ctx,lp,V4L_ListAction_Append,&apnt,0) ;
		spnt.Value.IntVal = gpi->ci->Cntry[i].Calendar ; v4l_ListPoint_Modify(ctx,lp,V4L_ListAction_Append,&spnt,0) ;
		spnt.Value.IntVal = gpi->ci->Cntry[i].Language ; v4l_ListPoint_Modify(ctx,lp,V4L_ListAction_Append,&spnt,0) ;
		{ struct V4L__ListPoint *lp1 ; struct V4DPI__LittlePoint ltlpt ; P listpt ; P *lpt = &listpt ; int ix ; enum DictionaryEntries de ;
		  INITLP(lpt,lp1,Dim_List) ;
		  for(ix=0;ix<VCAL_YMDOrderMax && gpi->ci->Cntry[i].ymdOrder[ix]!=V4LEX_YMDOrder_None;ix++)
		   { switch (gpi->ci->Cntry[i].ymdOrder[ix])
		      { case V4LEX_YMDOrder_DMY:	de = _DMY ; break ;
		        case V4LEX_YMDOrder_DYM:	de = _DYM ; break ;
		        case V4LEX_YMDOrder_MDY:	de = _MDY ; break ;
		        case V4LEX_YMDOrder_MYD:	de = _MYD ; break ;
		        case V4LEX_YMDOrder_YDM:	de = _YDM ; break ;
		        case V4LEX_YMDOrder_YMD:	de = _YMD ; break ;
		      } ;
		     dictPNTv(&ltlpt,Dim_UV4,v4im_GetEnumToDictVal(ctx,de,Dim_UV4)) ;
		     v4l_ListPoint_Modify(ctx,lp1,V4L_ListAction_Append,(P *)&ltlpt,0) ;
		   } ;
		  ENDLP(lpt,lp1) ; v4l_ListPoint_Modify(ctx,lp,V4L_ListAction_Append,lpt,0) ;
		}
		UCstrcpy(&apnt.Value.UCVal[1],gpi->ci->Cntry[i].CurrencySign) ;
		UCCHARPNTBYTES1(&apnt) ; v4l_ListPoint_Modify(ctx,lp,V4L_ListAction_Append,&apnt,0) ;
		apnt.Value.UCVal[1] = gpi->ci->Cntry[i].DigiDelim ;
		UCCHARPNTBYTES2(&apnt,2) ; v4l_ListPoint_Modify(ctx,lp,V4L_ListAction_Append,&apnt,0) ;
		apnt.Value.UCVal[1] = gpi->ci->Cntry[i].RadixPnt ;
		UCCHARPNTBYTES2(&apnt,2) ; v4l_ListPoint_Modify(ctx,lp,V4L_ListAction_Append,&apnt,0) ;
		logPNTv(&apnt,gpi->ci->Cntry[i].CurSgnPrefix) ; v4l_ListPoint_Modify(ctx,lp,V4L_ListAction_Append,&apnt,0) ;
		{ struct V4L__ListPoint *lp1 ; struct V4DPI__LittlePoint ltlpt ; P listpt ; P *lpt = &listpt ; int ix ;
		  INITLP(lpt,lp1,Dim_List) ;
		  for(ix=0;gpi->ci->Cntry[i].DDList[ix]!=0;ix++)
		   { intPNTv(&ltlpt,gpi->ci->Cntry[i].DDList[ix]) ; v4l_ListPoint_Modify(ctx,lp1,V4L_ListAction_Append,(P *)&ltlpt,0) ; } ;
		  ENDLP(lpt,lp1) ; v4l_ListPoint_Modify(ctx,lp,V4L_ListAction_Append,lpt,0) ;
		}
		ENDLP(tpt,lp)
		return(lp) ;
	      case V4DPI_PntType_TeleNum:
		ALLOCLP(tpt) ZPH(tpt) ; INITLP(tpt,lp,Dim_List) intPNT(&spnt) ;
		spnt.Value.IntVal = (ipt->Value.Tele.IntDialCode < 0 ? -ipt->Value.Tele.IntDialCode : ipt->Value.Tele.IntDialCode) ; v4l_ListPoint_Modify(ctx,lp,V4L_ListAction_Append,&spnt,0) ;
		spnt.Value.IntVal = ipt->Value.Tele.AreaCode ; v4l_ListPoint_Modify(ctx,lp,V4L_ListAction_Append,&spnt,0) ;
		spnt.Value.IntVal = ipt->Value.Tele.Number ; v4l_ListPoint_Modify(ctx,lp,V4L_ListAction_Append,&spnt,0) ;
		spnt.Value.IntVal = (ipt->Value.Tele.IntDialCode < 0 ? ipt->Value.Tele.Extension : 0) ; v4l_ListPoint_Modify(ctx,lp,V4L_ListAction_Append,&spnt,0) ;
		if (ipt->Value.Tele.IntDialCode < 0 && ipt->Value.Tele.Type > 0)
		 { dictPNT(&spnt,Dim_UV4) ;
		   switch (ipt->Value.Tele.Type)
		   { default:			spnt.Value.IntVal = v4im_GetEnumToDictVal(ctx,_Unknown,Dim_UV4) ; break ;
		     case V4DPI_TeleType_Cell:	spnt.Value.IntVal = v4im_GetEnumToDictVal(ctx,_Cell,Dim_UV4) ; break ;
		     case V4DPI_TeleType_Fax:	spnt.Value.IntVal = v4im_GetEnumToDictVal(ctx,_Cell,Dim_UV4) ; break ;
		     case V4DPI_TeleType_Home:	spnt.Value.IntVal = v4im_GetEnumToDictVal(ctx,_Cell,Dim_UV4) ; break ;
		     case V4DPI_TeleType_Work:	spnt.Value.IntVal = v4im_GetEnumToDictVal(ctx,_Cell,Dim_UV4) ; break ;
		   } ; v4l_ListPoint_Modify(ctx,lp,V4L_ListAction_Append,&spnt,0) ;
		 } else { memcpy(&spnt,&protoNone,V4PS_Int) ; } ;
		ENDLP(tpt,lp) return(lp) ;
	      case V4DPI_PntType_XDB:
		ALLOCLP(tpt) ZPH(tpt) ; INITLP(tpt,lp,Dim_List) intPNT(&spnt) ;
		spnt.Value.IntVal = ipt->Value.XDB.xdbId ; v4l_ListPoint_Modify(ctx,lp,V4L_ListAction_Append,&spnt,0) ;
		spnt.Value.IntVal = ipt->Value.XDB.recId ; v4l_ListPoint_Modify(ctx,lp,V4L_ListAction_Append,&spnt,0) ;
		ENDLP(tpt,lp) return(lp) ;
	    } ;
	 } ;
/*	Try to convert to a list */
	switch(ipt->PntType)
	 { default:
		v_Msg(ctx,ctx->ErrorMsgAux,"ListBadSpcPnt",ipt) ; return(NULL) ;
	   case V4DPI_PntType_AggRef:
		ALLOCLP(tpt) ZPH(tpt) ; INITLP(tpt,lp,Dim_List) ; intPNT(&spnt) ;
		spnt.Value.IntVal = ipt->Grouping+1 ; v4l_ListPoint_Modify(ctx,lp,V4L_ListAction_Append,&spnt,0) ;
		spnt.Value.IntVal = ipt->Value.IntVal ; v4l_ListPoint_Modify(ctx,lp,V4L_ListAction_Append,&spnt,0) ;
		ENDLP(tpt,lp) return(lp) ;
	   case V4DPI_PntType_Isct:
		if (ISQUOTED(ipt))
		 { ALLOCLP(tpt) ZPH(tpt) ; INITLP(tpt,lp,Dim_List) lp->ListType = V4L_ListType_Isct ;
		   lisct = (struct V4L__ListIsct *)&lp->Buffer[0] ;
		   lisct->pix = v4dpi_PntIdx_AllocPnt() ;		/* Allocate another point for actual Isct */
		   cpt = v4dpi_PntIdx_CvtIdxPtr(lisct->pix) ; memcpy(cpt,ipt,ipt->Bytes) ;
		   lp->Bytes = (char *)&lp->Buffer[ALIGN(sizeof *lisct)] - (char *)lp ;
		   ENDLP(tpt,lp)
		   return(lp) ;
		 } else
		 { ALLOCLP(tpt)
		   tpt = v4dpi_IsctEval(tpt,ipt,ctx,V4DPI_EM_EvalQuote,NULL,NULL) ;
		   if (tpt == NULL) { v_Msg(ctx,ctx->ErrorMsgAux,"ListEvalFail",ipt) ; return(NULL) ; } ;
		   ipt = tpt ; goto top_of_module ;
		 } ;
	   case V4DPI_PntType_UCChar:
		ALLOCLP(tpt) ZPH(tpt) ; INITLP(tpt,lp,Dim_List)
		if (ipt->Grouping == V4DPI_Grouping_Single)
		 { v4l_ListPoint_Modify(ctx,lp,V4L_ListAction_Append,ipt,0) ;
		 } else
		 { UCCHAR *b ;
		   pam = (struct V4DPI__Point_AlphaMix *)&ipt->Value.AlphaVal ;
		   b = (UCCHAR *)&pam->Entry[ipt->Grouping].BeginIndex ;
		   uccharPNT(&spnt) ; spnt.Dim = ipt->Dim ;
		   for(i=0;i<ipt->Grouping;i++)
		    { if (pam->Entry[i].EndIndex == 0)
		       { UCstrncpy(&spnt.Value.UCVal[1],b+pam->Entry[i].BeginIndex+1,*(b+pam->Entry[i].BeginIndex)) ;
		         spnt.Value.UCVal[1 + *(b+pam->Entry[i].BeginIndex)] = UCEOS ;
		       } ;
		       UCCHARPNTBYTES1(&spnt) ; v4l_ListPoint_Modify(ctx,lp,V4L_ListAction_Append,&spnt,0) ;
		    } ;
		 } ;

		ENDLP(tpt,lp)
		return(lp) ;
	   CASEofCharmU
		ALLOCLP(tpt) ZPH(tpt) ; INITLP(tpt,lp,Dim_List)
		if (ipt->Grouping == V4DPI_Grouping_Single)
		 { v4l_ListPoint_Modify(ctx,lp,V4L_ListAction_Append,ipt,0) ;
		 } else
		 { pam = (struct V4DPI__Point_AlphaMix *)&ipt->Value.AlphaVal ;
		   b = (char *)&pam->Entry[ipt->Grouping].BeginIndex ;
		   alphaPNT(&spnt) ; spnt.Dim = ipt->Dim ;
		   for(i=0;i<ipt->Grouping;i++)
		    { if (pam->Entry[i].EndIndex == 0)
		       { strncpy(&spnt.Value.AlphaVal[1],b+pam->Entry[i].BeginIndex+1,*(b+pam->Entry[i].BeginIndex)) ;
		         spnt.Value.AlphaVal[1 + *(b+pam->Entry[i].BeginIndex)] = '\0' ;
		       } ;
		       CHARPNTBYTES1(&spnt) ; v4l_ListPoint_Modify(ctx,lp,V4L_ListAction_Append,&spnt,0) ;
		    } ;
		 } ;

		ENDLP(tpt,lp)
		return(lp) ;
	   case V4DPI_PntType_Drawer:
		drw = v4im_GetDrawerPtr(ipt->Dim,ipt->Value.IntVal) ;
		if (drw == NULL) { v_Msg(ctx,ctx->ErrorMsgAux,"DrawerBadPnt",ipt,V4DPI_PntType_Drawer) ; return(NULL) ; }

//		dpt = (P *)drw->DrawerBuf ;
///		ALLOCLP(tpt) INITLP(tpt,lp,Dim_List) ; alphaPNT(&spnt) ;
//		for(i=1;i<=drw->Points;i++)
//		 { if (!v4l_ListPoint_Modify(ctx,lp,V4L_ListAction_Append,dpt,0))  { v_Msg(ctx,NULL,"LPModFail",intmodx) ; return(NULL) ; } ;
//		   ADVPNT(dpt) ;
//		 } ;
//		ENDLP(tpt,lp) ;
//		return(ALIGNLP(&tpt->Value)) ;

	     {	struct V4L__ListDrawer *ldrw ;
		ALLOCLP(tpt) INITLP(tpt,lp,Dim_List) ; lp->ListType = V4L_ListType_Drawer ;
		ldrw = (struct V4L__ListDrawer *)&lp->Buffer ;
		ldrw->drw = drw ; ldrw->index = 1 ; ldrw->dPt = (P *)&drw->DrawerBuf[0] ;
		lp->Bytes = (char *)&lp->Buffer - ((char *)lp + sizeof *ldrw) ;
		lp->Entries = drw->Points ;
		ENDLP(tpt,lp) ;
		return(ALIGNLP(&tpt->Value)) ;
	     }



	   case V4DPI_PntType_BigText:
		ALLOCLP(tpt) INITLP(tpt,lp,Dim_List) lp->ListType = V4L_ListType_BigText ;
		lbt = (struct V4L__ListBigText *)&lp->Buffer[0] ;
		lbt->btBuf = v4mm_AllocUC(V4LEX_BigText_Max) ; v4im_GetPointUC(&ok,lbt->btBuf,V4LEX_BigText_Max,ipt,ctx) ;
		lbt->ptrText = lbt->btBuf ; lbt->lineNum = 0 ;
		return(ALIGNLP(&tpt->Value)) ;
	   case V4DPI_PntType_Color:
	   case V4DPI_PntType_Country:
	   case V4DPI_PntType_XDict:
	   case V4DPI_PntType_Dict:
	   CASEofINT
		pim = (struct V4DPI__Point_IntMix *)&ipt->Value ;
		ALLOCLP(tpt) ZPH(tpt) ; INITLP(tpt,lp,Dim_List) lp->ListType = V4L_ListType_CmpndRange ;
		lcr = (struct V4L__ListCmpndRange *)&lp->Buffer[0] ; lcr->Entries = 0 ; lcr->Count = 0 ;
		tpt->PntType = V4DPI_PntType_List ; tpt->Dim = Dim_List ;
/*		Have a list or range or whatever - do it */
		for(i=0;i<ipt->Grouping;i++)
		 { lcr->Cmpnd[lcr->Count].Begin = pim->Entry[i].BeginInt ; lcr->Cmpnd[lcr->Count].End = pim->Entry[i].EndInt ;
		   lcr->Cmpnd[lcr->Count++].Increment = 1 ;
		   lcr->Entries += (1 + pim->Entry[i].EndInt - pim->Entry[i].BeginInt) ;
		 } ;
		lcr->Bytes = (char *)&lcr->Cmpnd[lcr->Count] - (char *)lcr ;
		lp->Bytes = (char *)&lp->Buffer[ALIGN(lcr->Bytes)] - (char *)lp ;
		ENDLP(tpt,lp) lp->Entries = lcr->Entries ; lp->Dim = ipt->Dim ; lp->PntType = ipt->PntType ;
		return(lp) ;
	   case V4DPI_PntType_Calendar:
	   case V4DPI_PntType_Real:
		prm = (struct V4DPI__Point_RealMix *)&ipt->Value ;
		ALLOCLP(tpt) ZPH(tpt) ; INITLP(tpt,lp,Dim_List) lp->ListType = V4L_ListType_CmpndRangeDBL ;
		lcrd = (struct V4L__ListCmpndRangeDBL *)&lp->Buffer[0] ; lcrd->Entries = 0 ; lcrd->Count = 0 ;
		tpt->PntType = V4DPI_PntType_List ; tpt->Dim = Dim_List ;
/*		Have a list or range or whatever - do it */
		for(i=0;i<ipt->Grouping;i++)
		 { memcpy(&lcrd->Cmpnd[lcrd->Count].Begin,&prm->Entry[i].BeginReal,sizeof(double)) ;
		   memcpy(&lcrd->Cmpnd[lcrd->Count].End,&prm->Entry[i].EndReal,sizeof(double)) ;
		   memcpy(&d1,&prm->Entry[i].BeginReal,sizeof(double)) ;
		   memcpy(&d2,&prm->Entry[i].EndReal,sizeof(double)) ;
		   lcrd->Cmpnd[lcrd->Count++].Increment = 1 ;
		   lcrd->Entries += (int)(1 + d2 - d1) ;
		 } ;
		lcrd->Bytes = (char *)&lcrd->Cmpnd[lcrd->Count] - (char *)lcrd ;
		lp->Bytes = (char *)&lp->Buffer[ALIGN(lcrd->Bytes)] - (char *)lp ;
		ENDLP(tpt,lp) lp->Entries = lcrd->Entries ; lp->Dim = ipt->Dim ; lp->PntType = ipt->PntType ;
		return(lp) ;
	 } ;
}

/*	v4im_EvalArithExp - Parses & Evaluates a Text Expression	*/
/*	Call: double = v4im_EvalArithExp( ctx , tcb , trace , ok , valuept , validate)
	  where double is resulting value as a double,
	  	ctx is current context,
	  	tcb points to current text input,
		trace is global trace option,
		ok is updated with TRUE/FALSE if ok or not,
		valuept, if not NULL, is addtional point for isct eval (defaults to UV4:EvalAE),
		validate is TRUE to just validate the component points, FALSE to perform parse/eval	*/

double v4im_EvalArithExp(ctx,tcb,trace,ok,valuept,validate)
  struct V4C__Context *ctx ;
  struct V4LEX__TknCtrlBlk *tcb ;
  int trace ; LOGICAL *ok,validate ;
  P *valuept ;
{ struct V4LEX__RevPolParse rpp ;
  struct V4DPI__Point ppt,tpt,*ipt,*ip ;
  struct V4LEX__TknCtrlBlk *tcbx ;
  static struct V4DPI__LittlePoint lpt ; static int lptSetup = FALSE ;
  enum DictionaryEntries deval ;
  int i,frameid,lok ; UCCHAR pbuf[750] ;
  static double dpfactors[] = { 1, 10, 100, 1000, 10000, 100000, 1000000, 10000000 } ;
  double resstack[100] ; int resx = 0 ;

	resstack[resx] = 0 ;
	if (!v4lex_RevPolParse(&rpp,tcb,V4LEX_RPPFlag_EOL+V4LEX_RPPFlag_V4IMEval,ctx)) { *ok = FALSE ; return(0.0) ; } ;

	if (validate)
	 { for(i=0;*ok && i<rpp.Count;i++)
	    { if (OPCODEISOPER(rpp.Token[i].OpCode)) continue ;		/* An operator - skip on validate */
	      switch (rpp.Token[i].Type)
	       { case V4LEX_TknType_PointWithStar:
		 case V4LEX_TknType_PointWithContext:
	         case V4LEX_TknType_Point:
			ipt = (struct V4DPI__Point *)rpp.Token[i].ValPtr ;
			dictPNTv(&lpt,Dim_UV4,v4im_GetEnumToDictVal(ctx,deval=_EvalAEVal,UNUSED)) ;
			if (lpt.Dim == 0 || lpt.Value.IntVal == 0)
			 { v_Msg(ctx,ctx->ErrorMsgAux,"UV4EvalLE") ; *ok = FALSE ; return(0.0) ; } ;
			INITISCT(&ppt) ; NOISCTVCD(&ppt) ; ppt.Grouping = 2 ;			/* Create isct: [UV4:EvalLE pt] */
			ip = ISCT1STPNT(&ppt) ; memcpy(ip,&lpt,lpt.Bytes) ; ppt.Bytes += lpt.Bytes ;
			ADVPNT(ip) ; memcpy(ip,ipt,ipt->Bytes) ; ppt.Bytes += ipt->Bytes ;
			if (rpp.Token[i].Type == V4LEX_TknType_PointWithContext)/* If next is context, then add */
			 { frameid = v4ctx_FramePush(ctx,NULL) ;		/* Start new context frame */
			   if (!v4ctx_FrameAddDim(ctx,V4C_FrameId_Real,(P *)rpp.Token[i+1].ValPtr,0,0)) { *ok = FALSE ; return(0.0) ; } ;
			 } ;
			ipt = v4dpi_IsctEval(&tpt,&ppt,ctx,0,NULL,NULL) ;
			if (rpp.Token[i].Type == V4LEX_TknType_PointWithContext)/* If next is context, then add */
			 { v4ctx_FramePop(ctx,frameid,NULL) ;			/* Pop off frame context */
			   i++ ;						/* Skip over context */
			 } ;
			if (ipt == NULL) { v_Msg(ctx,ctx->ErrorMsgAux,"EvalAEValFail",rpp.Token[i].ValPtr,&ppt) ; return(0.0) ; } ;
	         	if (ipt->PntType == V4DPI_PntType_Char)
			 { v4im_GetPointUC(ok,ctx->ErrorMsg,sizeof ctx->ErrorMsg,ipt,ctx) ;
			   return(0.0) ;
			 } ;
			continue ;
	       } ;
	    } ;
	   return(1.0) ;					/* If all points check out then return validate=TRUE */
	 } ;

	for(i=0;i<rpp.Count;i++)
	 { if (OPCODEISVALUE(rpp.Token[i].OpCode))			/* Not an operator, i.e. a value */
	    { switch(rpp.Token[i].Type)
	       { default:
			v_Msg(ctx,ctx->ErrorMsgAux,"EvalArithTkn",rpp.Token[i].Type) ; *ok = FALSE ; return(0.0) ;
	         case V4LEX_TknType_Integer:
	         	resstack[resx] = rpp.Token[i].IntVal ; resstack[resx] /= dpfactors[rpp.Token[i].dps] ;
	         	resx ++ ; continue ;
	         case V4LEX_TknType_Float:	resstack[resx++] = rpp.Token[i].Floating ; continue ;
	         case V4LEX_TknType_Isct:
			ipt = v4dpi_IsctEval(&tpt,(P *)rpp.Token[i].ValPtr,ctx,0,NULL,NULL) ;
			if (ipt == NULL)
			 { v_Msg(ctx,ctx->ErrorMsgAux,"EvalArithIsct",rpp.Token[i].ValPtr) ; *ok = FALSE ; return(0.0) ; } ;
			resstack[resx++] = v4im_GetPointDbl(ok,ipt,ctx) ;
			if (!*ok) { v_Msg(ctx,NULL,"EvalArithNotNum",ipt) ; return(0.0) ; } ;
			v4mm_FreeChunk(rpp.Token[i].ValPtr) ;
			continue ;
	         case V4LEX_TknType_PointWithContext:
	         case V4LEX_TknType_Point:
			ipt = (P *)rpp.Token[i].ValPtr ;
			if (ipt->PntType == V4DPI_PntType_Isct)		/* If token is isct then eval directly */
			 { ipt = v4dpi_IsctEval(&tpt,ipt,ctx,0,NULL,NULL) ;
			   if (ipt == NULL)
			    { v_Msg(ctx,ctx->ErrorMsgAux,"EvalArithIsct",rpp.Token[i].ValPtr) ; *ok = FALSE ; return(0.0) ; } ;
			   resstack[resx++] = v4im_GetPointDbl(ok,ipt,ctx) ;
			   if (!*ok) { v_Msg(ctx,NULL,"EvalArithNotNum",ipt) ; return(0.0) ; } ;
			   v4mm_FreeChunk(rpp.Token[i].ValPtr) ;
			   continue ;
			 } ;
			if (!lptSetup)
			 { dictPNT(&lpt,Dim_UV4) ; lptSetup = TRUE ;
			   lpt.Value.IntVal = v4im_GetEnumToDictVal(ctx,deval=_EvalAE,UNUSED) ;
			   if (lpt.Dim == 0 || lpt.Value.IntVal == 0)
			    { v_Msg(ctx,ctx->ErrorMsgAux,"UV4EvalAE") ; *ok = FALSE ; return(0.0) ; } ;
			 } ;
			INITISCT(&ppt) ; NOISCTVCD(&ppt) ; ppt.Grouping = 2 ; ip = ISCT1STPNT(&ppt) ;	/* Create isct: [UV4:EvalAE pt] */
			if (valuept != NULL)
			 { memcpy(ip,valuept,valuept->Bytes) ; ppt.Bytes += valuept->Bytes ;
			 } else { memcpy(ip,&lpt,lpt.Bytes) ; ppt.Bytes += lpt.Bytes ; } ;
			ADVPNT(ip) ; memcpy(ip,ipt,ipt->Bytes) ; ppt.Bytes += ipt->Bytes ;
			if (rpp.Token[i].Type == V4LEX_TknType_PointWithContext)	/* If next is context, then add */
			 { frameid = v4ctx_FramePush(ctx,NULL) ;	/* Start new context frame */
			   if (!v4ctx_FrameAddDim(ctx,V4C_FrameId_Real,(P *)rpp.Token[i+1].ValPtr,0,0)) { *ok = FALSE ; return(0.0) ; } ;
			 } ;
			ipt = v4dpi_IsctEval(&tpt,&ppt,ctx,0,NULL,NULL) ;
			if (rpp.Token[i].Type == V4LEX_TknType_PointWithContext)	/* If next is context, then add */
			 { v4ctx_FramePop(ctx,frameid,NULL) ;			/* Pop off frame context */
			   i++ ;						/* Skip over context */
			 } ;
			if (ipt == NULL)
			 { v_Msg(ctx,ctx->ErrorMsgAux,"EvalArithIsct",&ppt) ; *ok = FALSE ; return(0.0) ; } ;
			if (ipt->PntType == V4DPI_PntType_Char)			/* If alpha then assume a nested expression */
			 { tcbx = (struct V4LEX__TknCtrlBlk *)v4mm_AllocChunk(sizeof *tcbx,FALSE) ; v4lex_InitTCB(tcbx,V4LEX_TCBINIT_NoStdIn) ;
			   v4im_GetPointUC(ok,pbuf,UCsizeof(pbuf),ipt,ctx) ;
			   v4lex_NestInput(tcbx,NULL,pbuf,V4LEX_InpMode_String) ;
			   resstack[resx++] = v4im_EvalArithExp(ctx,tcbx,trace,&lok,valuept,FALSE) ;
			   v4lex_FreeTCB(tcbx) ;
			   if (!lok)			/* Fail if not OK */
			    { *ok = FALSE ; return(0.0) ; } ;
			 } else
			 { resstack[resx++] = v4im_GetPointDbl(ok,ipt,ctx) ;
			   if (!*ok) { v_Msg(ctx,NULL,"EvalArithNotNum",ipt) ; return(0.0) ; } ;
			 } ;
			v4mm_FreeChunk(rpp.Token[i].ValPtr) ;
	         	continue ;
	       } ;
	    } ;
	   switch (rpp.Token[i].OpCode)
	    { default: v_Msg(ctx,ctx->ErrorMsgAux,"EvalArithOpCd",rpp.Token[i].OpCode) ; *ok = FALSE ; return(0.0) ;
	      case V_OpCode_Plus:	resx-- ; resstack[resx-1] += resstack[resx] ; break ;
	      case V_OpCode_Minus:	resx-- ; resstack[resx-1] -= resstack[resx] ; break ;
	      case V_OpCode_UMinus:	resstack[resx-1] = -resstack[resx-1] ; break ;
	      case V_OpCode_NCStar:
	      case V_OpCode_Star:	resx-- ; resstack[resx-1] *= resstack[resx] ; break ;
	      case V_OpCode_Slash:	resx-- ; resstack[resx-1] /= resstack[resx] ; break ;
	      case V_OpCode_Percent:	resx-- ; resstack[resx-1] = (resstack[resx-1] * 100.0) / resstack[resx] ; break ;
	      case V_OpCode_Ampersand:	resx-- ; resstack[resx-1] = ((resstack[resx-1] > 0) && (resstack[resx] > 0)) ; break ;
	      case V_OpCode_Line:	resx-- ; resstack[resx-1] = ((resstack[resx-1] > 0) || (resstack[resx] > 0)) ; break ;
	      case V_OpCode_Langle:	resx-- ; resstack[resx-1] = (resstack[resx-1] < resstack[resx]) ; break ;
	      case V_OpCode_LangleEqual:resx-- ; resstack[resx-1] = (resstack[resx-1] <= resstack[resx]) ; break ;
	      case V_OpCode_Rangle:	resx-- ; resstack[resx-1] = (resstack[resx-1] > resstack[resx]) ; break ;
	      case V_OpCode_RangleEqual:resx-- ; resstack[resx-1] = (resstack[resx-1] >= resstack[resx]) ; break ;
	      case V_OpCode_LangleRangle:resx-- ; resstack[resx-1] = (resstack[resx-1] != resstack[resx]) ; break ;
	      case V_OpCode_Equal:	resx-- ; resstack[resx-1] = (resstack[resx-1] == resstack[resx]) ; break ;
	      case V_OpCode_Tilde:	resstack[resx-1] = (resstack[resx-1] <= 0) ; break ;
	    } ;
	 } ;
	*ok = TRUE ;
	return(resstack[0]) ;
}

/*	v4im_EvalListExp - Parses & Evaluates a Text-List Expression			*/
/*	Call: point = v4im_EvalListExp( ctx , respnt , tcb , trace , ok , dimid , validate )
	  where point is resulting point,
	  	ctx is current context,
		respnt is point to update with result,
	  	tcb points to current text input,
		trace is global trace option,
		ok is updated with TRUE/FALSE if all is well or not,
		dimid is dimension to use if not explicitly given, UNUSED if none,
		validate is TRUE to just validate component points, FALSE to parse/evaluate	*/

P *v4im_EvalListExp(ctx,respnt,tcb,trace,ok,dimid,validate)
  struct V4C__Context *ctx ;
  P *respnt ;
  struct V4LEX__TknCtrlBlk *tcb ;
  int trace,dimid ;
  LOGICAL *ok,validate ;
{ struct V4LEX__RevPolParse rpp ;
  struct V4DPI__Point ppt,tpt,vpt,*ipt,*ip ;
  struct V4DPI__LittlePoint lpt ;
  enum DictionaryEntries deval ;
  int i,frameid ;
  struct lcl__tempstack {
    int sx ;
    struct {
      P res ;			/* Resulting point */
     } e[30] ;			/* Stack entry */
   } ts ;

	ts.sx = 0 ;					/* Reset stack */
	if (!v4lex_RevPolParse(&rpp,tcb,V4LEX_RPPFlag_EOL+V4LEX_RPPFlag_V4IMEval+V4LEX_RPPFlag_ImplyAnd+V4LEX_RPPFlag_EvalLE,ctx))
	 { *ok = FALSE ; return(NULL) ; } ;
	if (rpp.Count <= 0) { v_Msg(ctx,ctx->ErrorMsgAux,"EvalLEEmpty") ; *ok = FALSE ; return(NULL) ; } ;
	*ok = TRUE ;
	if (validate)
	 { for(i=0;*ok && i<rpp.Count;i++)
	    { if (OPCODEISOPER(rpp.Token[i].OpCode)) continue ;		/* An operator - skip on validate */
	      switch (rpp.Token[i].Type)
	       { case V4LEX_TknType_PointWithStar:
		 case V4LEX_TknType_PointWithContext:
	         case V4LEX_TknType_Point:
			ipt = (struct V4DPI__Point *)rpp.Token[i].ValPtr ;
			if (dimid != UNUSED && ipt->Dim == Dim_NId) ipt->Dim = dimid ;
			dictPNTv(&lpt,Dim_UV4,v4im_GetEnumToDictVal(ctx,(rpp.Token[i].Type==V4LEX_TknType_PointWithStar ? (deval=_EvalLEValStar) : (deval=_EvalLEVal)),Dim_NId)) ;
			if (lpt.Dim == 0 || lpt.Value.IntVal == 0)
			 { v_Msg(ctx,ctx->ErrorMsgAux,"UV4EvalLE") ; *ok = FALSE ; return(NULL) ; } ;
			INITISCT(&ppt) ; NOISCTVCD(&ppt) ; ppt.Grouping = 2 ;			/* Create isct: [UV4:EvalLE pt] */
			ip = ISCT1STPNT(&ppt) ; memcpy(ip,&lpt,lpt.Bytes) ; ppt.Bytes += lpt.Bytes ;
			ADVPNT(ip) ; memcpy(ip,ipt,ipt->Bytes) ; ppt.Bytes += ipt->Bytes ;
			if (rpp.Token[i].Type == V4LEX_TknType_PointWithContext)/* If next is context, then add */
			 { frameid = v4ctx_FramePush(ctx,NULL) ;		/* Start new context frame */
			   if (!v4ctx_FrameAddDim(ctx,V4C_FrameId_Real,(P *)rpp.Token[i+1].ValPtr,0,0)) { *ok = FALSE ; return(NULL) ; } ;
			 } ;
			ipt = v4dpi_IsctEval(&tpt,&ppt,ctx,0,NULL,NULL) ;
			if (rpp.Token[i].Type == V4LEX_TknType_PointWithContext)/* If next is context, then add */
			 { v4ctx_FramePop(ctx,frameid,NULL) ;			/* Pop off frame context */
			   i++ ;						/* Skip over context */
			 } ;
			if (ipt == NULL)
			 { v_Msg(ctx,ctx->ErrorMsgAux,"EvalAEValFail",rpp.Token[i].ValPtr,&ppt) ;
			   uccharPNTv(respnt,ctx->ErrorMsgAux) ; return(respnt) ;
			 } ;
	         	if (ipt->PntType == V4DPI_PntType_Char)
			 { memcpy(respnt,ipt,ipt->Bytes) ;			/* If a string is returned - then it is the result (the problem!) */
			   return(respnt) ;
			 } ;
			continue ;
	       } ;
	    } ;
	   return((P *)&Log_True) ;					/* If all points check out then return validate=TRUE */
	 } ;
	for(i=0;*ok && i<rpp.Count;i++)
	 { 
	   if (OPCODEISVALUE(rpp.Token[i].OpCode))			/* Not an operator, i.e. a value */
	    { switch(rpp.Token[i].Type)
	       { default: v_Msg(ctx,ctx->ErrorMsgAux,"EvalArithTkn",rpp.Token[i].Type) ; *ok = FALSE ; return(NULL) ;
	         case V4LEX_TknType_Isct:
			ipt = v4dpi_IsctEval(&tpt,(P *)rpp.Token[i].ValPtr,ctx,0,NULL,NULL) ;
			if (ipt == NULL)
			 { v_Msg(ctx,ctx->ErrorMsgAux,"EvalArithIsct",rpp.Token[i].ValPtr) ; *ok = FALSE ; return(NULL) ; } ;
			memcpy(&ts.e[ts.sx++].res,ipt,ipt->Bytes) ;
			v4mm_FreeChunk(rpp.Token[i].ValPtr) ;
			continue ;
	         case V4LEX_TknType_String:
			ipt = (struct V4DPI__Point *)(rpp.Token[i].ValPtr = (char *)&vpt) ;
			uccharPNTv(ipt,rpp.Token[i].AlphaVal) ;
			goto uv4_entry ;
		 case V4LEX_TknType_Integer:
			ipt = (struct V4DPI__Point *)(rpp.Token[i].ValPtr = (char *)&vpt) ; intPNTv(ipt,rpp.Token[i].IntVal) ;
			goto uv4_entry ;
		 case V4LEX_TknType_PointWithStar:
		 case V4LEX_TknType_PointWithContext:
	         case V4LEX_TknType_Point:
			ipt = (struct V4DPI__Point *)rpp.Token[i].ValPtr ;
			if (dimid != UNUSED && ipt->Dim == Dim_NId) ipt->Dim = dimid ;
uv4_entry:
			dictPNTv(&lpt,Dim_UV4,v4im_GetEnumToDictVal(ctx,(rpp.Token[i].Type==V4LEX_TknType_PointWithStar ? (deval=_EvalLEStar) : (deval=_EvalLE)),Dim_NId)) ;
			if (lpt.Dim == 0 || lpt.Value.IntVal == 0)
			 { v_Msg(ctx,ctx->ErrorMsgAux,"UV4EvalLE") ; *ok = FALSE ; return(NULL) ; } ;
			INITISCT(&ppt) ; NOISCTVCD(&ppt) ; ppt.Grouping = 2 ;			/* Create isct: [UV4:EvalLE pt] */
			ip = ISCT1STPNT(&ppt) ; memcpy(ip,&lpt,lpt.Bytes) ; ppt.Bytes += lpt.Bytes ;
			ADVPNT(ip) ; memcpy(ip,ipt,ipt->Bytes) ; ppt.Bytes += ipt->Bytes ;
			if (rpp.Token[i].Type == V4LEX_TknType_PointWithContext)/* If next is context, then add */
			 { frameid = v4ctx_FramePush(ctx,NULL) ;		/* Start new context frame */
			   if (!v4ctx_FrameAddDim(ctx,V4C_FrameId_Real,(P *)rpp.Token[i+1].ValPtr,0,0)) { *ok = FALSE ; return(NULL) ; } ;
			 } ;
			ipt = v4dpi_IsctEval(&tpt,&ppt,ctx,0,NULL,NULL) ;
			if (rpp.Token[i].Type == V4LEX_TknType_PointWithContext)/* If next is context, then add */
			 { v4ctx_FramePop(ctx,frameid,NULL) ;			/* Pop off frame context */
			   i++ ;						/* Skip over context */
			 } ;
			if (ipt == NULL)
			 { v_Msg(ctx,ctx->ErrorMsgAux,"EvalArithIsct",&ppt) ; *ok = FALSE ; return(NULL) ; } ;
			memcpy(&ts.e[ts.sx++].res,ipt,ipt->Bytes) ;
	         	continue ;
	       } ;
	    } ;
	   switch (rpp.Token[i].OpCode)
	    { default: v_Msg(ctx,ctx->ErrorMsgAux,"EvalArithOpCd",rpp.Token[i].OpCode) ; *ok = FALSE ; return(NULL) ;
	      case V_OpCode_Ampersand:
		ts.sx-- ; *ok = v4l_BitMapAnd(ctx,V4IM_OpCode_EvalLE,&tpt,&ts.e[ts.sx-1].res,&ts.e[ts.sx].res) ; break ;
	      case V_OpCode_Line:
		ts.sx-- ; *ok = v4l_BitMapOr(ctx,V4IM_OpCode_EvalLE,&tpt,&ts.e[ts.sx-1].res,&ts.e[ts.sx].res) ; break ;
	      case V_OpCode_Tilde:
		if (!v4l_BitMapNot(ctx,V4IM_OpCode_EvalLE,&tpt,&ts.e[ts.sx-1].res)) { *ok = FALSE ; return(NULL) ; } ;
		break ;
	      case V_OpCode_Minus:
		ts.sx-- ; *ok = v4l_BitMapMinus(ctx,V4IM_OpCode_EvalLE,&tpt,&ts.e[ts.sx-1].res,&ts.e[ts.sx].res) ; break ;
	    } ; memcpy(&ts.e[ts.sx-1].res,&tpt,tpt.Bytes) ;
	 } ;
	memcpy(respnt,&ts.e[0].res,ts.e[0].res.Bytes) ;
	return(respnt) ;
}

/*	N U M E R I C   U T I L I T I E S				*/

/*	v4im_GetPointDbl - Returns point value as (double)		*/
/*	Call: double = v4im_GetPointDbl( ok, point , ctx )
	  where double = result as double,
		ok, if not NULL is updated with TRUE/FALSE if ok or not,
	  	point is pointer to point,
		ctx is current context					*/

double v4im_GetPointDbl(ok,point,ctx)
  LOGICAL *ok ;
  struct V4DPI__Point *point ;
  struct V4C__Context *ctx ;
{ double dbl,r1,i1 ;
  P p1,p2,*p3 ;
  struct V4DPI__DimInfo *di ;
  B64INT b64 ;

	*ok = TRUE ;
	if (point == NULL) { v_Msg(ctx,ctx->ErrorMsgAux,"UndefPoint") ; *ok = FALSE ; return(0.0) ; } ;
tippy_top:
	switch (point->PntType)
	 { 
	   case V4DPI_PntType_Special:
		switch(point->Grouping)
		 { default:
//		     DIMVAL(p3,ctx,point->Dim) ;
//	             if (p3 != NULL) { point = p3 ; goto tippy_top ; } ;
//		     v_Msg(ctx,ctx->ErrorMsgAux,"CtxNoCurVal2",point->Dim) ; *ok = FALSE ; return(0.0) ;
//		     p3 = point ; point = v4dpi_IsctEval(&p2,point,ctx,V4DPI_EM_EvalQuote,NULL,NULL) ;
//		     if (point != NULL && SPECIALToEVAL(point)) goto tippy_top ;
		     if (SPECIALToEVAL(point)) goto eval ;
		     v_Msg(ctx,ctx->ErrorMsgAux,"ProjectEval",p3,V4DPI_PntType_Real) ; *ok = FALSE ; return(0) ;
		   case V4DPI_Grouping_None:
		     DIMINFO(di,ctx,point->Dim) ;		/* If have dim:none then return none-value (if we got it) */
		     if (di->Flags & V4DPI_DimInfo_HaveNone)
		      { switch(di->PointType)
		         { default:			*ok = FALSE ;	/* Fall thru to error */
		           case V4DPI_PntType_Int:	dbl = (double)di->ds.Int.NoneValue ; break ;
		           case V4DPI_PntType_Real:	dbl = di->ds.Real.NoneValue ; break ;
		         } ;
		      } ;
		     if (!ok) { v_Msg(ctx,ctx->ErrorMsgAux,"ProjectDTProbN",point,V4DPI_PntType_Real,point->Dim) ; return(0) ; } ;
		 } ;	/* If not dim* then drop thru to error below */
		if (ok) break ;
	   default:
		v_Msg(ctx,ctx->ErrorMsgAux,"ProjectDTProb",point,V4DPI_PntType_Real) ; *ok = FALSE ; return(0.0) ;
	   case V4DPI_PntType_Shell:	point = (P *)&point->Value ; goto tippy_top ;
	   case V4DPI_PntType_Color:	dbl = v_ColorRefToRGB(point->Value.IntVal) ; break ;
	   case V4DPI_PntType_Country:	dbl = point->Value.IntVal ; break ;
	   case V4DPI_PntType_XDict:
	   case V4DPI_PntType_Dict:	/* Maybe we can force an evaluation on this point? */
		DIMINFO(di,ctx,point->Dim) ;
		if ((di->Flags & V4DPI_DimInfo_AutoIsct)==0)
		 { v_Msg(ctx,ctx->ErrorMsgAux,"ProjectDTProb",point,V4DPI_PntType_Real) ; *ok = FALSE ; return(0.0) ; } ;
		INITISCT(&p1) ; NOISCTVCD(&p1) ; p1.Grouping = 1 ;
		memcpy(ISCT1STPNT(&p1),point,point->Bytes) ; p1.Bytes += point->Bytes ;
		point = v4dpi_IsctEval(&p2,&p1,ctx,0,NULL,NULL) ;
		if (point != NULL) goto tippy_top ;
		v_Msg(ctx,ctx->ErrorMsgAux,"ProjectDTProb",point,V4DPI_PntType_Real) ; *ok = FALSE ; return(0.0) ;
		break ;
	   case V4DPI_PntType_PntIdx:
		point = v4dpi_PntIdx_CvtIdxPtr(point->Value.IntVal) ; goto tippy_top ;
	   case V4DPI_PntType_SymDef:
	   case V4DPI_PntType_Isct:
eval:		p3 = point ; point = v4dpi_IsctEval(&p2,point,ctx,V4DPI_EM_EvalQuote,NULL,NULL) ;
		if (point != NULL) goto tippy_top ;
		v_Msg(ctx,ctx->ErrorMsgAux,"ProjectEval",p3,V4DPI_PntType_Real) ; *ok = FALSE ; return(0) ;
	   case V4DPI_PntType_SSVal:	return(0.0) ;
	   case V4DPI_PntType_UOM:
		memcpy(&dbl,&point->Value.UOMVal.Num,sizeof dbl) ; break ;
	   case V4DPI_PntType_UOMPer:
		memcpy(&dbl,&point->Value.UOMPerVal.Amount,sizeof dbl) ; break ;
	   CASEofINT
		if (point->Grouping != V4DPI_Grouping_Single) goto notsp ;
		dbl = point->Value.IntVal ; break ;
	   case V4DPI_PntType_Fixed:
		memcpy(&b64,&point->Value.FixVal,sizeof b64) ;
		dbl = (double)b64 ; return(dbl / powers[point->LHSCnt]) ;
		break ;
	   case V4DPI_PntType_UTime:
	   case V4DPI_PntType_Calendar:
	   case V4DPI_PntType_Real:	/* Have to play games because RealVal may not be (double) aligned */
		if (point->Grouping != V4DPI_Grouping_Single) goto notsp ;
		GETREAL(dbl,point) ; break ;
	   case V4DPI_PntType_Complex:
		memcpy(&r1,&point->Value.Complex.r,sizeof(dbl)) ; if (r1 < 0) r1 = -r1 ;
		memcpy(&i1,&point->Value.Complex.i,sizeof(dbl)) ; if (i1 < 0) i1 = -i1 ;
		if (r1 == 0) { dbl = 0.0 ; }
		 else if (i1 == 0) { dbl = r1 ; }
		 else if (r1 > i1) { dbl = r1 * sqrt(1.0 + i1/r1 * i1/r1) ; }
		 else { dbl = i1 * sqrt(1.0 + r1/i1 * r1/i1) ; } ;
		break ;
	   CASEofChar
		{ UCCHAR ucbuf[64],*ucbp ;
		  v4im_GetPointUC(ok,ucbuf,UCsizeof(ucbuf),point,ctx) ; if (!ok) break ;
		  dbl = UCstrtod(ucbuf,&ucbp) ;
		  if (*ucbp != UCEOS) { v_Msg(ctx,ctx->ErrorMsgAux,"ProjectDTProb",point,V4DPI_PntType_Real) ; *ok = FALSE ; return(0) ; } ;
		  break ;
		}
	 } ;
/*	dbl = return amount */
	return(dbl) ;

notsp:
	v_Msg(ctx,ctx->ErrorMsgAux,"GetValMult",point) ; *ok = FALSE ; return(0) ;
}

/*	v4im_GetPointFixed - Returns point value as long int (fixed decimal)		*/
/*	Call: double = v4im_GetPointFixed( point , ctx , decimals )
	  where double = result as double,
		ok is set to TRUE/FALSE if OK or not (ctx->ErrorMsgAux updated if FALSE)
	  	point is pointer to point,
		ctx is current context,
		decimals is number of implied decimal places				*/

B64INT v4im_GetPointFixed(ok,point,ctx,decimals)
  LOGICAL *ok ;
  struct V4DPI__Point *point ;
  struct V4C__Context *ctx ;
  int decimals ;
{ double dbl,r1,i1 ;
  P p1,p2,*p3 ;
  struct V4DPI__DimInfo *di ;
  B64INT b64 ;

tippy_top:
	*ok = TRUE ;
	switch (point->PntType)
	 { 
//	   case V4DPI_PntType_Special:
//		if (point->Grouping == V4DPI_Grouping_Current)
//		 { DIMVAL(p3,ctx,point->Dim) ;
//	           if (p3 != NULL) { point = p3 ; goto tippy_top ; } ;
//		   *ok = FALSE ; v_Msg(ctx,ctx->ErrorMsgAux,"CtxNoCurVal2",point->Dim) ; return((B64INT)0) ;
//		 } ;	/* If not dim* then drop thru to error below */
	   case V4DPI_PntType_Special:
		if (SPECIALToEVAL(point)) goto eval ;
	   default:
		v_Msg(ctx,ctx->ErrorMsgAux,"ProjectDTProb",point,V4DPI_PntType_Real) ; *ok = FALSE ; return((B64INT)0) ;
	   case V4DPI_PntType_Color:	return(b64=v_ColorRefToRGB(point->Value.IntVal)) ;
	   case V4DPI_PntType_Country:	return(b64=point->Value.IntVal) ;
	   case V4DPI_PntType_XDict:
	   case V4DPI_PntType_Dict:	/* Maybe we can force an evaluation on this point? */
		DIMINFO(di,ctx,point->Dim) ;
		if ((di->Flags & V4DPI_DimInfo_AutoIsct)==0)
		 { v_Msg(ctx,ctx->ErrorMsgAux,"ProjectDTProb",point,V4DPI_PntType_Real) ; *ok = FALSE ; return((B64INT)0) ;
		 } ;
		if (point->Grouping != V4DPI_Grouping_Single) goto notsp ;
		INITISCT(&p1) ; NOISCTVCD(&p1) ; p1.Grouping = 1 ; memcpy(ISCT1STPNT(&p1),point,point->Bytes) ; p1.Bytes += point->Bytes ;
		point = v4dpi_IsctEval(&p2,&p1,ctx,0,NULL,NULL) ;
		if (point != NULL) goto tippy_top ;
		break ;
	   case V4DPI_PntType_PntIdx:
		point = v4dpi_PntIdx_CvtIdxPtr(point->Value.IntVal) ; goto tippy_top ;
	   case V4DPI_PntType_SymDef:
	   case V4DPI_PntType_Isct:
eval:		p3 = point ; point = v4dpi_IsctEval(&p2,point,ctx,V4DPI_EM_EvalQuote,NULL,NULL) ;
		if (point != NULL) goto tippy_top ;
		v_Msg(ctx,ctx->ErrorMsgAux,"ProjectEval",p3,V4DPI_PntType_Real) ; *ok = FALSE ; return((B64INT)0) ;
	   case V4DPI_PntType_SSVal:	return((B64INT)0) ;
	   case V4DPI_PntType_UOM:
		memcpy(&dbl,&point->Value.UOMVal.Num,sizeof dbl) ;
		b64 = (B64INT)(dbl * powers[decimals]) ;
		return(b64) ;
	   case V4DPI_PntType_UOMPer:
		memcpy(&dbl,&point->Value.UOMPerVal.Amount,sizeof dbl) ;
		b64 = (B64INT)(dbl * powers[decimals]) ;
		return(b64) ;
	   CASEofINT
		if (point->Grouping != V4DPI_Grouping_Single) goto notsp ;
		b64 = (B64INT)(point->Value.IntVal * powers[decimals]) ;
	   	return(b64) ;
	   case V4DPI_PntType_Fixed:
		if (point->Grouping != V4DPI_Grouping_Single) goto notsp ;
		memcpy(&b64,&point->Value.FixVal,sizeof b64) ;
		if (point->LHSCnt == decimals) return(b64) ;
		if (point->LHSCnt < decimals) 
		 { b64 *= ipowers[decimals - point->LHSCnt] ; }
		 else { b64 += (b64 < 0 ? -iround[point->LHSCnt-decimals] : iround[point->LHSCnt-decimals]) ;
			b64 /= ipowers[point->LHSCnt-decimals] ;
		      } ;
		return(b64) ;
	   case V4DPI_PntType_UTime:
	   case V4DPI_PntType_Calendar:
	   case V4DPI_PntType_Real:	/* Have to play games because RealVal may not be (double) aligned */
		if (point->Grouping != V4DPI_Grouping_Single) goto notsp ;
		GETREAL(dbl,point) ;
		dbl += (dbl < 0 ? -vRound[decimals] : vRound[decimals]) ;
		b64 = (B64INT)(dbl * powers[decimals]) ;
		return(b64) ;
	   case V4DPI_PntType_Complex:
		memcpy(&r1,&point->Value.Complex.r,sizeof(dbl)) ; if (r1 < 0) r1 = -r1 ;
		memcpy(&i1,&point->Value.Complex.i,sizeof(dbl)) ; if (i1 < 0) i1 = -i1 ;
		if (r1 == 0) { dbl = 0.0 ; }
		 else if (i1 == 0) { dbl = r1 ; }
		 else if (r1 > i1) { dbl = r1 * sqrt(1.0 + i1/r1 * i1/r1) ; }
		 else { dbl = i1 * sqrt(1.0 + r1/i1 * r1/i1) ; } ;
		b64 = (B64INT)(dbl * powers[decimals]) ;
		return(b64) ;
	 } ;
	return((B64INT)0) ;			/* Should not get here */

notsp:	v_Msg(ctx,ctx->ErrorMsgAux,"GetValMult",point) ; *ok = FALSE ; return(0) ;
}

/*	v4im_GetPointFileName - Returns a 'filename' point value as (UCCHAR)		*/
/*	Call: v4im_GetPointFileName( ok, dst , max , point , ctx , dfltExt )
	  where ok is updated with OK or not,
		dst is pointer to char buffer to be updated,
		max is max number of bytes in dst,
	  	point is pointer to point,
		ctx is current context,
		dfltExt, if not NULL, is default extension				*/

LOGICAL v4im_GetPointFileName(ok,dst,max,point,ctx,dfltExt)
  LOGICAL *ok ;
  UCCHAR *dst ;
  int max ;
  struct V4DPI__Point *point ;
  struct V4C__Context *ctx ;
  UCCHAR *dfltExt ;
{ P pt,*p3 ;
  struct V4DPI__Point_AlphaMix *pam ;
  UCCHAR *b ; int len,i ;

tippy_top:
	*ok = TRUE ;
	switch (point->PntType)
	 {
	   case V4DPI_PntType_XDict:	/* Maybe we can force an evaluation on this point? */
		b = v4dpi_RevXDictEntryGet(ctx,point->Dim,point->Value.IntVal) ; len = UCstrlen(b) ;
		if (len > max-1) { UCstrncpy(dst,b,max-1) ; *(dst+max-1) = UCEOS ; }
		 else { UCstrcpy(dst,b) ; } ;
		break ;
	   case V4DPI_PntType_Dict:	/* Maybe we can force an evaluation on this point? */
		b = v4dpi_RevDictEntryGet(ctx,point->Value.IntVal) ; len = UCstrlen(b) ;
		if (len > max-1) { UCstrncpy(dst,b,max-1) ; *(dst+max-1) = UCEOS ; }
		 else { UCstrcpy(dst,b) ; } ;
		break ;
	   case V4DPI_PntType_BigText:
		b = v4_BigTextCharValue(ctx,point) ;
		if (b == NULL) { *ok = FALSE ; UCstrcpy(dst,UClit("")) ; return(FALSE) ; } ;
		len = UCstrlen(b) ;
		if (len < max) { UCstrcpy(dst,b) ; }
		 else { UCstrncpy(dst,b,max-1) ; *(dst+max-1) = UCEOS ; } ;
		break ;
	   case V4DPI_PntType_UCChar:
		if (point->Grouping == V4DPI_Grouping_Single)
		 { len = UCCHARSTRLEN(point) ; if (len >= max) len = max - 1 ;
		   UCstrncpy(dst,&point->Value.UCVal[1],len) ; dst[len] = UCEOS ;
	         } else
/*		   If multiple values then just take first */
		 { pam = (struct V4DPI__Point_AlphaMix *)&point->Value ;
		   b = (UCCHAR *)&pam->Entry[point->Grouping].BeginIndex ;
		   len = *(b+pam->Entry[0].BeginIndex) ;
		   if (len >= max) len = max - 1 ;
		   UCstrncpy(dst,b+pam->Entry[0].BeginIndex+1,len) ; dst[len] = UCEOS ;
		 } ;
		break ;
	   CASEofCharmU
		if (point->Grouping == V4DPI_Grouping_Single)
		 { len = CHARSTRLEN(point) ;
		   if (len < max)
		    { for(i=0;i<len;i++) { dst[i] = point->Value.AlphaVal[i+1] ; }
		      dst[len] = '\0' ;
		    } else 
		    { for(i=0;i<max-1;i++) { dst[i] = point->Value.AlphaVal[i+1] ; } ;
		      dst[max-1] = UCEOS ;
		    } ;
	         } else
/*		   If multiple values then just take first */
		 { char *b ;
		   pam = (struct V4DPI__Point_AlphaMix *)&point->Value ;
		   b = (char *)&pam->Entry[point->Grouping].BeginIndex ;
		   len = *(b+pam->Entry[0].BeginIndex) ;
		   if (len >= max) len = max - 1 ;
		   for(i=0;i<len;i++) { dst[i] = b[pam->Entry[0].BeginIndex+1+i] ; } ; dst[len] = UCEOS ;
		 } ;
		break ;
	   case V4DPI_PntType_Special:
		if (SPECIALToEVAL(point)) goto eval ;
		v_Msg(ctx,ctx->ErrorMsgAux,"ProjectEval",point,V4DPI_PntType_Char) ; *ok = FALSE ; return(0) ;
	   case V4DPI_PntType_SymDef:
	   case V4DPI_PntType_Isct:
eval:		p3 = point ; point = v4dpi_IsctEval(&pt,point,ctx,V4DPI_EM_EvalQuote,NULL,NULL) ;
		if (point != NULL && SPECIALToEVAL(point)) goto tippy_top ;
		v_Msg(ctx,ctx->ErrorMsgAux,"ProjectEval",p3,V4DPI_PntType_Char) ; *ok = FALSE ; return(0) ;
	 } ;
#ifdef WINNT
/*	On WINDOWS - convert any forward slashes to correct directory delimiter of backslash */
	for(i=0;dst[i]!=UCEOS;i++) { if (dst[i] == UClit('/')) dst[i] = UClit('\\') ; } ;
#endif
	if (dfltExt != NULL)		/* If default extension given, then see if we need to use it */
	 { LOGICAL gotDot = FALSE ;
	   for(i=0;dst[i]!=UCEOS;i++)
	    { switch (dst[i])
	       { case UClit('.'):		gotDot = TRUE ; break ;
	         case V_FILEPATH_DELIM:		gotDot = FALSE ; break ;	/* Have to have dot after last path delimiter */
	       } ;
	    } ;
	   if (!gotDot) { UCstrcat(dst,UClit(".")) ; UCstrcat(dst,dfltExt) ; } ;
	 } ;
	return(TRUE) ;
}

/*	v4im_GetPointChar - Returns point value as (char)		*/
/*	Call: v4im_GetPointChar( ok, dst , max , point , ctx )
	  where ok is if not NULL is updated with OK or not,
		dst is pointer to char buffer to be updated,
		max is max number of bytes in dst,
	  	point is pointer to point,
		ctx is current context					*/

int v4im_GetPointChar(ok,dst,max,point,ctx)
  LOGICAL *ok ;
  char *dst ;
  int max ;
  struct V4DPI__Point *point ;
  struct V4C__Context *ctx ;
{ P pt,*p3 ;
  struct V4DPI__DimInfo *di ;
  B64INT b64 ;
  char *b ; char nbuf[64] ; int len,i ; double dbl ; UCCHAR *wb ;

tippy_top:
	*ok = TRUE ;
	switch (point->PntType)
	 {
//	   case V4DPI_PntType_Special:
//		if (point->Grouping == V4DPI_Grouping_Current)
//		 { DIMVAL(p3,ctx,point->Dim) ;
//	           if (p3 != NULL) { point = p3 ; goto tippy_top ; } ;
//		   *ok = FALSE ; v_Msg(ctx,ctx->ErrorMsgAux,"CtxNoCurVal2",point->Dim) ; return(0) ;
//		 } ;	/* If not dim* then drop thru to error below */
	   case V4DPI_PntType_Special:
		if (SPECIALToEVAL(point)) goto eval ;
	   default:
		v4dpi_PointToString(UCTBUF1,point,ctx,V4DPI_FormatOpt_Echo) ;	/* Convert to printable format */
		len = UCstrlen(UCTBUF1) ;
		if (len < max) { UCstrcatToASC(dst,UCTBUF1) ; }
		 else { UCTBUF1[max-1] = 0 ; UCstrcatToASC(dst,UCTBUF1) ; } ;
		break ;
	   case V4DPI_PntType_IntMod:
		wb = v4im_Display(point->Value.IntVal) ;
		len = UCstrlen(wb) ;
		if (len < max) { UCstrcpyToASC(dst,wb) ; }
		 else { strncpy(dst,UCretASC(wb),max-1) ; dst[max-1] = '\0' ; } ;
		return(TRUE) ;
	   case V4DPI_PntType_XDict:	/* Maybe we can force an evaluation on this point? */
		b = UCretASC(v4dpi_RevXDictEntryGet(ctx,point->Dim,point->Value.IntVal)) ; len = strlen(b) ;
		if (len > max-1) { strncpy(dst,b,max-1) ; *(dst+max-1) = '\0' ; }
		 else { strcpy(dst,b) ; } ;
		break ;
	   case V4DPI_PntType_Dict:	/* Maybe we can force an evaluation on this point? */
		if (memcmp(point,&protoNone,V4PS_Int) == 0) { ZS(dst) ; break ; } ;	/* If 'none' point then return empty string */
		b = UCretASC(v4dpi_RevDictEntryGet(ctx,point->Value.IntVal)) ; len = strlen(b) ;
		if (b[0] == '?' && gpi->xdr != NULL) b = UCretASC(v4dpi_RevXDictEntryGet(ctx,point->Dim,point->Value.IntVal)) ;
		if (len > max-1) { strncpy(dst,b,max-1) ; *(dst+max-1) = '\0' ; }
		 else { strcpy(dst,b) ; } ;
		break ;
	   case V4DPI_PntType_List:				/* Convert to characters with '\n' between elements */
		v4dpi_PointToString(UCTBUF1,point,ctx,V4DPI_FormatOpt_Echo) ;	/* Convert to printable format */
		len = UCstrlen(UCTBUF1) ;
		if (len < max) { UCstrcpyToASC(dst,UCTBUF1) ; }
		 else { UCTBUF1[max-1] = UCEOS ; UCstrcpyToASC(dst,UCTBUF1) ; } ;
		break ;
	   case V4DPI_PntType_BinObj:
		memcpy(dst,&point->Value.AlphaVal,point->Bytes-V4DPI_PointHdr_Bytes) ; break ;
	   case V4DPI_PntType_BigText:
		wb = v4_BigTextCharValue(ctx,point) ;
		if (wb == NULL) { *ok = FALSE ; strcpy(dst,"") ; return(FALSE) ; } ;
		len = UCstrlen(wb) ;
		if (len < max) { strcpy(dst,UCretASC(wb)) ; }
		 else { for(i=0;i<max-1;i++) { dst[i] = wb[i] ; } ;
			dst[max-1] = '\0' ;
		      } ;
		break ;
	   CASEofCharmU
		if (point->Value.AlphaVal[0] <= V4PT_MaxCharLenIn0)
		 { if (point->Value.AlphaVal[0] < max)
		    { memcpy(dst,&point->Value.AlphaVal[1],point->Value.AlphaVal[0]) ; *(dst+point->Value.AlphaVal[0]) = '\0' ; }
		    else { strncpy(dst,&point->Value.AlphaVal[1],max-1) ; *(dst+max-1) = '\0' ; } ;
	         } else
		 { len = strlen(&point->Value.AlphaVal[1]) ;
		   if (len < max) { strcpy(dst,&point->Value.AlphaVal[1]) ; }
		    else { strncpy(dst,&point->Value.AlphaVal[1],max-1) ; *(dst+max-1) = '\0' ; } ;
		 } ;
		break ;
#ifdef V4UNICODE
	   case V4DPI_PntType_UCChar:		/* Convert to UTF-8 */
		len = UCCHARSTRLEN(point) ;
#ifdef ISLITTLEENDIAN
		len = UTF16LEToUTF8(dst,max,&point->Value.UCVal[1],len) ;
#else
		len = UTF16BEToUTF8(dst,max,&point->Value.UCVal[1],len) ;
#endif
		if (len < 0) { v_Msg(ctx,ctx->ErrorMsgAux,"UCUTF8InvCode") ; *ok = FALSE ; return(0) ; } ;
		dst[len] = '\0' ;
		break ;
#endif
	   case V4DPI_PntType_SymDef:
	   case V4DPI_PntType_Isct:
eval:		p3 = point ; point = v4dpi_IsctEval(&pt,point,ctx,V4DPI_EM_EvalQuote,NULL,NULL) ;
		if (point != NULL) goto tippy_top ;
		v_Msg(ctx,ctx->ErrorMsgAux,"ProjectEval",p3,V4DPI_PntType_Char) ; *ok = FALSE ; return(0) ;
	   CASEofINT
		sprintf(nbuf,"%d",point->Value.IntVal) ; len = strlen(nbuf) ;
		if (len > max-1) { strncpy(dst,nbuf,max-1) ; *(dst+max-1) = '\0' ; }
		 else { strcpy(dst,nbuf) ; } ;
		break ;
	   case V4DPI_PntType_Fixed:
		memcpy(&b64,&point->Value.FixVal,sizeof b64) ;
		dbl = (double)b64 ; sprintf(nbuf,"%g",dbl) ; len = strlen(nbuf) ;
		if (len > max-1) { strncpy(dst,nbuf,max-1) ; *(dst+max-1) = '\0' ; }
		 else { strcpy(dst,nbuf) ; } ;
		break ;
	   case V4DPI_PntType_PntIdx:
		point = v4dpi_PntIdx_CvtIdxPtr(point->Value.IntVal) ; goto tippy_top ;
	   case V4DPI_PntType_UTime:
	   case V4DPI_PntType_Calendar:
	   case V4DPI_PntType_Real:	/* Have to play games because RealVal may not be (double) aligned */
		GETREAL(dbl,point) ; sprintf(nbuf,"%g",dbl) ; len = strlen(nbuf) ;
		if (len > max-1) { strncpy(dst,nbuf,max-1) ; *(dst+max-1) = '\0' ; }
		 else { strcpy(dst,nbuf) ; } ;
		break ;
	 } ;
/*	Make sure we got just a single point value */
	if (point->Grouping == V4DPI_Grouping_Single || point->Grouping > V4DPI_Grouping_MaxMix)
	 return(TRUE) ;
	DIMINFO(di,ctx,point->Dim) ;
/*	If this just happens to be an "Alpha Filename" then be nice & return as such */
	if (di->ds.Alpha.aFlags & V4DPI_DimInfoAlpha_IsFileName)
	 { v4im_GetPointFileName(ok,UCTBUF1,max,point,ctx,NULL) ;
	   strcpy(dst,UCretASC(UCTBUF1)) ;
	   return(TRUE) ;
	 } ;
	v_Msg(ctx,ctx->ErrorMsgAux,"GetValMult",point) ; *ok = FALSE ; return(0) ;
}


/*	v4im_GetPointUC - Returns point value as Unicode (wchar_t)	*/
/*	Call: v4im_GetPointUC( ok, dst , max , point , ctx )
	  where ok is is updated with OK or not,
		dst is pointer to UCCHAR buffer to be updated,
		max is max number of characters in dst,
	  	point is pointer to point,
		ctx is current context					*/

int v4im_GetPointUC(ok,dst,max,point,ctx)
  int *ok ;
  UCCHAR *dst ;
  int max ;
  struct V4DPI__Point *point ;
  struct V4C__Context *ctx ;
{ P pt,*p3 ;
  struct V4DPI__DimInfo *di ;
  UCCHAR *wb ; int i,len ;

tippy_top:
	*ok = TRUE ;
	switch (point->PntType)
	 {
//	   case V4DPI_PntType_Special:
//		if (point->Grouping == V4DPI_Grouping_Current)
//		 { DIMVAL(p3,ctx,point->Dim) ;
//	           if (p3 != NULL) { point = p3 ; goto tippy_top ; } ;
//		   *ok = FALSE ; v_Msg(ctx,ctx->ErrorMsgAux,"CtxNoCurVal2",point->Dim) ; return(0) ;
//		 } ;	/* If not dim* then drop thru to error below */
	   case V4DPI_PntType_Special:
		if (SPECIALToEVAL(point)) goto eval ;
	   default:					/* Most cases - just default to PointToString */
		v4dpi_PointToStringML(dst,point,ctx,V4DPI_FormatOpt_Echo,max) ;	/* Convert to printable format */
		break ;
	   CASEofCharmU
		len = CHARSTRLEN(point) ;
		if (len >= max) len = max - 1 ;
		for(i=1;i<=len;i++) { dst[i-1] = point->Value.AlphaVal[i] ; } ;
		dst[i-1] = UCEOS ;
		break ;
	   case V4DPI_PntType_UCChar:
		len = UCCHARSTRLEN(point) ;
		if (len < max) { UCstrcpy(dst,&point->Value.UCVal[1]) ; }
		 else { UCstrncpy(dst,&point->Value.UCVal[1],max-1) ; dst[max-1] = UCEOS ; } ;
		break ;
	   case V4DPI_PntType_Dict:
		if (memcmp(point,&protoNone,V4PS_Int) == 0) { ZUS(dst) ; break ; } ;	/* If 'none' point then return empty string */
		wb = v4dpi_RevDictEntryGet(ctx,point->Value.IntVal) ; len = UCstrlen(wb) ;
		if (wb[0] == '?' && gpi->xdr != NULL) wb = v4dpi_RevXDictEntryGet(ctx,point->Dim,point->Value.IntVal) ;
		if (len > max-1) { UCstrncpy(dst,wb,max-1) ; dst[max-1] = UCEOS ; }
		 else { UCstrcpy(dst,wb) ; } ;
		break ;
	   case V4DPI_PntType_BinObj:
		memcpy(dst,&point->Value.AlphaVal,point->Bytes-V4DPI_PointHdr_Bytes) ; break ;
	   case V4DPI_PntType_SymDef:
	   case V4DPI_PntType_Isct:
eval:		p3 = point ; point = v4dpi_IsctEval(&pt,point,ctx,V4DPI_EM_EvalQuote,NULL,NULL) ;
		if (point != NULL) goto tippy_top ;
		v_Msg(ctx,ctx->ErrorMsgAux,"ProjectEval",p3,V4DPI_PntType_Char) ; *ok = FALSE ; return(0) ;
	   case V4DPI_PntType_PntIdx:
		point = v4dpi_PntIdx_CvtIdxPtr(point->Value.IntVal) ; goto tippy_top ;
	 } ;
/*	Make sure we got just a single point value */
	if (point->Grouping == V4DPI_Grouping_Single || point->Grouping > V4DPI_Grouping_MaxMix)
	 return(TRUE) ;
	DIMINFO(di,ctx,point->Dim) ;
/*	If this just happens to be an "Alpha Filename" then be nice & return as such */
	if (di->ds.Alpha.aFlags & V4DPI_DimInfoAlpha_IsFileName)
	 return(v4im_GetPointFileName(ok,dst,max,point,ctx,NULL)) ;
	v_Msg(ctx,ctx->ErrorMsgAux,"GetValMult",point) ; *ok = FALSE ;
	return(0) ;
}

/*	v4im_GetPointInt - Returns point value as (int)		*/
/*	Call: int = v4im_GetPointInt(ok , point , ctx )
	  where int = result as int,
		ok is updated to TRUE/FALSE if point is valid number,
	  	point is pointer to point,
		ctx is current context				*/

int v4im_GetPointInt(ok,point,ctx)
  LOGICAL *ok ;
  struct V4DPI__Point *point ;
  struct V4C__Context *ctx ;
{ double dbl ;
  P p1,p2,*p3 ;
  struct V4DPI__DimInfo *di ;
  B64INT b64 ;

	*ok = TRUE ;
tippy_top:
	switch (point->PntType)
	 { 
	   case V4DPI_PntType_Special:
		if (SPECIALToEVAL(point))
		 { 
//		   DIMVAL(p3,ctx,point->Dim) ;
//	           if (p3 != NULL) { point = p3 ; goto tippy_top ; } ;
//		   v_Msg(ctx,ctx->ErrorMsgAux,"CtxNoCurVal2",point->Dim) ; *ok = FALSE ; return(0) ;
		   p3 = point ; point = v4dpi_IsctEval(&p2,point,ctx,V4DPI_EM_EvalQuote,NULL,NULL) ;
		   if (point != NULL) goto tippy_top ;
		   v_Msg(ctx,ctx->ErrorMsgAux,"ProjectEval",p3,V4DPI_PntType_Int) ; *ok = FALSE ; return(0) ;
		 } else if (point->Grouping == V4DPI_Grouping_None)
		 { DIMINFO(di,ctx,point->Dim) ;		/* If have dim:none then return none-value (if we got it) */
		   if (di->Flags & V4DPI_DimInfo_HaveNone)
		    { switch(di->PointType)
		       { default:			break ;	/* Fall thru to error */
		         case V4DPI_PntType_Int:	return(di->ds.Int.NoneValue) ;
		         case V4DPI_PntType_Real:	return(DtoI(di->ds.Real.NoneValue)) ;
		       } ;
		      v_Msg(ctx,ctx->ErrorMsgAux,"ProjectDTProbN",point,V4DPI_PntType_Int,point->Dim) ; *ok = FALSE ; return(0) ;
		    } ;
		 } ;	/* If not dim* then drop thru to error below */
	   default:
		v_Msg(ctx,ctx->ErrorMsgAux,"ProjectDTProb",point,V4DPI_PntType_Int) ; *ok = FALSE ; return(0) ;
	   case V4DPI_PntType_Shell:	point = (P *)&point->Value ; goto tippy_top ;
	   case V4DPI_PntType_Color:	return(v_ColorRefToRGB(point->Value.IntVal)) ;
	   case V4DPI_PntType_Country:	return(point->Value.IntVal) ;
	   case V4DPI_PntType_XDict:
	   case V4DPI_PntType_Dict:	/* Maybe we can force an evaluation on this point? */
		DIMINFO(di,ctx,point->Dim) ;
		if ((di->Flags & V4DPI_DimInfo_AutoIsct)==0)
		 { v_Msg(ctx,ctx->ErrorMsgAux,"ProjectDTProb",point,V4DPI_PntType_Int) ; *ok = FALSE ; return(0) ; } ;
		INITISCT(&p1) ; NOISCTVCD(&p1) ; p1.Grouping = 1 ; memcpy(ISCT1STPNT(&p1),point,point->Bytes) ; p1.Bytes += point->Bytes ;
		point = v4dpi_IsctEval(&p2,&p1,ctx,0,NULL,NULL) ;
		if (point != NULL) goto tippy_top ;
		break ;
	   case V4DPI_PntType_PntIdx:
		point = v4dpi_PntIdx_CvtIdxPtr(point->Value.IntVal) ; goto tippy_top ;
	   case V4DPI_PntType_SymDef:
	   case V4DPI_PntType_Isct:
		p3 = point ; point = v4dpi_IsctEval(&p2,point,ctx,V4DPI_EM_EvalQuote,NULL,NULL) ;
		if (point != NULL) goto tippy_top ;
		v_Msg(ctx,ctx->ErrorMsgAux,"ProjectEval",p3,V4DPI_PntType_Int) ; *ok = FALSE ; return(0) ;
	   case V4DPI_PntType_SSVal:	return(0) ;
	   case V4DPI_PntType_UOM:
		memcpy(&dbl,&point->Value.UOMVal.Num,sizeof dbl) ; return(DtoI(dbl)) ;
	   case V4DPI_PntType_UOMPer:
		memcpy(&dbl,&point->Value.UOMPerVal.Amount,sizeof dbl) ; return(DtoI(dbl)) ;
	   CASEofINT
		if (point->Grouping != V4DPI_Grouping_Single) goto notsp ;
		return(point->Value.IntVal) ;
	   case V4DPI_PntType_Fixed:
		memcpy(&b64,&point->Value.FixVal,sizeof b64) ;
		dbl = (double)b64 ; return(DtoI(dbl / powers[point->LHSCnt])) ;
	   CASEofChar
		{ UCCHAR ucbuf[64],*ucbp ; int inum ;
		  v4im_GetPointUC(ok,ucbuf,UCsizeof(ucbuf),point,ctx) ; if (!ok) break ;
		  inum = UCstrtol(ucbuf,&ucbp,10) ;
		  if (*ucbp != UCEOS) { v_Msg(ctx,ctx->ErrorMsgAux,"ProjectDTProb",point,V4DPI_PntType_Int) ; *ok = FALSE ; return(0) ; } ;
		  return(inum) ;
		}
	   case V4DPI_PntType_Calendar:
	   case V4DPI_PntType_UTime:
	   case V4DPI_PntType_Real:	/* Have to play games because RealVal may not be (double) aligned */
		if (point->Grouping != V4DPI_Grouping_Single) goto notsp ;
		GETREAL(dbl,point) ; return(DtoI(dbl)) ;
	 } ;
	return(0) ;			/* Should not get here */
	
notsp:	v_Msg(ctx,ctx->ErrorMsgAux,"ProjectMult",point,V4DPI_PntType_Int) ; *ok = FALSE ; return(0) ;
}

/*	v4im_GetPointDur - Returns a time duration a (double) number of seconds		*/
/*	Call: dur = v4im_GetPointDur( ok , point , ctx )
	  where ud = result as (int)universal date,
		ok is updated TRUE/FALSE if ok/not-ok,
	  	point is pointer to point,
		ctx is current context							*/

double v4im_GetPointDur(ok,point,ctx)
  LOGICAL *ok ;
  struct V4DPI__Point *point ;
  struct V4C__Context *ctx ;
{ 
  P p2,*p3 ;
  int udtNow ; double dur, calNow ;

tippy_top:
	switch (point->PntType)
	 {
//	   case V4DPI_PntType_Special:
//		if (point->Grouping == V4DPI_Grouping_Current)
//		 { DIMVAL(p3,ctx,point->Dim) ;
//	           if (p3 != NULL) { point = p3 ; goto tippy_top ; } ;
//		   v_Msg(ctx,ctx->ErrorMsgAux,"CtxNoCurVal2",point->Dim) ; *ok = FALSE ; return(0) ;
//		 } ;	/* If not dim* then drop thru to error below */
	   case V4DPI_PntType_Special:
		if (SPECIALToEVAL(point)) goto eval ;
	   default:
		v_Msg(ctx,NULL,"ProjectDTProb",point,V4DPI_PntType_UDate) ; *ok = FALSE ; return(0) ;
	   case V4DPI_PntType_PntIdx:
		point = v4dpi_PntIdx_CvtIdxPtr(point->Value.IntVal) ; goto tippy_top ;
	   case V4DPI_PntType_SymDef:
	   case V4DPI_PntType_Isct:
eval:		p3 = point = v4dpi_IsctEval(&p2,point,ctx,V4DPI_EM_EvalQuote,NULL,NULL) ;
		if (point != NULL && SPECIALToEVAL(point)) goto tippy_top ;
		v_Msg(ctx,ctx->ErrorMsgAux,"ProjectEval",p3,V4DPI_PntType_UDate) ; *ok = FALSE ; return(0) ;
	   case V4DPI_PntType_CodedRange:
	   case V4DPI_PntType_Int:
		*ok = TRUE ; return((double)point->Value.IntVal) ;
	   case V4DPI_PntType_Real:
	   case V4DPI_PntType_UTime:
		GETREAL(dur,point) ; *ok = TRUE ; return(dur) ;
	   case V4DPI_PntType_Calendar:
		GETREAL(dur,point) ;
		calNow = VCal_MJDOffset + TIMEOFFSETDAY +(double)(time(NULL))/(double)VCAL_SecsInDay ;
		dur = (dur - calNow) * (double)VCAL_SecsInDay ;
		*ok = TRUE ; return(dur) ;
	   case V4DPI_PntType_UDT:
		udtNow = valUDTisNOW ;
		dur = (double)point->Value.IntVal - udtNow ;
		*ok = TRUE ; return(dur) ;
	 } ;
	return(0) ;			/* Should not get here */
}

/*	v4im_GetPointUD - Returns point value as (int)UniversalDate		*/
/*	Call: ud = v4im_GetPointUD( ok , point , ctx )
	  where ud = result as (int)universal date,
		ok is updated TRUE/FALSE if ok/not-ok,
	  	point is pointer to point,
		ctx is current context						*/

int v4im_GetPointUD(ok,point,ctx)
  LOGICAL *ok ;
  struct V4DPI__Point *point ;
  struct V4C__Context *ctx ;
{ 
  P p1,p2,*p3 ;
  struct V4DPI__DimInfo *di ;
  int y,m,d,ud ; double dnum ;

tippy_top:
	switch (point->PntType)
	 {
//	   case V4DPI_PntType_Special:
//		if (point->Grouping == V4DPI_Grouping_Current)
//		 { DIMVAL(p3,ctx,point->Dim) ;
//	           if (p3 != NULL) { point = p3 ; goto tippy_top ; } ;
//		   v_Msg(ctx,ctx->ErrorMsgAux,"CtxNoCurVal2",point->Dim) ; *ok = FALSE ; return(0) ;
//		 } ;	/* If not dim* then drop thru to error below */
	   case V4DPI_PntType_Special:
		if (SPECIALToEVAL(point)) goto eval ;
	   default:
		v_Msg(ctx,NULL,"ProjectDTProb",point,V4DPI_PntType_UDate) ; *ok = FALSE ; return(0) ;
	   case V4DPI_PntType_XDict:
	   case V4DPI_PntType_Dict:	/* Maybe we can force an evaluation on this point? */
	      DIMINFO(di,ctx,point->Dim) ;
	      if ((di->Flags & V4DPI_DimInfo_AutoIsct)==0)
	       { v_Msg(ctx,ctx->ErrorMsgAux,"ProjectDTProb",point,V4DPI_PntType_UDate) ; *ok = FALSE ; return(0) ; } ;
		INITISCT(&p1) ; NOISCTVCD(&p1) ; p1.Grouping = 1 ; memcpy(ISCT1STPNT(&p1),point,point->Bytes) ; p1.Bytes += point->Bytes ;
		point = v4dpi_IsctEval(&p2,&p1,ctx,0,NULL,NULL) ; if (point != NULL) goto tippy_top ;
	      v_Msg(ctx,ctx->ErrorMsgAux,"ProjectDTProb",point,V4DPI_PntType_UDate) ; *ok = FALSE ; return(0) ;
		break ;
	   case V4DPI_PntType_PntIdx:
		point = v4dpi_PntIdx_CvtIdxPtr(point->Value.IntVal) ; goto tippy_top ;
	   case V4DPI_PntType_SymDef:
	   case V4DPI_PntType_Isct:
eval:		p3 = point = v4dpi_IsctEval(&p2,point,ctx,V4DPI_EM_EvalQuote,NULL,NULL) ;
		if (point != NULL) goto tippy_top ;
		v_Msg(ctx,ctx->ErrorMsgAux,"ProjectEval",p3,V4DPI_PntType_UDate) ; *ok = FALSE ; return(0) ;
	   case V4DPI_PntType_CodedRange:
	   case V4DPI_PntType_Int:
		y = point->Value.IntVal / 10000 ; m = (point->Value.IntVal / 100) % 100 ;
		d = point->Value.IntVal % 100 ;
		ud = vcal_UDateFromYMD(FALSE,y,m,d,ctx->ErrorMsgAux) ;
		*ok = (ud != VCAL_BadVal) ; return(ud) ;
	   case V4DPI_PntType_Calendar:
		GETREAL(dnum,point) ;
		*ok = TRUE ; return(vcal_CalToUDate(dnum,VCAL_TimeZone_Local,ok)) ;
	   case V4DPI_PntType_UDate:
		*ok = TRUE ; return(point->Value.IntVal) ;
	 } ;
	return(0) ;			/* Should not get here */
}

/*	v4im_GetPointCal - Returns point value as Calendar		*/
/*	Call: ud = v4im_GetPointCal( ok , point , ctx )
	  where cal = result as (double)calendar date,
		ok is updated TRUE/FALSE if ok/not-ok,
	  	point is pointer to point,
		ctx is current context					*/

double v4im_GetPointCal(ok,point,ctx)
  LOGICAL *ok ;
  struct V4DPI__Point *point ;
  struct V4C__Context *ctx ;
{ 
  P p2,*p3 ;
  int y,m,d,rd ; double dnum ;

tippy_top:
	switch (point->PntType)
	 {
//	   case V4DPI_PntType_Special:
//		if (point->Grouping == V4DPI_Grouping_Current)
//		 { DIMVAL(p3,ctx,point->Dim) ;
//	           if (p3 != NULL) { point = p3 ; goto tippy_top ; } ;
//		   v_Msg(ctx,ctx->ErrorMsgAux,"CtxNoCurVal2",point->Dim) ; *ok = FALSE ; return(0) ;
//		 } ;	/* If not dim* then drop thru to error below */
	   case V4DPI_PntType_Special:
		if (SPECIALToEVAL(point)) goto eval ;
	   default:
		v_Msg(ctx,ctx->ErrorMsgAux,"ProjectDTProb",point,V4DPI_PntType_Calendar) ;
		*ok = FALSE ; return(0) ;
	   case V4DPI_PntType_SymDef:
	   case V4DPI_PntType_Isct:
eval:		p3 = point ; point = v4dpi_IsctEval(&p2,point,ctx,V4DPI_EM_EvalQuote,NULL,NULL) ;
		if (point != NULL) goto tippy_top ;
		v_Msg(ctx,ctx->ErrorMsgAux,"ProjectEval",p3,V4DPI_PntType_Calendar) ; *ok = FALSE ; return(0) ;
	   case V4DPI_PntType_CodedRange:
	   case V4DPI_PntType_Int:
		y = point->Value.IntVal / 10000 ; m = (point->Value.IntVal / 100) % 100 ;
		d = point->Value.IntVal % 100 ;
		if (!VerifyGregorianYMD(y,m,d,ctx->ErrorMsgAux)) { *ok = FALSE ; return(0) ; } ;
		rd = FixedFromGregorian(y,m,d) ;
		*ok = TRUE ; return((double)rd) ;
	   case V4DPI_PntType_Calendar:
		GETREAL(dnum,point) ;
		*ok = TRUE ; return(dnum) ;
	   case V4DPI_PntType_UDT:
		dnum = UDTtoCAL(point->Value.IntVal) ;
		return(dnum) ;
	   case V4DPI_PntType_UDate:
		dnum = (double)(point->Value.IntVal + VCal_MJDOffset) ;
		return(dnum) ;
	 } ;
	return(0) ;			/* Should not get here */
}

/*	v4im_GetPointLog - Returns point value as (int)Logical		*/
/*	Call: log = v4im_GetPointLog( ok , point , ctx )
	  where log = result as (int)log,
		ok is pointer to int to be updated with OK, if NULL then generate error if problem,
	  	point is pointer to point,
		ctx is current context					*/

LOGICAL v4im_GetPointLog(ok,point,ctx)
  LOGICAL *ok ;
  struct V4DPI__Point *point ;
  struct V4C__Context *ctx ;
{ double dbl ;
  P p2,*p3 ;
  int lok,i ; UCCHAR *term ;

tippy_top:
	*ok = TRUE ;
	switch (point->PntType)
	 {
//	   case V4DPI_PntType_Special:
//		if (point->Grouping == V4DPI_Grouping_Current)
//		 { p3 = point ; point = v4dpi_IsctEval(&p2,point,ctx,V4DPI_EM_EvalQuote,NULL,NULL) ;
//		   if (point != NULL) goto tippy_top ;
//		   goto fail ;
//		 } ;	/* If not dim* then drop thru to error below */
	   case V4DPI_PntType_Special:
		if (SPECIALToEVAL(point)) goto eval ;
	   default:
		goto fail ;
	   CASEofChar
		v4im_GetPointUC(&lok,UCTBUF1,V4TMBufMax,point,ctx) ;
		i = v_ParseLog(UCTBUF1,&term) ; if (*term == UCEOS) return(i) ;
		goto fail ;
	   case V4DPI_PntType_Dict:	/* Maybe we can force an evaluation on this point? */
		if (point->Value.IntVal == v4dpi_DictEntryGet(ctx,UNUSED,gpi->ci->li->LI[gpi->ci->Cntry[gpi->ci->CurX].Language].Yes,NULL,NULL)) return(TRUE) ;
		if (point->Value.IntVal == v4dpi_DictEntryGet(ctx,UNUSED,gpi->ci->li->LI[gpi->ci->Cntry[gpi->ci->CurX].Language].True,NULL,NULL)) return(TRUE) ;
		if (point->Value.IntVal == v4dpi_DictEntryGet(ctx,UNUSED,gpi->ci->li->LI[gpi->ci->Cntry[gpi->ci->CurX].Language].No,NULL,NULL)) return(FALSE) ;
		if (point->Value.IntVal == v4dpi_DictEntryGet(ctx,UNUSED,gpi->ci->li->LI[gpi->ci->Cntry[gpi->ci->CurX].Language].False,NULL,NULL)) return(FALSE) ;
		goto fail ;
	   case V4DPI_PntType_PntIdx:
		point = v4dpi_PntIdx_CvtIdxPtr(point->Value.IntVal) ; goto tippy_top ;
	   case V4DPI_PntType_SymDef:
	   case V4DPI_PntType_Isct:
eval:		p3 = point ; point = v4dpi_IsctEval(&p2,point,ctx,V4DPI_EM_EvalQuote,NULL,NULL) ;
		if (point != NULL) goto tippy_top ;
		goto fail ;
	   case V4DPI_PntType_Logical:
	   case V4DPI_PntType_CodedRange:
	   case V4DPI_PntType_Delta:
	   case V4DPI_PntType_Int:		return(point->Value.IntVal > 0) ;
	   case V4DPI_PntType_Fixed:
	   case V4DPI_PntType_Calendar:
	   case V4DPI_PntType_Real:
		GETREAL(dbl,point) ; return(dbl > 0) ;
	 } ;
	*ok = FALSE ;
	return(FALSE) ;			/* Should not get here */
fail:
	v_Msg(ctx,ctx->ErrorMsgAux,"ProjectDTProb",point,V4DPI_PntType_Logical) ; *ok = FALSE ; return(FALSE) ;
}

/*	v4im_SetPointValue - Updates point value (numeric)		*/
/*	Call: v4im_SetPointValue( ctx , point , dblval )
	  where ctx is current context
		point is point to be updated,
	  	dblval is numeric value as double			*/

void v4im_SetPointValue(ctx,point,dblval)
  struct V4C__Context *ctx ;
  struct V4DPI__Point *point ;
  double dblval ;
{ B64INT b64 ;

	switch (point->PntType)
	 { default:				/* Not valid numeric - force point to double */
		dblPNTv(point,dblval) ; break ;
	   CASEofINT			point->Value.IntVal = DtoI(dblval) ; break ;
	   case V4DPI_PntType_UTime:
	   case V4DPI_PntType_Calendar:
	   case V4DPI_PntType_Real:	PUTREAL(point,dblval) ; break ;
	   case V4DPI_PntType_Fixed:
		dblval += (dblval < 0 ? -vRound[point->LHSCnt] : vRound[point->LHSCnt]) ;
	   	b64 = (B64INT)(dblval * powers[point->LHSCnt]) ;
		memcpy(&point->Value.FixVal,&b64,sizeof b64) ; break ;
	   case V4DPI_PntType_UOM:	memcpy(&point->Value.UOMVal.Num,&dblval,sizeof dblval) ; break ;
	   case V4DPI_PntType_UOMPer:	memcpy(&point->Value.UOMPerVal.Amount,&dblval,sizeof dblval) ; break ;
		break ;
	 } ;
}

/*	T A L L Y   R O U T I N E S						*/

#ifdef V4ENABLEMULTITHREADS
LOGICAL v4im_MTGrabLock(ctx,flagp)
  struct V4C__Context *ctx ;
  DCLSPINLOCK *flagp ;
{ int tries ;

/*	Try for lock. Should not have to wait long, nor should there be many tries */
	for(tries=0;tries<1000000;tries++)
	 { 
	   if (GETSPINLOCK(flagp)) return(TRUE) ;
	   if (tries % 100000) HANGLOOSE(10) ; 
	   gpi->mtLockConflicts++ ;
	 } ;
	v_Msg(ctx,ctx->ErrorMsgAux,"MTCantLock") ; return(FALSE) ;
} ;
#endif

/*	ok = v4im_TallyEntryInsert - Inserts (or merges) entry into hash table	*/
/*	Call: v4im_TallyEntryInsert( ctx, vtee , vte, vtew , actx , isct )
	  where ok is TRUE/FALSE,
		vtee is pointer to TallyEnumEnvironment,
		vte is pointer to TallyEntry to be inserted/merged,
		vtew is pointer to "With" values (NULL if none),
		actx is current action index					*/

int v4im_TallyEntryInsert(ctx,vtee,vte,vtew,actx)
  struct V4C__Context *ctx ;
  struct V4IM_TallyEnumEnvironment *vtee ;
  struct V4IM__TallyEntry *vte ;
  struct V4IM__TallyEntryWith *vtew ;
  int actx ;
{
  struct V4DPI__Point *tpt,*tpt1 ;
  struct V4IM__TallyMaster *vtm ;
  struct V4IM__TallyEntry *vte1 ;
  struct V4IM__TallyEntryWith *vtew1 ;
  int lx,hval,px,vx,hx,wx,chainmax,hdir ;

	vtm = vtee->vtm ;
	lx = 0 ; chainmax = 20 ; hdir = 1 ;				/* Init these once */
top:	/* Entry to restart hash search based on backwards hash calculation */
	tpt = (struct V4DPI__Point *)((char *)vte + vte->Offset) ;	/* Loop thru all points for hash value */
	hval = 0 ; chainmax = 20 ;
	for(px=0;px<vtm->Action[actx].NumComboPoints;px++)
	 { int thash ;
	   if (hdir == 1) { VHASH32_FWDb(thash,&tpt->Value,tpt->Bytes - V4DPI_PointHdr_Bytes) } else { VHASH32_REVb(thash,&tpt->Value,tpt->Bytes - V4DPI_PointHdr_Bytes) } ;
	   hval = hval ^ thash ;
	   ADVPNT(tpt) ;
	   chainmax += (hval & 0xf) ;				/* Make up psuedo-random max for chaining (see below) */
	 } ; 
	if (vtm->Action[actx].NumComboPoints == 0) hval = vtm->Action[actx].DfltHash ;
	if (hval == 0) { hval = 1 ; } else if (hval < 0) hval &= 0x7fffffff ;
	hx = hval % vtm->TallyEntryMax ;
	for(;;lx++,hx=(hx >= vtm->TallyEntryMax - 1 ? 0 : hx+1))
	 { 
	   if (vtm->teb->Entry[hx] == NULL) break ;		/* No entries matching! */
	   vte1 = vtm->teb->Entry[hx] ;
	   if (vte1->HashVal != hval)			/* Got a hit - try next entry */
	    { if (((++vtee->HashHits) & V4IM_Tally_HashHitInterval) == 0)
	       { v_Msg(ctx,UCTBUF2,"*TallyHashCnf",V4IM_OpCode_Tally,vtee->HashHits) ; vout_UCText(VOUT_Warn,0,UCTBUF2) ;
	         v_Msg(ctx,UCTBUF2,"*TallyHashCnf2",V4IM_OpCode_Tally,(int)(vtm->TallyEntryMax*1.5)) ; vout_UCText(VOUT_Warn,0,UCTBUF2) ;
	       } ;
	      if (lx == chainmax && hdir == 1)		/* We have chained too many times? - not good */
	       { hdir = 2 ;				/* Flip hash calculation direction to right-to-left */
	         goto top ;				/* Start all over again */
	       } ;
	      continue ;
	    } ;
	   if (vte1->ActionX != actx) continue ;	/* Hash entry from another group */
	   tpt = (struct V4DPI__Point *)((char *)vte + vte->Offset) ;	/* Loop thru all points for hash value */
	   tpt1 = (struct V4DPI__Point *)((char *)vte1 + vte1->Offset) ;
	   for(px=0;px<vtm->Action[actx].NumComboPoints;px++)	/* Hashes match - check combo values */
	    { if (memcmp(tpt,tpt1,tpt->Bytes) != 0) break ;	/* Points match? if <> 0 then no */
	      ADVPNT(tpt) ; ADVPNT(tpt1) ;
	    } ; if (px >= vtm->Action[actx].NumComboPoints) break ;	/* All points match - get out of loop */
	 } ;
	if (vtm->teb->Entry[hx] == NULL)			/* New entry? */
	 { 
	   if (!GRABMTLOCK(vtm->tebLock)) return(FALSE) ;
	   if ((++vtm->EntryCount) >= vtm->TallyEntryMax)
	    { v_Msg(ctx,ctx->ErrorMsgAux,"TallyMaxHS",vtm->TallyEntryMax) ; FREEMTLOCK(vtm->tebLock) ; return(FALSE) ; } ;
	   vte->ActionX = actx ;
	   vte1 = v4im_tallyAllocAndCopy(vtm,vte,vte->Bytes) ;
	   if (vtm->Action[actx].NumWith > 0)		/* Do we have "With" values */
	    { vte1->auxPtr = v4mm_AllocChunk(vtm->Action[actx].NumWith*sizeof(*tpt),FALSE) ;
	      vtew1 = (struct V4IM__TallyEntryWith *)vte1->auxPtr ;
	      for(vx=0;vx<vtm->Action[actx].NumWith;vx++)	/* Copy first points over into vte1 */
	       { memcpy(&vtew1->wpt[vx],&vtew->wpt[vx],vtew->wpt[vx].Bytes) ; } ;
	    } ;
	   vte1->HashVal = hval ;
	   vtm->teb->Entry[hx] = vte1 ;			/* Remember where/what we did */
#ifdef V4ENABLEMULTITHREADS
	   INITMTLOCK(vte1->mtLock) ;			/* Make this vte entry available */
	   FREEMTLOCK(vtm->tebLock) ;
#endif
	 } else						/* Existing entry, merge vte into it */
	 { 
	   if (!GRABMTLOCK(vte1->mtLock)) return(FALSE) ;
	   for(vx=0;vx<vtm->Action[actx].NumValues;vx++)
	    { 

	      vte1->Entry[vx].Count += vte->Entry[vx].Count ;
	      switch (vtm->Action[actx].ActionType)
	       { default:
		   switch (vte1->Entry[vx].eType)
		    { case V4IM_TEeType_ns:
			vte1->Entry[vx].tec.ns.Sum += vte->Entry[vx].tec.ns.Sum ;
			break ;
		      case V4IM_TEeType_fs:
			if (vte->Entry[vx].tec.fs.fSum != 0)
			 { for(;vte1->Entry[vx].tec.fs.decimals<vte->Entry[vx].tec.fs.decimals;vte1->Entry[vx].tec.fs.decimals++)
			    { vte1->Entry[vx].tec.fs.fSum *= 10 ; } ;
			   SCALEFIX(vte->Entry[vx].tec.fs.fSum,vte->Entry[vx].tec.fs.decimals,vte1->Entry[vx].tec.fs.decimals)
			   vte1->Entry[vx].tec.fs.fSum += vte->Entry[vx].tec.fs.fSum ;
			 } ;
			break ;
		      case V4IM_TEeType_us:
			if (vte->Entry[vx].eType == V4IM_TEeType_ns)
			 { if (vte->Entry[vx].tec.ns.Sum != 0) printf("Mismatched UOM\n") ; break ;
			 } ;
			if (vte->Entry[vx].tec.us.uRef != vte1->Entry[vx].tec.us.uRef) { printf("Mismatched UOM\n") ; break ; } ;
			vte1->Entry[vx].tec.us.uSum += vte->Entry[vx].tec.us.uSum ;
		    } ; break ;
	         case V4IM_ActType_Min:
		   switch (vte1->Entry[vx].eType)
		    { case V4IM_TEeType_ns:
			if (vte->Entry[vx].tec.ns.Sum < vte1->Entry[vx].tec.ns.Sum)
			 { vte1->Entry[vx].tec.ns.Sum = vte->Entry[vx].tec.ns.Sum ;
			   vtew1 = (struct V4IM__TallyEntryWith *)vte1->auxPtr ;
			   for(wx=0;wx<vtm->Action[actx].NumWith;wx++)
			    { memcpy(&vtew1->wpt[wx],&vtew->wpt[wx],vtew->wpt[vx].Bytes) ; } ;
			 } ;
			break ;
		      case V4IM_TEeType_fs:
		      case V4IM_TEeType_us:
			break ;
		    } ; break ;
	         case V4IM_ActType_Max:
		   switch (vte1->Entry[vx].eType)
		    { case V4IM_TEeType_ns:
			if (vte->Entry[vx].tec.ns.Sum > vte1->Entry[vx].tec.ns.Sum)
			 { vte1->Entry[vx].tec.ns.Sum = vte->Entry[vx].tec.ns.Sum ;
			   vtew1 = (struct V4IM__TallyEntryWith *)vte1->auxPtr ;
			   for(wx=0;wx<vtm->Action[actx].NumWith;wx++)
			    { memcpy(&vtew1->wpt[wx],&vtew->wpt[wx],vtew->wpt[vx].Bytes) ; } ;
			 } ;
			break ;
		      case V4IM_TEeType_fs:
		      case V4IM_TEeType_us:
			break ;
		    } ; break ;
	         case V4IM_ActType_StdDev:
		   vte1->Entry[vx].tec.sd.sdSum += vte->Entry[vx].tec.sd.sdSum ;
		   vte1->Entry[vx].tec.sd.sdSumSq += vte->Entry[vx].tec.sd.sdSumSq ;
		   break ;
	       } ;
	    } ;
	   FREEMTLOCK(vte1->mtLock) ;
	 } ;
	return(TRUE) ;
}

/*	v4im_TallyEntryAlloc - Allocates a new buffer for Tally		*/
/*	Call: v4im_TallyEntryAlloc( vtm )
	  where vtm is pointer to current tally master, CurBuf updated	*/

void v4im_TallyEntryAlloc(vtm)
  struct V4IM__TallyMaster *vtm ;
{ struct V4IM__TallyBuf *obuf ;

	obuf = vtm->CurBuf ;		/* Save current value */
	vtm->CurBuf = (struct V4IM__TallyBuf *)v4mm_AllocChunk(sizeof *obuf,FALSE) ;
	vtm->CurBuf->PriorBuf = obuf ;	/* Link to prior so we can deallocate when done */
	vtm->CurBuf->NextFree = 0 ;	/* Make current empty */
}

/*	v4im_TallyMakeBinds - Here to create bindings from Tally() results	*/
/*	Call: ok = v4im_TallyMakeBinds( ctx , vtm , actx , bindif)
	  where ctx is context,
		vtm is tally master,
		actx is action index under consideration,
		bindif, if not NULL, is test to perform before making binding	*/

int v4im_TallyMakeBinds(ctx,vtm,actx,bindif)
  struct V4C__Context *ctx ;
  struct V4IM__TallyMaster *vtm ;
  int actx ;
  struct V4DPI__Point *bindif ;
{ struct V4IM__TallyEntry *vte ;
  struct V4IM__TallyEntryWith *vtew ;
  struct V4L__ListPoint *lp ;
  struct V4DPI__Binding binding ;
  struct V4DPI__DimInfo *di=NULL ;
  struct V4DPI__Point bindpt,valpt,isctbuf,*ipt,*ipt1,*tpt ;
  int vx,i,j,k,ok,PntType,resdim,dobind,frameid=UNUSED ; double dbl ;


	if (bindif != NULL) { frameid = v4ctx_FramePush(ctx,NULL) ; } ;		/* Start new context frame */

/*	Gonna make a mess 'o bindings */
	for(vx=0;vx<vtm->TallyEntryMax;vx++)
	 { if (vtm->teb->Entry[vx] == NULL) continue ;		/* Nothing in this slot */
	   vte = vtm->teb->Entry[vx] ; if (vte->ActionX != actx) continue ;
	   if (vtm->Action[actx].p3->PntType == V4DPI_PntType_List)
	    { lp = ALIGNLP(&vtm->Action[actx].p3->Value) ;	/* Third element is base bind iscts */
	    } else { lp = NULL ; }
	   for(i=1;;i++)						/* Loop thru each point in list */
	    { if (lp == NULL) { tpt = vtm->Action[actx].p3 ; }
	       else { if (v4l_ListPoint_Value(ctx,lp,i,&isctbuf) <= 0) break ; tpt = &isctbuf ; } ;
	      if (tpt->PntType != V4DPI_PntType_Isct)			/* If bind point not intersection then make one */
	       { INITISCT(&bindpt) ; NOISCTVCD(&bindpt) ; bindpt.Grouping = 1 ;
	         ipt = ISCT1STPNT(&bindpt) ; memcpy(ipt,tpt,tpt->Bytes) ; bindpt.Bytes += tpt->Bytes ;
		 ADVPNT(ipt) ;
	       } else
	       { memcpy(&bindpt,tpt,tpt->Bytes) ;
	         for(ipt=ISCT1STPNT(&bindpt),j=0;j<bindpt.Grouping;j++,ADVPNT(ipt)) { } ;
	       } ;
	      bindpt.Dim = 0 ;		/* No dimension/cache-flag */
	      ipt1 = (struct V4DPI__Point *)((char *)vte + vte->Offset) ;
	      for(k=0;k<vtm->Action[actx].NumComboPoints;k++)			/* Append each of the combo points */
	       { memcpy(ipt,ipt1,ipt1->Bytes) ; bindpt.Grouping ++ ;
	         ADVPNT(ipt) ; ADVPNT(ipt1) ;
	       } ;
	      ISCTLEN(&bindpt,ipt) ;
	      if (vtm->Action[actx].ResDim > 0) { resdim = vtm->Action[actx].ResDim ; }
	       else if (vtm->GlobalResDim > 0) { resdim = vtm->GlobalResDim ; }
	       else { resdim = 0 ; } ;



	      if (resdim > 0)
	       { DIMINFO(di,ctx,resdim) ; PntType = di->PointType ; }
	       else { switch (vte->Entry[i-1].eType)
		       { case V4IM_TEeType_ns:	PntType = V4DPI_PntType_Int ; break ;
		         case V4IM_TEeType_sd:	PntType = V4DPI_PntType_Real ; break ;
		         case V4IM_TEeType_fs:	PntType = V4DPI_PntType_Fixed ; break ;
		         case V4IM_TEeType_us:	PntType = V4DPI_PntType_UOM ; break ;
		       } ;
		    } ;
	      switch (vtm->Action[actx].ActionType)
	       { default:
		 case V4IM_ActType_Min:
		 case V4IM_ActType_Max:
		   break ;			/* xxSum has correct value */
		 case V4IM_ActType_Count:
		   switch (vte->Entry[i-1].eType)
		    { case V4IM_TEeType_ns:	vte->Entry[i-1].tec.ns.Sum = vte->Entry[i-1].Count ; break ;
		      case V4IM_TEeType_sd:	break ;
		      case V4IM_TEeType_fs:	vte->Entry[i-1].tec.fs.fSum = vte->Entry[i-1].Count ; break ;
		      case V4IM_TEeType_us:	vte->Entry[i-1].tec.us.uSum = vte->Entry[i-1].Count ; break ;
		    } ; break ;
		 case V4IM_ActType_Avg:
		   switch (vte->Entry[i-1].eType)
		    { case V4IM_TEeType_ns:	vte->Entry[i-1].tec.ns.Sum /= vte->Entry[i-1].Count ; break ;
		      case V4IM_TEeType_sd:	break ;
		      case V4IM_TEeType_fs:	vte->Entry[i-1].tec.fs.fSum /= vte->Entry[i-1].Count ; break ;
		      case V4IM_TEeType_us:	vte->Entry[i-1].tec.us.uSum /= vte->Entry[i-1].Count ; break ;
		    } ; break ;
		 case V4IM_ActType_Sub:
		   switch (vte->Entry[i-1].eType)
		    { case V4IM_TEeType_ns:	vte->Entry[i-1].tec.ns.Sum = -vte->Entry[i-1].tec.ns.Sum ; break ;
		      case V4IM_TEeType_sd:	break ;
		      case V4IM_TEeType_fs:	vte->Entry[i-1].tec.fs.fSum = -vte->Entry[i-1].tec.ns.Sum ; break ;
		      case V4IM_TEeType_us:	vte->Entry[i-1].tec.us.uSum = -vte->Entry[i-1].tec.ns.Sum ; break ;
		    } ; break ;
		 case V4IM_ActType_StdDev:
		   vte->Entry[i-1].tec.sd.sdSum = vte->Entry[i-1].Count * vte->Entry[i-1].tec.sd.sdSumSq - (vte->Entry[i-1].tec.sd.sdSum * vte->Entry[i-1].tec.sd.sdSum) ;
		   vte->Entry[i-1].tec.sd.sdSum = (vte->Entry[i-1].Count <= 1 ? 0.0 : vte->Entry[i-1].tec.sd.sdSum / (vte->Entry[i-1].Count * (vte->Entry[i-1].Count - 1.0))) ;
		   if (vte->Entry[i-1].tec.sd.sdSum > 0 && vte->Entry[i-1].Count > 1) { vte->Entry[i-1].tec.sd.sdSum = sqrt(vte->Entry[i-1].tec.sd.sdSum) ; }
		    else vte->Entry[i-1].tec.sd.sdSum = 0 ;
		   break ;
	       } ;
	      ZPH(&valpt) ;		/* Create value & append to inner list */
	      valpt.PntType = PntType ;
	      switch (PntType)
	       { default:
		 case V4DPI_PntType_CodedRange:
		 case V4DPI_PntType_Int:
		   valpt.Dim = (resdim > 0 ? resdim : Dim_Int) ; valpt.Bytes = V4PS_Int ;
		   switch(vte->Entry[i-1].eType)
		    { case V4IM_TEeType_ns:	dbl = vte->Entry[i-1].tec.ns.Sum ; break ;
		      case V4IM_TEeType_sd:	dbl = vte->Entry[i-1].tec.sd.sdSum ; break ;
		      case V4IM_TEeType_fs:	dbl = vte->Entry[i-1].tec.fs.fSum ; break ;
		      case V4IM_TEeType_us:	dbl = vte->Entry[i-1].tec.us.uSum ; break ;
		    } ;
		   if (dbl < (double)V4LIM_SmallestNegativeInt || dbl > (double)V4LIM_BiggestPositiveInt)
		    { v_Msg(ctx,ctx->ErrorMsgAux,"TallyLimit",dbl,valpt.Dim,V4DPI_PntType_Int) ; goto fail ; } ;
		   valpt.Value.IntVal = DtoI(dbl) ;
		   break ;
		 case V4DPI_PntType_UOM:
		   valpt.Dim = (resdim > 0 ? resdim : vte->Entry[i-1].Dim) ; valpt.Bytes = V4PS_UOM ;
		   memcpy(&valpt.Value.UOMVal.Num,&vte->Entry[i-1].tec.us.uSum,sizeof valpt.Value.UOMVal.Num) ;
		   valpt.Value.UOMVal.Ref = vte->Entry[i-1].tec.us.uRef ; valpt.Value.UOMVal.Index = vte->Entry[i-1].tec.us.uIndex ;
		   break ;
		 case V4DPI_PntType_Fixed:
		   valpt.Dim = (resdim > 0 ? resdim : vte->Entry[i-1].Dim) ; valpt.Bytes = V4PS_Fixed ; valpt.LHSCnt = (di == NULL ? 0 : di->Decimals) ;
		   switch(vte->Entry[i-1].eType)
		    { case V4IM_TEeType_ns:
			SCALEFIX(vte->Entry[i-1].tec.ns.Sum,0,di->Decimals) ;
			{ B64INT li ; li = DtoLI(vte->Entry[i-1].tec.ns.Sum) ;
			  memcpy(&valpt.Value.FixVal,&li,sizeof valpt.Value.FixVal) ;
			} ;
			break ;
		      case V4IM_TEeType_sd:
			SCALEFIX(vte->Entry[i-1].tec.sd.sdSum,0,di->Decimals) ;
			{ B64INT li ; li = DtoLI(vte->Entry[i-1].tec.sd.sdSum) ;
			  memcpy(&valpt.Value.FixVal,&li,sizeof valpt.Value.FixVal) ;
			} ;
			break ;
		      case V4IM_TEeType_fs:
			SCALEFIX(vte->Entry[i-1].tec.fs.fSum,vte->Entry[i-1].tec.fs.decimals,di->Decimals)
			memcpy(&valpt.Value.FixVal,&vte->Entry[i-1].tec.fs.fSum,sizeof valpt.Value.FixVal) ;
			break ;
		      case V4IM_TEeType_us:
			SCALEFIX(vte->Entry[i-1].tec.us.uSum,0,di->Decimals) ;
			{ B64INT li ; li = DtoLI(vte->Entry[i-1].tec.us.uSum) ;
			  memcpy(&valpt.Value.FixVal,&li,sizeof valpt.Value.FixVal) ;
			} ;
			break ;
		    } ;
		   break ;
		 case V4DPI_PntType_Calendar:
		 case V4DPI_PntType_UTime:
		 case V4DPI_PntType_Real:
		   valpt.Dim = (resdim > 0 ? resdim : Dim_Num) ; valpt.Bytes = V4PS_Real ;
		   switch(vte->Entry[i-1].eType)
		    { case V4IM_TEeType_ns:	PUTREAL(&valpt,vte->Entry[i-1].tec.ns.Sum) ; break ;
		      case V4IM_TEeType_sd:	PUTREAL(&valpt,vte->Entry[i-1].tec.sd.sdSum) ; break ;
		      case V4IM_TEeType_fs:	PUTREAL(&valpt,vte->Entry[i-1].tec.fs.fSum) ; break ;
		      case V4IM_TEeType_us:	PUTREAL(&valpt,vte->Entry[i-1].tec.us.uSum) ; break ;
		    } ;
		   break ;
	       } ;

	       if (bindif != NULL)				/* Do we have a test to perform to see if we really want to make this binding? */
		{ if (!v4ctx_FrameAddDim(ctx,0,&valpt,0,0)) goto fail ; CLEARCACHE
		  ipt = v4dpi_IsctEval(&isctbuf,bindif,ctx,V4DPI_EM_EvalQuote,NULL,NULL) ;
		  if (ipt == NULL) goto fail ;
		  dobind = PNTlogVAL(&ok,ipt,ctx) ; if (!ok) goto fail ;
		  if (!dobind) vte->vteFlags |= V4IM_vteFlags_NoBind ;
		} else { dobind = TRUE ; } ;

	      if (dobind)
	       { if (!v4dpi_BindListMake(&binding,&valpt,&bindpt,ctx,NULL,NOWGTADJUST,0,DFLTRELH)) return(FALSE) ;
	         if (traceGlobal & V4TRACE_TallyBind)
	          { v_Msg(ctx,UCTBUF2,"*TraceTallyBind",&bindpt,&valpt) ; vout_UCText(VOUT_Trace,0,UCTBUF2) ; } ;
	       } ;
	      if (lp == NULL) break ;
	    } ;
/*	   Now repeat above for any With values */
	   if (vtm->Action[actx].WBind == NULL) continue ;		/* Got WBinds to deal with? */
	   if (vtm->Action[actx].WBind->PntType == V4DPI_PntType_List)
	    { lp = ALIGNLP(&vtm->Action[actx].WBind->Value) ;
	    } else { lp = NULL ; }
	   vtew = (struct V4IM__TallyEntryWith *)vte->auxPtr ;		/* Link up to the "with" values */
	   for(i=1;;i++)						/* Loop thru each point in list */
	    { if (lp == NULL) { ipt = vtm->Action[actx].WBind ; }
	       else { if (v4l_ListPoint_Value(ctx,lp,i,&isctbuf) <= 0) break ; ipt = &isctbuf ; } ;
	      if (ipt->PntType != V4DPI_PntType_Isct)			/* If bind point not intersection then make one */
	       { INITISCT(&bindpt) ; NOISCTVCD(&bindpt) ; bindpt.Grouping = 1 ; tpt = ISCT1STPNT(&bindpt) ;
	         memcpy(tpt,ipt,ipt->Bytes) ; bindpt.Bytes = V4DPI_PointHdr_Bytes + ipt->Bytes ;
		 ADVPNT(tpt) ; ipt = tpt ;
	       } else
	       { memcpy(&bindpt,ipt,ipt->Bytes) ;
	         for(ipt=ISCT1STPNT(&bindpt),j=0;j<bindpt.Grouping;j++,ADVPNT(ipt)) { } ;
	       } ;
	      ipt1 = (struct V4DPI__Point *)((char *)vte + vte->Offset) ;
	      for(k=0;k<vtm->Action[actx].NumComboPoints;k++)
	       { memcpy(ipt,ipt1,ipt1->Bytes) ; bindpt.Grouping ++ ;
	         ADVPNT(ipt) ; ADVPNT(ipt1) ;
	       } ;
	      ISCTLEN(&bindpt,ipt) ;
	      if(!v4dpi_BindListMake(&binding,&vtew->wpt[i-1],&bindpt,ctx,NULL,NOWGTADJUST,0,DFLTRELH)) return(FALSE) ;
	      if (traceGlobal & V4TRACE_TallyBind)
	       { 
		 v_Msg(ctx,UCTBUF2,"*TraceTallyBind",&bindpt,&vtew->wpt[i-1]) ; vout_UCText(VOUT_Trace,0,UCTBUF2) ;
	       } ;
	      if (lp == NULL) break ;
	    } ;
/*	   End of section to inject "With" values */
	 } ;
/*	Re-synch context */
	if (frameid != UNUSED) v4ctx_FramePop(ctx,frameid,NULL) ;
	if (!v4dpi_BindListMake(NULL,NULL,NULL,ctx,NULL,NOWGTADJUST,0,DFLTRELH)) return(FALSE) ;
	v4ctx_Resynch(ctx) ;
	return(TRUE) ;
fail:	if (frameid != UNUSED) v4ctx_FramePop(ctx,frameid,NULL) ;
	return(FALSE) ;
}


/*	v4im_TallyMakeProjections - Here to create projections from Tally() results	*/
/*	Call: ok = v4im_TallyMakeProjections( ctx , vtm , actx , bindif)
	  where ctx is context,
		vtm is tally master,
		actx is action index under consideration,
		bindif, if not NULL, is test for actually creating projection		*/

int v4im_TallyMakeProjections(ctx,vtm,actx,bindif)
  struct V4C__Context *ctx ;
  struct V4IM__TallyMaster *vtm ;
  int actx ;
  struct V4DPI__Point *bindif ;
{ struct V4IM__TallyEntry *vte ;
  struct V4L__ListPoint *lp ;
  struct V4DPI__DimInfo *di ;
  struct V4DPI__Point *ipt,valpt,isctbuf ;
  struct V4DPI__Point *dimpt,*srcpt ;
  int vx,i,PntType,ok,dobind,frameid=UNUSED ;

	if (bindif != NULL) { frameid = v4ctx_FramePush(ctx,NULL) ; } ;		/* Start new context frame */
/*	Go thru all the hash entries looking for something to do */
	for(vx=0;vx<vtm->TallyEntryMax;vx++)
	 { if (vtm->teb->Entry[vx] == NULL) continue ;		/* Nothing in this slot */
	   vte = vtm->teb->Entry[vx] ; if (vte->ActionX != actx) continue ;
	   if (vtm->Action[actx].Project->PntType == V4DPI_PntType_List)
	    { lp = ALIGNLP(&vtm->Action[actx].Project->Value) ;	/* Third element is base bind iscts */
	    } else { lp = NULL ; }
	   for(i=1;;i++)						/* Loop thru each point in list */
	    { if (lp == NULL) { dimpt = vtm->Action[actx].Project ; }
	       else { if (v4l_ListPoint_Value(ctx,lp,i,&isctbuf) <= 0) break ; dimpt = &isctbuf ; } ;
	      if (dimpt->Dim != Dim_Dim) { v_Msg(ctx,ctx->ErrorMsgAux,"TallyNotDimDim",V4IM_Tag_Project,dimpt) ; return(FALSE) ; } ;
	      DIMINFO(di,ctx,dimpt->Value.IntVal) ; PntType = di->PointType ;

	      if (vtm->Action[actx].NumComboPoints != 1)
	       { v_Msg(ctx,ctx->ErrorMsgAux,"TallyProj1Src",V4IM_Tag_By,V4IM_Tag_Project) ; return(FALSE) ; } ;
	      srcpt = (struct V4DPI__Point *)((char *)vte + vte->Offset) ;


	      switch (vtm->Action[actx].ActionType)
	       { default:
		 case V4IM_ActType_Min:
		 case V4IM_ActType_Max:
		   break ;			/* xxSum has correct value */
		 case V4IM_ActType_Count:
		   switch (vte->Entry[i-1].eType)
		    { case V4IM_TEeType_ns:	vte->Entry[i-1].tec.ns.Sum = vte->Entry[i-1].Count ; break ;
		      case V4IM_TEeType_sd:	break ;
		      case V4IM_TEeType_fs:	vte->Entry[i-1].tec.fs.fSum = vte->Entry[i-1].Count ; break ;
		      case V4IM_TEeType_us:	vte->Entry[i-1].tec.us.uSum = vte->Entry[i-1].Count ; break ;
		    } ; break ;
		 case V4IM_ActType_Avg:
		   switch (vte->Entry[i-1].eType)
		    { case V4IM_TEeType_ns:	vte->Entry[i-1].tec.ns.Sum /= vte->Entry[i-1].Count ; break ;
		      case V4IM_TEeType_sd:	break ;
		      case V4IM_TEeType_fs:	vte->Entry[i-1].tec.fs.fSum /= vte->Entry[i-1].Count ; break ;
		      case V4IM_TEeType_us:	vte->Entry[i-1].tec.us.uSum /= vte->Entry[i-1].Count ; break ;
		    } ; break ;
		 case V4IM_ActType_Sub:
		   switch (vte->Entry[i-1].eType)
		    { case V4IM_TEeType_ns:	vte->Entry[i-1].tec.ns.Sum = -vte->Entry[i-1].tec.ns.Sum ; break ;
		      case V4IM_TEeType_sd:	break ;
		      case V4IM_TEeType_fs:	vte->Entry[i-1].tec.fs.fSum = -vte->Entry[i-1].tec.ns.Sum ; break ;
		      case V4IM_TEeType_us:	vte->Entry[i-1].tec.us.uSum = -vte->Entry[i-1].tec.ns.Sum ; break ;
		    } ; break ;
		 case V4IM_ActType_StdDev:
		   vte->Entry[i-1].tec.sd.sdSum = vte->Entry[i-1].Count * vte->Entry[i-1].tec.sd.sdSumSq - (vte->Entry[i-1].tec.sd.sdSum * vte->Entry[i-1].tec.sd.sdSum) ;
		   vte->Entry[i-1].tec.sd.sdSum = (vte->Entry[i-1].Count <= 1 ? 0.0 : vte->Entry[i-1].tec.sd.sdSum / (vte->Entry[i-1].Count * (vte->Entry[i-1].Count - 1.0))) ;
		   if (vte->Entry[i-1].tec.sd.sdSum > 0 && vte->Entry[i-1].Count > 1) { vte->Entry[i-1].tec.sd.sdSum = sqrt(vte->Entry[i-1].tec.sd.sdSum) ; }
		    else vte->Entry[i-1].tec.sd.sdSum = 0 ;
		   break ;
	       } ;

	      ZPH(&valpt) ;		/* Create value & append to inner list */
	      valpt.PntType = PntType ; valpt.Dim = di->DimId ;

	      switch (PntType)
	       { default:
		 case V4DPI_PntType_CodedRange:
		 case V4DPI_PntType_Int:
		   valpt.Bytes = V4PS_Int ;
		   switch(vte->Entry[i-1].eType)
		    { case V4IM_TEeType_ns:	valpt.Value.IntVal = DtoI(vte->Entry[i-1].tec.ns.Sum) ; break ;
		      case V4IM_TEeType_sd:	valpt.Value.IntVal = DtoI(vte->Entry[i-1].tec.sd.sdSum) ; break ;
		      case V4IM_TEeType_fs:	valpt.Value.IntVal = DtoI(vte->Entry[i-1].tec.fs.fSum) ; break ;
		      case V4IM_TEeType_us:	valpt.Value.IntVal = DtoI(vte->Entry[i-1].tec.us.uSum) ; break ;
		    } ;
		   break ;
		 case V4DPI_PntType_UOM:
		   valpt.Bytes = V4PS_UOM ;
		   memcpy(&valpt.Value.UOMVal.Num,&vte->Entry[i-1].tec.us.uSum,sizeof valpt.Value.UOMVal.Num) ;
		   valpt.Value.UOMVal.Ref = vte->Entry[i-1].tec.us.uRef ; valpt.Value.UOMVal.Index = vte->Entry[i-1].tec.us.uIndex ;
		   break ;
		 case V4DPI_PntType_Fixed:
		   valpt.Bytes = V4PS_Fixed ; valpt.LHSCnt = di->Decimals ;
		   switch(vte->Entry[i-1].eType)
		    { case V4IM_TEeType_ns:
			SCALEFIX(vte->Entry[i-1].tec.ns.Sum,0,di->Decimals) ;
			{ B64INT li ; li = DtoLI(vte->Entry[i-1].tec.ns.Sum) ;
			  memcpy(&valpt.Value.FixVal,&li,sizeof valpt.Value.FixVal) ;
			} ;
			break ;
		      case V4IM_TEeType_sd:
			SCALEFIX(vte->Entry[i-1].tec.sd.sdSum,0,di->Decimals) ;
			{ B64INT li ; li = DtoLI(vte->Entry[i-1].tec.sd.sdSum) ;
			  memcpy(&valpt.Value.FixVal,&li,sizeof valpt.Value.FixVal) ;
			} ;
			break ;
		      case V4IM_TEeType_fs:
			SCALEFIX(vte->Entry[i-1].tec.fs.fSum,vte->Entry[i-1].tec.fs.decimals,di->Decimals)
			memcpy(&valpt.Value.FixVal,&vte->Entry[i-1].tec.fs.fSum,sizeof valpt.Value.FixVal) ;
			break ;
		      case V4IM_TEeType_us:
			SCALEFIX(vte->Entry[i-1].tec.us.uSum,0,di->Decimals) ;
			{ B64INT li ; li = DtoLI(vte->Entry[i-1].tec.us.uSum) ;
			  memcpy(&valpt.Value.FixVal,&li,sizeof valpt.Value.FixVal) ;
			} ;
			break ;
		    } ;
		   break ;
		 case V4DPI_PntType_Calendar:
		 case V4DPI_PntType_Real:
		   valpt.Bytes = V4PS_Real ;
		   switch(vte->Entry[i-1].eType)
		    { case V4IM_TEeType_ns:	PUTREAL(&valpt,vte->Entry[i-1].tec.ns.Sum) ; break ;
		      case V4IM_TEeType_sd:	PUTREAL(&valpt,vte->Entry[i-1].tec.sd.sdSum) ; break ;
		      case V4IM_TEeType_fs:	PUTREAL(&valpt,vte->Entry[i-1].tec.fs.fSum) ; break ;
		      case V4IM_TEeType_us:	PUTREAL(&valpt,vte->Entry[i-1].tec.us.uSum) ; break ;
		    } ;
		   break ;
	       } ;

	      if (bindif != NULL)				/* Do we have a test to perform to see if we really want to make this binding? */
	       { if (!v4ctx_FrameAddDim(ctx,0,&valpt,0,0)) goto fail ; CLEARCACHE
	         ipt = v4dpi_IsctEval(&isctbuf,bindif,ctx,V4DPI_EM_EvalQuote,NULL,NULL) ;
	         if (ipt == NULL) goto fail ;
	         dobind = v4im_GetPointLog(&ok,ipt,ctx) ; if (!ok) goto fail ;
		 if (!dobind) vte->vteFlags |= V4IM_vteFlags_NoBind ;
	       } else { dobind = TRUE ; } ;
/*	      Want to do define projection - dimpt:=valpt */
	      if (dobind)
	       { struct V4DPI__Point *argpnts[3], *respnt=&isctbuf ; int argcnt=2, intmodx=V4IM_OpCode_Tally, fallthruval, *fallthru=&fallthruval ;
	         struct V4DPI__Point *v4im_DoProject() ;
		 argpnts[1] = &valpt ; argpnts[2] = srcpt ;
	         v4im_DoProject(ctx,respnt,argpnts,argcnt,intmodx,fallthru) ;
	       } ;
	      if (lp == NULL) break ;
	    } ;
	 } ;
	if (frameid != UNUSED) v4ctx_FramePop(ctx,frameid,NULL) ;
	v4ctx_Resynch(ctx) ;
	return(TRUE) ;

fail:	if (frameid != UNUSED) v4ctx_FramePop(ctx,frameid,NULL) ;
	return(FALSE) ;
}

/*	v4im_TallyList - Append point to proper list		*/
/*	Call: ok = v4im_TallyList( ctx , listpt , vtee ,actx, vte , isct )
	  where ctx is context,
		listpt is pointer to listpoint,
		vtee is TallyEnumEnvironment,
		actx is action index,
		vte is TallyEntry with combo-points set,
		isct is original isct that got us here		*/

int v4im_TallyList(ctx,listpt,vtee,actx,vte)
  struct V4C__Context *ctx ;
  struct V4DPI__Point *listpt ;
  struct V4IM_TallyEnumEnvironment *vtee ;
  int actx ;
  struct V4IM__TallyEntry *vte ;
{
  struct V4IM__TallyMaster *vtm ;
  struct V4DPI__Point *tpt,*tpt1 ;
  struct V4IM__TallyEntry *vte1 ;
  struct V4IM__TallySort vts ;
  struct V4IM__TallyListBitMap *tlbm ;
  struct V4IM__TallyListPoints *vtlp ;
  struct V4IM__TallySortCache *tsc ;
  int i,k,hval,px,vx,hx,*ip ; int *iptr ;

	XDBSAVEROW(listpt) ;			/* Maybe we need to save XDB row associated with this point? */
	vtm = vtee->vtm ;
	tpt = (struct V4DPI__Point *)((char *)vte + vte->Offset) ;	/* Loop thru all points for hash value */
	hval = 0 ;
	for(px=0;px<vtm->Action[actx].NumComboPoints;px++)
	 { iptr = (int *)&tpt->Value ;			/* Go thru point value int-by-int-by-int */
	   for(vx=0;vx<(int)((tpt->Bytes - V4DPI_PointHdr_Bytes)/(sizeof(int)));vx++)
	    { hval += (tpt->Dim + vx) * *iptr ; iptr += 1 ; } ;
	   ADVPNT(tpt) ;
	 } ;
	if (vtm->Action[actx].NumComboPoints == 0) hval = vtm->Action[actx].DfltHash ;
	if (hval == 0) { hval = 1 ; } else if (hval < 0) hval &= 0x7fffffff ;
	hx = hval % vtm->TallyEntryMax ;		/* Convert to index into hash table */
	for(;;hx=(hx+1)%vtm->TallyEntryMax)
	 { if (vtm->teb->Entry[hx] == NULL) break ;		/* No entries matching! */
	   vte1 = vtm->teb->Entry[hx] ; if (vte1->ActionX != actx) continue ;
	   if (vte1->HashVal != hval)			/* Got a hit - try next entry */
	    { if (((++vtee->HashHits) & V4IM_Tally_HashHitInterval) == 0)
	       { v_Msg(ctx,UCTBUF2,"*TraceTallyHash",vtee->HashHits) ; vout_UCText(VOUT_Warn,0,UCTBUF2) ;
	         v_Msg(ctx,UCTBUF2,"*TraceTallyHash1",(int)(vtm->TallyEntryMax*1.5)) ; vout_UCText(VOUT_Warn,0,UCTBUF2) ;
	       } ;
	      continue ;
	    } ;
	   tpt = (struct V4DPI__Point *)((char *)vte + vte->Offset) ;	/* Loop thru all points for hash value */
	   tpt1 = (struct V4DPI__Point *)((char *)vte1 + vte1->Offset) ;
	   for(px=0;px<vtm->Action[actx].NumComboPoints;px++)	/* Hashes match - check combo values */
	    { if (memcmp(tpt,tpt1,tpt->Bytes) != 0) break ;	/* Points match? if <> 0 then no */
	      ADVPNT(tpt) ; ADVPNT(tpt1) ;
	    } ; if (px >= vtm->Action[actx].NumComboPoints) break ;	/* All points match - get out of loop */
	 } ;
	if (vtm->teb->Entry[hx] == NULL)			/* New entry? */
	 { 
	   if (!GRABMTLOCK(vtm->tebLock)) return(FALSE) ;
	   if ((++vtm->EntryCount) >= vtm->TallyEntryMax)
	    { FREEMTLOCK(vtm->tebLock) ; v_Msg(ctx,ctx->ErrorMsgAux,"TallyMaxHS",vtm->TallyEntryMax) ; return(FALSE) ;
	    } ;
	   vte1 = v4im_tallyAllocAndCopy(vtm,vte,vte->Bytes) ;
	   vte1->HashVal = hval ;
	   vtm->teb->Entry[hx] = vte1 ;			/* Remember where/what we did */
/*	   If SetOf or UCount then allocate fixed size bit map (may want to make fancier later) */
	   if ((vtm->Action[actx].ActionType == V4IM_ActType_UList || vtm->Action[actx].ActionType == V4IM_ActType_UCount) && vtm->Action[actx].bitsInMap > 0)
	    { 

	      k = V4IM_TallyListBitMapHeader + BM1_StructBytes(vtm->Action[actx].tsc->Bits) ;
	      vte1->auxPtr = v4mm_AllocChunk(k,TRUE) ;
	      tlbm = (struct V4IM__TallyListBitMap *)vte1->auxPtr ;
	      tlbm->Dim = listpt->Dim ; tlbm->PointType = listpt->PntType ;
	      tlbm->MaxIntVal = vtm->Action[actx].tsc->Bits ;
	      BM1_Dcl(&tlbm->bm1,vtm->Action[actx].tsc->Bits) ;
	      vte1->vteFlags |= V4IM_vteFlags_bitMap ;
	    } else
	    { if (vtm->CurBuf->NextFree + sizeof *vtlp >= V4IM_TallyBuf_Max)
	       v4im_TallyEntryAlloc(vtm) ;

	      vtlp = (struct V4IM__TallyListPoints *)&vtm->CurBuf->Buffer[vtm->CurBuf->NextFree] ;
	      vtm->CurBuf->NextFree += (((sizeof *vtlp)+ALIGN_DOUBLE)&~ALIGN_DOUBLE) ;
	      vtlp->numEntries = 0 ; vtlp->totalEntries = 0 ; vte1->auxPtr = vtlp ;
	    } ;
#ifdef V4ENABLEMULTITHREADS
	   INITMTLOCK(vte1->mtLock) ;			/* Make this vte entry available */
	   FREEMTLOCK(vtm->tebLock) ;
#endif

	 } else						/* Existing entry, merge vte into it */
	 {
	 } ;
	if (vte1->vteFlags & V4IM_vteFlags_bitMap)	/* Trying to do SetOf::xxx into bitmap? */
	 { 
	   tlbm = (struct V4IM__TallyListBitMap *)vte1->auxPtr ;
	   if (listpt->Dim == tlbm->Dim && listpt->Value.IntVal > 0 && listpt->Value.IntVal <= tlbm->MaxIntVal)
	    { 
	      if (!GRABMTLOCK(vte1->mtLock)) return(FALSE) ;
	      
	      if (!BM1_IsBitSet(&tlbm->bm1,listpt->Value.IntVal))
	       { BM1_SetBit(&tlbm->bm1,listpt->Value.IntVal) ; if (tlbm->Count >= 0) tlbm->Count++ ;
	       } ;
	      
	      FREEMTLOCK(vte1->mtLock) ; return(TRUE) ;
	    } else
	    { 
	      v_Msg(ctx,ctx->ErrorMsgAux,"TallyBitMapRng",actx+1,tlbm->MaxIntVal,listpt->Value.IntVal,listpt) ; return(FALSE) ;
	    } ;
	 } ;
/*	Here to append this ListOf point to vtlp, if it is full then write out to temp sort file */
	vtlp = (struct V4IM__TallyListPoints *)vte1->auxPtr ;
	if (listpt->Bytes > sizeof vts.sortpt)
	 { v_Msg(ctx,ctx->ErrorMsgAux,"ListPtLen",listpt,listpt->Bytes,sizeof vts.sortpt) ; return(FALSE) ;
	 } ;
	if (!GRABMTLOCK(vtm->sfpLock)) return(FALSE) ;
	vtlp->totalEntries++ ;
	if (vtlp->totalEntries > vtm->Action[actx].biMax) { FREEMTLOCK(vtm->sfpLock) ; return(TRUE) ; } ;	/* Exceeded max number we want - don't bother with anything else to follow */
	if (vtlp->numEntries < V4IM_ListOfPointMax)
	 { memcpy(&vtlp->entry[vtlp->numEntries].loPnt,listpt,listpt->Bytes) ;
	   vtlp->numEntries++ ; FREEMTLOCK(vtm->sfpLock) ;
	   return(TRUE) ;
	 } ;
	vts.HashX = hx ; vts.Repeat = 1 ;		/* Set up sort record */
	vts.Order = (vtm->LastOrder++) ;		/* Keep track of order */
	memcpy(&vts.sortpt,listpt,listpt->Bytes) ;
	if (vtm->Action[actx].tsc != NULL)		/* Trying to cache entries? */
	 { tsc = vtm->Action[actx].tsc ;
	   hx = vts.HashX ; ip = (int *)listpt ; for(i=0;i<(int)(listpt->Bytes/(sizeof *ip));i++) { hx += *ip ; ip++ ; } ;
	   if (hx < 0) hx &= 0x7fffffff ; hx = hx % tsc->Count ;
	   for(;;hx=((hx+1)%tsc->Count))	/* Look for prior identical entry */
	    { 
	      if (tsc->tse[hx].HashX == vts.HashX && memcmp(listpt,&tsc->tse[hx].sortpt,listpt->Bytes) == 0)
	       { tsc->tse[hx].Repeat++ ; FREEMTLOCK(vtm->sfpLock) ; return(TRUE) ; } ;
	      if (tsc->tse[hx].Repeat > 0)
	       { fwrite(&tsc->tse[hx],sizeof(vts),1,vtm->Action[actx].sfp) ;
	       } ;
	      memcpy(&tsc->tse[hx],&vts,sizeof(vts)) ;
	      FREEMTLOCK(vtm->sfpLock) ;
	      return(TRUE) ;
	    } ;
	 } ;
	fwrite(&vts,1,sizeof(vts),vtm->Action[actx].sfp) ;
	FREEMTLOCK(vtm->sfpLock) ;
	return(TRUE) ;
}

/*	v4im_TallyListMake - Second part to make lists		*/
/*	Returns TRUE/FALSE if ok or not				*/

LOGICAL v4im_TallyListMake(ctx,vtm,actx,acttype,bindif)
  struct V4C__Context *ctx ;
  struct V4IM__TallyMaster *vtm ;
  int actx,acttype ;
  struct V4DPI__Point *bindif ;
{
  struct V4DPI__DimInfo *di ;
  struct V4L__ListPoint *lp,*lp1 ;
  struct V4DPI__Binding binding ;
  struct V4DPI__Point listpt,bindpt,isctbuf,*ipt,*ipt1,*tpt ;
  struct V4IM__TallyEntry *vte ;
  struct V4IM__TallySort vts ;
  struct V4IM__TallySortCache *tsc ;
  struct V4IM__TallyListBitMap *tlbm ;
  struct V4IM__TallyListPoints *vtlp ;
  struct V4L_MultPoints vmp ;
#ifdef VMSOS
  int res,resx ;
   struct vms__dsc {
     short int length ;		/* Length of value */
     short int desc ;		/* Descriptive info */
     char *pointer ;		/* Pointer to value */
    } strdsc ;
#endif
  UCCHAR tnbuf[256] ;
  int oldx,i,j,k,mode,vx,maxpoints,ok,dobind,frameid=UNUSED ; COUNTER eofFlag ;
  UCCHAR buf1[1000] ;
  struct V4L__ListBMData1 *vlbmd ; int vlbmdbytes ;

	if (vtm->Action[actx].tsc != NULL)			/* Did we cache anything? */
	 { tsc = vtm->Action[actx].tsc ;
	   for(i=0;i<tsc->Count;i++)
	    { if (tsc->tse[i].Repeat > 0) { fwrite(&tsc->tse[i],sizeof(vts),1,vtm->Action[actx].sfp) ; } ;
	    } ;
	   v4mm_FreeChunk(vtm->Action[actx].tsc) ; vtm->Action[actx].tsc = NULL ;
	 } ;

/*	Are we creating a bitmap list as the result of all this ? */
	if (vtm->Action[actx].ActionType == V4IM_ActType_UList && vtm->Action[actx].listDimId != 0)
	 {
	   for(vx=0;vx<vtm->TallyEntryMax;vx++)
	    { 
	      if (vtm->teb->Entry[vx] == NULL) continue ;		/* Nothing in this slot */
	      vte = vtm->teb->Entry[vx] ; if (vte->ActionX != actx) continue ;
	      if (vte->auxPtr == NULL) continue ;
		ipt = vtm->Action[actx].p3 ; 
		
		    if (ipt->PntType != V4DPI_PntType_Isct)			/* If bind point not intersection then make one */
		     { INITISCT(&bindpt) ; NOISCTVCD(&bindpt) ; bindpt.Grouping = 1 ; tpt = ISCT1STPNT(&bindpt) ;
		       memcpy(tpt,ipt,ipt->Bytes) ; bindpt.Bytes = V4DPI_PointHdr_Bytes + ipt->Bytes ;
		       ADVPNT(tpt) ; ipt = tpt ;
		     } else
		     { memcpy(&bindpt,ipt,ipt->Bytes) ;
		       for(ipt=ISCT1STPNT(&bindpt),j=0;j<bindpt.Grouping;j++,ADVPNT(ipt)) { } ;
		     } ;
		    ipt1 = (struct V4DPI__Point *)((char *)vte + vte->Offset) ;
		    for(k=0;k<vtm->Action[actx].NumComboPoints;k++)			/* Append each of the combo points */
		     { memcpy(ipt,ipt1,ipt1->Bytes) ; bindpt.Grouping ++ ;
		       ADVPNT(ipt) ; ADVPNT(ipt1) ;
		     } ;
		    ISCTLEN(&bindpt,ipt) ;
			tlbm = (struct V4IM__TallyListBitMap *)vte->auxPtr ;
		       listpt.PntType = V4DPI_PntType_SegBitMap ; listpt.Bytes = V4PS_Int ; listpt.Dim = vtm->Action[actx].ResDim ;
		       listpt.Value.IntVal = v4seg_PutSegments(ctx,&tlbm->bm1,BM1_StructBytes((vtm->Action[actx].bitsInMap)),FALSE,FALSE) ;
		      if (!v4dpi_BindListMake(&binding,&listpt,&bindpt,ctx,NULL,NOWGTADJUST,0,DFLTRELH))
		       goto fail ;
		       if (traceGlobal & V4TRACE_TallyBind)
		        { 
		          v_Msg(ctx,UCTBUF2,"*TraceTallyBind",&bindpt,&listpt) ; vout_UCText(VOUT_Trace,0,UCTBUF2) ;
		        } ;
	    } ;
	   return(TRUE) ;
	 } ;

	if ((vtm->Action[actx].ActionType == V4IM_ActType_UList || vtm->Action[actx].ActionType == V4IM_ActType_UCount) && vtm->Action[actx].bitsInMap > 0)
	 {
	   ZPH(&vts.sortpt) ; vts.sortpt.Bytes = V4PS_Int ; vts.Repeat = -1 ; /* Flag so we can just append below */
	   for(vx=0;vx<vtm->TallyEntryMax;vx++)
	    { 
	      if (vtm->teb->Entry[vx] == NULL) continue ;		/* Nothing in this slot */
	      vte = vtm->teb->Entry[vx] ; if (vte->ActionX != actx) continue ;
	      if (vte->auxPtr == NULL) continue ;
	      tlbm = (struct V4IM__TallyListBitMap *)vte->auxPtr ;
	      vts.HashX = vx ; vts.sortpt.Dim = tlbm->Dim ; vts.sortpt.PntType = tlbm->PointType ;
	      for(i=1;i<=tlbm->MaxIntVal;i++)
	       { 
		 if (!BM1_IsBitSet(&tlbm->bm1,i)) continue ;
		 vts.sortpt.Value.IntVal = i ;
		 fwrite(&vts,sizeof(vts),1,vtm->Action[actx].sfp) ;
	       } ;
	      v4mm_FreeChunk(tlbm) ; vte->auxPtr = NULL ;		/* Free chunk & clear out pointer so we don't try and use this again */
	    } ;
	 } ;
	fclose(vtm->Action[actx].sfp) ;
	v_MakeOpenTmpFile(UClit("v4tlm"),tnbuf,UCsizeof(tnbuf),NULL,NULL) ;
/*	Sort the list file on HashX and Order */
	v_Msg(ctx,buf1,"@-d -q -l%1d -ki0 -ki4 %2U %3U",sizeof(vts),vtm->Action[actx].FileName,tnbuf) ;
	if (!v_SpawnSort(buf1,V_SPAWNWAIT_Infinite,ctx->ErrorMsgAux))
	 return(FALSE) ;
	vtm->Action[actx].sfp = UCfopen(tnbuf,"rb") ;			/* (Re)open sorted file */
	if (vtm->Action[actx].sfp == NULL)
	 { v_Msg(ctx,ctx->ErrorMsgAux,"SortNoResFile",buf1,errno) ; return(FALSE) ; } ;
	mode = (acttype == V4IM_ActType_List ? V4L_ListAction_Append : V4L_ListAction_AppendUnique) ;

	maxpoints = UNUSED ;
	if (vtm->Action[actx].ResDim > 0)		/* Look to see if we should make a bitmap */
	 { DIMINFO(di,ctx,vtm->Action[actx].ResDim) ;
	   if (di->ListDimId > 0)			/* Target list dimension has its own target dimension */
	    { if (vtm->Action[actx].Cache > 0)		/* If Bits::xx set then take that value */
	       { maxpoints = vtm->Action[actx].Cache ; }
	       else { maxpoints = v4dpi_DimUniqueNumPoints(ctx,di->ListDimId) ; } ;
	      if (maxpoints == UNUSED)
	       { v_Msg(ctx,NULL,"TallyListExpPts",di->ListDimId,vtm->Action[actx].ResDim) ;
	         UCstrcpy(ctx->ErrorMsgAux,ctx->ErrorMsg) ; return(FALSE) ;
	       } ;
/*	      Allocate bitmap structure & initialize it */
	      maxpoints = BM1_CalcMaxBit(maxpoints) ;		/* Round to next higher 32 */
	      vlbmdbytes = BM1_StructBytes(maxpoints) ;
	      vlbmd = (struct V4L__ListBMData1 *)v4mm_AllocChunk(vlbmdbytes,TRUE) ;
	      vlbmd->MaxBit = maxpoints ;
	    } ;
	 } ;

	ZPH(&listpt) ; ZPH(&bindpt) ;
	if (bindif != NULL) { frameid = v4ctx_FramePush(ctx,NULL) ; } ;		/* Start new context frame */
	for(eofFlag=0,oldx=-1,vx=0,vts.HashX=-99;;)
	 {
	   switch (eofFlag)
	    { 
	      case 0:	if (fread(&vts,sizeof(vts),1,vtm->Action[actx].sfp) <= 0) { eofFlag = 1 ; continue ; } ;
			break ;
	      case 1:	for (vts.HashX=UNUSED;vx<vtm->TallyEntryMax;vx++)
			 { if (vtm->teb->Entry[vx] == NULL) continue ;		/* Nothing in this slot */
			   vte = vtm->teb->Entry[vx] ; if (vte->ActionX != actx) continue ;
			   if (vte->auxPtr == NULL) continue ;
			   vtlp = (struct V4IM__TallyListPoints *)vte->auxPtr ;
			   if (vtlp->totalEntries < vtm->Action[actx].biMin || vtlp->totalEntries > vtm->Action[actx].biMax) continue ;
			   vts.HashX = vx ; vts.Order = UNUSED ;	/* Set Order to UNUSED so we know (below) not to include this vts entry (just the vte->auxPtr stuff) */
			   break ;
			 } ;
			if (vts.HashX == UNUSED) { eofFlag = 2 ; continue ; } ;
			break ;
	      case 2:	vts.HashX = -90 ; break ;
	    } ;
	   if (oldx != vts.HashX)
	    { vte = (oldx >= 0 ? vtm->teb->Entry[oldx] : NULL) ;
	      vtlp = (vte == NULL ? NULL : (struct V4IM__TallyListPoints *)vte->auxPtr) ;
	      if (oldx >= 0 && (vtlp != NULL ? (vtlp->totalEntries >= vtm->Action[actx].biMin && vtlp->totalEntries <= vtm->Action[actx].biMax) : TRUE)) /* Make binding for this list */
	       {
		 
		 if (vtm->Action[actx].p3->PntType == V4DPI_PntType_List)
		  { lp = ALIGNLP(&vtm->Action[actx].p3->Value) ;	/* Third element is base bind iscts */
		  } else { lp = NULL ; }
		 for(i=1;;i++)						/* Loop thru each point in list */
		  { if (lp == NULL) { ipt = vtm->Action[actx].p3 ; }
		     else { if (v4l_ListPoint_Value(ctx,lp,i,&isctbuf) <= 0) break ; ipt = &isctbuf ; } ;
		    if (ipt->PntType != V4DPI_PntType_Isct)			/* If bind point not intersection then make one */
		     { INITISCT(&bindpt) ; NOISCTVCD(&bindpt) ; bindpt.Grouping = 1 ; tpt = ISCT1STPNT(&bindpt) ;
		       memcpy(tpt,ipt,ipt->Bytes) ; bindpt.Bytes = V4DPI_PointHdr_Bytes + ipt->Bytes ;
		       ADVPNT(tpt) ; ipt = tpt ;
		     } else
		     { memcpy(&bindpt,ipt,ipt->Bytes) ;
		       for(ipt=ISCT1STPNT(&bindpt),j=0;j<bindpt.Grouping;j++,ADVPNT(ipt)) { } ;
		     } ;
		    ipt1 = (struct V4DPI__Point *)((char *)vte + vte->Offset) ;
		    for(k=0;k<vtm->Action[actx].NumComboPoints;k++)			/* Append each of the combo points */
		     { memcpy(ipt,ipt1,ipt1->Bytes) ; bindpt.Grouping ++ ;
		       ADVPNT(ipt) ; ADVPNT(ipt1) ;
		     } ;
		    ISCTLEN(&bindpt,ipt) ;
		    if (maxpoints != UNUSED)			/* If created a bitmap then write it out */
		     { 


		       for(i=0,j=0;i<vmp.pointCount;i++,j+=tpt->Bytes)
		        { tpt = (P *)&vmp.pointBuf[j] ;
			  if (tpt->Value.IntVal > maxpoints)			/* Is bit outside of bitmap range ? (boy did this burn me VEH050503) */
			   { struct V4L__ListBMData1 *vlbmd1 ; int vlbmdbytes1 ;
			     maxpoints = BM1_CalcMaxBit((int)(maxpoints * 1.1)) ;	/* Have to allocate bigger bitmap */
			     vlbmdbytes1 = BM1_StructBytes(maxpoints) ;
			     vlbmd1 = (struct V4L__ListBMData1 *)v4mm_AllocChunk(vlbmdbytes1,TRUE) ;
			     memcpy(vlbmd1,vlbmd,vlbmdbytes) ; v4mm_FreeChunk(vlbmd) ; vlbmd = vlbmd1 ;
			     vlbmd->MaxBit = maxpoints ; vlbmdbytes = vlbmdbytes1 ;
			   } ;
			  BM1_SetBit(vlbmd,tpt->Value.IntVal) ;
		        } ; vte->auxPtr = NULL ;		/* Set this so we don't create list below */





		       listpt.PntType = V4DPI_PntType_SegBitMap ; listpt.Bytes = V4PS_Int ; listpt.Dim = di->DimId ;
		       listpt.Value.IntVal = v4seg_PutSegments(ctx,vlbmd,vlbmdbytes,FALSE,FALSE) ;
		       memset(vlbmd,0,vlbmdbytes) ; vlbmd->MaxBit = maxpoints ;	/* Clear bitmap for next go-around */
		     } else
		     { 
		       if (vmp.pointCount > 0)			/* Do we have points in vmp ? */
		        { if (mode != V4L_ListAction_AppendUnique && OKToUse_littleListPNTv(&vmp))	/*  then try to make fast list, otherwise use ListPoint_Modify() */
			   { littlelistPNTv(&listpt,&vmp) ;
			   } else
			   { INITLP(&listpt,lp1,Dim_List) ;
			     if (!v4l_ListPoint_Modify(ctx,lp1,(mode == V4L_ListAction_AppendUnique ? V4L_ListAction_AppendUniqueMult : V4L_ListAction_AppendMult),(P *)&vmp,0))
			      return(FALSE) ;
			     ENDLP(&listpt,lp1) ;
			   } ;
		        } else
		        { lp1 = ALIGNLP(&listpt.Value) ;
		          listpt.Bytes = ALIGN((char *)&listpt.Value.AlphaVal[lp1->Bytes] - (char *)&listpt) ;
		          if (listpt.Bytes < V4DPI_PointHdr_Bytes + ((char *)&lp1->Buffer[0] - (char *)lp1))
		           listpt.Bytes = V4DPI_PointHdr_Bytes + ((char *)&lp1->Buffer[0] - (char *)lp1) ;	/* Make sure min size */
		          listpt.Dim = (vtm->Action[actx].ResDim > 0 ? vtm->Action[actx].ResDim : Dim_List) ;
		          listpt.PntType = V4DPI_PntType_List ;
		        } ;
		     } ;
		    if (bindif != NULL)				/* Do we have a test to perform to see if we really want to make this binding? */
		     { 
		       FASTCTXADD(&listpt,1) ;
		       ipt = v4dpi_IsctEval(&isctbuf,bindif,ctx,V4DPI_EM_EvalQuote,NULL,NULL) ;
		       if (ipt == NULL) goto fail ;
		       dobind = PNTlogVAL(&ok,ipt,ctx) ; if (!ok) goto fail ;
		       if (!dobind) vte->vteFlags |= V4IM_vteFlags_NoBind ;
		     } else { dobind = TRUE ; } ;
		    if (dobind)
		     { if (!v4dpi_BindListMake(&binding,&listpt,&bindpt,ctx,NULL,NOWGTADJUST,0,DFLTRELH)) goto fail ;
		       if (traceGlobal & V4TRACE_TallyBind)
		        { 
		          v_Msg(ctx,UCTBUF2,"*TraceTallyBind",&bindpt,&listpt) ; vout_UCText(VOUT_Trace,0,UCTBUF2) ;
		        } ;
		     } ;
		    if (lp == NULL) break ;
		  } ;
	       } ;
	      if (vts.HashX == -90) goto end_of_line ;
	      lp = ALIGNLP(&listpt.Value) ; memset(lp,0,V4L_ListPointHdr_Bytes) ;	/* Set up resulting list point */
	      lp->ListType = V4L_ListType_Point ;
	      oldx = vts.HashX ; vte = vtm->teb->Entry[oldx] ;
	      vmp.pointCount = 0 ; vmp.totalBytes = 0 ;
/*	      Append any points in TallyListPoints first */
	      vtlp = (struct V4IM__TallyListPoints *)vte->auxPtr ;
	      if (vtlp != NULL)
	       { for(i=0;i<vtlp->numEntries;i++)
	          { memcpy(&vmp.pointBuf[vmp.totalBytes],&vtlp->entry[i].loPnt,vtlp->entry[i].loPnt.Bytes) ;
		    vmp.pointCount++ ; vmp.totalBytes += vtlp->entry[i].loPnt.Bytes ;
	          } ; vte->auxPtr = NULL ;		/* Set this so we don't create list below */
	       } ;
	    } ;

/*	   Don't use this vts point if Order UNUSED (we are dumping out entries that fit entirely within vte->auxPt(vtlp) */
	   if (vts.Order == UNUSED) continue ;

	   if (maxpoints != UNUSED)					/* Creating a bitmap */
	    { 
	      if (vts.sortpt.Value.IntVal > maxpoints)			/* Is bit outside of bitmap range ? (boy did this burn me VEH050503) */
	       { struct V4L__ListBMData1 *vlbmd1 ; int vlbmdbytes1 ;
	         maxpoints = BM1_CalcMaxBit((int)(maxpoints * 1.1)) ;	/* Have to allocate bigger bitmap */
	         vlbmdbytes1 = BM1_StructBytes(maxpoints) ;
	         vlbmd1 = (struct V4L__ListBMData1 *)v4mm_AllocChunk(vlbmdbytes1,TRUE) ;
		 memcpy(vlbmd1,vlbmd,vlbmdbytes) ; v4mm_FreeChunk(vlbmd) ; vlbmd = vlbmd1 ;
	         vlbmd->MaxBit = maxpoints ; vlbmdbytes = vlbmdbytes1 ;
	       } ;
	      BM1_SetBit(vlbmd,vts.sortpt.Value.IntVal) ;
	    } else
	    { if (vts.Repeat == -1)					/* If from bitmap we know it's unique! */
	       { if (!v4l_ListPoint_Modify(ctx,lp,V4L_ListAction_Append,(P *)&vts.sortpt,0))
	        return(FALSE) ;
	       } else
	       { j= (mode == V4L_ListAction_AppendUnique ? 1 : vts.Repeat) ;
	         for(i=0;i<j;i++)						/* If appending UNIQUE then only do once! */
	          { 
	            
		    if (vmp.totalBytes + vts.sortpt.Bytes >= V4L_MultPointBufMax) /* If our local point buffer full then create (partial) list */
		     { if (!v4l_ListPoint_Modify(ctx,lp,(mode == V4L_ListAction_AppendUnique ? V4L_ListAction_AppendUniqueMult : V4L_ListAction_AppendMult),(P *)&vmp,0))
		        return(FALSE) ;
		       vmp.pointCount = UNUSED ; vmp.totalBytes = 0 ;		/* Flag vmp so we don't use it anymore */
		     } ;
		    if (vmp.pointCount != UNUSED)		/* Is it OK to jam points into vmp ? */
		     { memcpy(&vmp.pointBuf[vmp.totalBytes],&vts.sortpt,vts.sortpt.Bytes) ;
		       vmp.pointCount++ ; vmp.totalBytes += vts.sortpt.Bytes ;
		     } else					/* No - use old (slow) routine to build up list */
		     { if (!v4l_ListPoint_Modify(ctx,lp,mode,(P *)&vts.sortpt,0))
		        return(FALSE) ;	/* Append to resulting list */
		     } ;
	          } ;
	       } ;
	    } ;
	 } ;
end_of_line:
	if (frameid != UNUSED) v4ctx_FramePop(ctx,frameid,NULL) ;
	fclose(vtm->Action[actx].sfp) ;
	UCremove(tnbuf) ;						/* Delete sorted file */
	return(TRUE) ;

fail:	if (frameid != UNUSED) v4ctx_FramePop(ctx,frameid,NULL) ;
	if (vtm->Action[actx].sfp != NULL) fclose(vtm->Action[actx].sfp) ;
	return(FALSE) ;
}


/*	v4im_TallyUCount - Second part of UCount to create bindings with counts		*/

LOGICAL v4im_TallyUCount(ctx,vtm,actx,acttype)
  struct V4C__Context *ctx ;
  struct V4IM__TallyMaster *vtm ;
  int actx,acttype ;
{
  struct V4L__ListPoint *lp,*lp1 ;
  struct V4DPI__Binding binding ;
  struct V4DPI__Point listpt,bindpt,isctbuf,*ipt,*ipt1,*tpt ;
  struct V4DPI__LittlePoint cntpt ;
  struct V4IM__TallyEntry *vte ;
  struct V4IM__TallySort vts ;
  struct V4IM__TallySortCache *tsc ;
  struct V4IM__TallyListBitMap *tlbm ;
#ifdef VMSOS
  int res,resx ;
   struct vms__dsc {
     short int length ;		/* Length of value */
     short int desc ;		/* Descriptive info */
     char *pointer ;		/* Pointer to value */
    } strdsc ;
#endif
  UCCHAR tnbuf[256] ;
  int oldx,i,j,k,vx,havesort ;
  UCCHAR buf1[1000] ;

	if (vtm->Action[actx].tsc != NULL)			/* Did we cache anything? */
	 { tsc = vtm->Action[actx].tsc ;
	   for(i=0;i<tsc->Count;i++)
	    { if (tsc->tse[i].Repeat > 0) { fwrite(&tsc->tse[i],sizeof(vts),1,vtm->Action[actx].sfp) ; } ;
	    } ;
	   v4mm_FreeChunk(vtm->Action[actx].tsc) ; vtm->Action[actx].tsc = NULL ;
	 } ;
	intPNT(&cntpt) ; havesort = TRUE ;

	if (vtm->Action[actx].Cache == 1.0 || vtm->Action[actx].bitsInMap > 0)
	 { havesort = FALSE ;
	   ZPH(&vts.sortpt) ; vts.sortpt.Bytes = V4PS_Int ; vts.Repeat = -1 ; /* Flag so we can just append below */
	   for(vx=0;vx<vtm->TallyEntryMax;vx++)
	    { 
	      if (vtm->teb->Entry[vx] == NULL) continue ;		/* Nothing in this slot */
	      vte = vtm->teb->Entry[vx] ; if (vte->ActionX != actx) continue ;
	      if (vte->auxPtr == NULL) continue ;
	      tlbm = (struct V4IM__TallyListBitMap *)vte->auxPtr ;
	      if (tlbm->Count >= 0)					/* If have count, then use it without going to sort records */
	       { if (vtm->Action[actx].p3->PntType == V4DPI_PntType_List)
		  { lp = ALIGNLP(&vtm->Action[actx].p3->Value) ;	/* Third element is base bind iscts */
		  } else { lp = NULL ; }
		 for(i=1;;i++)						/* Loop thru each point in list */
		  { if (lp == NULL) { ipt = vtm->Action[actx].p3 ; }
		     else { if (v4l_ListPoint_Value(ctx,lp,i,&isctbuf) <= 0) break ; ipt = &isctbuf ; } ;
		    if (ipt->PntType != V4DPI_PntType_Isct)			/* If bind point not intersection then make one */
		     { INITISCT(&bindpt) ; NOISCTVCD(&bindpt) ; bindpt.Grouping = 1 ; tpt = ISCT1STPNT(&bindpt) ;
		       memcpy(tpt,ipt,ipt->Bytes) ; bindpt.Bytes = V4DPI_PointHdr_Bytes + ipt->Bytes ;
		       ADVPNT(tpt) ; ipt = tpt ;
		     } else
		     { memcpy(&bindpt,ipt,ipt->Bytes) ;
		       for(ipt=ISCT1STPNT(&bindpt),j=0;j<bindpt.Grouping;j++,ADVPNT(ipt)) { } ;
		     } ;
		    ipt1 = (struct V4DPI__Point *)((char *)vte + vte->Offset) ;
		    for(k=0;k<vtm->Action[actx].NumComboPoints;k++)			/* Append each of the combo points */
		     { memcpy(ipt,ipt1,ipt1->Bytes) ; bindpt.Grouping ++ ;
		       ADVPNT(ipt) ; ADVPNT(ipt1) ;
		     } ;
		    ISCTLEN(&bindpt,ipt) ;
		    cntpt.Value.IntVal = tlbm->Count ;
		    if (!v4dpi_BindListMake(&binding,(P *)&cntpt,&bindpt,ctx,NULL,NOWGTADJUST,0,DFLTRELH)) return(FALSE) ;
		    if (traceGlobal & V4TRACE_TallyBind)
		     { 
		       v_Msg(ctx,UCTBUF2,"*TraceTallyUCnt",&bindpt,&cntpt) ; vout_UCText(VOUT_Trace,0,UCTBUF2) ;
		     } ;
		    if (lp == NULL) break ;
		  } ;
		 v4mm_FreeChunk(tlbm) ;
		 continue ;
	       } ;
	      if (!havesort)
	       { vout_Text(VOUT_Trace,0,"*TallyUCount: Bitmap out of range - using sort file") ; } ;
	      havesort = TRUE ;
	      vts.HashX = vx ; vts.sortpt.Dim = tlbm->Dim ; vts.sortpt.PntType = tlbm->PointType ;
	      for(i=1;i<=tlbm->MaxIntVal;i++)
	       { 
		 if (!BM1_IsBitSet(&tlbm->bm1,i)) continue ;
		 
		 vts.sortpt.Value.IntVal = i ;
		 fwrite(&vts,sizeof(vts),1,vtm->Action[actx].sfp) ;
	       } ;
	      v4mm_FreeChunk(tlbm) ;
	    } ;
	 } ;
	if (!havesort) goto end_of_line ;				/* If everything in maps then all done */
	fclose(vtm->Action[actx].sfp) ;

	v_MakeOpenTmpFile(UClit("v4ucnt"),tnbuf,UCsizeof(tnbuf),NULL,NULL) ;
	v_Msg(ctx,buf1,"@-d -q -l%1d -ki0 %2U %3U",sizeof(vts),vtm->Action[actx].FileName,tnbuf) ;
	if (!v_SpawnSort(buf1,V_SPAWNWAIT_Infinite,UCTBUF2)) { vout_UCText(VOUT_Err,0,UCTBUF2) ; exit(EXITABORT) ; } ;
	vtm->Action[actx].sfp = UCfopen(tnbuf,"rb") ;			/* (Re)open sorted file */
	if (vtm->Action[actx].sfp == NULL)
	 { v_Msg(ctx,ctx->ErrorMsgAux,"SortNoResFile",buf1,errno) ; return(FALSE) ; } ;
	for(oldx=-1,vts.HashX=-99;;)
	 {
	   if (fread(&vts,sizeof(vts),1,vtm->Action[actx].sfp) <= 0) vts.HashX = -90 ;
	   if (oldx != vts.HashX)
	    { if (oldx >= 0)					/* Make binding for this list */
	       {
		 vte = vtm->teb->Entry[oldx] ;
		 if (vtm->Action[actx].p3->PntType == V4DPI_PntType_List)
		  { lp = ALIGNLP(&vtm->Action[actx].p3->Value) ;	/* Third element is base bind iscts */
		  } else { lp = NULL ; }
		 for(i=1;;i++)						/* Loop thru each point in list */
		  { if (lp == NULL) { ipt = vtm->Action[actx].p3 ; }
		     else { if (v4l_ListPoint_Value(ctx,lp,i,&isctbuf) <= 0) break ; ipt = &isctbuf ; } ;
		    if (ipt->PntType != V4DPI_PntType_Isct)			/* If bind point not intersection then make one */
		     { INITISCT(&bindpt) ; NOISCTVCD(&bindpt) ; bindpt.Grouping = 1 ; tpt = ISCT1STPNT(&bindpt) ;
		       memcpy(tpt,ipt,ipt->Bytes) ; bindpt.Bytes = V4DPI_PointHdr_Bytes + ipt->Bytes ;
		       ADVPNT(tpt) ; ipt = tpt ;
		     } else
		     { memcpy(&bindpt,ipt,ipt->Bytes) ;
		       for(ipt=ISCT1STPNT(&bindpt),j=0;j<bindpt.Grouping;j++,ADVPNT(ipt)) { } ;
		     } ;
		    ipt1 = (struct V4DPI__Point *)((char *)vte + vte->Offset) ;
		    for(k=0;k<vtm->Action[actx].NumComboPoints;k++)			/* Append each of the combo points */
		     { memcpy(ipt,ipt1,ipt1->Bytes) ; bindpt.Grouping ++ ;
		       ADVPNT(ipt) ; ADVPNT(ipt1) ;
		     } ;
		    ISCTLEN(&bindpt,ipt) ;
		    lp1 = ALIGNLP(&listpt.Value) ;
		    cntpt.Value.IntVal = lp1->Entries ;
		    if (!v4dpi_BindListMake(&binding,(P *)&cntpt,&bindpt,ctx,NULL,NOWGTADJUST,0,DFLTRELH)) return(FALSE) ;
		    if (traceGlobal & V4TRACE_TallyBind)
		     { 
		       v_Msg(ctx,UCTBUF2,"*TraceTallyBind",&bindpt,&cntpt) ; vout_UCText(VOUT_Trace,0,UCTBUF2) ;
		     } ;
		    if (lp == NULL) break ;
		  } ;
	       } ;
	      if (vts.HashX == -90) goto end_of_line ;
	      lp = ALIGNLP(&listpt.Value) ; memset(lp,0,V4L_ListPointHdr_Bytes) ;	/* Set up resulting list point */
	      lp->ListType = V4L_ListType_Point ;
	      oldx = vts.HashX ;
	    } ;
	   if (vts.Repeat == -1)					/* If from bitmap we know it's unique! */
	    { if (!v4l_ListPoint_Modify(ctx,lp,V4L_ListAction_Append,(P *)&vts.sortpt,0)) return(FALSE) ;
	    } else
	    { if (!v4l_ListPoint_Modify(ctx,lp,V4L_ListAction_AppendUnique,(P *)&vts.sortpt,0)) return(FALSE) ;	/* Append to resulting list */
	    } ;
	 } ;
end_of_line:
	fclose(vtm->Action[actx].sfp) ;
	UCremove(tnbuf) ;						/* Delete sorted file */
	return(TRUE) ;
}

/*	v4im_TallyMakeByList - Make a list of all points we tally "by"	*/

LOGICAL v4im_TallyMakeByList(ctx,vtm,actx,byif)
  struct V4C__Context *ctx ;
  struct V4IM__TallyMaster *vtm ;
  struct V4DPI__Point *byif ;				/* If not NULL then test for inclusion in the ByList */
  int actx ;
{ struct V4IM__TallyEntry *vte ;
  struct V4L__ListPoint *lp,*lp1 ;
  struct V4DPI__Binding binding ;
  struct V4DPI__Point bipt,valpt,tlpt,*ipt,*ipt1,*tpt ;
  int vx,k ;

	INITLP((&valpt),lp,Dim_List)

	for(vx=0;vx<vtm->TallyEntryMax;vx++)
	 { if (vtm->teb->Entry[vx] == NULL) continue ;		/* Nothing in this slot */
	   vte = vtm->teb->Entry[vx] ; if (vte->ActionX != actx) continue ;
	   if (vte->vteFlags & V4IM_vteFlags_NoBind) continue ;
	   if (vtm->Action[actx].NumComboPoints == 1)		/* Append single point or have to make list of points? */
	    { tpt = (P *)((char *)vte + vte->Offset) ;			/* tpt = combo point */
	      if (byif != NULL)					/* Testing ByIf ? */
	       { if (!v4ctx_FrameAddDim(ctx,0,tpt,0,0)) return(FALSE) ;
		 CLEARCACHE
		 ipt = v4dpi_IsctEval(&bipt,byif,ctx,V4DPI_EM_EvalQuote,NULL,NULL) ;
		 if (ipt != NULL ? ipt->Value.IntVal <= 0 : TRUE) continue ;
	       } ;
	    } else
	    { ipt1 = (struct V4DPI__Point *)((char *)vte + vte->Offset) ;
	      INITLP((&tlpt),lp1,Dim_List)
	      for(k=0;k<vtm->Action[actx].NumComboPoints;k++)	/* Append each of the combo points */
	       { if (byif != NULL)				/* Testing ByIf ? */
	          { if (!v4ctx_FrameAddDim(ctx,0,ipt1,0,0)) return(FALSE) ;
		    CLEARCACHE
		    ipt = v4dpi_IsctEval(&bipt,byif,ctx,V4DPI_EM_EvalQuote,NULL,NULL) ;
		    if (ipt != NULL ? ipt->Value.IntVal <= 0 : TRUE) continue ;
		  } ;
	         XDBSAVEROW(ipt1) ;
	         if (!v4l_ListPoint_Modify(ctx,lp1,V4L_ListAction_Append,ipt1,0)) return(FALSE) ;/* Append to resulting list */
	         ADVPNT(ipt1) ;
	       } ;
	      ENDLP((&tlpt),lp1)
	      tpt = &tlpt ;
	     } ;
	   if (!v4l_ListPoint_Modify(ctx,lp,V4L_ListAction_Append,tpt,0)) return(FALSE) ;/* Append to resulting list */
	 } ;
	ENDLP((&valpt),lp)
	tpt = vtm->Action[actx].p4 ;
	if (tpt->PntType != V4DPI_PntType_Isct)
	 { tpt = &bipt ; INITISCT(tpt) ; NOISCTVCD(tpt) ; tpt->Grouping = 1 ;
	   memcpy(ISCT1STPNT(tpt),vtm->Action[actx].p4,vtm->Action[actx].p4->Bytes) ;
	   tpt->Bytes += vtm->Action[actx].p4->Bytes ;
	 } ;
	if (!v4dpi_BindListMake(&binding,&valpt,tpt,ctx,NULL,NOWGTADJUST,0,DFLTRELH)) return(FALSE) ;
	if (traceGlobal & V4TRACE_TallyBind)
	 { 
	   v_Msg(ctx,UCTBUF2,"*TraceTallyBind",vtm->Action[actx].p4,&valpt) ; vout_UCText(VOUT_Trace,0,UCTBUF2) ;
	 } ;
	return(TRUE) ;
}

#define V4IM_TallyArray_DimMax 4		/* Maximum number of Array dimensions allowed */
#define V4IM_TallyArray_DimValues 10000		/* Maximum number of Array values per dimension */
#define V4IM_TallyArray_HoldMax 2000		/* Number of held entries per lta */

LOGICAL v4im_TallyMakeArray(ctx,vtm,actx,intmodx)
  struct V4C__Context *ctx ;
  struct V4IM__TallyMaster *vtm ;
  INDEX actx  ;		/* tally list index with the array */
  INTMODX intmodx ;
{
  struct V4DPI__DimInfo *di ;
  struct V4IM__MDArray *vmda,lvmda ;
  struct V4IM__TallyEntry *vte ;
  struct V4DPI__Binding bindpt ;
  P *tcpt,*ipt,isctPnt,arrayPnt ;
  struct lcl__tallyArray {
    struct lcl__tallyArray *ltaPrior ;			/* Link to prior - may have to chain multiple depending on number of entries */
    COUNTER count ;					/* Number of entries below */
    struct {
      unsigned short dimX[V4IM_TallyArray_DimMax] ;	/* Dimension indexes for this entry */
      double value ;
     } entry[V4IM_TallyArray_HoldMax] ;
   } lta1, *lta, *ltaSave ;
  int dimIndexes[V4IM_TallyArray_DimMax][V4IM_TallyArray_DimValues] ; INDEX dimIndexNum[V4IM_TallyArray_DimMax] ; DIMID dimIds[V4IM_TallyArray_DimMax] ;
  INDEX i,vx,dx ; LOGICAL isInc ;

/*	Init lta to hold new array values */
	lta = &lta1 ; lta->count = 0 ; lta->ltaPrior = NULL ;
	isInc = FALSE ;
/*	First pass is to build up the array's dimension values - must be 32-bit value */
	for(i=0;i<V4IM_TallyArray_DimMax;i++) { dimIndexNum[i] = 0 ; } ;
	for(vx=0;vx<vtm->TallyEntryMax;vx++)
	 { if (vtm->teb->Entry[vx] == NULL) continue ;		/* Nothing in this slot */
	   vte = vtm->teb->Entry[vx] ; if (vte->ActionX != actx) continue ;
	   tcpt = (struct V4DPI__Point *)((char *)vte + vte->Offset) ;		/* First tally combo-point */
	   if (lta->count >= V4IM_TallyArray_HoldMax)
	    { struct lcl__tallyArray *ltaNew = v4mm_AllocChunk(sizeof *ltaNew,FALSE) ;
	      ltaNew->ltaPrior = lta ; lta = ltaNew ; lta->count = 0 ;
	    } ;
	   for(dx=0;dx<vtm->Action[actx].NumComboPoints;dx++)	/* Append each of the combo points */
	    { int indexVal = tcpt->Value.IntVal ; dimIds[dx] = tcpt->Dim ;
	      for(i=0;i<dimIndexNum[dx];i++) { if (dimIndexes[dx][i] == indexVal) break ; } ;
	      if (i >= dimIndexNum[dx])
	       { if (i >= V4IM_TallyArray_DimValues) { v_Msg(ctx,NULL,"TallyArrayDim",intmodx,V4IM_TallyArray_DimValues,dx+1) ; return(FALSE) ; } ;
		 dimIndexes[dx][i] = indexVal ; dimIndexNum[dx]++ ;
	       } ;
	      lta->entry[lta->count].dimX[dx] = i ;		/* Remember index value */
	      ADVPNT(tcpt) ;
	    } ;
	   switch (vtm->Action[actx].ActionType)
	    { default:
	      case V4IM_ActType_Min:
	      case V4IM_ActType_Max:
		switch (vte->Entry[0].eType)
		 { case V4IM_TEeType_ns:	lta->entry[lta->count].value = vte->Entry[0].tec.ns.Sum ; break ;
		   case V4IM_TEeType_sd:	break ;
		   case V4IM_TEeType_fs:	lta->entry[lta->count].value = vte->Entry[0].tec.ns.Sum ; break ;
		   case V4IM_TEeType_us:	lta->entry[lta->count].value = vte->Entry[0].tec.ns.Sum ; break ;
		 } ; break ;
	      case V4IM_ActType_Count:
		lta->entry[lta->count].value = vte->Entry[0].Count ;
		break ;
	      case V4IM_ActType_Avg:
		switch (vte->Entry[0].eType)
		 { case V4IM_TEeType_ns:	lta->entry[lta->count].value = vte->Entry[0].tec.ns.Sum / vte->Entry[0].Count ; break ;
		   case V4IM_TEeType_sd:	break ;
		   case V4IM_TEeType_fs:	lta->entry[lta->count].value = vte->Entry[0].tec.fs.fSum / vte->Entry[0].Count ; break ;
		   case V4IM_TEeType_us:	lta->entry[lta->count].value = vte->Entry[0].tec.us.uSum / vte->Entry[0].Count ; break ;
		 } ; break ;
	      case V4IM_ActType_Sub:
		switch (vte->Entry[0].eType)
		 { case V4IM_TEeType_ns:	lta->entry[lta->count].value = -vte->Entry[0].tec.ns.Sum ; break ;
		   case V4IM_TEeType_sd:	break ;
		   case V4IM_TEeType_fs:	lta->entry[lta->count].value = -vte->Entry[0].tec.ns.Sum ; break ;
		   case V4IM_TEeType_us:	lta->entry[lta->count].value = -vte->Entry[0].tec.ns.Sum ; break ;
		 } ; break ;
	      case V4IM_ActType_StdDev:
		lta->entry[lta->count].value = vte->Entry[0].Count * vte->Entry[0].tec.sd.sdSumSq - (vte->Entry[0].tec.sd.sdSum * vte->Entry[0].tec.sd.sdSum) ;
		lta->entry[lta->count].value = (vte->Entry[0].Count <= 1 ? 0.0 : vte->Entry[0].tec.sd.sdSum / (vte->Entry[0].Count * (vte->Entry[0].Count - 1.0))) ;
		if (vte->Entry[0].tec.sd.sdSum > 0 && vte->Entry[0].Count > 1) { lta->entry[lta->count].value = sqrt(vte->Entry[0].tec.sd.sdSum) ; }
		 else lta->entry[lta->count].value = 0 ;
		break ;
	    } ;
	   lta->count++ ;
	 } ;
/*	Now create the V4 array */
	DIMINFO(di,ctx,(vtm->Action[actx].ResDim > 0 ? vtm->Action[actx].ResDim : (vtm->GlobalResDim > 0 ? vtm->GlobalResDim : Dim_Int))) ;
	memset(&lvmda,0,sizeof lvmda) ;
	lvmda.MDDimCount = vtm->Action[actx].NumComboPoints ;
	lvmda.ElBytes = gpi->PointBytes[di->PointType] - V4DPI_PointHdr_Bytes ;
	lvmda.Dim = di->DimId ; lvmda.PntType = di->PointType ;
	lvmda.MDDim[lvmda.MDDimCount-1].Offset = lvmda.ElBytes ;
	lvmda.Elements = 1 ;
	for(dx=0;dx<lvmda.MDDimCount;dx++)		/* Convert MaxNum to actual maximum number */
	 { struct V4IM__MDArrayIndexes *mdi ;
	   if (dimIds[dx] == 0 || dimIndexNum[dx] == 0) { v_Msg(ctx,NULL,"TallyArrayNone",intmodx) ; return(FALSE) ; } ;
	   mdi = (struct V4IM__MDArrayIndexes *)v4mm_AllocChunk(MDIndexBytes(dimIndexNum[dx]),FALSE) ;
	   mdi->Count = dimIndexNum[dx] ; mdi->dimId = dimIds[dx] ;
	   for(i=0;i<dimIndexNum[dx];i++)
	    { mdi->Indexes[i] = dimIndexes[dx][i] ; } ;
	   lvmda.MDDim[dx].vmdi = mdi ;
	   lvmda.MDDim[dx].MaxNum = dimIndexNum[dx] ; lvmda.MDDim[dx].BaseVal = 1 ;
	   lvmda.Elements *= lvmda.MDDim[dx].MaxNum ;
	 } ;
	for(i=lvmda.MDDimCount-2;i>=0;i--)	/* Determine sizes of subsets of array */
	 { lvmda.MDDim[i].Offset = lvmda.MDDim[i+1].Offset * lvmda.MDDim[i+1].MaxNum ; } ;
	lvmda.Bytes = lvmda.MDDim[0].Offset * lvmda.MDDim[0].MaxNum ;
	lvmda.Data = v4mm_AllocChunk(lvmda.Bytes,TRUE) ;
/*	Have temp array structure - allocate for real & setup array point */
	vmda = (struct V4IM__MDArray *)v4mm_AllocChunk(sizeof lvmda,FALSE) ;
	memcpy(vmda,&lvmda,sizeof lvmda) ;
	ZPH(&arrayPnt) ; arrayPnt.Dim = Dim_UArray ; arrayPnt.PntType = V4DPI_PntType_MDArray ;
	arrayPnt.Bytes = gpi->PointBytes[V4DPI_PntType_MDArray] ;
	arrayPnt.Value.IntVal = han_Make() ; han_SetPointer(arrayPnt.Value.IntVal,0,vmda) ;
/*	Now create intersection containing Array::xxx name to be bound to the array point */
	INITISCT(&isctPnt) ; NOISCTVCD(&isctPnt) ; ipt = ISCT1STPNT(&isctPnt) ;
	memcpy(ipt,vtm->Action[actx].Array,vtm->Action[actx].Array->Bytes) ; isctPnt.Bytes += vtm->Action[actx].Array->Bytes ; isctPnt.Grouping++ ;
	if (!v4dpi_BindListMake(&bindpt,&arrayPnt,&isctPnt,ctx,NULL,NOWGTADJUST,0,DFLTRELH))
	 return(FALSE) ;
/*	Now make a second pass to populate the array */
	ltaSave = lta ;
	for(;lta!=NULL;lta=lta->ltaPrior)
	 { INDEX ex ;
	   for(ex=0;ex<lta->count;ex++)
	    { INDEX ix ; char *bo ;
	      for(bo=vmda->Data,ix=vmda->MDDimCount-1;ix>=0;ix--)
	       { bo += vmda->MDDim[ix].Offset * lta->entry[ex].dimX[ix] ; } ;
	      switch (lvmda.PntType)
	       { default:		return(FALSE) ;
	         CASEofINT		{ int *inum = (int *)bo ; if (isInc) { *inum += lta->entry[ex].value ; } else { *inum = lta->entry[ex].value ; } } ; break ;
	         CASEofDBL		if (isInc) { double dbl ; memcpy(&dbl,bo,sizeof(double)) ; dbl += lta->entry[ex].value ; memcpy(bo,&dbl,sizeof(double)) ; }
					 else { memcpy(bo,&lta->entry[ex].value,sizeof(double)) ; } ;
					break ;
	       } ;
	    } ;
	 } ;
/*	Free up any allocated lta's */
	for(lta=ltaSave;lta!=&lta1;lta=ltaSave)
	 { ltaSave = lta->ltaPrior ; v4mm_FreeChunk(lta) ;
	 } ;
	return(TRUE) ;
}

/*	v4im_TallyAreaWrite - Writes out results via specified file pointer */

void v4im_TallyAreaWrite(ctx,fp,vtm,mdim,actx)
  struct V4C__Context *ctx ;
  FILE *fp ;
  struct V4IM__TallyMaster *vtm ;
  int mdim,actx ;
{ struct V4IM__TallyEntry *vte ;
  P *pt ;
  struct V4DPI__DimInfo *di ;
  int vx,i ; char tb1[100],tb2[100],*b1,*b2 ;

	if (actx == UNUSED)					/* Write out header? */
	 { fprintf(fp,"H,%d,%d\n",mdim,vtm->ActionCount) ;
	   for(i=0;i<vtm->ActionCount;i++)
	    { fprintf(fp,"C,%d,%d,%d,%d\n",i,vtm->Action[i].NumComboPoints,vtm->Action[i].NumValues,vtm->Action[i].ActionType) ; } ;
	   fprintf(fp,"ZHC\n") ;
	   return ;
	 } ;
	for(vx=0;vx<vtm->TallyEntryMax;vx++)
	 { if (vtm->teb->Entry[vx] == NULL) continue ;		/* Nothing in this slot */
	   vte = vtm->teb->Entry[vx] ; if (vte->ActionX != actx) continue ;
	   for(i=0;i<vtm->Action[actx].NumValues;i++)
	    { 

	      sprintf(tb1,"NEED TO REPLACE CODE FOR NEW VTE STRUCTURE") ;
	      for(b1=tb1,b2=tb1;;)				/* Get rid of leading spaces in tb1 */
	       { if (*b2 == ' ') { b2++ ; continue ; }
	         *b1 = *b2 ; if (*b2 == '\0') break ; b1++ ; b2++ ;
	       } ;
	      fprintf(fp,"V,%d,%d,%s,%s\n",actx,vte->Entry[i].Count,tb1,tb2) ;
	    } ;
	   pt = (P *)((char *)vte + vte->Offset) ;			/* First point */
	   for(i=0;i<vtm->Action[actx].NumComboPoints;i++)
	    { 
	      switch(pt->PntType)
	       { CASEofINT
	         case V4DPI_PntType_Color:
		 case V4DPI_PntType_Country:
	         case V4DPI_PntType_XDict:
	         case V4DPI_PntType_Dict:	sprintf(tb1,"%d",pt->Value.IntVal) ; break ;
	       } ;
	      DIMINFO(di,ctx,pt->Dim) ;
	      v_Msg(ctx,(UCCHAR *)tb2,"@%1D",di->DimId) ;
	      fprintf(fp,"P,%s,%s\n",tb1,UCretASC((UCCHAR *)tb2)) ;
	      ADVPNT(pt) ;
	    } ;
	 } ;
}

/*	v4im_DoTransform - Handle Transform with Tagged Values */

P *v4im_DoTransform(ctx,respnt,intmodx,argcnt,argpnts)
  struct V4C__Context *ctx ;
  INTMODX intmodx ;
  int argcnt ;
  P *respnt,*argpnts[] ;
{ struct V4DPI__DimInfo *di ;
  P *pt1,*ipt,*fpt,*lpt,spnt,apnt ;
  struct V4DPI__Point_IntMix *rpim,*ipim ;
  struct V4DPI__Point_RealMix *rprm,*iprm ;
  struct V4DPI__Point_AlphaMix *rpam,*ipam ;
  int i,len,frameid,justfl,i1,i2,nextfree,index,ok ; char *tbuf,tb1[V4DPI_AlphaVal_Max+1],tb2[V4DPI_AlphaVal_Max+1] ; double d1,d2 ;

	pt1 = argpnts[1] ; frameid = UNUSED ;
	fpt = NULL ; lpt = NULL ; di = NULL ; justfl = UNUSED ;
	for(i=2;i<=argcnt;i++)				/* Loop thru each tagged argument */
	 {
	   switch (v4im_CheckPtArgNew(ctx,argpnts[i],&ipt,NULL))
	    { default:			v_Msg(ctx,NULL,"TagBadUse",intmodx) ; goto transform_fail ;
	      case V4IM_Tag_Unk:	v_Msg(ctx,NULL,"TagUnknown",intmodx) ; goto transform_fail ;
	      case V4IM_Tag_All:	fpt = lpt = ipt ; break ;
	      case V4IM_Tag_Dim:
		ISVALIDDIM(ipt->Value.IntVal,i,"Transform()") ;	DIMINFO(di,ctx,ipt->Value.IntVal) ;
		if (di == NULL) { v_Msg(ctx,NULL,"ModArgNotDim",intmodx,i,ipt) ; goto transform_fail ; } ;
		break ;
	      case V4IM_Tag_First:	fpt = ipt ; break ;
	      case V4IM_Tag_Last:	lpt = ipt ; break ;
	      case -V4IM_Tag_First:	justfl = 1 ; break ;
	      case -V4IM_Tag_Last:	justfl = 2 ; break ;
	    } ;
	 } ;
	memcpy(respnt,pt1,pt1->Bytes) ;			/* Init the result point */
	if (di != NULL)
	 { respnt->PntType = di->PointType ; respnt->Dim = di->DimId ; } ;
	rpim = (struct V4DPI__Point_IntMix *)&respnt->Value ;
	rprm = (struct V4DPI__Point_RealMix *)&respnt->Value ;
	rpam = (struct V4DPI__Point_AlphaMix *)&respnt->Value ;
	switch (justfl)					/* Maybe wants just first/last portion of point */
	 { case 1:
		if (pt1->Grouping == 0) return(respnt) ;
		respnt->Grouping = 0 ;
		switch (pt1->PntType)
		 { default:
			respnt->Value.IntVal = rpim->Entry[0].BeginInt ; respnt->Bytes = V4PS_Int ; break ;
		   case V4DPI_PntType_Calendar:
		   case V4DPI_PntType_Real:
			PUTREAL(respnt,rprm->Entry[0].BeginReal) ;
			respnt->Bytes = V4PS_Real ; break ;
		   CASEofCharmU
			tbuf = (char *)&rpam->Entry[pt1->Grouping].BeginIndex ;
			len = *(tbuf+rpam->Entry[0].BeginIndex) ;
			strncpy(tb1,tbuf+rpam->Entry[0].BeginIndex+1,len) ; tb1[len] = 0 ;
			strcpy(&respnt->Value.AlphaVal[1],tb1) ;
			CHARPNTBYTES2(respnt,len)
			break ;
		 } ;
		return(respnt) ;
	   case 2:
		if (pt1->Grouping == 0) return(respnt) ;
		respnt->Grouping = 0 ;
		switch (pt1->PntType)
		 { default:
			respnt->Value.IntVal = rpim->Entry[pt1->Grouping-1].EndInt ; respnt->Bytes = V4PS_Int ; break ;
		   case V4DPI_PntType_Calendar:
		   case V4DPI_PntType_Real:
			PUTREAL(respnt,rprm->Entry[pt1->Grouping-1].EndReal) ;
			respnt->Bytes = V4PS_Real ; break ;
		   CASEofCharmU
			tbuf = (char *)&rpam->Entry[pt1->Grouping].BeginIndex ;
			i = (rpam->Entry[pt1->Grouping-1].EndIndex == 0 ? rpam->Entry[pt1->Grouping-1].BeginIndex : rpam->Entry[pt1->Grouping-1].EndIndex) ;
			len = *(tbuf+i) ; strncpy(tb1,tbuf+i+1,len) ; tb1[len] = 0 ;
			strcpy(&respnt->Value.AlphaVal[1],tb1) ;
			CHARPNTBYTES2(respnt,len)
			break ;
		 } ;


		return(respnt) ;
	 } ;
	frameid = v4ctx_FramePush(ctx,NULL) ;		/* Start new context frame */
	if (pt1->Grouping == 0)				/* If first argument is single point, then ... */
	 { if (!v4ctx_FrameAddDim(ctx,0,pt1,0,0)) { v_Msg(ctx,NULL,"CtxAddFail",intmodx) ; goto transform_fail ; } ;
	   CLEARCACHE
	   if (fpt != NULL)
	    { ipt = v4dpi_IsctEval(&spnt,fpt,ctx,V4DPI_EM_EvalQuote,NULL,NULL) ;
	      if (ipt == NULL) { v_Msg(ctx,NULL,"TagEvalFail",intmodx,V4IM_Tag_First,fpt) ; goto transform_fail ; } ;
	      ok = TRUE ;
	      switch(respnt->PntType)
	       { default:
			i1 = v4im_GetPointInt(&ok,ipt,ctx) ; break ;
		 case V4DPI_PntType_UDT:
			switch(ipt->PntType)
			 { default:			v_Msg(ctx,NULL,"ProjectDTErr",intmodx,ipt,V4DPI_PntType_UDT) ; goto transform_fail ;
			   case V4DPI_PntType_UDT:	i1 = ipt->Value.IntVal ; break ;
			   case V4DPI_PntType_UDate:	i1 = (ipt->Value.IntVal - VCAL_UDTUDateOffset) * VCAL_SecsInDay ; break ;
			 } ;
			break ;
		 case V4DPI_PntType_Calendar:
		 case V4DPI_PntType_Real:
			d1 = v4im_GetPointDbl(&ok,ipt,ctx) ; break ;
		 CASEofCharmU
			v4im_GetPointChar(&ok,tb1,sizeof tb1,ipt,ctx) ; break ;
	       } ;
	      if (!ok) { v_Msg(ctx,NULL,"ModFailed2",intmodx) ; goto transform_fail ; } ;

	    } else
	    { switch(respnt->PntType)
	       { default:
			i1 = v4im_GetPointInt(&ok,pt1,ctx) ; break ;
		 case V4DPI_PntType_Calendar:
		 case V4DPI_PntType_Real:
			d1 = v4im_GetPointDbl(&ok,pt1,ctx) ; break ;
		 CASEofChar
			v4im_GetPointChar(&ok,tb1,sizeof tb1,pt1,ctx) ; break ;
	       } ;
	      if (!ok) { v_Msg(ctx,NULL,"ModFailed2",intmodx) ; goto transform_fail ; } ;
	    } ;
	   if (lpt != NULL)
	    { ipt = v4dpi_IsctEval(&spnt,lpt,ctx,V4DPI_EM_EvalQuote,NULL,NULL) ;
	      if (ipt == NULL) { v_Msg(ctx,NULL,"TagEvalFail",intmodx,V4IM_Tag_Last,lpt) ; goto transform_fail ; } ;
	      switch(respnt->PntType)
	       { default:
			i2 = v4im_GetPointInt(&ok,ipt,ctx) ; break ;
		 case V4DPI_PntType_UDT:
			switch(ipt->PntType)
			 { default:			v_Msg(ctx,NULL,"ProjectDTErr",intmodx,ipt,V4DPI_PntType_UDT) ; goto transform_fail ;
			   case V4DPI_PntType_UDT:	i2 = ipt->Value.IntVal ; break ;
			   case V4DPI_PntType_UDate:	i2 = (ipt->Value.IntVal - VCAL_UDTUDateOffset) * VCAL_SecsInDay + VCAL_SecsInDay - 1 ; break ;
			 } ;
			break ;
		 case V4DPI_PntType_Calendar:
		 case V4DPI_PntType_Real:
			d2 = v4im_GetPointDbl(&ok,ipt,ctx) ; break ;
		 CASEofCharmU
			v4im_GetPointChar(&ok,tb2,sizeof tb2,ipt,ctx) ; break ;
	       } ;
	      if (!ok) { v_Msg(ctx,NULL,"ModFailed2",intmodx) ; goto transform_fail ; } ;
	    } else
	    { switch(respnt->PntType)
	       { default:
			i2 = v4im_GetPointInt(&ok,pt1,ctx) ; break ;
		 case V4DPI_PntType_Calendar:
		 case V4DPI_PntType_Real:
			d2 = v4im_GetPointDbl(&ok,pt1,ctx) ; break ;
		 CASEofCharmU
			v4im_GetPointChar(&ok,tb2,sizeof tb2,pt1,ctx) ; break ;
	       } ;
	      if (!ok) { v_Msg(ctx,NULL,"ModFailed2",intmodx) ; goto transform_fail ; } ;
	    } ;

	   respnt->Grouping++ ;
	   switch(respnt->PntType)
	    { default:
		rpim->Entry[0].BeginInt = i1 ; rpim->Entry[0].EndInt = i2 ;
		SETBYTESGRPINT(respnt) ; break ;
//		respnt->Bytes = V4DPI_PointHdr_Bytes + sizeof(rpim->Entry[0]) ; break ;
	      case V4DPI_PntType_Calendar:
	      case V4DPI_PntType_Real:
		memcpy(&rprm->Entry[0].BeginReal,&d1,sizeof d1) ; memcpy(&rprm->Entry[0].EndReal,&d2,sizeof d2) ;
		SETBYTESGRPDBL(respnt) ;
		break ;
//		respnt->Bytes = V4DPI_PointHdr_Bytes + sizeof(rprm->Entry[0]) ; break ;
	      CASEofCharmU
		if (strlen(tb1) + strlen(tb2) + sizeof(rpam->Entry[0]) + 2 > V4DPI_AlphaVal_Max)
		 { v_Msg(ctx,NULL,"PointMaxSize",intmodx,strlen(tb1) + strlen(tb2) + sizeof(rpam->Entry[0]) + 2,V4DPI_AlphaVal_Max,V4DPI_PntType_Char) ;
		   goto transform_fail ;
		 } ;
		nextfree = sizeof rpam->Entry[0] ; rpam->Entry[0].BeginIndex = nextfree - sizeof rpam->Entry[0] ;
		memcpy(&respnt->Value.AlphaVal[nextfree+1],tb1,strlen(tb1)) ; respnt->Value.AlphaVal[nextfree+0] = strlen(tb1) ;
		nextfree += ALIGN(1+respnt->Value.AlphaVal[nextfree+0]) ;
		rpam->Entry[0].EndIndex = nextfree - sizeof rpam->Entry[0] ;
		memcpy(&respnt->Value.AlphaVal[nextfree+1],tb2,strlen(tb2)) ; respnt->Value.AlphaVal[nextfree+0] = strlen(tb2) ;
		nextfree += ALIGN(1+respnt->Value.AlphaVal[nextfree+0]) ;
		respnt->Bytes = V4DPI_PointHdr_Bytes + nextfree ; break ;
	    } ;

	   if (!v4ctx_FramePop(ctx,frameid,NULL)) { v_Msg(ctx,NULL,"ModCtxPopFrame",intmodx,frameid) ; goto transform_fail ; } ;		/* Pop off frame context */
	   return(respnt) ;
	 } ;
	ipim = (struct V4DPI__Point_IntMix *)&pt1->Value ;
	iprm = (struct V4DPI__Point_RealMix *)&pt1->Value ;
	ipam = (struct V4DPI__Point_AlphaMix *)&pt1->Value ;
	CPH(&apnt,pt1) ; apnt.Grouping = 0 ;		/* Set up single value version of first argument point */
	nextfree = pt1->Grouping * sizeof rpam->Entry[0] ;
	respnt->Grouping = 0 ;
	for(i=0;i<pt1->Grouping;i++)
	 { switch(pt1->PntType)
	    { default:
		v_Msg(ctx,NULL,"ModArgPntType",intmodx,1,pt1,pt1->PntType) ; goto transform_fail ;
	      CASEofINT
	      case V4DPI_PntType_Dict:
	      case V4DPI_PntType_XDict:
		apnt.Value.IntVal = ipim->Entry[i].BeginInt ; apnt.Bytes = V4PS_Int ; break ;
	      case V4DPI_PntType_Calendar:
	      case V4DPI_PntType_Real:
		PUTREAL(&apnt,iprm->Entry[i].BeginReal) ; apnt.Bytes = V4PS_Real ; break ;
	      CASEofCharmU
		tbuf = (char *)&ipam->Entry[pt1->Grouping].BeginIndex ; len = *(tbuf+ipam->Entry[i].BeginIndex) ;
		strncpy(&apnt.Value.AlphaVal[1],tbuf+ipam->Entry[i].BeginIndex+1,len) ;
		CHARPNTBYTES2(&apnt,len)
		break ;
	    } ;
	   if (!v4ctx_FrameAddDim(ctx,0,&apnt,0,0)) { v_Msg(ctx,NULL,"CtxAddFail",intmodx) ; goto transform_fail ; } ;
	   CLEARCACHE
	   if (fpt != NULL)
	    { ipt = v4dpi_IsctEval(&spnt,fpt,ctx,V4DPI_EM_EvalQuote,NULL,NULL) ;
	      if (ipt == NULL)
	       { v_Msg(ctx,NULL,"TagEvalFail",intmodx,V4IM_Tag_First,fpt) ; goto transform_fail ; } ;
	      switch(respnt->PntType)
	       { default:			i1 = v4im_GetPointInt(&ok,ipt,ctx) ; break ;
	         case V4DPI_PntType_Calendar:
		 case V4DPI_PntType_Real:	d1 = v4im_GetPointDbl(&ok,ipt,ctx) ; break ;
		 CASEofCharmU			v4im_GetPointChar(&ok,tb1,sizeof tb1,ipt,ctx) ; break ;
	       } ;
	      if (!ok) { v_Msg(ctx,NULL,"ModFailed2",intmodx) ; goto transform_fail ; } ;
	    } ;

	   switch(pt1->PntType)
	    { default:
		apnt.Value.IntVal = ipim->Entry[i].EndInt ; apnt.Bytes = V4PS_Int ; break ;
	      case V4DPI_PntType_Calendar:
	      case V4DPI_PntType_Real:
		PUTREAL(&apnt,iprm->Entry[i].EndReal) ; apnt.Bytes = V4PS_Real ; break ;
	      CASEofCharmU
		tbuf = (char *)&ipam->Entry[pt1->Grouping].BeginIndex ;
		index = (ipam->Entry[i].EndIndex == 0 ? ipam->Entry[i].BeginIndex : ipam->Entry[i].EndIndex) ;
		len = *(tbuf+index) ; strncpy(&apnt.Value.AlphaVal[1],tbuf+index+1,len) ;
		CHARPNTBYTES2(&apnt,len)
		break ;
	    } ;
	   if (!v4ctx_FrameAddDim(ctx,0,&apnt,0,0)) { v_Msg(ctx,NULL,"CtxAddFail",intmodx) ; goto transform_fail ; } ;
	   CLEARCACHE
	   if (lpt != NULL)
	    { ipt = v4dpi_IsctEval(&spnt,lpt,ctx,V4DPI_EM_EvalQuote,NULL,NULL) ;
	      if (ipt == NULL)
	       { v_Msg(ctx,NULL,"TagEvalFail",intmodx,V4IM_Tag_Last,lpt) ; goto transform_fail ; } ;
	      switch(respnt->PntType)
	       { default:			i2 = v4im_GetPointInt(&ok,ipt,ctx) ; break ;
	         case V4DPI_PntType_Calendar:
		 case V4DPI_PntType_Real:	d2 = v4im_GetPointDbl(&ok,ipt,ctx) ; break ;
		 CASEofCharmU			v4im_GetPointChar(&ok,tb2,sizeof tb2,ipt,ctx) ; break ;
	       } ;
	      if (!ok) { v_Msg(ctx,NULL,"ModFailed2",intmodx) ; goto transform_fail ; } ;
	    } ;
	   switch(respnt->PntType)
	    { default:
		if (lpt == NULL) i2 = i1 ; if (fpt == NULL) i1 = i2 ;
		rpim->Entry[i].BeginInt = i1 ; rpim->Entry[i].EndInt = i2 ;
//		respnt->Bytes = V4DPI_PointHdr_Bytes + (++respnt->Grouping)*sizeof(rpim->Entry[0]) ;
		respnt->Grouping++ ; SETBYTESGRPINT(respnt) ;
		break ;
	      case V4DPI_PntType_Calendar:
	      case V4DPI_PntType_Real:
		if (lpt == NULL) d2 = d1 ; if (fpt == NULL) d1 = d2 ;
		memcpy(&rprm->Entry[i].BeginReal,&d1,sizeof d1) ; memcpy(&rprm->Entry[i].EndReal,&d2,sizeof d2) ;
//		respnt->Bytes = V4DPI_PointHdr_Bytes + (++respnt->Grouping)*sizeof(rprm->Entry[0]) ;
		respnt->Grouping++ ; SETBYTESGRPDBL(respnt) ;
		break ;
	      CASEofCharmU
		if (lpt == NULL) strcpy(tb2,tb1) ; if (fpt == NULL) strcpy(tb1,tb2) ;
		rpam->Entry[0].BeginIndex = nextfree - (pt1->Grouping * sizeof rpam->Entry[0]) ;
		memcpy(&respnt->Value.AlphaVal[nextfree+1],tb1,strlen(tb1)) ; respnt->Value.AlphaVal[nextfree+0] = strlen(tb1) ;
		nextfree += ALIGN(1+respnt->Value.AlphaVal[nextfree+0]) ;
		rpam->Entry[0].EndIndex = nextfree - (pt1->Grouping * sizeof rpam->Entry[0]) ;
		memcpy(&respnt->Value.AlphaVal[nextfree+1],tb2,strlen(tb2)) ; respnt->Value.AlphaVal[nextfree+0] = strlen(tb2) ;
		nextfree += ALIGN(1+respnt->Value.AlphaVal[nextfree+0]) ;
		respnt->Bytes = V4DPI_PointHdr_Bytes + nextfree ; break ;
	    } ;
	 } ;
	if (!v4ctx_FramePop(ctx,frameid,NULL)) { v_Msg(ctx,NULL,"ModCtxPopFrame",intmodx,frameid) ; goto transform_fail ; } ;		/* Pop off frame context */
	return(respnt) ;
transform_fail:
	if (frameid != UNUSED) v4ctx_FramePop(ctx,frameid,NULL) ;
	REGISTER_ERROR(0) ; return(NULL) ;
}


/*	v4im_DoEvalPt - Handles EvalPt() Function	*/

P *v4im_DoEvalPt(ctx,respnt,argpnts,argcnt,intmodx)
  struct V4C__Context *ctx ;
  P *respnt,*argpnts[] ;
  int argcnt,intmodx ;
{ P *ipt,*cpt,*ept,vpt,opt ;
  struct V4LEX__TknCtrlBlk *tcb ;
  UCCHAR ptbuf[V4TMBufMax] ; INDEX i,doOpt ; LOGICAL ok ;

	ZUS(ptbuf) ; doOpt = 0 ;
	for(i=1;i<=argcnt;i++)				/* Loop thru each tagged argument */
	 { if(argpnts[i]->PntType != V4DPI_PntType_TagVal)
	    { LENMAX len = UCstrlen(ptbuf) ;
	      v4im_GetPointUC(&ok,&ptbuf[len],V4TMBufMax-len,argpnts[i],ctx) ;
	      if (!ok) { v_Msg(ctx,NULL,"ModFailed2",intmodx) ; goto fail ; } ;
	      continue ;
	    } ;
	   switch (v4im_CheckPtArgNew(ctx,argpnts[i],&cpt,NULL))
	    { default:			v_Msg(ctx,NULL,"TagBadUse",intmodx) ; goto fail ;
	      case V4IM_Tag_Unk:	v_Msg(ctx,NULL,"TagUnknown",intmodx) ; goto fail ;
	      case -V4IM_Tag_Optimize:	doOpt = i ; break ;
	      case V4IM_Tag_Token:
//		{ LOGICAL needqt ; INDEX j ;
//		  v4im_GetPointUC(&ok,UCTBUF1,V4TMBufMax,cpt,ctx) ; if (!ok) { v_Msg(ctx,NULL,"ModFailed2",intmodx) ; goto fail ; } ;
//		  for(j=0,needqt=FALSE;UCTBUF1[j]!=UCEOS;j++) { if (!vuc_IsAlphaNum(UCTBUF1[j])) { needqt = TRUE ; break ; } ; } ;
//		  if (j >= V4DPI_DictEntryVal_Max || needqt || UCempty(UCTBUF1)) { v_StringLit(UCTBUF1,UCTBUF2,V4TMBufMax,UClit('"'),UClit('\\')) ; UCstrcat(ptbuf,UCTBUF2) ; }
//		   else { UCstrcat(ptbuf,UCTBUF1) ; } ;
//		}
		v4im_GetPointUC(&ok,UCTBUF1,V4TMBufMax,cpt,ctx) ; if (!ok) { v_Msg(ctx,NULL,"ModFailed2",intmodx) ; goto fail ; } ;
		v_StringLit(UCTBUF1,UCTBUF2,V4TMBufMax,UClit('"'),UClit('\\')) ; UCstrcat(ptbuf,UCTBUF2) ;

		break ;
	    } ;
	 } ;
	tcb = v4mm_AllocChunk(sizeof *tcb,FALSE) ; v4lex_InitTCB(tcb,V4LEX_TCBINIT_NoStdIn) ;
	v4lex_NestInput(tcb,NULL,NULL,V4LEX_InpMode_RetEOF) ; v4lex_NestInput(tcb,NULL,ptbuf,V4LEX_InpMode_String) ;
	if (!v4dpi_PointParse(ctx,&vpt,tcb,V4DPI_PointParse_RetFalse))
	 { v4lex_FreeTCB(tcb) ;
	   v_Msg(ctx,NULL,"ModFailed2",intmodx) ;
	   if (traceGlobal & V4TRACE_EvalPt)
	    { v_Msg(ctx,UCTBUF1,"@*EvalPt(%1U) -> parse failed: %0A\n",ptbuf) ; vout_UCText(VOUT_Trace,0,UCTBUF1) ;
	    } ;
	   goto fail ;
	 } ;
	v4lex_FreeTCB(tcb) ;
	if (doOpt > 0)
	 { int savertStackX, savertStackFail ;
	   savertStackX = ctx->rtStackX ; savertStackFail = ctx->rtStackFail ; ctx->rtStackX += 2 ;
	   ok = v4eval_OptPoint(ctx,&vpt,&opt,sizeof opt,NULL) ;
	   ctx->rtStackX = savertStackX ; ctx->rtStackFail = savertStackFail ;
	   if (ok < 1) { v_Msg(ctx,NULL,"DoNoOptimize",intmodx,doOpt) ;  ipt = NULL ; goto fail ; } ;
	   if (traceGlobal & V4TRACE_Optimize)
	    { v_Msg(ctx,UCTBUF2,"*TraceDoOpt",&opt) ; vout_UCText(VOUT_Trace,0,UCTBUF2) ; } ;
	   ept = &opt ;
	 } else { ept = &vpt ; } ;
	ipt = v4dpi_IsctEval(respnt,ept,ctx,0,NULL,NULL) ;
	if (traceGlobal & V4TRACE_EvalPt)
	 { v_Msg(ctx,UCTBUF1,"@*EvalPt(%1U) -> %2P\n",ptbuf,ipt) ; vout_UCText(VOUT_Trace,0,UCTBUF1) ;
	 } ;
	if (ipt == NULL)
	 { v_Msg(ctx,NULL,"ModArgEval2",intmodx,&vpt) ; goto fail ; } ;
	return(ipt) ;

fail:	REGISTER_ERROR(0) ; return(NULL) ;
}

/*	v4im_DoSpawn - Handles Spawn() Function	*/

P *v4im_DoSpawn(ctx,respnt,argpnts,argcnt,intmodx,trace)
  struct V4C__Context *ctx ;
  P *respnt,*argpnts[] ;
  int argcnt,intmodx,trace ;
{ P *cpt,pntbuf ;
  int oshreflist[V4OSH_Max], refcount ;
  struct V4OSH__Table *osh ;
#ifdef WINNT
  HANDLE hlist[V4OSH_Max] ; int count ;
#endif
  UCCHAR cmd[V4TMBufMax], arg[V4TMBufMax] ;
  INDEX ix ; ETYPE tag ; FLAGS32 wait ; LOGICAL ok, doEcho, doSpawn, window ; FILEID fileId ; LENMAX waitSecs,kBytesOut ;

	wait = V_SPAWNPROC_Wait ; ZUS(cmd) ; ZUS(arg) ; refcount = 0 ; window = FALSE ; doEcho = FALSE ; doSpawn = TRUE ; fileId = UNUSED ; waitSecs = 0 ; kBytesOut = 0 ;
	for(ix=1,ok=TRUE;ok&&ix<=argcnt;ix++)
	 { if (argpnts[ix]->PntType != V4DPI_PntType_TagVal)
	    { if (argpnts[ix]->PntType == V4DPI_PntType_OSHandle)
	       { if (refcount >= V4OSH_Max) { v_Msg(ctx,NULL,"SpawnMaxProc",intmodx,V4OSH_Max) ; goto fail ; } ;
	         oshreflist[refcount++] = argpnts[ix]->Value.IntVal ;
	         continue ;
	       } ;
	      v4im_GetPointUC(&ok,UCTBUF1,V4TMBufMax,argpnts[ix],ctx) ; if (!ok) break ;
	      if (UCstrlen(cmd) + UCstrlen(UCTBUF1) >= UCsizeof(cmd))
	       { v_Msg(ctx,NULL,"StrLitTooBig2",intmodx,ix,UCsizeof(cmd)) ; goto fail ; } ;
	      UCstrcat(cmd,UCTBUF1) ; continue ;
	    } ;
	   switch (tag=v4im_CheckPtArgNew(ctx,argpnts[ix],&cpt,&pntbuf))
	    { default:			v_Msg(ctx,NULL,"TagBadUse",intmodx) ; goto fail ;
	      case V4IM_Tag_Unk:	v_Msg(ctx,NULL,"TagUnknown",intmodx) ; goto fail ;
	      case V4IM_Tag_Active:
		if (cpt->PntType != V4DPI_PntType_OSHandle)
		 { v_Msg(ctx,NULL,"ModArgPntType2",intmodx,ix,cpt->PntType,V4DPI_PntType_OSHandle) ; goto fail ; } ;
		return(v_OSH_IsProcThreadActive(cpt->Value.IntVal) ? (P *)&Log_True : NULL) ;
	      case V4IM_Tag_Arg:
		v4im_GetPointUC(&ok,arg,V4TMBufMax,cpt,ctx) ; break ;
	      case V4IM_Tag_Bytes:
		kBytesOut = v4im_GetPointDbl(&ok,cpt,ctx) / 1000 ;
		break ;
	      case V4IM_Tag_Append:
	      case V4IM_Tag_Create:
		{ UCCHAR fileName[V_FileName_Max] ;
		  v4im_GetPointUC(&ok,fileName,UCsizeof(fileName),cpt,ctx) ; if (!ok) break ;
		  fileId = vout_OpenStreamFile(NULL,fileName,NULL,NULL,(tag==V4IM_Tag_Append),gpi->OutputCharSet,0,ctx->ErrorMsgAux) ;
		  if (fileId == UNUSED)
		   { v_Msg(ctx,NULL,"OSFileSysErr",intmodx,ix) ; goto fail ; } ;
///*		  Spawn() output is sent to Progress stream */
//		  if (!vout_BindStreamFile(fileId,UNUSED,VOUT_Progress,ctx->ErrorMsgAux))
//		   { v_Msg(ctx,NULL,"OSFileSysErr",intmodx,ix) ; goto fail ; } ;
		}
		break ;
	      case -V4IM_Tag_Echo:
		doEcho = TRUE ; break ;
	      case V4IM_Tag_Echo:
		if (cpt->PntType == V4DPI_PntType_Logical) { doEcho = v4im_GetPointLog(&ok,cpt,ctx) ; break ; } ;
		switch (v4im_GetDictToEnumVal(ctx,cpt))
		 { default:		v_Msg(ctx,NULL,"ModTagValue",intmodx,2,V4IM_Tag_Echo,argpnts[ix]) ; goto fail ;
		   case _Only:		doEcho = TRUE ; doSpawn = FALSE ; break ;
		 } ;
		break ;
	      case V4IM_Tag_Maximum:
		waitSecs = v4im_GetPointInt(&ok,cpt,ctx) ; if (!ok) break ;
		if (waitSecs < 1 || waitSecs > V_SPAWNWAIT_MaxSecs) { v_Msg(ctx,NULL,"ModArgRange",intmodx,ix,cpt,1,V_SPAWNWAIT_MaxSecs) ; goto fail ; } ;
		break ;
	      case V4IM_Tag_Result:
	      { INDEX j ;
		if (cpt->PntType != V4DPI_PntType_OSHandle)
		 { v_Msg(ctx,NULL,"ModArgPntType2",intmodx,ix,cpt->PntType,V4DPI_PntType_OSHandle) ; goto fail ; } ;
		osh = gpi->osh ; 
		if (osh != NULL) { for(j=0;j<osh->Count;j++) { if (osh->Entry[j].Ref == cpt->Value.IntVal) break ; } ; } ;
		if (osh == NULL ? TRUE : j >= osh->Count) { v_Msg(ctx,NULL,"SpawnProcInv",intmodx) ; goto fail ; } ;
#ifdef WINNT
		ok = GetExitCodeProcess(osh->Entry[j].hProcess,&ix) ;
		if (ok == 0) { v_Msg(ctx,NULL,"SpawnProcInv",intmodx) ; goto fail ; } ;
		if (ix == STILL_ACTIVE) { v_Msg(ctx,NULL,"SpawnProcRun",intmodx) ; goto fail ; } ;
		intPNTv(respnt,ix) ; return(respnt) ;
#else
		v_Msg(ctx,NULL,"ModTagNYI",intmodx,V4IM_Tag_Result) ; goto fail ;
#endif
	      }
	      case V4IM_Tag_Wait:
		switch (v4im_GetDictToEnumVal(ctx,cpt))
		 { default:		break ; /* Fall thru and check for logical */
		   case _Application:	wait = V_SPAWNPROC_Application ; goto do_spawn ;
		   case _Any:		wait = V_SPAWNPROC_Any ; goto do_wait ;
		   case _All:		wait = V_SPAWNPROC_All ; goto do_wait ;
		 } ;
		wait = v4im_GetPointLog(&ok,cpt,ctx) ; if (!ok) break ;
		wait = (wait ? V_SPAWNPROC_Wait : V_SPAWNPROC_NoWait) ;
		if (refcount > 0 || ix == 1) goto do_wait ;
		break ;
	      case -V4IM_Tag_Window:	window = TRUE ; break ;
	    } ;
	 } ;
	if (!ok) { v_Msg(ctx,NULL,"ModInvArg",intmodx,ix-1) ; goto fail ; } ;

do_spawn:
	if (doEcho)
	 { v_Msg(ctx,UCTBUF1,"@*%1U\n",cmd) ; vout_UCText(VOUT_Status,0,UCTBUF1) ; } ;
	if (!doSpawn)
	 { logPNTv(respnt,FALSE) ; return(respnt) ; } ;
	if (window) wait |= V_SPAWNPROC_NewWindow ;
//	if (UCstrlen(arg) > 0) { if (v_SpawnProcess(cmd,arg,(SPAWNMAXWAITENC(waitSecs)|wait),ctx->ErrorMsgAux,respnt,NULL,fileId)) return(respnt) ; }
//	 else { if (v_SpawnProcess(NULL,cmd,(SPAWNMAXWAITENC(waitSecs)|wait),ctx->ErrorMsgAux,respnt,NULL,fileId)) return(respnt) ; } ;
	{ struct V__SpawnArgs sa ; memset(&sa,0,sizeof sa) ;
	  sa.waitFlags = wait ; sa.waitSeconds = waitSecs ; sa.errBuf = ctx->ErrorMsgAux ; sa.fileId = fileId ; sa.kilobytesOut = kBytesOut ; sa.respnt = respnt ;
 	  if (UCnotempty(arg)) { sa.exeFile = cmd ; sa.argBuf = arg ; } else { sa.argBuf = cmd ; } ;
	  if (v_SpawnProcess(&sa)) return(respnt) ;
	}



	v_Msg(ctx,NULL,"SpawnErr",intmodx) ; goto fail ;

/*	Here to wait for one or more processes to complete */
do_wait:
	switch (wait)
	 { case V_SPAWNPROC_All:
	   case V_SPAWNPROC_Wait:
#ifdef WINNT
		count = v_OSH_WinNTProcHandleList(hlist) ;
		ok = WaitForMultipleObjects(count,hlist,TRUE,INFINITE) ;
		if (ok == WAIT_FAILED) { v_Msg(ctx,NULL,"SpawnWait",intmodx,GetLastError()) ; goto fail ; } ;
#endif
		return((P *)&Log_True) ;
		break ;
	   case V_SPAWNPROC_Any:
#ifdef WINNT
		count = v_OSH_WinNTProcHandleList(hlist) ;
		ok = WaitForMultipleObjects(count,hlist,FALSE,INFINITE) ;
		if (ok == WAIT_FAILED) { v_Msg(ctx,NULL,"SpawnWait",intmodx,GetLastError()) ; goto fail ; } ;
		return((P *)&Log_True) ;		   
#endif
		break ;

	 } ;

fail:	REGISTER_ERROR(0) ; RETURNFAILURE ;
}

/*	v4im_DoEvalCmd - Handles EvalCmd() Function	*/

P *v4im_DoEvalCmd(ctx,respnt,argpnts,argcnt,intmodx,trace)
  struct V4C__Context *ctx ;
  P *respnt,*argpnts[] ;
  int argcnt,intmodx,trace ;
{ P *ipt ;
  struct V4LEX__TknCtrlBlk *tcb ;
  struct UC__File UCFile ;
  UCCHAR tnbuf[256] ;
  UCCHAR cmd[V4TMBufMax] ;
  jmp_buf environment ;                 /* Error recovery environment */
  INDEX saveStackX ; UCCHAR *b,*b1 ; INDEX i ; LOGICAL echo,ok ;

	echo = FALSE ; ZUS(cmd) ; tcb = NULL ;
	for(i=1,ok=TRUE;ok&&i<=argcnt;i++)
	 { if (argpnts[i]->PntType != V4DPI_PntType_TagVal)
	    { v4im_GetPointUC(&ok,UCTBUF1,V4TMBufMax,argpnts[i],ctx) ; if (!ok) break ;
	      if (UCstrlen(cmd) + UCstrlen(UCTBUF1) >= UCsizeof(cmd))
	       { v_Msg(ctx,NULL,"StrLitTooBig2",intmodx,i,UCsizeof(cmd)) ; goto fail ; } ;
	      UCstrcat(cmd,UCTBUF1) ; continue ;
	    } ;
	   switch (v4im_CheckPtArgNew(ctx,argpnts[i],&ipt,NULL))
	    { default:			v_Msg(ctx,NULL,"TagBadUse",intmodx) ; goto fail ;
	      case V4IM_Tag_Unk:	v_Msg(ctx,NULL,"TagUnknown",intmodx) ; goto fail ;
	      case -V4IM_Tag_Echo:	echo = TRUE ; break ;
	    } ;
	 } ;
	if (!ok) { v_Msg(ctx,NULL,"ModInvArg",intmodx,i-1) ; goto fail ; } ;
	COPYJMP(environment,(gpi->environment)) ;
	if (setjmp(gpi->environment) != 0)		/* Set up trapping of ALL errors */
	 { COPYJMP((gpi->environment),environment) ;
	   ctx->rtStackX = saveStackX ;
	   UCstrcpy(ctx->ErrorMsg,gpi->ErrMsg) ; goto fail ;
	 } ;
	saveStackX = ctx->rtStackX ;

	tcb = v4mm_AllocChunk(sizeof *tcb,FALSE) ; v4lex_InitTCB(tcb,V4LEX_TCBINIT_NoStdIn) ;
	tcb->maxCharInpBuf = V4LEX_Tkn_SrcFileLineMax ;
	if (UCstrchr(cmd,EOLbt) != NULL)			/* Do we have multiple "lines" (probably from BigText?) */
	 { int fid,fx ;

	   v_MakeOpenTmpFile(UClit("v4ec"),tnbuf,UCsizeof(tnbuf),NULL,ctx->ErrorMsg) ;
	   if ((fid=vout_OpenStreamFile(NULL,tnbuf,UClit("tmp"),NULL,FALSE,V4L_TextFileType_UTF16,0,ctx->ErrorMsgAux)) == UNUSED)
	    { v_Msg(ctx,NULL,"ModFailed2",intmodx) ; goto fail ; } ;
	   fx = vout_FileIdToFileX(fid) ;
	   for(b=cmd;;b=b1+1)
	    { b1 = UCstrchr(b,EOLbt) ; if (b1 != NULL) *b1 = '\0' ;
	      if (echo) { v_Msg(ctx,UCTBUF1,"@*%1M(\"%2U\")\n",intmodx,b) ; vout_UCText(VOUT_Trace,0,UCTBUF1) ; } ;
	      vout_UCTextFileX(fx,0,b) ; vout_NLFileX(fx) ; if (b1 == NULL) break ;
	    } ;
	   vout_UCTextFileX(fx,0,UClit("Exit NoStatistics\n")) ;
	   vout_CloseFile(fid,UNUSED,ctx->ErrorMsgAux) ;
	   if (!v_UCFileOpen(&UCFile,tnbuf,UCFile_Open_Read,TRUE,ctx->ErrorMsgAux,intmodx))
	    { v_Msg(ctx,NULL,"ModFailed2",intmodx) ; goto fail ; } ;
	   v4lex_NestInput(tcb,&UCFile,tnbuf,V4LEX_InpMode_TempFile) ;
	 } else
	 { UCFile.fp = NULL ; v4lex_NestInput(tcb,NULL,UClit("EXIT\n"),V4LEX_InpMode_String) ;
	   if (echo) { v_Msg(ctx,UCTBUF1,"@*%1M(\"%2U\")\n",intmodx,cmd) ; vout_UCText(VOUT_Trace,0,UCTBUF1) ; } ;
	   UCstrcat(cmd,UClit("\n")) ; v4lex_NestInput(tcb,NULL,cmd,V4LEX_InpMode_String) ;
	 } ;
	switch (V4EVAL_ResMask & v4eval_Eval(tcb,ctx,(UCFile.fp != NULL),trace,FALSE,TRUE,FALSE,NULL))	/* Evaluate the argument */
	 { case V4EVAL_Res_NestRetErr:	ipt = NULL ; break ;
	   default:			ipt = (P *)&Log_True ; break ;
	 }
	v4lex_FreeTCB(tcb) ; tcb = NULL ;
	ctx->rtStackX = saveStackX ;
	COPYJMP((gpi->environment),environment) ;
	if (ipt == NULL)
	 { v_Msg(ctx,NULL,"ModFailed2",intmodx) ; goto fail ; } ;
	return(ipt) ;				/*  & return as value */

fail:	if (tcb != NULL) v4lex_FreeTCB(tcb) ;
	REGISTER_ERROR(0) ; RETURNFAILURE ;
}



/*	v4im_DoGeo - GeoCoordinate Functions	*/

P *v4im_DoGeo(ctx,respnt,argpnts,argcnt,intmodx,trace)
  struct V4C__Context *ctx ;
  P *respnt,*argpnts[] ;
  int argcnt,intmodx,trace ;
{ P ptbuf,*ipt,*cpt,*geo1,*geo2, *geo3 ;
  int i,ix,ok,t,tz,rows,columns,grow,gcolumn,hgt ; int uomfctr = V4DPI_GeoCoordDist_KMeter ;
  double lat,lon,phi,theta,res,cal ; double x1,x2, y1,y2, z1,z2 ; double bearing = UNUSED ;
  double Direction(),Sunrise(),Sunset() ;
  static double distFactors[] = { GEODISTFACTORS } ;
  static double timeFactors[] = { GEOTIMEFACTORS } ;

	geo1 = NULL ; geo2 = NULL ; geo3 = NULL ;
	for(ix=1,ok=TRUE;ok && ix<=argcnt;ix++)
	 { if (argpnts[ix]->PntType == V4DPI_PntType_GeoCoord)
	    { if (geo1 == NULL) { geo1 = argpnts[ix] ; continue ; } ;
	      if (geo2 == NULL) { geo2 = argpnts[ix] ; continue ; } ;
	      if (geo3 == NULL) { geo3 = argpnts[ix] ; continue ; } ;
	      v_Msg(ctx,NULL,"GeoMaxGeo",intmodx,3) ; goto geo_fail ;
	    } ;
	   switch (t=v4im_CheckPtArgNew(ctx,argpnts[ix],&cpt,&ptbuf))
	    { default:			v_Msg(ctx,NULL,"TagBadUse",intmodx) ; goto geo_fail ;
	      case V4IM_Tag_Unk:	v_Msg(ctx,NULL,"TagUnknown",intmodx) ; goto geo_fail ;
	      case V4IM_Tag_Dawn:
	      case V4IM_Tag_Dusk:
		if (geo1 == NULL || geo2 != NULL) { v_Msg(ctx,NULL,"GeoArgNum",intmodx,t,1) ; goto geo_fail ; } ;
		lat = GETGEOLAT(&geo1->Value.GeoCoord) ;
		lon = (double)geo1->Value.GeoCoord.Coord2 / V4DPI_GeoCoord_Factor ;
		cal = v4im_GetPointCal(&ok,cpt,ctx) ;
		tz = geo1->Value.GeoCoord.TimeZone ;
		if (tz == VCAL_TimeZone_Local)		/* If no time zone then guess at one from longitude */
		 { tz = (int)(24.0 * (lon / 360.0)) ; } ;
		hgt = GETGEOALT(&geo1->Value.GeoCoord) ;
		if (hgt < 0) hgt = 0 ;
		res = (t == V4IM_Tag_Dawn ? Sunrise(&ok,(int)cal,lat,lon,hgt,tz)
					  : Sunset(&ok,(int)cal,lat,lon,hgt,tz)) ;
		res -= (double)tz / 24.0 ;	/* Adjust time back to universal */
		if (!ok) { v_Msg(ctx,NULL,"GeoFail",intmodx,t) ; goto geo_fail ; } ;
		ipt = respnt ; ZPH(ipt) ; ipt->Bytes = V4PS_Calendar ; ipt->Dim = Dim_UCal ; ipt->PntType = V4DPI_PntType_Calendar ;
		PUTREAL(ipt,res) ; return(ipt) ;
	      case V4IM_Tag_Direction:
		bearing = v4im_GetPointDbl(&ok,cpt,ctx) ; if (!ok) break ;
		if (bearing < 0 || bearing >= 360) { v_Msg(ctx,NULL,"ModArgRange",intmodx,ix,cpt,0,360) ; goto geo_fail ; } ;
		break ;
	      case -V4IM_Tag_Direction:
		if (geo1 == NULL || geo2 == NULL) { v_Msg(ctx,NULL,"GeoArgNum",intmodx,t,2) ; goto geo_fail ; } ;
		res = Direction(GETGEOLAT(&geo1->Value.GeoCoord),GETGEOLON(&geo1->Value.GeoCoord),GETGEOLAT(&geo2->Value.GeoCoord),GETGEOLON(&geo2->Value.GeoCoord)) ;		
		break ;
	      case V4IM_Tag_Distance:
/*		Are we determining geo from start point, bearing, and distance, or are we determining geo between two points ? */
		if (geo2 == NULL && bearing != UNUSED)
		 { double lat,lon ;
		   v_NewLatLonFromLLAD(&lat,&lon,GETGEOLAT(&geo1->Value.GeoCoord),GETGEOLON(&geo1->Value.GeoCoord),bearing,v4im_GetPointDbl(&ok,cpt,ctx)) ;
		   if (!ok) break ;
		   memcpy(respnt,argpnts[1],argpnts[1]->Bytes) ;
		   SETGEOLAT(&respnt->Value.GeoCoord,lat) ; SETGEOLON(&respnt->Value.GeoCoord,lon) ;
		   return(respnt) ;
		 } ;
/*		First calculate distance between two points (same as -V4IM_Tag_Distance below) */
		if (geo1 == NULL || geo2 == NULL) { v_Msg(ctx,NULL,"GeoArgNum",intmodx,t,2) ; goto geo_fail ; } ;
		lat = GETGEOLAT(&geo1->Value.GeoCoord) ; phi = 90.0 - lat ; phi = phi * 2.0 * PI / 360.0 ;
		lon = GETGEOLON(&geo1->Value.GeoCoord) ; theta = lon * 2.0 * PI / 360.0 ;
		x1 = MEANEARTHRADIUS * cos(theta) * sin(phi) ; y1 = MEANEARTHRADIUS * sin(theta) * sin(phi) ; z1 = MEANEARTHRADIUS * cos(phi) ;
		lat = GETGEOLAT(&geo2->Value.GeoCoord) ; phi = 90.0 - lat ; phi = phi * 2.0 * PI / 360.0 ;
		lon = GETGEOLON(&geo2->Value.GeoCoord) ;theta = lon * 2.0 * PI / 360.0 ;
		x2 = MEANEARTHRADIUS * cos(theta) * sin(phi) ; y2 = MEANEARTHRADIUS * sin(theta) * sin(phi) ; z2 = MEANEARTHRADIUS * cos(phi) ;
		res = sqrt((x1-x2)*(x1-x2) + (y1-y2)*(y1-y2) + (z1-z2)*(z1-z2)) ;
		res = 2.0 * MEANEARTHRADIUS * asin(res / (2.0 * MEANEARTHRADIUS)) ;
		{ double A,B,f,d,x,y,z ;
		  double lat,lon,lat1,lon1, lat2,lon2 ;
/*		  See http://williams.best.vwh.net/avform.htm#GCF for source of code */
		  lat1 = GETGEOLAT(&geo1->Value.GeoCoord) ; lat1 = 90.0 - lat1 ; lat1 = lat1 * 2.0 * PI / 360.0 ;
		  lon1 = GETGEOLON(&geo1->Value.GeoCoord) ; lon1 = lon1 * 2.0 * PI / 360.0 ;
		  lat2 = GETGEOLAT(&geo2->Value.GeoCoord) ; lat2 = 90.0 - lat2 ; lat2 = lat2 * 2.0 * PI / 360.0 ;
		  lon2 = GETGEOLON(&geo2->Value.GeoCoord) ; lon2 = lon2 * 2.0 * PI / 360.0 ;
		  d = res / METERSinNAUTICALMILE ;		/* d = distance in nautical miles */
		  d = (PI /(180*60)) * d ;		/* d = distance in radians */
		  f = v4im_GetPointDbl(&ok,cpt,ctx) ; if (!ok) break ;
		  if (f < 0 || f > 1.0) { v_Msg(ctx,NULL,"GeoFracDist",intmodx,cpt) ; goto geo_fail ; } ;
		  A=sin((1-f)*d)/sin(d) ;
		  B=sin(f*d)/sin(d) ;
		  x = A*cos(lat1)*cos(lon1) +  B*cos(lat2)*cos(lon2) ;
		  y = A*cos(lat1)*sin(lon1) +  B*cos(lat2)*sin(lon2) ;
		  z = A*sin(lat1)           +  B*sin(lat2) ;
		  lat=atan2(z,sqrt(x*x + y*y)) ;
		  lon=atan2(y,x) ;
		  memcpy(respnt,argpnts[1],argpnts[1]->Bytes) ;
		  lat =  90 - (lat * (360.0 / (2.0 * PI))) ;
		  lon = (lon * (360.0 / (2.0 * PI))) ;
		  respnt->Value.GeoCoord.Coord1 = DtoI(lat * V4DPI_GeoCoord_Factor) ; respnt->Value.GeoCoord.Coord2 = DtoI(lon * V4DPI_GeoCoord_Factor) ;
		  return(respnt) ;
		}

	      case -V4IM_Tag_Distance:
		if (geo1 == NULL || geo2 == NULL) { v_Msg(ctx,NULL,"GeoArgNum",intmodx,t,2) ; goto geo_fail ; } ;
		res = v_DistBetween2LL(GETGEOLAT(&geo1->Value.GeoCoord),GETGEOLON(&geo1->Value.GeoCoord),GETGEOLAT(&geo2->Value.GeoCoord),GETGEOLON(&geo2->Value.GeoCoord),uomfctr) ;
		break ;
	      case V4IM_Tag_Grid:
		if (geo3 == NULL) { v_Msg(ctx,NULL,"GeoMissingGeo",intmodx,3,cpt) ; goto geo_fail ; } ;
		if (cpt->PntType == V4DPI_PntType_Int2)
		 { rows = cpt->Value.Int2Val[0] ; columns = cpt->Value.Int2Val[1] ; }
		 else { rows = (columns = v4im_GetPointInt(&ok,cpt,ctx)) ; if (!ok) break ; } ;
		if (geo1->Value.GeoCoord.Coord1 > geo2->Value.GeoCoord.Coord1 || geo1->Value.GeoCoord.Coord2 < geo2->Value.GeoCoord.Coord2
		    || geo1->Value.GeoCoord.Coord1 < geo3->Value.GeoCoord.Coord1 || geo1->Value.GeoCoord.Coord2 > geo3->Value.GeoCoord.Coord2)
		 { v_Msg(ctx,NULL,"GeoOutsideGrid",intmodx,geo1,geo2,geo3) ; goto geo_fail ; } ;
		grow = DtoI(((double)(geo2->Value.GeoCoord.Coord1 - geo1->Value.GeoCoord.Coord1) / (double)(geo2->Value.GeoCoord.Coord1 - geo3->Value.GeoCoord.Coord1)) * (rows - 1)) + 1 ;
		gcolumn = DtoI(((double)(geo2->Value.GeoCoord.Coord2 - geo1->Value.GeoCoord.Coord2) / (double)(geo2->Value.GeoCoord.Coord2 - geo3->Value.GeoCoord.Coord2)) * (columns - 1) + 1) ;
		ZPH(respnt) ; respnt->Dim = Dim_Int2 ; respnt->PntType = V4DPI_PntType_Int2 ; respnt->Bytes = V4PS_Int2 ;
		respnt->Value.Int2Val[0] = grow ; respnt->Value.Int2Val[1] = gcolumn ;
		return(respnt) ;
	      case -V4IM_Tag_Intercept:
		if (geo1 == NULL || geo2 == NULL) { v_Msg(ctx,NULL,"GeoArgNum",intmodx,t,2) ; goto geo_fail ; } ;
		if (geo1->Value.GeoCoord.GCType != V4DPI_GCType_Distance) { v_Msg(ctx,NULL,"GeoNoVel",intmodx,1) ; goto geo_fail ; } ;	      
		if (geo2->Value.GeoCoord.GCType != V4DPI_GCType_Distance) { v_Msg(ctx,NULL,"GeoNoVel",intmodx,2) ; goto geo_fail ; } ;	      

		{ struct V4DPI__Value_GCDSV tar,proj ; int cnt ;
		  double lat, lon ; double m,km, mps1,mps2,sec2, nm ;
		  memcpy(&tar,&geo1->Value.GeoCoord,sizeof tar) ; memcpy(&proj,&geo2->Value.GeoCoord,sizeof proj) ;
		  
		for(cnt=0;cnt<25;cnt++)
		 { 
		   km = v_DistBetween2LL(GETGEOLAT(&tar),GETGEOLON(&tar),GETGEOLAT(&proj),GETGEOLON(&proj),V4DPI_GeoCoordDist_KMeter) ;
/*		   How long will it take projectile (proj) to reach geo1 ? */
		   mps2 = GETGEODSTSPD(&proj) * distFactors[proj.distUOM] / timeFactors[proj.speedUnit] ;	/* geo2's speed in meters/second */
		   sec2 = (km * 1000) / mps2 ;			/* sec2 = number of seconds to get there */
/*		   Where will target be after sec seconds ? */
		   mps1 = GETGEODSTSPD(&tar) * distFactors[tar.distUOM] / timeFactors[tar.speedUnit] ;	/* geo1's speed in meters/second */
		   m = mps1 * sec2 ;				/* m = distance geo1 travels */
		   nm = m / METERSinNAUTICALMILE ;		/* nm = distance in nautical miles */

		   v_NewLatLonFromLLAD(&lat,&lon,GETGEOLAT(&geo1->Value.GeoCoord),GETGEOLON(&geo1->Value.GeoCoord),GETGEOAZ(&geo1->Value.GeoCoord),m) ;
		   SETGEOLAT(&tar,lat) ; SETGEOLON(&tar,lon) ;
		 } ;
		 memcpy(respnt,geo1,geo1->Bytes) ; memcpy(&respnt->Value.GeoCoord,&tar,sizeof tar) ;
		 return(respnt) ;
		}


	      case V4IM_Tag_LunarAltitude:
		if (geo1->PntType != V4DPI_PntType_GeoCoord) { v_Msg(ctx,NULL,"ModArgPntType2",intmodx,ix,geo1->PntType,V4DPI_PntType_GeoCoord) ; goto geo_fail ; } ;
		lat = GETGEOLAT(&geo1->Value.GeoCoord) ;
		lon = GETGEOLON(&geo1->Value.GeoCoord) ;
		cal = v4im_GetPointCal(&ok,cpt,ctx) ; if (!ok) break ;
		res = LunarAltitude(cal,lat,lon) ; dblPNTv(respnt,res) ;
		return(respnt) ;
	      case V4IM_Tag_UOM:
		{ int cx = gpi->ci->li->CurX ; UCCHAR tag[64],sbbuf[512] ;
		  v4im_GetPointUC(&ok,tag,UCsizeof(tag),cpt,ctx) ; if (!ok) break ;
		  for(i=0;i<V4LI_DstMax;i++) { if (UCstrcmpIC(tag,gpi->ci->li->LI[cx].Dst[i].dstAbbr) == 0) break ; } ;
		  if (i < V4LI_DstMax) { uomfctr = gpi->ci->li->LI[cx].Dst[i].dstIntVal ; break ; } ;
		  ZUS(sbbuf) ; for(i=0;i<V4LI_DstMax;i++) { if (UCnotempty(gpi->ci->li->LI[cx].Dst[i].dstAbbr)) { UCstrcat(sbbuf,gpi->ci->li->LI[cx].Dst[i].dstAbbr) ; UCstrcat(sbbuf,UClit(",")) ; } ; } ;
		  sbbuf[UCstrlen(sbbuf) - 1] = UCEOS ; v_Msg(ctx,ctx->ErrorMsgAux,"DPIGeoUOMBad",tag,sbbuf) ; ok = FALSE ; break ;
		}
	    } ;
	 } ;
	if (!ok) { v_Msg(ctx,NULL,"ModInvArg",intmodx,ix-1) ; goto geo_fail ; } ;
	dblPNTv(respnt,res) ; return(respnt) ;
geo_fail:
	REGISTER_ERROR(0) ; return(NULL) ;
}

/*	v4im_DoIn - Handles the In() intmod */
LOGICAL v4im_DoIn(ctx,pt,inpt,intmodx,arg)
  struct V4C__Context *ctx ;
  P *pt, *inpt ;
  int intmodx,arg ;
{
  struct V4DPI__DimInfo *di ;
  struct V4DPI__Point_IntMix *pim ;
  struct V4DPI__Point_RealMix *prm ;
  struct V4DPI__Point_FixMix *pfm ;
  struct V4DPI__Point_AlphaMix *pam ;
  struct V4DPI__Point_UOMMix *pum ;
  struct V4DPI__Point_UOMPerMix *pupm ;
  struct V4DPI__Point *tpt,isctbuf ;
  struct V4L__ListPoint *lp ;
  struct V4IM__Drawer *drw ;
  struct V4DPI__LittlePoint lpt ;
  struct V4DPI__CodedRange *vcr ;
  enum DictionaryEntries deval ;
  int i,j,inum,ok,maxdp ; char *tbuf ; UCCHAR *ub,*utbuf ; double d1,d2,d3 ; B64INT b641,b642,b643 ;
match_start:
	
	lpt.Value.IntVal = 0 ;			/* Many entries below expect this to be clear */
	switch (inpt->PntType)
	 { default: v_Msg(ctx,NULL,"ModArgPntType",intmodx,2,inpt,inpt->PntType) ; return(-999) ;
	   case V4DPI_PntType_List:
		lp = v4im_VerifyList(NULL,ctx,inpt,intmodx) ;
		if (lp == NULL) { v_Msg(ctx,NULL,"ModInvArgList",intmodx,2) ; return(-999) ; } ;
		if (lp->ListType == V4L_ListType_BitMap)
		 { return(v4l_BitMapTest(ctx,intmodx,pt->Value.IntVal,inpt)) ;
		 } ;
		for(i=1;v4l_ListPoint_Value(ctx,lp,i,&isctbuf) > 0;i++)	/* Loop thru each point in list */
		 { if (v4im_DoIn(ctx,pt,&isctbuf,intmodx,i) > 0) return(TRUE) ; } ;
		return(FALSE) ;				/* If not in list then return false */
	   case V4DPI_PntType_Special:
		switch (inpt->Grouping)
		 { default: v_Msg(ctx,NULL,"ModArgSpcPt",intmodx,2,inpt) ; return(-999) ;
		   case V4DPI_Grouping_All:
			if (pt->Dim == inpt->Dim) return(TRUE) ;/* Same dimension -> return TRUE */
			DIMINFO(di,ctx,inpt->Dim) ;
			return(pt->PntType == di->PointType) ;	/* Matches all points with same point type */
		   case V4DPI_Grouping_Undefined:
			return(FALSE) ;				/* If here then have context point, not UNDEFINED! */
		 } ; break ;
	   case V4DPI_PntType_Shell:	/* A shell, just grab contained points & try again! */
		inpt = (P *)&inpt->Value ; pt = (P *)&pt->Value ;
		goto match_start ;
	   case V4DPI_PntType_MemPtr:
		if (inpt->Grouping == V4DPI_Grouping_Single)
		 { if (memcmp(&inpt->Value.MemPtr,&pt->Value.MemPtr,sizeof(pt->Value.MemPtr))==0) return(TRUE) ; } ;
		break ;
	   case V4DPI_PntType_UOM:
//		if (inpt->Grouping == V4DPI_Grouping_Single)
//		 { if (memcmp(&inpt->Value.UOMVal.Num,&pt->Value.UOMVal.Num,sizeof(pt->Value.UOMVal.Num))==0) return(TRUE) ; break ; } ;
	   	d1 = v4im_GetPointDbl(&ok,pt,ctx) ; memcpy(&d2,&inpt->Value.UOMVal.Num,sizeof d2) ;
		if (pt->Value.UOMVal.Ref != inpt->Value.UOMVal.Ref && fabs(d1) > gpi->DblEpsilon) return(FALSE) ;
		if (!ok) { v_Msg(ctx,NULL,"ModInvArg",intmodx,1) ; return(-999) ; } ;
//VEH101216 - Treat as double (using epsilon)
		if ((inpt->Grouping == V4DPI_Grouping_Single) || (inpt->Grouping > V4DPI_Grouping_MaxMix)) goto in_dbl ;
//		switch (inpt->Grouping)
//		 { 
//		   case V4DPI_Grouping_Single:	return(d1 == d2) ;
//		   case V4DPI_Grouping_GT:	return(d1 > d2) ;
//		   case V4DPI_Grouping_GE:	return(d1 >= d2) ;
//		   case V4DPI_Grouping_LT:	return(d1 < d2) ;
//		   case V4DPI_Grouping_LE:	return(d1 <= d2) ;
//		   case V4DPI_Grouping_NE:	return(d1 != d2) ;
//		 } ;
/*		Have a list or range or whatever - do it */
		pum = (struct V4DPI__Point_UOMMix *)&inpt->Value ;
		for(i=0;i<inpt->Grouping;i++)
		 { memcpy(&d2,&pum->Entry[i].BeginUOM.Num,SIZEofDOUBLE) ; memcpy(&d3,&pum->Entry[i].EndUOM.Num,SIZEofDOUBLE) ;
		   if ((d1 + gpi->DblEpsilon) >= d2 && (d1 - gpi->DblEpsilon) <= d3) return(TRUE) ;
		 } ;
		break ;
	   case V4DPI_PntType_UOMPer:
//		if (pt->Value.UOMPerVal.Ref != inpt->Value.UOMPerVal.Ref) return(FALSE) ;
//		if (inpt->Grouping == V4DPI_Grouping_Single)
//		 { if (memcmp(&inpt->Value.UOMPerVal.Num,&pt->Value.UOMPerVal.Num,sizeof(pt->Value.UOMPerVal.Num))==0) return(TRUE) ; break ; } ;
	   	d1 = v4im_GetPointDbl(&ok,pt,ctx) ; memcpy(&d2,&inpt->Value.UOMPerVal.Num,sizeof d2) ;
		if (pt->Value.UOMVal.Ref != inpt->Value.UOMVal.Ref && fabs(d1) > gpi->DblEpsilon) return(FALSE) ;
		if (!ok) { v_Msg(ctx,NULL,"ModInvArg",intmodx,1) ; return(-999) ; } ;
//VEH101216 - Treat as double (using epsilon)
		if ((inpt->Grouping == V4DPI_Grouping_Single) || (inpt->Grouping > V4DPI_Grouping_MaxMix)) goto in_dbl ;
//		switch (inpt->Grouping)
//		 { case V4DPI_Grouping_Single:	return(d1 == d2) ;
//		   case V4DPI_Grouping_GT:	return(d1 > d2) ;
//		   case V4DPI_Grouping_GE:	return(d1 >= d2) ;
//		   case V4DPI_Grouping_LT:	return(d1 < d2) ;
//		   case V4DPI_Grouping_LE:	return(d1 <= d2) ;
//		   case V4DPI_Grouping_NE:	return(d1 != d2) ;
//		 } ;
/*		Have a list or range or whatever - do it */
		pupm = (struct V4DPI__Point_UOMPerMix *)&inpt->Value ;
		for(i=0;i<inpt->Grouping;i++)
		 { memcpy(&d2,&pupm->Entry[i].BeginUOMPer.Amount,SIZEofDOUBLE) ; memcpy(&d3,&pupm->Entry[i].EndUOMPer.Amount,SIZEofDOUBLE) ;
		   if (d1 >= d2 && d1 <= d3) return(TRUE) ;
		 } ;
		break ;
	   case V4DPI_PntType_RegExpPattern:
		v4im_GetPointChar(&ok,ASCTBUF1,V4TMBufMax,pt,ctx) ;
		if (!ok) { v_Msg(ctx,NULL,"ModInvArg",intmodx,1) ; return(-999) ; } ;
		i = vregexp_RegExec((regex_t *)((char *)inpt + inpt->Bytes - sizeof(regex_t)),ASCTBUF1,0,NULL,0) ;
		return(!i) ;
	   case V4DPI_PntType_Fixed:
		if (pt->PntType == V4DPI_PntType_Fixed) { FIXNORMALIZE(b641,b642,pt,inpt) }
		 else { d2 = v4im_GetPointDbl(&ok,pt,ctx) ; goto in_dbl_from_fix ; } ;
		switch (inpt->Grouping)
		 { case V4DPI_Grouping_Single:	return(b641 == b642) ;
		   case V4DPI_Grouping_GT:	return(b641 > b642) ;
		   case V4DPI_Grouping_GE:	return(b641 >= b642) ;
		   case V4DPI_Grouping_LT:	return(b641 < b642) ;
		   case V4DPI_Grouping_LE:	return(b641 <= b642) ;
		   case V4DPI_Grouping_NE:	return(b641 != b642) ;
		 } ;
/*		Have a list or range or whatever - do it */
/*		At this point b641 has pt's value & is scaled properly, i = proper scaling for all inpt values to be had */
		maxdp = (pt->LHSCnt >= inpt->LHSCnt ? pt->LHSCnt : inpt->LHSCnt) ;
		pfm = (struct V4DPI__Point_FixMix *)&inpt->Value ;
		for(i=0;i<inpt->Grouping;i++)
		 { memcpy(&b642,&pfm->Entry[i].BeginFix,sizeof(B64INT)) ; SCALEFIX(b642,inpt->LHSCnt,maxdp) ;
		   memcpy(&b643,&pfm->Entry[i].EndFix,sizeof(B64INT)) ; SCALEFIX(b643,inpt->LHSCnt,maxdp) ;
		   if (b641 >= b642 && b641 <= b643) return(TRUE) ;
		 } ;
		break ;
	   case V4DPI_PntType_Real:
in_real:
	   	GETREAL(d2,inpt) ;
in_dbl_from_fix:
		d1 = v4im_GetPointDbl(&ok,pt,ctx) ;
		if (!ok) { v_Msg(ctx,NULL,"ModInvArg",intmodx,1) ; return(-999) ; } ;
in_dbl:
		switch (inpt->Grouping)
		 { 
		   case V4DPI_Grouping_Single:	return(fabs(d1-d2) <= gpi->DblEpsilon) ;
		   case V4DPI_Grouping_GT:	return(d1 + gpi->DblEpsilon > d2) ;
		   case V4DPI_Grouping_GE:	return(d1 + gpi->DblEpsilon >= d2) ;
		   case V4DPI_Grouping_LT:	return(d1 - gpi->DblEpsilon < d2) ;
		   case V4DPI_Grouping_LE:	return(d1 - gpi->DblEpsilon <= d2) ;
		   case V4DPI_Grouping_NE:	return(fabs(d1-d2) > gpi->DblEpsilon) ;
		 } ;
/*		Have a list or range or whatever - do it */
		prm = (struct V4DPI__Point_RealMix *)&inpt->Value ;
		for(i=0;i<inpt->Grouping;i++)
		 { memcpy(&d2,&prm->Entry[i].BeginReal,SIZEofDOUBLE) ; memcpy(&d3,&prm->Entry[i].EndReal,SIZEofDOUBLE) ;
		   if (d1 >= d2 && d1 <= d3) return(TRUE) ;
		 } ;
		break ;
	   case V4DPI_PntType_Drawer:
		drw = v4im_GetDrawerPtr(inpt->Dim,inpt->Value.IntVal) ;
		if (drw == NULL) { v_Msg(ctx,NULL,"DrawerNoneSpec",intmodx,inpt) ; return(-999) ; } ;
		if (drw->Points == 0) return(FALSE) ;
		tpt = (P *)drw->DrawerBuf ;
		for(i=1;i<=drw->Points;i++)
		 { j = v4im_DoIn(ctx,pt,tpt,intmodx,arg) ;
		   if (j <= 0) { ADVPNT(tpt) ; continue ; } ;
		   return(j) ;
		 } ;
		return(FALSE) ;
	   case V4DPI_PntType_PntIdx:
		return(v4im_DoIn(ctx,pt,v4dpi_PntIdx_CvtIdxPtr(inpt->Value.IntVal),intmodx,arg)) ;
	   case V4DPI_PntType_Calendar:
		GETREAL(d2,inpt) ; d1 = 0.0 ;
		switch(pt->PntType)
		 { 
		   case V4DPI_PntType_Calendar:
			GETREAL(d1,pt) ;
			goto in_dbl ;
		   case V4DPI_PntType_UDate:
			if (pt->Value.IntVal == VCAL_UDate_None) break ;		/* If 'none' then don't try to convert to uquarter, keep as 0 */
			d1 = (double)(pt->Value.IntVal + VCal_MJDOffset) ; goto in_dbl ;
		   case V4DPI_PntType_UDT:
			if (pt->Value.IntVal == VCAL_UDT_None) break ;
			d1 = UDTtoCAL(pt->Value.IntVal) ;
			goto in_dbl ;
		 } ; return(FALSE) ;
	   case V4DPI_PntType_UMonth:
		switch(pt->PntType)		/* See if we can do some date conversions */
		 { default:	goto in_int ;	/* Just fall thru to Int compare */
		   case V4DPI_PntType_UDT:
			if (pt->Value.IntVal == VCAL_UDT_None) break ;		/* If 'none' then don't try to convert to uquarter, keep as 0 */
			UDtoUMONTH(lpt.Value.IntVal,UDTtoUD(pt->Value.IntVal)) ;
			break ;	/* Convert date to month & drop thru */
		   case V4DPI_PntType_Calendar:
			GETREAL(d1,pt) ;
			if (d1 == 0) break ;		/* If 'none' then don't try to convert to uquarter, keep as 0 */
			UDtoUMONTH(lpt.Value.IntVal,vcal_CalToUDate(d1,VCAL_TimeZone_Local,&ok)) ;
			if (!ok) { v_Msg(ctx,NULL,"CalInvRange",intmodx,pt,V4DPI_PntType_UMonth) ; return(-999) ; } ;
			break ;	/* Convert date to month & drop thru */
		   case V4DPI_PntType_UDate:
			if (pt->Value.IntVal == VCAL_UDate_None) break ;		/* If 'none' then don't try to convert to uquarter, keep as 0 */
			UDtoUMONTH(lpt.Value.IntVal,pt->Value.IntVal) ;
			break ;	/* Convert date to month & drop thru */
		 } ; ZPH(&lpt) ; lpt.PntType = V4DPI_PntType_Int ; pt = (P *)&lpt ; goto in_int ;
	   case V4DPI_PntType_UDate:
		switch(pt->PntType)
		 { default:	goto in_int ;
		   case V4DPI_PntType_Calendar:
			GETREAL(d1,pt) ;
			lpt.Value.IntVal = vcal_CalToUDate(d1,VCAL_TimeZone_Local,&ok) ;
			if (!ok) { v_Msg(ctx,NULL,"CalInvRange",intmodx,pt,V4DPI_PntType_UDate) ; return(-999) ; } ;
			break ;
		   case V4DPI_PntType_UDT:
			if (pt->Value.IntVal == VCAL_UDT_None) break ;		/* If 'none' then don't try to convert to uquarter, keep as 0 */
			lpt.Value.IntVal = pt->Value.IntVal/VCAL_SecsInDay+VCAL_UDTUDateOffset ; break ;
		 } ; ZPH(&lpt) ; lpt.PntType = V4DPI_PntType_Int ; pt = (P *)&lpt ; goto in_int ;
	   case V4DPI_PntType_UYear:
		switch(pt->PntType)		/* See if we can do some date conversions */
		 { default:	goto in_int ;	/* Just fall thru to Int compare */
		   case V4DPI_PntType_UDT:
			i = mscu_udate_to_yyyymmdd(pt->Value.IntVal/VCAL_SecsInDay+VCAL_UDTUDateOffset) ;
			lpt.Value.IntVal = i/10000 ; break ;
		   case V4DPI_PntType_Calendar:
			GETREAL(d1,pt) ;
			i = mscu_udate_to_yyyymmdd(vcal_CalToUDate(d1,VCAL_TimeZone_Local,&ok)) ;
			if (!ok) { v_Msg(ctx,NULL,"CalInvRange",intmodx,pt,V4DPI_PntType_UYear) ; return(-999) ; } ;
			lpt.Value.IntVal = i/10000 ; break ;
		   case V4DPI_PntType_UDate:
			i = mscu_udate_to_yyyymmdd(pt->Value.IntVal) ;
			lpt.Value.IntVal = i/10000 ; break ;
		   case V4DPI_PntType_UMonth:
			if (pt->Value.IntVal == VCAL_UMonth_None) break ;		/* If 'none' then don't try to convert to uquarter, keep as 0 */
			lpt.Value.IntVal = (pt->Value.IntVal / 12) + VCAL_BaseYear ; break ;
		   case V4DPI_PntType_UQuarter:
			if (pt->Value.IntVal == VCAL_UQuarter_None) break ;		/* If 'none' then don't try to convert to uquarter, keep as 0 */
			lpt.Value.IntVal = UQTRtoUYEAR(pt->Value.IntVal) ; break ;
		   case V4DPI_PntType_UPeriod:
			if (pt->Value.IntVal == VCAL_UPeriod_None) break ;		/* If 'none' then don't try to convert to uquarter, keep as 0 */
			{ int ppy ; DIMINFO(di,ctx,pt->Dim) ; ppy = (di->ds.UPeriod.periodsPerYear == 0 ? 13 : di->ds.UPeriod.periodsPerYear) ;
			  lpt.Value.IntVal = (pt->Value.IntVal / ppy) + VCAL_BaseYear ;
			}
			break ;
		   case V4DPI_PntType_UWeek:
			if (pt->Value.IntVal == VCAL_UWeek_None) break ;		/* If 'none' then don't try to convert to uquarter, keep as 0 */
			lpt.Value.IntVal = (pt->Value.IntVal / 52) + VCAL_BaseYear ; break ;
		 } ; ZPH(&lpt) ; lpt.PntType = V4DPI_PntType_Int ; pt = (P *)&lpt ; goto in_int ;
	   case V4DPI_PntType_UQuarter:
		switch(pt->PntType)		/* See if we can do some date conversions */
		 { default:	goto in_int ;	/* Just fall thru to Int compare */
		   case V4DPI_PntType_UDT:
			if (pt->Value.IntVal == VCAL_UDT_None) break ;		/* If 'none' then don't try to convert to uquarter, keep as 0 */
			i = mscu_udate_to_yyyymmdd(pt->Value.IntVal/VCAL_SecsInDay+VCAL_UDTUDateOffset) ;
			lpt.Value.IntVal = YYYYMMDDtoUQTR(i) ; break ;
		   case V4DPI_PntType_UDate:
			if (pt->Value.IntVal == VCAL_UDate_None) break ;		/* If 'none' then don't try to convert to uquarter, keep as 0 */
			i = mscu_udate_to_yyyymmdd(pt->Value.IntVal) ;
			lpt.Value.IntVal = YYYYMMDDtoUQTR(i) ; break ;
		   case V4DPI_PntType_UMonth:
			if (pt->Value.IntVal == VCAL_UMonth_None) break ;		/* If 'none' then don't try to convert to uquarter, keep as 0 */
			lpt.Value.IntVal = UMONTHtoUQTR(pt->Value.IntVal) ; break ;
		   case V4DPI_PntType_UQuarter:
			lpt.Value.IntVal = pt->Value.IntVal ; break ;
		 } ; ZPH(&lpt) ; lpt.PntType = V4DPI_PntType_Int ; pt = (P *)&lpt ; goto in_int ;
	   case V4DPI_PntType_UTime:
		switch(pt->PntType)		/* See if we can do some date conversions */
		 { default:	break ;		/* Just fall thru to Double compare */
		   case V4DPI_PntType_UTime:
			break ;
		   case V4DPI_PntType_UDT:
			pt = (P *)&lpt ; ZPH(pt) ; pt->PntType = V4DPI_PntType_Real ;
			d1 = (double)(pt->Value.IntVal % VCAL_SecsInDay) ; PUTREAL(pt,d1) ; break ;
		 } ; goto in_dbl_from_fix ;
	   case V4DPI_PntType_Dict:
		if (pt->PntType == V4DPI_PntType_Dict)
		 { inum = pt->Value.IntVal ;  goto in_int2 ; } ;
		goto in_dictstr ;
	   case V4DPI_PntType_XDict:
		if (pt->PntType == V4DPI_PntType_XDict && pt->Dim == inpt->Dim)
		 { inum = pt->Value.IntVal ; goto in_int2 ; } ;
/*		Have to convert to string & do string compare */
in_dictstr:	v4im_GetPointUC(&ok,UCTBUF1,V4TMBufMax,pt,ctx) ;	/* Convert first point to string */
		if (ok && inpt->Grouping == V4DPI_Grouping_Single)
		 { v4im_GetPointUC(&ok,UCTBUF2,V4TMBufMax,inpt,ctx) ;
		   return(UCstrcmpIC(UCTBUF1,UCTBUF2) == 0) ;
		 } ;
		if (!ok) { v_Msg(ctx,NULL,"ModFailed2",intmodx) ; return(-999) ; } ;
		if (inpt->Grouping > V4DPI_PointIntMix_Max) return(FALSE) ;
		pim = (struct V4DPI__Point_IntMix *)&inpt->Value ;
		for(i=0;i<inpt->Grouping;i++)
		 { ub = (inpt->PntType == V4DPI_PntType_Dict ?
		    v4dpi_RevDictEntryGet(ctx,pim->Entry[i].BeginInt) : v4dpi_RevXDictEntryGet(ctx,inpt->Dim,pim->Entry[i].BeginInt)) ;
		   if (UCstrcmpIC(UCTBUF1,ub) == 0) return(TRUE) ;
		 } ; return(FALSE) ;
		break ;
	   case V4DPI_PntType_CodedRange:
		DIMINFO(di,ctx,inpt->Dim)
		if ((di->rtFlags & V4DPI_rtDimInfo_Initvcr) == 0)
		 { di->rtFlags |= V4DPI_rtDimInfo_Initvcr ;
/*		   Construct [Dim:dim UV4:CodedRange] and execute to initialize */
		   INITISCT(&isctbuf) ; NOISCTVCD(&isctbuf) ; isctbuf.Grouping = 2 ;
		   tpt = ISCT1STPNT(&isctbuf) ; dictPNTv(tpt,Dim_UV4,v4im_GetEnumToDictVal(ctx,deval=_CodedRange,UNUSED)) ;
		   if (tpt->Dim != 0 && tpt->Value.IntVal != 0)
		    { ADVPNT(tpt) ; dictPNTv(tpt,Dim_Dim,di->DimId) ;
		      ADVPNT(tpt) ; ISCTLEN(&isctbuf,tpt) ;
/*		      Evaluate - don't care if it succeeds or fails */
		      v4dpi_IsctEval(&isctbuf,&isctbuf,ctx,V4DPI_EM_EvalQuote,NULL,NULL) ;
		    } ;
		 } ;
		inum = v4im_GetPointInt(&ok,pt,ctx) ;
		if (!ok) { v_Msg(ctx,NULL,"ModInvArg",intmodx,1) ; return(-999) ; } ;
		switch (inpt->Grouping)
		 { case V4DPI_Grouping_Single:
		    if (inum == inpt->Value.IntVal) return(TRUE) ;
		    for(vcr=di->vcr;vcr!=NULL;vcr=vcr->vcr)
		     { if (inpt->Value.IntVal == vcr->InternalValue) { inpt = vcr->crPoint ; goto in_int2 ; } ;
		     } ;
		    return(FALSE) ;
		   case V4DPI_Grouping_GT:	return(inum > inpt->Value.IntVal) ;
		   case V4DPI_Grouping_GE:	return(inum >= inpt->Value.IntVal) ;
		   case V4DPI_Grouping_LT:	return(inum < inpt->Value.IntVal) ;
		   case V4DPI_Grouping_LE:	return(inum <= inpt->Value.IntVal) ;
		   case V4DPI_Grouping_NE:	return(inum != inpt->Value.IntVal) ;
		 } ;
/*		Have a list or range or whatever - do it */
		pim = (struct V4DPI__Point_IntMix *)&inpt->Value ;
		for(i=0;i<inpt->Grouping;i++)
		 { if (inum >= pim->Entry[i].BeginInt && inum <= pim->Entry[i].EndInt)
		    return(TRUE) ;
/*		   If pim entry is single point then see if have a matching range */
		   if (pim->Entry[i].BeginInt != pim->Entry[i].EndInt) continue ;
		   for(vcr=di->vcr;vcr!=NULL;vcr=vcr->vcr)
		    { if (pim->Entry[i].BeginInt == vcr->InternalValue) { break ; } ;
		    } ; if (vcr == NULL) continue ;
/*		   Have a range to check - nest once (don't recurse - too expensive & may get endless loops */
		   tpt = vcr->crPoint ;
		   switch(tpt->Grouping)
		    { case V4DPI_Grouping_Single:	return(inum == tpt->Value.IntVal) ;
		      case V4DPI_Grouping_GT:		return(inum > tpt->Value.IntVal) ;
		      case V4DPI_Grouping_GE:		return(inum >= tpt->Value.IntVal) ;
		      case V4DPI_Grouping_LT:		return(inum < tpt->Value.IntVal) ;
		      case V4DPI_Grouping_LE:		return(inum <= tpt->Value.IntVal) ;
		      case V4DPI_Grouping_NE:		return(inum != tpt->Value.IntVal) ;
		    } ;
		   pim = (struct V4DPI__Point_IntMix *)&tpt->Value ;
		   for(i=0;i<tpt->Grouping;i++)
		    { if (inum >= pim->Entry[i].BeginInt && inum <= pim->Entry[i].EndInt)
		       return(TRUE) ;
		    } ;
		 } ;
		break ;
	   case V4DPI_PntType_Logical:
/*		Get logical value of pt and compare to inpt, if cannot coerce to logical then return FALSE */
		i = v4im_GetPointLog(&ok,pt,ctx) ;
		return(ok ? i == inpt->Value.IntVal : FALSE) ;
	   case V4DPI_PntType_AggRef:
		return(pt->Value.IntVal == inpt->Value.IntVal && pt->Grouping == inpt->Grouping && pt->PntType == V4DPI_PntType_AggRef) ;
	   case V4DPI_PntType_BigText:
	   case V4DPI_PntType_IntMod:
	   case V4DPI_PntType_SSVal:
	   case V4DPI_PntType_UDT:
	   case V4DPI_PntType_UWeek:
	   case V4DPI_PntType_UPeriod:
	   case V4DPI_PntType_OSHandle:
	   case V4DPI_PntType_Color:
	   case V4DPI_PntType_Country:
	   case V4DPI_PntType_Int:
		if (pt->PntType == V4DPI_PntType_Real) goto in_real ;
in_int:	/* Entry point for vanilla int compares */
		inum = v4im_GetPointInt(&ok,pt,ctx) ;
		if (!ok) { v_Msg(ctx,NULL,"ModInvArg",intmodx,1) ; return(-999) ; } ;
in_int2:/* Entry point for DICT compares */
		switch (inpt->Grouping)
		 { case V4DPI_Grouping_Single:
/*			As per documentation, In(a b) same as EqK(a b) for single points (VEH061114) */
			if (inpt->PntType == V4DPI_PntType_Real || inpt->PntType == V4DPI_PntType_Fixed)
			 { return(fabs(v4im_GetPointDbl(&ok,pt,ctx) - v4im_GetPointDbl(&ok,inpt,ctx)) <= gpi->DblEpsilon) ; }
		 	 else { return(inum == inpt->Value.IntVal) ; } ;
		   case V4DPI_Grouping_GT:	return(inum > inpt->Value.IntVal) ;
		   case V4DPI_Grouping_GE:	return(inum >= inpt->Value.IntVal) ;
		   case V4DPI_Grouping_LT:	return(inum < inpt->Value.IntVal) ;
		   case V4DPI_Grouping_LE:	return(inum <= inpt->Value.IntVal) ;
		   case V4DPI_Grouping_NE:	return(inum != inpt->Value.IntVal) ;
		 } ;
/*		Have a list or range or whatever - do it */
		pim = (struct V4DPI__Point_IntMix *)&inpt->Value ;
		for(i=0;i<inpt->Grouping;i++)
		 { if (inum >= pim->Entry[i].BeginInt && inum <= pim->Entry[i].EndInt)
		    return(TRUE) ;
		 } ;
		break ;
	   case V4DPI_PntType_V4IS:
		if (memcmp(&inpt->Value,&pt->Value,sizeof(struct V4DPI__PntV4IS)) == 0) return(TRUE) ;
		break ;
	   case V4DPI_PntType_Complex:
		if (memcmp(&inpt->Value.Complex,&pt->Value.Complex,sizeof(struct V4DPI__Value_Complex)) == 0) return(TRUE) ;
		break ;
	   case V4DPI_PntType_GeoCoord:
		if (memcmp(&inpt->Value.GeoCoord,&pt->Value.GeoCoord,sizeof (struct V4DPI__Value_GeoCoord)) == 0) return(TRUE) ;
		break ;
	   case V4DPI_PntType_TeleNum:
/*		Telephone - only compare basic number, not type & extension */
		if (inpt->Value.Tele.AreaCode != pt->Value.Tele.AreaCode) break ;
		if (inpt->Value.Tele.Number != pt->Value.Tele.Number) break ;
		if ((inpt->Value.Tele.IntDialCode < 0 ? -inpt->Value.Tele.IntDialCode : inpt->Value.Tele.IntDialCode) != (pt->Value.Tele.IntDialCode < 0 ? -pt->Value.Tele.IntDialCode : pt->Value.Tele.IntDialCode)) break ;
		return(TRUE) ;
	   case V4DPI_PntType_Int2:
		if (memcmp(&inpt->Value.Int2Val,&pt->Value.Int2Val,sizeof(pt->Value.Int2Val)) == 0) return(TRUE) ;
		break ;
	   case V4DPI_PntType_XDB:
		if (memcmp(&inpt->Value.XDB,&pt->Value.XDB,sizeof(pt->Value.XDB)) == 0) return(TRUE) ;
		break ;
	   CASEofCharmU
	   case V4DPI_PntType_FrgnDataEl: case V4DPI_PntType_FrgnStructEl:
/*		If single string, convert to upper case & search entire string */
		if (inpt->Grouping == V4DPI_Grouping_Single || inpt->Grouping > V4DPI_Grouping_MaxMix)
		 { v4im_GetPointChar(&ok,ASCTBUF1,V4TMBufMax,pt,ctx) ;
		   if (ok) v4im_GetPointChar(&ok,(char *)UCTBUF2,V4TMBufMax,inpt,ctx) ;
		   if (!ok) { v_Msg(ctx,NULL,"ModFailed2",intmodx) ; return(-999) ; } ;
//		   for(b=ASCTBUF1;*b!=0;b++) { *b = toupper(*b) ; } ; for(b=(char *)UCTBUF2;*b!=0;b++) { *b = toupper(*b) ; } ;
		   i = strcmp(ASCTBUF1,(char *)UCTBUF2) ;
		   switch (inpt->Grouping)
		    { case V4DPI_Grouping_Single:	return(i == 0) ;
		      case V4DPI_Grouping_GT:		return(i > 0) ;
		      case V4DPI_Grouping_GE:		return(i >= 0) ;
		      case V4DPI_Grouping_LT:		return(i < 0) ;
		      case V4DPI_Grouping_LE:		return(i <= 0) ;
		      case V4DPI_Grouping_NE:		return(i != 0) ;
		    } ;
		 } ;
/*		If multiple strings, then check for multiple exact matches */
		pam = (struct V4DPI__Point_AlphaMix *)&inpt->Value ;
		v4im_GetPointChar(&ok,ASCTBUF1,V4TMBufMax,pt,ctx) ; tbuf = (char *)&pam->Entry[inpt->Grouping].BeginIndex ;
		if (!ok) { v_Msg(ctx,NULL,"ModFailed2",intmodx) ; return(-999) ; } ;
		for(i=0;i<inpt->Grouping;i++)
		 { if (pam->Entry[i].EndIndex == 0)
		    { if (strncmp(ASCTBUF1,tbuf+pam->Entry[i].BeginIndex+1,*(tbuf+pam->Entry[i].BeginIndex)) == 0)
		       return(TRUE) ;
		    } else
		    { if (strncmp(ASCTBUF1,tbuf+pam->Entry[i].BeginIndex+1,*(tbuf+pam->Entry[i].BeginIndex)) < 0)
		       break ;
		      if (strncmp(ASCTBUF1,tbuf+pam->Entry[i].EndIndex+1,*(tbuf+pam->Entry[i].EndIndex)) <= 0)
		       return(TRUE) ;
		    } ;
		 } ;
		break ;
	   case V4DPI_PntType_UCChar:
/*		If single string, convert to upper case & search entire string */
/*		If single string, convert to upper case & search entire string */
		if (inpt->Grouping == V4DPI_Grouping_Single || inpt->Grouping > V4DPI_Grouping_MaxMix)
		 { v4im_GetPointUC(&ok,UCTBUF1,V4TMBufMax,pt,ctx) ; if (ok) v4im_GetPointUC(&ok,UCTBUF2,V4TMBufMax,inpt,ctx) ;
		   if (!ok) { v_Msg(ctx,NULL,"ModFailed2",intmodx) ; return(-999) ; } ;
		   i = UCstrcmp(UCTBUF1,UCTBUF2) ;
		   switch (inpt->Grouping)
		    { case V4DPI_Grouping_Single:	return(i == 0) ;
		      case V4DPI_Grouping_GT:		return(i > 0) ;
		      case V4DPI_Grouping_GE:		return(i >= 0) ;
		      case V4DPI_Grouping_LT:		return(i < 0) ;
		      case V4DPI_Grouping_LE:		return(i <= 0) ;
		      case V4DPI_Grouping_NE:		return(i != 0) ;
		    } ;
		 } ;
/*		If multiple strings, then check for multiple exact matches */
		pam = (struct V4DPI__Point_AlphaMix *)&inpt->Value ;
		v4im_GetPointUC(&ok,UCTBUF1,V4TMBufMax,pt,ctx) ; utbuf = (UCCHAR *)&pam->Entry[inpt->Grouping].BeginIndex ;
		if (!ok) { v_Msg(ctx,NULL,"ModFailed2",intmodx) ; return(-999) ; } ;
		for(i=0;i<inpt->Grouping;i++)
		 { if (pam->Entry[i].EndIndex == 0)
		    { if (UCstrncmp(UCTBUF1,utbuf+pam->Entry[i].BeginIndex+1,*(utbuf+pam->Entry[i].BeginIndex)) == 0)
		       return(TRUE) ;
		    } else
		    { if (UCstrncmp(UCTBUF1,utbuf+pam->Entry[i].BeginIndex+1,*(utbuf+pam->Entry[i].BeginIndex)) < 0)
		       break ;
		      if (UCstrncmp(UCTBUF1,utbuf+pam->Entry[i].EndIndex+1,*(utbuf+pam->Entry[i].EndIndex)) <= 0)
		       return(TRUE) ;
		    } ;
		 } ;
		break ;
	 } ;
	return(FALSE) ;		/* If we have not yet returned TRUE then must be FALSE */
}

/*	v4im_DoList - Handles the List() intmod			*/

P *v4im_DoList(ctx,respnt,argpnts,argcnt,intmodx)
  struct V4C__Context *ctx ;
  P *respnt,*argpnts[] ;
  int argcnt,intmodx ;
{ P *ipt,*tpt,*cpt, *arg2,*awpt,*sumpt,*bgnpt,*evpt ;
  P pnt,pnt2,pnt3,pnt4, arg2buf ;
  P *v4im_ListSetHandler() ;
  struct V4L__ListPoint *lp,*lp1,*lp2 ;
  struct V4DPI__DimInfo *di ;
  struct V4L__ListCmpndRange *lcr ;
  struct V4L__ListCmpndRangeDBL *lcrd ;
  struct V4L__ListIsct *lisct ;
  struct V4IM__SetPoint *vsp ;
  struct V4DPI__Point_IntMix *pim ;
  struct V4DPI__Point_AlphaMix *pam ;
  struct V4DPI__Point_RealMix *prm ;
  struct V4L__ListV4IS *lv4 ;
  struct V4L__ListTextTable *ltt ;
  struct V4L__ListMultiAppend *vlma ;
  struct V4DPI__PntV4IS *pis ;
  struct V4IS__V4Areas *v4a ;
  struct V4V4IS__StructEl *stel ;
  struct V4V4IS__RuntimeList *rtl ;
  int indexes[20] ; int frameid ;
  int isdbl,i,j,k,pix,num,ix,rx,sx,fx,tag,isPntIdx,index,sdim,argnum,firstsum,every,ok,columns,resdim ; double byval,d1,d2,d3 ;
  INDEX numVal = V4LIM_BiggestPositiveInt ;
  UCCHAR AreaName[V_FileName_Max], TableName[100], cdel[32] ; char *bp ;

	frameid = UNUSED ;
/*	Hardest part of this module is determining what the user wants */
	ipt = argpnts[1] ;
	if (ipt->PntType == V4DPI_PntType_V4IS)			/* Making list out of V4IS Area? */
	 { tpt = respnt ;
	   DIMINFO(di,ctx,Dim_List) ;
	   ZPH(tpt) ; tpt->Dim = di->DimId ; tpt->PntType = di->PointType ;
	   tpt->Bytes = V4DPI_PointHdr_Bytes + sizeof(*pis) ;
	   lp = ALIGNLP(&tpt->Value) ; memset(lp,0,V4L_ListPointHdr_Bytes) ;
	   lp->ListType = V4L_ListType_V4IS ; lp->PntType = ipt->PntType ; lp->Dim = ipt->Dim ;
	   lv4 = (struct V4L__ListV4IS *)&lp->Buffer[0] ;
	   pis = (struct V4DPI__PntV4IS *)&ipt->Value ;	/* Link up to V4IS info */
	   v4a = gpi->v4a ;				/* Pull v4a from process info */
	   if (v4a == NULL) { v_Msg(ctx,NULL,"V4ISNoArea",intmodx) ; goto list_fail ; } ;
	   for(i=0;i<v4a->Count;i++) { if (pis->Handle == v4a->Area[i].Handle) break ; } ;
	   if (i >= v4a->Count)				/* Could not find area? */
	    { v_Msg(ctx,NULL,"V4ISNoArea",intmodx) ; goto list_fail ; } ;
	   lv4->Handle = pis->Handle ; lv4->SubIndex = UNUSED ; lv4->CountOffset = UNUSED ; lv4->CountBytes = UNUSED ;
	   lv4->Sample = UNUSED ; lv4->Number = UNUSED ; lv4->Ifpix = UNUSED ; lv4->Subpix = UNUSED ; lv4->KeyNum = 0 ;
	   lv4->Whilepix = UNUSED ; lv4->Firstpix = UNUSED ;
	   for (ok=TRUE,ix=2;ok&&ix<=argcnt;ix++)
	    { 
	      switch (v4im_CheckPtArgNew(ctx,argpnts[ix],&arg2,&arg2buf))
	    { default:			v_Msg(ctx,NULL,"TagBadUse",intmodx) ; goto list_fail ;
	      case V4IM_Tag_Unk:	v_Msg(ctx,NULL,"TagUnknown",intmodx) ; goto list_fail ;
		 case V4IM_Tag_If:
			pix = v4dpi_PntIdx_AllocPnt() ;		/* Allocate another point for actual Isct */
			cpt = v4dpi_PntIdx_CvtIdxPtr(pix) ; memcpy(cpt,arg2,arg2->Bytes) ;
			*(lv4->Ifpix == UNUSED ? &lv4->Ifpix : &lv4->Subpix) = pix ;
			break ;
		 case V4IM_Tag_While:
			pix = v4dpi_PntIdx_AllocPnt() ;		/* Allocate another point for actual Isct */
			cpt = v4dpi_PntIdx_CvtIdxPtr(pix) ; memcpy(cpt,arg2,arg2->Bytes) ;
			lv4->Whilepix = pix ;
			break ;
		 case V4IM_Tag_First:
			pix = v4dpi_PntIdx_AllocPnt() ;		/* Allocate another point for actual Isct */
			cpt = v4dpi_PntIdx_CvtIdxPtr(pix) ; memcpy(cpt,arg2,arg2->Bytes) ;
			lv4->Firstpix = pix ;
			break ;
		 case V4IM_Tag_Sample:		lv4->Sample = v4im_GetPointInt(&ok,arg2,ctx) ; break ;
		 case V4IM_Tag_Number:		lv4->Number = v4im_GetPointInt(&ok,arg2,ctx) ; break ;
		 case V4IM_Tag_Count:		/* Have to do some work to get field offset & bytes */
			index = v4im_GetPointInt(&ok,arg2,ctx) ;
			if (index < 1) 
			 { v_Msg(ctx,NULL,"ModArgVal",intmodx,ix,argpnts[ix],0) ; goto list_fail ;
			 } ;
			if (gpi->rtl == NULL) v4v4is_LoadFileRef(ctx,v4a->Area[i].FileRef) ;
			rtl = gpi->rtl ;
			for(rx=0;rx<rtl->Count;rx++) { if (rtl->FileRefs[rx] == v4a->Area[i].FileRef) break ; } ;
			if (rx < rtl->Count) { stel = rtl->stel[rx] ; }
			 else { stel = (struct V4V4IS__StructEl *)v4v4is_LoadFileRef(ctx,v4a->Area[i].FileRef) ;
				if (stel == NULL)
				 { v_Msg(ctx,NULL,"V4ISStructEl",intmodx,v4a->Area[i].FileRef) ; goto list_fail ;	/* Can't find Struct/El info? */
				 } ;
			      } ;
			for(fx=index-1;fx<stel->Count;fx++)		/* Now look for the element - make guess at starting point */
			 { if (stel->Field[fx].Index == index) break ; } ;
			if (fx >= stel->Count)				/* That didn't work, try from begin */
			 { for(fx=0;fx<stel->Count;fx++)			/* Now look for the element */
			    { if (stel->Field[fx].Index == index) break ; } ;
			   if (fx >= stel->Count)
			    { v_Msg(ctx,NULL,"V4ISNoFldIndex",intmodx,index,v4a->Area[i].FileRef) ; goto list_fail ; } ;
			 } ;
			if (stel->Field[fx].StructNum > 0)
			 { v_Msg(ctx,NULL,"V4ISNestEl",intmodx) ; goto list_fail ; } ;
			lv4->CountOffset = stel->Field[fx].Offset ; lv4->CountBytes = stel->Field[fx].Bytes ;
			break ;
		 case V4IM_Tag_Length:		lv4->CountBytes = v4im_GetPointInt(&ok,arg2,ctx) ; break ;
		 case V4IM_Tag_KeyNum:		lv4->KeyNum = v4im_GetPointInt(&ok,arg2,ctx) ; break ;
	       } ; if (!ok) { v_Msg(ctx,NULL,"ModInvArg",intmodx,ix-1) ; goto list_fail ; } ;
	    } ;
	   if (lv4->CountOffset != UNUSED && lv4->CountBytes == UNUSED) lv4->CountBytes = sizeof(int) ;
	   return(respnt) ;
	 } ;
	if (ipt->PntType == V4DPI_PntType_TagVal)			/* First argument a tag? */
	 { switch (v4im_CheckPtArgNew(ctx,ipt,&arg2,&arg2buf))
	    { default:			v_Msg(ctx,NULL,"TagBadUse",intmodx) ; goto list_fail ;
	      case V4IM_Tag_Unk:	v_Msg(ctx,NULL,"TagUnknown",intmodx) ; goto list_fail ;
	      case V4IM_Tag_Area:
		if (gpi->RestrictionMap & V_Restrict_FileRead) { v_Msg(ctx,NULL,"RestrictMod",intmodx) ; goto list_fail ; } ;
		v4im_GetPointFileName(&ok,AreaName,UCsizeof(AreaName),arg2,ctx,NULL) ; if (!ok) break ;
		ipt = (P *)v4im_Init_ltf(ctx,intmodx,respnt,NULL,AreaName,Dim_Alpha,0) ;
		if (ipt == NULL) goto list_fail ;
		return(ipt) ;

	      case V4IM_Tag_Bits:
		INITLP(respnt,lp,Dim_List) ; intPNTv(&pnt,0) ;
/*		Dimension is that of Bits::xxx argument iff it is of type Int */
		pnt.Dim = (arg2->PntType == V4DPI_PntType_Int ? arg2->Dim : Dim_Int) ;
		num =  v4im_GetPointInt(&ok,arg2,ctx) ;
	        if (!ok) { v_Msg(ctx,NULL,"ModInvArg",intmodx,2) ; goto list_fail ; } ;
		for(i=1;i!=0&&num!=0;i<<=1)
		 { pnt.Value.IntVal++ ;
		   if ((num & i) == 0) continue ;
		   if (!v4l_ListPoint_Modify(ctx,lp,V4L_ListAction_Append,&pnt,0)) { v_Msg(ctx,NULL,"LPModFail",intmodx) ; goto list_fail ; } ; num &= ~i ;
		 } ;
		ENDLP(respnt,lp) ; return(respnt) ;
	      case V4IM_Tag_To:
		DIMINFO(di,ctx,Dim_List) ;
		tpt = respnt ;
		ZPH(tpt) ; lp = ALIGNLP(&tpt->Value) ; memset(lp,0,V4L_ListPointHdr_Bytes) ;
		lp->ListType = V4L_ListType_CmpndRange ; lp->PntType = arg2->PntType ;
		lp->Dim = arg2->Dim ;
		lcr = (struct V4L__ListCmpndRange *)&lp->Buffer[0] ; lcr->Entries = 0 ; lcr->Count = 0 ;
		tpt->PntType = di->PointType ; tpt->Dim = di->DimId ;
		lcr->Cmpnd[lcr->Count].Begin = 1 ; lcr->Cmpnd[lcr->Count].End = v4im_GetPointInt(&ok,arg2,ctx) ;
	        if (!ok) { v_Msg(ctx,NULL,"ModInvArg",intmodx,2) ; goto list_fail ; } ;
		lcr->Cmpnd[lcr->Count].Increment = 1 ; lcr->Entries = 1 ; lcr->Count++ ;
		goto lcr_setup ;
	      case -V4IM_Tag_Union:
	      case -V4IM_Tag_XUnion:
	      case -V4IM_Tag_Subtract:
	      case -V4IM_Tag_Intersect:
		return(v4im_ListSetHandler(ctx,respnt,argpnts,argcnt,intmodx,0)) ;
	    } ;
	 } ;
	if (ipt->PntType == V4DPI_PntType_BigText)	/* If BigText then return list of lines */
	 { 
	   char tbuf[V4LEX_BigText_Max], *b1,*b2 ;
	   v4im_GetPointChar(&ok,tbuf,sizeof tbuf,ipt,ctx) ;
	   INITLP(respnt,lp1,Dim_List) ; alphaPNT(&pnt) ;
	   for(b1=tbuf,j=1;;j++)
	    { b2 = strchr(b1,EOLbt) ; if (b2 != NULL) *b2 = '\0' ;
	      i = strlen(b1) ;
	      if (i >= V4DPI_AlphaVal_Max)
	       { v_Msg(ctx,NULL,"BigTextLineTL",intmodx,j,i,V4DPI_AlphaVal_Max,V4DPI_PntType_Char) ; goto list_fail ; } ;
	      strcpy(&pnt.Value.AlphaVal[1],b1) ;
	      CHARPNTBYTES2(&pnt,i)
	      if (!v4l_ListPoint_Modify(ctx,lp1,V4L_ListAction_Append,&pnt,0)) { v_Msg(ctx,NULL,"LPModFail",intmodx) ; goto list_fail ; } ;
	      if (b2 == NULL) break ; b1 = b2 + 1 ;
	    } ;
	   ENDLP(respnt,lp1)
	   return(respnt) ;
	 } ;
/*	O N L Y   1   A R G U M E N T   -   C O N V E R T   T O   L I S T	*/
	if (argcnt == 1)
	 { if (ipt->Dim == Dim_Dim || ipt->PntType == V4DPI_PntType_XDB)	/* Is this a point on Dim or ODBC dimension ? */
	    { i = Dim_List ;
	      tpt = respnt ;
	      ipt = v4dpi_DimUniqueToList(tpt,ctx,ipt->Value.IntVal,i,ipt,TRUE) ;
	      if (ipt == NULL) { v_Msg(ctx,NULL,"ModInvArg",intmodx,1) ; goto list_fail ; } ;
	      return(ipt) ;
	    } ;
	   switch (ipt->PntType)
	    { default:
		DIMINFO(di,ctx,Dim_List) ;
		pim = (struct V4DPI__Point_IntMix *)&ipt->Value ;
		tpt = respnt ;
		ZPH(tpt) ; lp = ALIGNLP(&tpt->Value) ; memset(lp,0,V4L_ListPointHdr_Bytes) ;
		lp->ListType = V4L_ListType_CmpndRange ; lp->PntType = ipt->PntType ; lp->Dim = ipt->Dim ;
		lcr = (struct V4L__ListCmpndRange *)&lp->Buffer[0] ; lcr->Entries = 0 ; lcr->Count = 0 ;
		tpt->PntType = di->PointType ; tpt->Dim = di->DimId ;
/*		Have a list or range or whatever - do it */
		if (ipt->Grouping == 0)				/* Just a single value in point? */
		 { lcr->Cmpnd[lcr->Count].Begin = ipt->Value.IntVal ; lcr->Cmpnd[lcr->Count].End = ipt->Value.IntVal ;
		   lcr->Cmpnd[lcr->Count].Increment = 1 ; lcr->Entries = 1 ; lcr->Count++ ;
		 } else
		 { for(i=0;i<ipt->Grouping;i++)
		    { lcr->Cmpnd[lcr->Count].Begin = pim->Entry[i].BeginInt ; lcr->Cmpnd[lcr->Count].End = pim->Entry[i].EndInt ;
		      lcr->Cmpnd[lcr->Count++].Increment = 1 ;
		      lcr->Entries += (1 + pim->Entry[i].EndInt - pim->Entry[i].BeginInt) ;
		    } ;
		 } ; goto lcr_setup ;
	      CASEofCharmU
		tpt = respnt ; ZPH(tpt) ; INITLP(tpt,lp,Dim_List)
		if (ipt->Grouping == V4DPI_Grouping_Single)
		 { if (!v4l_ListPoint_Modify(ctx,lp,V4L_ListAction_Append,ipt,0)) { v_Msg(ctx,NULL,"LPModFail",intmodx) ; goto list_fail ; } ;
		 } else
		 { pam = (struct V4DPI__Point_AlphaMix *)&ipt->Value.AlphaVal ;
		   bp = (char *)&pam->Entry[ipt->Grouping].BeginIndex ; alphaPNT(&pnt) ;
		   for(i=0;i<ipt->Grouping;i++)
		    { if (pam->Entry[i].EndIndex == 0)
		       { strncpy(&pnt.Value.AlphaVal[1],bp+pam->Entry[i].BeginIndex+1,*(bp+pam->Entry[i].BeginIndex)) ;
		       } ;
		       CHARPNTBYTES1(&pnt) ; if (!v4l_ListPoint_Modify(ctx,lp,V4L_ListAction_Append,&pnt,0)) { v_Msg(ctx,NULL,"LPModFail",intmodx) ; goto list_fail ; } ;
		    } ;
		 } ;
		ENDLP(tpt,lp)
		return(tpt) ;
	      case V4DPI_PntType_UCChar:
		tpt = respnt ; ZPH(tpt) ; INITLP(tpt,lp,Dim_List)
		if (ipt->Grouping == V4DPI_Grouping_Single)
		 { if (!v4l_ListPoint_Modify(ctx,lp,V4L_ListAction_Append,ipt,0)) { v_Msg(ctx,NULL,"LPModFail",intmodx) ; goto list_fail ; } ;
		 } else
		 { UCCHAR *bp ;
		   pam = (struct V4DPI__Point_AlphaMix *)&ipt->Value.AlphaVal ;
		   bp = (UCCHAR *)&pam->Entry[ipt->Grouping].BeginIndex ; uccharPNT(&pnt) ;
		   for(i=0;i<ipt->Grouping;i++)
		    { if (pam->Entry[i].EndIndex == 0)
		       { UCstrncpy(&pnt.Value.UCVal[1],bp+pam->Entry[i].BeginIndex+1,*(bp+pam->Entry[i].BeginIndex)) ;
		       } ;
		       UCCHARPNTBYTES1(&pnt) ; if (!v4l_ListPoint_Modify(ctx,lp,V4L_ListAction_Append,&pnt,0)) { v_Msg(ctx,NULL,"LPModFail",intmodx) ; goto list_fail ; } ;
		    } ;
		 } ;
		ENDLP(tpt,lp)
		return(tpt) ;
	      case V4DPI_PntType_Calendar:
	      case V4DPI_PntType_Real:
		DIMINFO(di,ctx,Dim_List) ;
		prm = (struct V4DPI__Point_RealMix *)&ipt->Value ;
		tpt = respnt ;
		ZPH(tpt) ; lp = ALIGNLP(&tpt->Value) ; memset(lp,0,V4L_ListPointHdr_Bytes) ;
		lp->ListType = V4L_ListType_CmpndRangeDBL ; lp->PntType = ipt->PntType ; lp->Dim = ipt->Dim ;
		lcrd = (struct V4L__ListCmpndRangeDBL *)&lp->Buffer[0] ; lcrd->Entries = 0 ; lcrd->Count = 0 ;
		tpt->PntType = di->PointType ; tpt->Dim = di->DimId ;
/*		Have a list or range or whatever - do it */
		if (ipt->Grouping == 0)				/* Just a single value in point? */
		 { GETREAL(lcrd->Cmpnd[lcrd->Count].Begin,ipt) ;
		   GETREAL(lcrd->Cmpnd[lcrd->Count].End,ipt) ;
		   lcrd->Cmpnd[lcrd->Count].Increment = 1 ; lcrd->Entries = 1 ; lcrd->Count++ ;
		 } else
		 { for(i=0;i<ipt->Grouping;i++)
		    { memcpy(&d1,&prm->Entry[i].BeginReal,sizeof(double)) ;
		      memcpy(&lcrd->Cmpnd[lcrd->Count].Begin,&d1,sizeof(double)) ;
		      memcpy(&d2,&prm->Entry[i].EndReal,sizeof(double)) ;
		      memcpy(&lcrd->Cmpnd[lcrd->Count].End,&d2,sizeof(double)) ;
		      lcrd->Cmpnd[lcrd->Count++].Increment = 1 ;
		      lcrd->Entries += (int)(1 + d2 - d1) ;
		    } ;
		 } ;
		lcrd->Bytes = (char *)&lcrd->Cmpnd[lcrd->Count] - (char *)lcrd ;
		lp->Entries = lcrd->Entries ; lp->Bytes = (char *)&lp->Buffer[ALIGN(lcrd->Bytes)] - (char *)lp ;
		tpt->Bytes = (char *)&tpt->Value.AlphaVal[lp->Bytes] - (char *)tpt ;
		if (tpt->Bytes < V4DPI_PointHdr_Bytes + ((char *)&lp->Buffer[0] - (char *)lp))
	 	 tpt->Bytes = V4DPI_PointHdr_Bytes + ((char *)&lp->Buffer[0] - (char *)lp) ;	/* Make sure min size */
		return(tpt) ;
	      case V4DPI_PntType_List:
		memcpy(respnt,ipt,ipt->Bytes) ; return(respnt) ;	/* Just return list */
	      case V4DPI_PntType_Isct:
		DIMINFO(di,ctx,Dim_List) ;
		tpt = respnt ;
		ZPH(tpt) ; lp = ALIGNLP(&tpt->Value) ; memset(lp,0,V4L_ListPointHdr_Bytes) ;
		tpt->PntType = di->PointType ; tpt->Dim = di->DimId ;
		lp->ListType = V4L_ListType_Isct ; lp->Dim = ipt->Dim ;
		lisct = (struct V4L__ListIsct *)&lp->Buffer[0] ;
		lisct->pix = v4dpi_PntIdx_AllocPnt() ;		/* Allocate another point for actual Isct */
		cpt = v4dpi_PntIdx_CvtIdxPtr(lisct->pix) ;
		memcpy(cpt,ipt,ipt->Bytes) ;
		lp->Bytes = (char *)&lp->Buffer[ALIGN(sizeof *lisct)] - (char *)lp ;
		tpt->Bytes = (char *)&tpt->Value.AlphaVal[lp->Bytes] - (char *)tpt ;
		if (tpt->Bytes < V4DPI_PointHdr_Bytes + ((char *)&lp->Buffer[0] - (char *)lp))
	 	 tpt->Bytes = V4DPI_PointHdr_Bytes + ((char *)&lp->Buffer[0] - (char *)lp) ;	/* Make sure min size */
		return(tpt) ;
	    } ;
	 } ;
/*	M U L T I  -  A R G ,   1 S T   A R G   *N O T*   A   L I S T		*/
	if (isPntIdx = (ipt->PntType == V4DPI_PntType_PntIdx))
	 argpnts[1] = (ipt = v4dpi_PntIdx_CvtIdxPtr(ipt->Value.IntVal)) ;
	switch (ipt->PntType)
	 { case V4DPI_PntType_List:	goto first_arg_list ;
	   default:			if (v4im_CouldBeList(ctx,ipt)) goto first_arg_list ;
	 } ;
	for (ix=2;ix<=argcnt && ipt->PntType != V4DPI_PntType_List;ix++)
	 { 
	   ok = TRUE ;
	   if (ix == 2)			/* Init byval, etc. */
	    { lcr = NULL ; byval = 1.0 ; d1 = 0.0 ; d2 = 0.0 ; d3 = 0.0 ; isdbl = FALSE ; ZUS(AreaName) ; ZUS(TableName) ;
	      switch(argpnts[1]->PntType)
	       { case V4DPI_PntType_Calendar:
	         case V4DPI_PntType_Real:	isdbl = TRUE ; d1 = v4im_GetPointDbl(&ok,argpnts[1],ctx) ; break ;
	         CASEofINT			isdbl = FALSE ; d1 = v4im_GetPointDbl(&ok,argpnts[1],ctx) ; break ;
		 case V4DPI_PntType_Color:	break ;
		 case V4DPI_PntType_Country:	break ;
		 case V4DPI_PntType_XDict:	break ;
		 case V4DPI_PntType_Dict:	break ;
		 default: v_Msg(ctx,NULL,"ModArgPntType",intmodx,1,argpnts[1],argpnts[1]->PntType) ; goto list_fail ;
	       } ; if (!ok) { v_Msg(ctx,NULL,"ModInvArg",intmodx,1) ; goto list_fail ; } ;
	    } ;
	   switch (v4im_CheckPtArgNew(ctx,argpnts[ix],&arg2,&arg2buf))
	    { default:			goto first_arg_list ;		/* Try to force first arg to list & handle there */
	      case V4IM_Tag_Unk:	v_Msg(ctx,NULL,"TagUnknown",intmodx) ; goto list_fail ;
	      case V4IM_Tag_Area:
		if (gpi->RestrictionMap & V_Restrict_FileRead) { v_Msg(ctx,NULL,"RestrictMod",intmodx) ; goto list_fail ; } ;
	        v4im_GetPointFileName(&ok,AreaName,UCsizeof(AreaName),arg2,ctx,NULL) ; break ;
	      case V4IM_Tag_Table:
		if (gpi->RestrictionMap & V_Restrict_FileRead) { v_Msg(ctx,NULL,"RestrictMod",intmodx) ; goto list_fail ; } ;
	        v4im_GetPointUC(&ok,TableName,UCsizeof(TableName),arg2,ctx) ; break ;
	      case V4IM_Tag_By:
		isdbl |= arg2->PntType == V4DPI_PntType_Real ; byval = v4im_GetPointDbl(&ok,arg2,ctx) ;
		break ;
	      case V4IM_Tag_To:
		isdbl |= arg2->PntType == V4DPI_PntType_Real ; d2 = v4im_GetPointDbl(&ok,arg2,ctx) ;
		break ;
	      case V4IM_Tag_Number:
		isdbl |= arg2->PntType == V4DPI_PntType_Real ; d3 = v4im_GetPointDbl(&ok,arg2,ctx) ;
		break ;
	    } ;
	   if (!ok) { v_Msg(ctx,NULL,"ModInvArg",intmodx,ix-1) ; goto list_fail ; } ;
	   if (ix < argcnt) continue ;
	   if (UCstrlen(TableName) > 0)
	    { sdim = Dim_List ;
	      ISVALIDDIM(argpnts[1]->Value.IntVal,1,"List()") ;
	      DIMINFO(di,ctx,argpnts[1]->Value.IntVal) ;
	      ZPH(respnt) ; INITLP(respnt,lp,sdim) ltt = (struct V4L__ListTextTable *)&lp->Buffer[0] ;
	      lp->ListType = V4L_ListType_TextTable ;
	      { struct V4LEX__Table *zzz ; 
	        for(zzz=gpi->vlt;zzz!=NULL;zzz=zzz->link)
	         { if (UCstrcmpIC(zzz->Name,TableName) == 0) break ; } ;
	        if (zzz == NULL) { v_Msg(ctx,NULL,"TblUnknown",intmodx,TableName) ; goto list_fail ; } ;
	        COPYPTR(ltt->vlt,zzz) ;
	      }
	      for(i=0;i<V4C_AreaAgg_Max;i++) { if (gpi->TextAgg[i].vlt == NULL) break ; } ;
	      if (i >= V4C_AreaAgg_Max)
	       { v_Msg(ctx,NULL,"ListMaxTextAgg",intmodx,V4C_AreaAgg_Max) ; goto list_fail ; } ;
	      ltt->TextAggIndex = i ;
	      if (!v_UCFileOpen(&ltt->UCFile,AreaName,UCFile_Open_Read,TRUE,ctx->ErrorMsgAux,intmodx))
	       { v_Msg(ctx,NULL,"ModFailed2",intmodx) ; goto list_fail ; } ;
	      ltt->Dim = argpnts[1]->Value.IntVal ; ltt->Count = 0 ; ltt->ActCount = 0 ;
	      ltt->line = v4mm_AllocUC(V4LEX_Tkn_InpLineMax) ;	/* Allocate input buffer */
	      ENDLP(respnt,lp) ; respnt->Dim = sdim ;
	      gpi->TextAgg[ltt->TextAggIndex].line = ltt->line ;
	      COPYPTR(gpi->TextAgg[ltt->TextAggIndex].vlt,ltt->vlt) ;
	      gpi->TextAgg[ltt->TextAggIndex].Count = ltt->Count ;
	      return(respnt) ;
	    } ;
	   DIMINFO(di,ctx,Dim_List) ;
	   tpt = respnt ;
	   lp = ALIGNLP(&tpt->Value) ; memset(lp,0,V4L_ListPointHdr_Bytes) ;	/* Link up list structure */
/*	   Got d1 (start) & maybe d2(end), d3(increment), figure out what to do based on this & isdbl */
	   if (isdbl)
	    {
	      lp->ListType = V4L_ListType_CmpndRangeDBL ; lp->PntType = V4DPI_PntType_Real ;
	      if (argpnts[1]->PntType == V4DPI_PntType_Real || argpnts[1]->PntType == V4DPI_PntType_Calendar)
	       { lp->Dim = argpnts[1]->Dim ; }
	       else { lp->Dim = Dim_Num ; } ;
	      lcrd = (struct V4L__ListCmpndRangeDBL *)&lp->Buffer[0] ; lcrd->Entries = 0 ; lcrd->Count = 0 ;
	      tpt->PntType = di->PointType ; tpt->Dim = di->DimId ;
	      memcpy(&lcrd->Cmpnd[lcrd->Count].Begin,&d1,sizeof d1) ; memcpy(&lcrd->Cmpnd[lcrd->Count].Increment,&byval,sizeof d1) ;
	      if (d3 != 0) d2 = d1 + (d3-1)*byval ;
	      memcpy(&lcrd->Cmpnd[lcrd->Count++].End,&d2,sizeof d2) ;
	      lcrd->Entries = (int)(1 + (lcrd->Cmpnd[0].End - lcrd->Cmpnd[0].Begin) / lcrd->Cmpnd[0].Increment) ;
	      lcrd->Bytes = (char *)&lcrd->Cmpnd[lcrd->Count] - (char *)lcrd ;
	      lp->Entries = lcrd->Entries ; lp->Bytes = (char *)&lp->Buffer[ALIGN(lcrd->Bytes)] - (char *)lp ;
	      tpt->Bytes = (char *)&tpt->Value.AlphaVal[lp->Bytes] - (char *)tpt ;
	      if (tpt->Bytes < V4DPI_PointHdr_Bytes + ((char *)&lp->Buffer[0] - (char *)lp))
	      tpt->Bytes = V4DPI_PointHdr_Bytes + ((char *)&lp->Buffer[0] - (char *)lp) ;	/* Make sure min size */
	      return(tpt) ;
	    } else
	    { 
	      lp->ListType = V4L_ListType_CmpndRange ; lp->PntType = argpnts[1]->PntType ;
	      lp->Dim = argpnts[1]->Dim ;
	      lcr = (struct V4L__ListCmpndRange *)&lp->Buffer[0] ; lcr->Entries = 0 ; lcr->Count = 0 ;
	      tpt->PntType = di->PointType ; tpt->Dim = di->DimId ;
	      lcr->Cmpnd[lcr->Count].Begin = (int)d1 ; lcr->Cmpnd[lcr->Count].Increment = (int)byval ;
	      if (d3 != 0) d2 = d1 + (d3-1)*byval ;
	      lcr->Cmpnd[lcr->Count++].End = (int)d2 ;
	      lcr->Entries = 1 + (lcr->Cmpnd[0].End - lcr->Cmpnd[0].Begin) / lcr->Cmpnd[0].Increment ;
	      goto lcr_setup ;
	    } ;
	 } ;
/*	M U L T I  -  A R G ,  1 S T   A R G   *I S*   A   L I S T	*/
first_arg_list:
	resdim = ipt->Dim ;					/* Save dimension for result */
	lp = v4im_VerifyList(NULL,ctx,ipt,intmodx) ;			/* First argument is a list, check second */
	if (lp == NULL) { v_Msg(ctx,NULL,"ModInvArgList",intmodx,1) ; goto list_fail ; } ;
	sdim = 0 ; argnum = 2 ;
	awpt = NULL ; sumpt = NULL ; bgnpt = NULL ; evpt = NULL ; every = UNUSED ;
next_arg:
	if (argnum > argcnt)					/* End of arguments? */
	 { if (evpt != NULL)					/* Maybe handle Every::nnn */
	    {
		if (bgnpt == NULL) { num = 0 ; }		/* Have an initializing point? */
		 else { num = v4im_GetPointInt(&ok,bgnpt,ctx) ;
			if (!ok) { v_Msg(ctx,NULL,"ModInvArg2",intmodx,bgnpt) ; goto list_fail ; } ;
		      } ;
		if (every <= 0) { v_Msg(ctx,NULL,"ListEveryArg",intmodx,V4IM_Tag_Every,every) ; goto list_fail ; } ;
		if (num >= every) num = num % every ;		/* If start already bigger then adjust down */
		frameid = v4ctx_FramePush(ctx,NULL) ;		/* Start new context frame */
		INITLP(respnt,lp1,resdim)
		for(i=1;v4l_ListPoint_Value(ctx,lp,i,&pnt) > 0;i++)	/* Loop thru each point in list */
		 { if (pnt.PntType == V4DPI_PntType_Isct)		/* If an ISCT then evaluate it */
		    { ipt = v4dpi_IsctEval(&pnt2,&pnt,ctx,V4DPI_EM_EvalQuote,NULL,NULL) ; }
		    else { ipt = &pnt ; } ;
		   if (!v4ctx_FrameAddDim(ctx,0,ipt,0,0)) { v_Msg(ctx,NULL,"CtxAddFail") ; goto list_fail ; } ;
		   if (sdim != 0)
		    { if (!v4ctx_FrameAddDim(ctx,0,ipt,sdim,0)) { v_Msg(ctx,NULL,"CtxAddFail") ; goto list_fail ; } ; } ;
		   CLEARCACHE
		   if (sumpt == NULL) { num += 1 ; }
		    else { if (sumpt->PntType != V4DPI_PntType_Isct) { num += v4im_GetPointInt(&ok,sumpt,ctx) ; }
			    else { tpt = v4dpi_IsctEval(&pnt3,sumpt,ctx,V4DPI_EM_EvalQuote,NULL,NULL) ;
				   ok = FALSE ; if (tpt != NULL) num += v4im_GetPointInt(&ok,tpt,ctx) ;
				 } ;
			   if (!ok) { v_Msg(ctx,NULL,"ModInvArg2",intmodx,sumpt) ; goto list_fail ; } ;

			 } ;
		   for(;num>=every;num-=every)			/* Have we made it to next "every" */
		    {						/* Note: may append point more than once if multiple every's */
		      if (!v4l_ListPoint_Modify(ctx,lp1,V4L_ListAction_Append,ipt,0)) { v_Msg(ctx,NULL,"LPModFail",intmodx) ; goto list_fail ; } ;
		    } ;
		 } ;
		ENDLP(respnt,lp1)
		if (!v4ctx_FramePop(ctx,frameid,NULL)) { v_Msg(ctx,NULL,"ModCtxPopFrame",intmodx,frameid) ; goto list_fail ; } ;			/* Pop off frame context */
		goto return_respnt ;
	    } ;
	   return(NULL) ;
	 } ;
	switch (tag=v4im_CheckPtArgNew(ctx,argpnts[argnum++],&arg2,&arg2buf))
	 { default:			v_Msg(ctx,NULL,"TagBadUse",intmodx) ; goto list_fail ;
	   case V4IM_Tag_Unk:		v_Msg(ctx,NULL,"TagUnknown",intmodx) ; goto list_fail ;
	   case V4IM_Tag_Union:
	   case V4IM_Tag_XUnion:
	   case V4IM_Tag_Subtract:
	   case V4IM_Tag_Intersect:
		if (lp->ListType == V4L_ListType_BitMap)	/* If all arguments are BitMaps then do special here */
		 { P *bm1, *bm2 ;
		   for(i=2;i<=argcnt;i++)
		    { v4im_CheckPtArgNew(ctx,argpnts[i],&arg2,&arg2buf) ;
		      lp = v4im_VerifyList(NULL,ctx,arg2,intmodx) ;
		      if (lp->ListType != V4L_ListType_BitMap) goto not_bm ;
		    } ;
		   bm1 = argpnts[1] ; ok = TRUE ;
		   for(argnum=2;argnum<=argcnt;argnum++)
		    { if (memcmp(argpnts[argnum],&protoNone,V4PS_Int) == 0) continue ;	/* Don't format UV4:none point */
		      tag = v4im_CheckPtArgNew(ctx,argpnts[argnum],&arg2,&arg2buf) ;
		      if (memcmp(arg2,&protoNone,V4PS_Int) == 0) continue ;	/* Don't format UV4:none point */
		      lp = v4im_VerifyList(NULL,ctx,arg2,intmodx) ;
		      bm2 = arg2 ;
		      switch (tag)
		       { default:			goto not_bm ;
		         case V4IM_Tag_Union:		ok = v4l_BitMapOr(ctx,intmodx,respnt,bm1,bm2) ; break ;
		         case V4IM_Tag_XUnion:		goto not_bm ;
		         case V4IM_Tag_Subtract:	ok = v4l_BitMapMinus(ctx,intmodx,respnt,bm1,bm2) ; break ;
		         case V4IM_Tag_Intersect:	ok = v4l_BitMapAnd(ctx,intmodx,respnt,bm1,bm2) ; break ;
		       } ;
		      if (!ok) { v_Msg(ctx,NULL,"ModFailed2",intmodx) ; goto list_fail ; } ;
		      bm1 = respnt ;
		    } ;
		   goto return_respnt ;
		 } ;
not_bm:		vsp = (struct V4IM__SetPoint *)v4mm_AllocChunk(sizeof *vsp,TRUE) ;
		for(i=1;i<=argcnt;i++)
		 { if (i > 2)
		    { if (memcmp(argpnts[i],&protoNone,V4PS_Int) == 0) continue ;	/* Don't format UV4:none point */
		      tag=v4im_CheckPtArgNew(ctx,argpnts[i],&arg2,&arg2buf) ;
		    } ;
		   if (memcmp((i==1 ? argpnts[i]: arg2),&protoNone,V4PS_Int) == 0) continue ;	/* Don't format UV4:none point */
		   lp = v4im_VerifyList(NULL,ctx,(i==1 ? argpnts[i]: arg2),intmodx) ;
		   if (lp == NULL)
		    { v_Msg(ctx,NULL,"ModInvArgList2",intmodx,(i==1 ? argpnts[i] : arg2)) ; goto list_fail ; } ;
		   if (!v4im_SetPointLoad(ctx,vsp,lp,ipt->Dim))
		    { v_Msg(ctx,NULL,"ModFailed2",intmodx) ; goto list_fail ; } ;
		   if (i < 2) continue ;			/* Wait until we get at least two lists */
		   switch(tag)
		    { default:		v_Msg(ctx,NULL,"TagNotTag4",intmodx,i,argpnts[i],V4IM_Tag_Union,V4IM_Tag_XUnion,V4IM_Tag_Intersect,V4IM_Tag_Subtract) ; goto list_fail ;
		      case V4IM_Tag_Union:
			for(k=0;k<V4IM_SetPointMapMax;k++) { vsp->List[0].Map[k] |= vsp->List[vsp->ListCount-1].Map[k] ; } ; break ;
		      case V4IM_Tag_XUnion:
			for(k=0;k<V4IM_SetPointMapMax;k++) { vsp->List[0].Map[k] ^= vsp->List[vsp->ListCount-1].Map[k] ; } ; break ;
		      case V4IM_Tag_Subtract:
			for(k=0;k<V4IM_SetPointMapMax;k++) { vsp->List[0].Map[k] &= ~vsp->List[vsp->ListCount-1].Map[k] ; } ; break ;
		      case V4IM_Tag_Intersect:
			for(k=0;k<V4IM_SetPointMapMax;k++) { vsp->List[0].Map[k] &= vsp->List[vsp->ListCount-1].Map[k] ; } ; break ;
		    } ;
		   vsp->ListCount -- ;			/* We can get rid of last list since List[0] holds result */
		   memset(&vsp->List[vsp->ListCount].Map,0,sizeof vsp->List[vsp->ListCount].Map) ;
		 } ;
		ipt = (struct V4DPI__Point *)v4im_SetPointMakeList(ctx,respnt,vsp,0,TRUE) ; if (ipt == NULL) { v_Msg(ctx,NULL,"LPModFail",intmodx) ; goto list_fail ; } ;
		v4mm_FreeChunk(vsp) ;
		return(ipt) ;
	   case V4IM_Tag_Dim:
dim_entry:	for(i=1;v4l_ListPoint_Value(ctx,lp,i,&pnt) > 0;i++)	/* Loop thru each point in list */
		 { if (arg2->Value.IntVal == pnt.Dim)				/* Got a match on dimensions? */
		    { ipt = respnt ;
		      memcpy(ipt,&pnt,pnt.Bytes) ; return(ipt) ;
		    } ;
		 } ;
		v_Msg(ctx,NULL,"ListNoDim",intmodx,arg2->Value.IntVal,argpnts[1]) ; goto list_fail ;
	   case -V4IM_Tag_Evaluate:
		INITLP(respnt,lp1,resdim) ;
		for(i=1;v4l_ListPoint_Value(ctx,lp,i,&pnt) > 0;i++)	/* Loop thru each point in list */
		 { ipt = v4dpi_IsctEval(&pnt2,&pnt,ctx,V4DPI_EM_EvalQuote,NULL,NULL) ;
		   if (ipt == NULL) { v_Msg(ctx,NULL,"TagEvalFail",intmodx,tag,&pnt) ; goto list_fail ; } ;
		   if (!v4l_ListPoint_Modify(ctx,lp1,V4L_ListAction_Append,ipt,0)) { v_Msg(ctx,NULL,"LPModFail",intmodx) ; goto list_fail ; } ;
		 } ;
		ENDLP(respnt,lp1) ;
		goto return_respnt ;
	   case -V4IM_Tag_Hash64:
		{ B64INT b64 = v_Hash64b((char *)lp,lp->Bytes) ;
		  fixPNTv(respnt,b64) ;
		}
		return(respnt) ; ;
	   case V4IM_Tag_Key:
	   case V4IM_Tag_Key2:
		index = (tag == V4IM_Tag_Key ? 1 : 2) ;
		for(i=1;v4l_ListPoint_Value(ctx,lp,i,&pnt) > 0;i++)			/* Loop thru each point in list */
		 { if (pnt.PntType == V4DPI_PntType_List) { ipt = &pnt ; }
		    else { ipt = v4dpi_IsctEval(&pnt2,&pnt,ctx,V4DPI_EM_EvalQuote,NULL,NULL) ;
			   if (ipt == NULL) { v_Msg(ctx,NULL,"TagEvalFail",intmodx,tag,&pnt) ; goto list_fail ; } ;
			   if (ipt->PntType != V4DPI_PntType_List) continue ;
			 } ;
		   lp1 = ALIGNLP(&pnt.Value) ;
		   if (v4l_ListPoint_Value(ctx,lp1,index,&pnt2) <= 0) continue ;	/* Get key value */
/*		   if either arg2 or &pnt2 are strings then do string match */
		   if (arg2->PntType == V4DPI_PntType_Char || arg2->PntType == V4DPI_PntType_UCChar || pnt2.PntType == V4DPI_PntType_Char || pnt2.PntType == V4DPI_PntType_UCChar)
		    { v4im_GetPointUC(&ok,UCTBUF1,V4TMBufMax,arg2,ctx) ; v4im_GetPointUC(&ok,UCTBUF2,V4TMBufMax,&pnt2,ctx) ;
		      ok = (UCstrcmp(UCTBUF1,UCTBUF2) == 0) ;
		    } else
		    { ok = (memcmp(arg2,&pnt2,arg2->Bytes) == 0) ;
		    } ;
		   if (ok)				/* Got a match ? */
		    { if (SIZEofLIST(lp1) == 2)						/* What is length of this list? */
		       { if (v4l_ListPoint_Value(ctx,lp1,(index == 1 ? 2 : 1),&pnt2) <= 0) continue ;	/*  if 2 then return other entry in list (second if Key::xxx, first if Key2:xxx)  */
			 memcpy(respnt,&pnt2,pnt2.Bytes) ; goto return_respnt ;
		       } ;
		      memcpy(respnt,&pnt,pnt.Bytes) ; goto return_respnt ;			/*  otherwise return entire list */
		    } ;
		 } ;
		v_Msg(ctx,NULL,"ListNoKey",intmodx,arg2,argpnts[1]) ;
		return(NULL) ;
	   case V4IM_Tag_KeyNum:
		index = 1 ;
		for(i=1;v4l_ListPoint_Value(ctx,lp,i,&pnt) > 0;i++)			/* Loop thru each point in list */
		 { if (pnt.PntType == V4DPI_PntType_List) { ipt = &pnt ; }
		    else { ipt = v4dpi_IsctEval(&pnt2,&pnt,ctx,V4DPI_EM_EvalQuote,NULL,NULL) ;
			   if (ipt == NULL) { v_Msg(ctx,NULL,"TagEvalFail",intmodx,tag,&pnt) ; goto list_fail ; } ;
			   if (ipt->PntType != V4DPI_PntType_List) continue ;
			 } ;
		   lp1 = ALIGNLP(&pnt.Value) ;
		   if (v4l_ListPoint_Value(ctx,lp1,index,&pnt2) <= 0) continue ;	/* Get key value */
		   if (memcmp(arg2,&pnt2,arg2->Bytes) == 0)				/* Got a match ? */
		    { intPNTv(respnt,i) ; goto return_respnt ;				/*  yes - return index within list */
		    } ;
		 } ;
		intPNTv(respnt,0) ;							/* Can't find key - return 0 (FALSE) */
		goto return_respnt ;
	   case V4IM_Tag_Select:
		pim = (struct V4DPI__Point_IntMix *)&arg2->Value ;
		INITLP(respnt,lp1,resdim) ;
		if (arg2->Grouping == 0)				/* Just a single value in point? */
		 { for(i=1;v4l_ListPoint_Value(ctx,lp,i,&pnt) > 0;i++)	/* Loop thru each point in list */
		    { if (pnt.Value.IntVal == arg2->Value.IntVal) 
		       if (!v4l_ListPoint_Modify(ctx,lp1,V4L_ListAction_Append,&pnt,0)) { v_Msg(ctx,NULL,"LPModFail",intmodx) ; goto list_fail ; } ;
		    } ;
		   ENDLP(respnt,lp1) ;
		   goto return_respnt ;
		 } ;
		DIMINFO(di,ctx,arg2->Dim) ;
		if ((di->Flags & V4DPI_DimInfo_RangeOK) == 0)			/* If range of values NOT ok then handle here */
		 { for(i=0;i<arg2->Grouping;i++)
		    { for(j=1;v4l_ListPoint_Value(ctx,lp,j,&pnt) > 0;j++)	/* Loop thru each point in list */
		       { if (pnt.Value.IntVal == pim->Entry[i].BeginInt) break ; } ;
		      for(;v4l_ListPoint_Value(ctx,lp,j,&pnt) > 0;j++)
		       { if (!v4l_ListPoint_Modify(ctx,lp1,V4L_ListAction_Append,&pnt,0)) { v_Msg(ctx,NULL,"LPModFail",intmodx) ; goto list_fail ; }
			 if (pnt.Value.IntVal == pim->Entry[i].EndInt) break ;
		       } ;
		    } ;
		 } else							/* Handle integers - accept >= <= ranges */
		 { for(i=0;i<arg2->Grouping;i++)
		    { for(j=1;v4l_ListPoint_Value(ctx,lp,j,&pnt) > 0;j++)	/* Loop thru each point in list */
		       { if (pnt.Value.IntVal >= pim->Entry[i].BeginInt) break ; } ;
		      for(;v4l_ListPoint_Value(ctx,lp,j,&pnt) > 0;j++)
		       { if (pnt.Value.IntVal > pim->Entry[i].EndInt) break ;
		         if (!v4l_ListPoint_Modify(ctx,lp1,V4L_ListAction_Append,&pnt,0)) { v_Msg(ctx,NULL,"LPModFail",intmodx) ; goto list_fail ; } ;
			 if (pnt.Value.IntVal == pim->Entry[i].EndInt) break ;
		       } ;
		    } ;
		 } ;
		ENDLP(respnt,lp1) ;
		goto return_respnt ;
	   case -V4IM_Tag_Length:
		intPNTv(respnt,SIZEofLIST(lp)) ; goto return_respnt ;
	   case -V4IM_Tag_Alpha:
		ZUS(cdel) ; goto alpha_entry ;
	   case V4IM_Tag_Break:
		{ struct V4L__Partitions vlp ;
		  if (!v4l_ListPartition(ctx,(struct V4L__ListPoint *)&ipt->Value,&vlp,v4im_GetPointInt(&ok,arg2,ctx),intmodx)) goto list_fail ;
		  INITLP(respnt,lp1,Dim_List)
		  ZPH(&pnt) ; pnt.PntType = V4DPI_PntType_List ; pnt.Dim = Dim_List ;
		  pnt.Bytes = V4DPI_PointHdr_Bytes + vlp.lpbuf.Bytes ; memcpy(&pnt.Value,&vlp.lpbuf,vlp.lpbuf.Bytes) ;
		  if (!v4l_ListPoint_Modify(ctx,lp1,V4L_ListAction_Append,&pnt,0)) { v_Msg(ctx,NULL,"LPModFail",intmodx) ; goto list_fail ; } ;
		  ZPH(&pnt) ; pnt.PntType = V4DPI_PntType_Int2 ; pnt.Dim = Dim_Int2 ; pnt.Bytes = V4PS_Int2 ;
		  for(i=0;i<vlp.Count;i++)
		   { pnt.Value.Int2Val[0] = vlp.Seg[i].Start ; pnt.Value.Int2Val[1] = vlp.Seg[i].End ;
		     if (!v4l_ListPoint_Modify(ctx,lp1,V4L_ListAction_Append,&pnt,0)) { v_Msg(ctx,NULL,"LPModFail",intmodx) ; goto list_fail ; } ;
		   } ;
		  ENDLP(respnt,lp1) ;
		  goto return_respnt ;
		}
	   case V4IM_Tag_Column:
		{ int len, dlen ; LOGICAL csv=FALSE ;
		  if (arg2->PntType == V4DPI_PntType_Dict)
		   { switch (v4im_GetDictToEnumVal(ctx,arg2))
		      { default:	v_Msg(ctx,NULL,"ListColArg",intmodx,V4IM_Tag_Column,DE(CSV),DE(Tab)) ; goto list_fail ;
		        case _CSV:	csv = TRUE ; UCstrcpy(cdel,UClit(",")) ; break ;
		        case _Tab:	UCstrcpy(cdel,UClit("\t")) ; break ;
		      } ;
		   } else { v4im_GetPointUC(&ok,cdel,UCsizeof(cdel),arg2,ctx) ; } ;
alpha_entry:	  dlen = UCstrlen(cdel) ;
		  ZUS(UCTBUF1) ; len = 0 ;
		  for(i=1;v4l_ListPoint_Value(ctx,lp,i,&pnt) > 0;i++)	/* Loop thru each point in list */
		   { v4dpi_PointToStringML(UCTBUF2,&pnt,ctx,V4DPI_FormatOpt_Echo,V4TMBufMax) ;
		     if (len + dlen + UCstrlen(UCTBUF2) + 2 >= V4LEX_BigText_Max)
		      { v_Msg(ctx,NULL,"ModArgMaxAlpha",intmodx,i,len+dlen+2,UCstrlen(UCTBUF2),V4LEX_BigText_Max) ; goto list_fail ; } ;
/*		     Are we doing CSV ? */
		     if (csv)
		      { UCCHAR csvbuf[V4TMBufMax], *uc = UCstrpbrk(UCTBUF2,UClit(",\"' ")) ;
			if (uc == NULL) { if (i > 1) UCstrcat(UCTBUF1,cdel) ; UCstrcat(UCTBUF1,UCTBUF2) ; len += (dlen + UCstrlen(UCTBUF2)) ; continue ; }
/*			Have to do a little work to fix up this string for legal CSV */
			v_StringLit(UCTBUF2,csvbuf,V4TMBufMax,UClit('"'),UClit('"')) ;
		        len += (dlen + UCstrlen(csvbuf)) ;
			if (len + 2 >= V4LEX_BigText_Max){ v_Msg(ctx,NULL,"ModArgMaxAlpha",intmodx,i,len,2,V4LEX_BigText_Max) ; goto list_fail ; } ;
		        if (i > 1) UCstrcat(UCTBUF1,cdel) ; UCstrcat(UCTBUF1,csvbuf) ;
		      } else
		      { if (i > 1) UCstrcat(UCTBUF1,cdel) ; UCstrcat(UCTBUF1,UCTBUF2) ; len += (dlen + UCstrlen(UCTBUF2)) ;
		      } ;
		   } ;
		  if (len >= V4DPI_UCVAL_MaxSafe)		/* Save as string or BigText ? */
		   { v4dpi_SaveBigTextPoint2(ctx,UCTBUF1,respnt,Dim_Alpha,TRUE) ;
		   } else { uccharPNT(respnt) ; UCstrcpy(&respnt->Value.UCVal[1],UCTBUF1) ; UCCHARPNTBYTES2(respnt,len) ; } ;
		  goto return_respnt ;
		}
	   case V4IM_Tag_Shell:		sdim = v4dpi_DimShellDimId(&ok,ctx,arg2) ; if (!ok) { v_Msg(ctx,NULL,"ModFailed2",intmodx) ; goto list_fail ; } ; goto next_arg; /* Pick up the dimension */
	   case V4IM_Tag_AWhile:	awpt = arg2 ; goto next_arg ;
	   case V4IM_Tag_Sum:		sumpt = arg2 ; goto next_arg ;
	   case V4IM_Tag_Begin:		bgnpt = arg2 ; goto next_arg ;
	   case V4IM_Tag_Every:
	   	evpt = arg2 ; if (ISVAL(evpt)) every = v4im_GetPointInt(&ok,arg2,ctx) ;
		if (!ok) { v_Msg(ctx,NULL,"ModInvArg2",intmodx,arg2) ; goto list_fail ; } ;
		goto next_arg ;
	   case V4IM_Tag_If:
	   case V4IM_Tag_While:
		if (arg2->PntType != V4DPI_PntType_Isct)
		 { v_Msg(ctx,NULL,"TagValueNotIsct",intmodx,tag,arg2->PntType) ; goto list_fail ; } ;
		if (sumpt != NULL)
		 { if (sumpt->PntType != V4DPI_PntType_List) { lp2 = NULL ; }
		    else { lp2 = v4im_VerifyList(NULL,ctx,sumpt,intmodx) ; } ;
		   firstsum = TRUE ;
		 } ;
		frameid = v4ctx_FramePush(ctx,NULL) ;		/* Start new context frame */
		cpt = respnt ; INITLP(cpt,lp1,resdim) ;
		for(i=1;v4l_ListPoint_Value(ctx,lp,i,&pnt) > 0;i++)	/* Loop thru each point in list */
		 { if (pnt.PntType == V4DPI_PntType_Isct)		/* If an ISCT then evaluate it */
		    { ipt = v4dpi_IsctEval(&pnt2,&pnt,ctx,V4DPI_EM_EvalQuote,NULL,NULL) ; }
		    else { ipt = &pnt ; } ;
		   if (ipt == NULL) { v_Msg(ctx,NULL,"TagEvalFail",intmodx,tag,&pnt) ; goto list_fail ; } ;
		   if (!v4ctx_FrameAddDim(ctx,0,ipt,0,0)) { v_Msg(ctx,NULL,"CtxAddFail") ; goto list_fail ; } ;
		   if (sdim != 0) v4ctx_FrameAddDim(ctx,0,ipt,sdim,0) ;	/*  and may an extra shell dimension */
		   CLEARCACHE
		   memcpy(&pnt4,ipt,ipt->Bytes) ;			/* Save copy of current list point */
		   ipt = v4dpi_IsctEval(&pnt,arg2,ctx,V4DPI_EM_EvalQuote,NULL,NULL) ;
		   if (ipt == NULL)
		    { v_Msg(ctx,NULL,"TagEvalFail",intmodx,tag,arg2) ; goto list_fail ; } ;
		   if (ipt->Value.IntVal > 0)	/* If result is TRUE then append to result list */
		    { 
		      if (sumpt != NULL)
		       { for(sx=1;;sx++)
			  { if (lp2 != NULL)
			     { if (v4l_ListPoint_Value(ctx,lp2,sx,&pnt) <= 0) break ; tpt = &pnt ; }
			     else { tpt = sumpt ; } ;
			    tpt = v4dpi_IsctEval(&arg2buf,tpt,ctx,V4DPI_EM_EvalQuote,NULL,NULL) ;
			    if (tpt == NULL)
			     { v_Msg(ctx,NULL,"TagEvalFail",intmodx,V4IM_Tag_Sum,sumpt) ; goto list_fail ; } ;
			    if (firstsum)					/* If first time then just add to context */
			     { 
			       if (!v4ctx_FrameAddDim(ctx,0,tpt,0,0)) { v_Msg(ctx,NULL,"CtxAddFail",intmodx) ; goto list_fail ; } ;
			     } else
			     { DIMVAL(ipt,ctx,tpt->Dim) ;		/* Get current dimension value */
			       ok = TRUE ; d1 = (ipt == NULL ? 0 : v4im_GetPointDbl(&ok,ipt,ctx)) ;
			       if (!ok) { v_Msg(ctx,NULL,"ModInvArg2",intmodx,ipt) ; goto list_fail ; } ;
			       d1 += v4im_GetPointDbl(&ok,tpt,ctx) ;	/* Add current value to context value */
			       if (!ok) { v_Msg(ctx,NULL,"ModInvArg2",intmodx,tpt) ; goto list_fail ; } ;
			       v4im_SetPointValue(ctx,tpt,d1) ;
			       if (!v4ctx_FrameAddDim(ctx,0,tpt,0,0)) { v_Msg(ctx,NULL,"CtxAddFail",intmodx) ; goto list_fail ; } ;
			     } ;
			    if (lp2 == NULL) break ;			/* Don't have list */
			  } ;
			 firstsum = FALSE ;
		       } ;
		      if (!v4l_ListPoint_Modify(ctx,lp1,V4L_ListAction_Append,&pnt4,0)) { v_Msg(ctx,NULL,"LPModFail",intmodx) ; goto list_fail ; } ;
		      if (awpt != NULL)					/* Have AWhile:xxx point? */
		       { ipt = v4dpi_IsctEval(&arg2buf,awpt,ctx,V4DPI_EM_EvalQuote,NULL,NULL) ;
			 if (ipt == NULL)
			  { v_Msg(ctx,NULL,"TagEvalFail",intmodx,V4IM_Tag_AWhile,awpt) ; goto list_fail ; } ;
			 if (ipt->Value.IntVal <= 0) break ;		/* FALSE = continue with next point */
		       } ;
		    } else { if (tag==V4IM_Tag_While) break ; } ;		/* If WHILE and got a FALSE then quit loop */
		 } ;
		ENDLP(cpt,lp1)
		if (!v4ctx_FramePop(ctx,frameid,NULL)) { v_Msg(ctx,NULL,"ModCtxPopFrame",intmodx,frameid) ; goto list_fail ; } ;			/* Pop off frame context */
		goto return_respnt ;
	   case V4IM_Tag_Columns:
		columns = v4im_GetPointInt(&ok,arg2,ctx) ;
		if (!ok) { v_Msg(ctx,NULL,"ModInvArg2",intmodx,arg2) ; goto list_fail ; } ;
		INITLP(respnt,lp1,resdim)				/* Set up resulting list */
		lp = v4im_VerifyList(NULL,ctx,ipt=argpnts[1],intmodx) ;
		if (lp == NULL) { v_Msg(ctx,NULL,"ModInvArgList2",intmodx,argpnts[1]) ; goto list_fail ; } ;
		num = SIZEofLIST(lp) ;					/* num = number of points in list */
		if (num <= 0) { v_Msg(ctx,NULL,"ListSizeErr",intmodx,ipt) ; goto list_fail ; } ;
		every = (num + columns - 1) / columns ;			/* every = horizontal offset for each column */
		tpt = &pnt2 ;						/* tpt = temp list */
		INITLP(tpt,lp2,resdim) ;				/*  linked to lp2 */
		for(rx=1;rx<=every;rx++)				/* Loop thru each "row" */
		 { 
		   tpt = &pnt2 ;					/* tpt = temp "column" list */
		   INITLP(tpt,lp2,resdim) ;				/*  linked to lp2 */
		   for(i=0;i<columns;i++)
		    { if (v4l_ListPoint_Value(ctx,lp,(rx + i*every),&pnt) > 0)
		        { if (!v4l_ListPoint_Modify(ctx,lp2,V4L_ListAction_Append,&pnt,0)) { v_Msg(ctx,NULL,"LPModFail",intmodx) ; goto list_fail ; } ; } ;/* Append to column list */
		    } ;
		   ENDLP(tpt,lp2)
		   v4l_ListPoint_Modify(ctx,lp1,V4L_ListAction_Append,tpt,0) ; /* Append row to resulting list */
		 } ;
		ENDLP(respnt,lp1)
		goto return_respnt ;
	   case -V4IM_Tag_Reverse:
		INITLP(respnt,lp1,resdim)
		lp = v4im_VerifyList(NULL,ctx,ipt = argpnts[1],intmodx) ;
		if (lp == NULL) { v_Msg(ctx,NULL,"ModInvArgList2",intmodx,argpnts[1]) ; goto list_fail ; } ;
		if ((i=v4l_ListPoint_Value(ctx,lp,V4L_ListSize,&pnt)) == V4L_ListSize_Unk) { v_Msg(ctx,NULL,"ListUnkSize",intmodx,-V4IM_Tag_Reverse) ; goto list_fail ; } ;
		for(;i>0;i--)
		 { v4l_ListPoint_Value(ctx,lp,i,&pnt) ;
		   if (!v4l_ListPoint_Modify(ctx,lp1,V4L_ListAction_Append,&pnt,0)) { v_Msg(ctx,NULL,"LPModFail",intmodx) ; goto list_fail ; } ;/* Append to resulting list */
		 } ;
		ENDLP(respnt,lp1)
		goto return_respnt ;
	   case V4IM_Tag_Head:
		INITLP(respnt,lp1,resdim)
		num = v4im_GetPointInt(&ok,arg2,ctx) ; if (!ok) { v_Msg(ctx,NULL,"ModInvArg",intmodx,2) ; goto list_fail ; } ;
		if (num < 0)
		 { i = SIZEofLIST(lp) ;
		   if (i <= 0) { v_Msg(ctx,NULL,"ListSizeErr",intmodx,arg2) ; goto list_fail ; } ;
		   num += i ;
		 } ;
		lp = v4im_VerifyList(NULL,ctx,ipt = argpnts[1],intmodx) ;
		if (lp == NULL) { v_Msg(ctx,NULL,"ModInvArgList2",intmodx,argpnts[1]) ; goto list_fail ; } ;
		for(i=1;v4l_ListPoint_Value(ctx,lp,i,&pnt) > 0 && i <= num;i++)	/* Loop thru each point in list */
		 { if (!v4l_ListPoint_Modify(ctx,lp1,V4L_ListAction_Append,&pnt,0)) { v_Msg(ctx,NULL,"LPModFail",intmodx) ; goto list_fail ; } ;/* Append to resulting list */
		 } ;
		ENDLP(respnt,lp1)
		goto return_respnt ;
	   case V4IM_Tag_Tail:
		INITLP(respnt,lp1,resdim)
		num = v4im_GetPointInt(&ok,arg2,ctx) ; if (!ok) { v_Msg(ctx,NULL,"ModInvArg",intmodx,2) ; goto list_fail ; } ;
		lp = v4im_VerifyList(NULL,ctx,ipt = argpnts[1],intmodx) ;
		if (lp == NULL) { v_Msg(ctx,NULL,"ModInvArgList2",intmodx,argpnts[1]) ; goto list_fail ; } ;
		i = SIZEofLIST(lp) ;					/* Get total size of list */
		if (i <= 0) { v_Msg(ctx,NULL,"ListSizeErr",intmodx,arg2) ; goto list_fail ; } ;
		if (num < 0) { num = i + num ; } ;			/* If negative then take from left hand */
		if (num > i) num = i ;					/* Can't return more than this number */
		i = i - num + 1 ;					/* Start at num from the end */
		for(;v4l_ListPoint_Value(ctx,lp,i,&pnt) > 0;i++)	/* Loop thru each point in list */
		 { if (!v4l_ListPoint_Modify(ctx,lp1,V4L_ListAction_Append,&pnt,0)) { v_Msg(ctx,NULL,"LPModFail",intmodx) ; goto list_fail ; } ;
		 } ;
		ENDLP(respnt,lp1)
		goto return_respnt ;
	   case V4IM_Tag_Group:
/*		Group::xxx tag does not eval argument - if it's a 'special' point then eval, if it's an isct then don't and drop down to logic below */
		if (arg2->PntType == V4DPI_PntType_Special)
		 { arg2 = v4dpi_IsctEval(&arg2buf,arg2,ctx,V4DPI_EM_EvalQuote,NULL,NULL) ;
		   if (arg2 == NULL) { v_Msg(ctx,NULL,"TagEvalFail",intmodx,V4IM_Tag_Group,arg2) ; goto list_fail ; } ;
		 } ;
		INITLP(respnt,lp1,argpnts[1]->Dim)			/* Set up resulting list */
		memcpy(&pnt4,argpnts[1],argpnts[1]->Bytes) ;		/* VEH131106 - copy first arg into local point (problems if in context and we update context below) */
		lp = v4im_VerifyList(NULL,ctx,ipt=&pnt4,intmodx) ;
		if (lp == NULL) { v_Msg(ctx,NULL,"ModInvArgList2",intmodx,argpnts[1]) ; goto list_fail ; } ;
		tpt = &pnt2 ;						/* tpt = temp list */
		INITLP(tpt,lp2,resdim) ; j = TRUE ;			/*  linked to lp2 */
		if (arg2->PntType == V4DPI_PntType_Int)
		 {

		   for(i=1;v4l_ListPoint_Value(ctx,lp,i,&pnt) > 0;i++)	/* Loop thru each point in list */
		    { if (!v4l_ListPoint_Modify(ctx,lp2,V4L_ListAction_Append,&pnt,0)) { v_Msg(ctx,NULL,"LPModFail",intmodx) ; goto list_fail ; } ;
		      if ((i % arg2->Value.IntVal) != 0) { continue ; } ;
		      ENDLP(tpt,lp2)
		      if (!v4l_ListPoint_Modify(ctx,lp1,V4L_ListAction_Append,tpt,0)) { v_Msg(ctx,NULL,"LPModFail",intmodx) ; goto list_fail ; } ; /* If false then append group to final list */
		      INITLP(tpt,lp2,resdim) ;
		    } ;
		   if (lp2->Entries > 0)					/* Have last one to append? */
		    { ENDLP(tpt,lp2) ; if (!v4l_ListPoint_Modify(ctx,lp1,V4L_ListAction_Append,tpt,0)) { v_Msg(ctx,NULL,"LPModFail",intmodx) ; goto list_fail ; } ;
		    } ;
		   ENDLP(respnt,lp1)
		   goto return_respnt ;
		 } ;



		for(i=1;v4l_ListPoint_Value(ctx,lp,i,&pnt) > 0;i++)	/* Loop thru each point in list */
		 { if (!v4l_ListPoint_Modify(ctx,lp2,V4L_ListAction_Append,&pnt,0)) { v_Msg(ctx,NULL,"LPModFail",intmodx) ; goto list_fail ; } ;
		   ENDLP(tpt,lp2)
		   if (!v4ctx_FrameAddDim(ctx,0,tpt,0,0)) { v_Msg(ctx,NULL,"CtxAddFail",intmodx) ; goto list_fail ; } ;
		   ipt = v4dpi_IsctEval(&pnt3,arg2,ctx,V4DPI_EM_EvalQuote,NULL,NULL) ;
		   if (ipt == NULL) { v_Msg(ctx,NULL,"TagEvalFail",intmodx,V4IM_Tag_Group,arg2) ; goto list_fail ; } ;
		   if (j || (ipt == NULL ? FALSE : ipt->Value.IntVal > 0))	/* Result True or False */
		    { j = FALSE ; continue ; } ;			/* If true then keep appending to temp point */
		   lp2->Entries -- ;					/* Take out last entry */
		   if (!v4l_ListPoint_Modify(ctx,lp1,V4L_ListAction_Append,tpt,0)) { v_Msg(ctx,NULL,"LPModFail",intmodx) ; goto list_fail ; } ; /* If false then append group to final list */
		   INITLP(tpt,lp2,resdim) j = TRUE ; i -- ;
		 } ;
		if (lp2->Entries > 0)					/* Have last one to append? */
		 { if (!v4l_ListPoint_Modify(ctx,lp1,V4L_ListAction_Append,tpt,0)) { v_Msg(ctx,NULL,"LPModFail",intmodx) ; goto list_fail ; } ;
		 } ;
		ENDLP(respnt,lp1)
		goto return_respnt ;
	   case V4IM_Tag_Maximum:
		d1 = -DBL_MAX ;
		for(i=1;v4l_ListPoint_Value(ctx,lp,i,&pnt) > 0;i++)	/* Loop thru each point in list */
		 { 
		   if (!v4ctx_FrameAddDim(ctx,0,&pnt,0,0)) { v_Msg(ctx,NULL,"CtxAddFail",intmodx) ; goto list_fail ; } ;
		   ipt = v4dpi_IsctEval(&pnt2,arg2,ctx,V4DPI_EM_EvalQuote,NULL,NULL) ;
		   if (ipt == NULL)
		    { v_Msg(ctx,NULL,"TagEvalFail",intmodx,V4IM_Tag_Maximum,arg2) ; goto list_fail ; } ;
		   d2 = v4im_GetPointDbl(&ok,ipt,ctx) ;
		   if (!ok) { v_Msg(ctx,NULL,"ModInvArg2",intmodx,ipt) ; goto list_fail ; } ;
		   if (d2 > d1) { d1 = d2 ; memcpy(respnt,&pnt,pnt.Bytes) ; } ;
		 } ; goto return_respnt ;
	   case V4IM_Tag_Minimum:
		d1 = DBL_MAX ;
		for(i=1;v4l_ListPoint_Value(ctx,lp,i,&pnt) > 0;i++)	/* Loop thru each point in list */
		 { 
		   if (!v4ctx_FrameAddDim(ctx,0,&pnt,0,0)) { v_Msg(ctx,NULL,"CtxAddFail",intmodx) ; goto list_fail ; } ;
		   ipt = v4dpi_IsctEval(&pnt2,arg2,ctx,V4DPI_EM_EvalQuote,NULL,NULL) ;
		   if (ipt == NULL)
		    { v_Msg(ctx,NULL,"TagEvalFail",intmodx,V4IM_Tag_Minimum,arg2) ; goto list_fail ; } ;
		   d2 = v4im_GetPointDbl(&ok,ipt,ctx) ;
		   if (!ok) { v_Msg(ctx,NULL,"ModInvArg2",intmodx,ipt) ; goto list_fail ; } ;
		   if (d2 < d1) { d1 = d2 ; memcpy(respnt,&pnt,pnt.Bytes) ; } ;
		 } ; goto return_respnt ;
	   case V4IM_Tag_Bits:
		switch(arg2->PntType)
		 { default:	v_Msg(ctx,NULL,"ListBits",V4IM_Tag_Bits,arg2) ; goto list_fail ;
		   CASEofINT	break ;
		 } ;
		INITLP(respnt,lp1,argpnts[1]->Dim)
		lp2 = v4im_VerifyList(NULL,ctx,arg2,intmodx) ;
		if (lp2 == NULL) { v_Msg(ctx,NULL,"ModInvArgList2",intmodx,arg2) ; goto list_fail ; } ;
		for(j=1,i=arg2->Value.IntVal;i!=0;j++)				/* Loop thru all bits set in IntVal */
		 { if ((i & 1) != 0)						/* Is bit set? */
		    { if (v4l_ListPoint_Value(ctx,lp,j,&pnt4))		/*  yes - append corresponding list element to result */
		       if (!v4l_ListPoint_Modify(ctx,lp1,V4L_ListAction_Append,&pnt4,0)) { v_Msg(ctx,NULL,"LPModFail",intmodx) ; goto list_fail ; } ;
		    } ;
		   if (i > 0) { i = i >> 1 ; }					/* Shift all bits over 1 */
		    else { i &= 0x7fffffff ; i = i >> 1 ; i |= 0x40000000 ; } ;
		 } ;
		ENDLP(respnt,lp1)
		goto return_respnt ;
	   case V4IM_Tag_Nth:						/* NOTE: Negative is from right hand side! */
		if (arg2->Dim == Dim_Dim) goto dim_entry ;		/* If List(list Nth::dim) then assume really want List(list dim) */
		if (arg2->PntType == V4DPI_PntType_List)
		 { INITLP(respnt,lp1,argpnts[1]->Dim)
		   lp2 = v4im_VerifyList(NULL,ctx,arg2,intmodx) ;
		   if (lp2 == NULL) { v_Msg(ctx,NULL,"ModInvArgList2",intmodx,arg2) ; goto list_fail ; } ;
		   for(i=1;v4l_ListPoint_Value(ctx,lp2,i,&pnt) > 0;i++)	/* Loop thru each point in list */
		    { j = v4im_GetPointInt(&ok,&pnt,ctx) ;
		      if (!ok) { v_Msg(ctx,NULL,"ModInvArg2",intmodx,&pnt) ; goto list_fail ; } ;
		      if (j < 0)	/* Negative index = index from right */
		       { k = SIZEofLIST(lp) ;
			 if (k <= 0) { v_Msg(ctx,NULL,"ListSizeErr",intmodx,argpnts[1]) ; goto list_fail ; } ;
		         j += (k + 1) ;
		       } ;
		      if (v4l_ListPoint_Value(ctx,lp,j,&pnt4) < 1) continue ;
		      if (!v4l_ListPoint_Modify(ctx,lp1,V4L_ListAction_Append,&pnt4,0)) { v_Msg(ctx,NULL,"LPModFail",intmodx) ; goto list_fail ; } ;
		    } ;
		   ENDLP(respnt,lp1)
		   goto return_respnt ;
		 } ;
		if (arg2->Grouping == V4DPI_Grouping_Single)
		 { i = v4im_GetPointInt(&ok,arg2,ctx) ; if (!ok) { v_Msg(ctx,NULL,"ModInvArg",intmodx,2) ; goto list_fail ; } ;
		   if (i < 0)
		    { k = SIZEofLIST(lp) ;
		      if (k <= 0) { v_Msg(ctx,NULL,"ListSizeErr",intmodx,argpnts[1]) ; goto list_fail ; } ;
		      i += (k + 1) ;
		    } ;
		   if (i <= 0) { v_Msg(ctx,NULL,"ListNth",intmodx,V4IM_Tag_Nth,arg2,i) ; goto list_fail ; } ;
		   if (v4l_ListPoint_Value(ctx,lp,i,respnt) < 1)
		    { v_Msg(ctx,NULL,"ListNth",intmodx,V4IM_Tag_Nth,arg2,i) ; goto list_fail ; } ;
		   goto return_respnt ;
		 } ;
		pim = (struct V4DPI__Point_IntMix *)&arg2->Value ;
		INITLP(respnt,lp1,resdim)
		for(i=0;i<arg2->Grouping;i++)
		 { for(j=pim->Entry[i].BeginInt;j<=pim->Entry[i].EndInt;j++)
		    { if (v4l_ListPoint_Value(ctx,lp,j,&pnt4) < 1) continue ;
		      if (!v4l_ListPoint_Modify(ctx,lp1,V4L_ListAction_Append,&pnt4,0)) { v_Msg(ctx,NULL,"LPModFail",intmodx) ; goto list_fail ; } ;
		    } ;
		 } ;
		ENDLP(respnt,lp1)
		goto return_respnt ;
	   case V4IM_Tag_Occurs:
		intPNTv(respnt,0) ;						/* Start with count of 0 */
		for(i=1;v4l_ListPoint_Value(ctx,lp,i,&pnt) > 0;i++)	/* Loop thru each point in list */
		 { switch (arg2->PntType)
		    { default:
			if (memcmp(arg2,&pnt,pnt.Bytes) == 0) respnt->Value.IntVal++ ;
			break ;
		      CASEofChar
			if (arg2->Dim != pnt.Dim) continue ;
			ok = vuc_Cmp2PtsStr(&pnt,arg2) ; if (ok) respnt->Value.IntVal++ ; 
			break ;
		    } ;
		 } ;
		return(respnt) ;
	   case V4IM_Tag_Position:
		for(i=1;v4l_ListPoint_Value(ctx,lp,i,&pnt) > 0;i++)	/* Loop thru each point in list */
		 { switch (arg2->PntType)
		    { default:
			if (memcmp(arg2,&pnt,pnt.Bytes) != 0) continue ;
			intPNTv(respnt,i) ; goto return_respnt ;
		      CASEofChar
			if (arg2->Dim != pnt.Dim) continue ;
			ok = vuc_Cmp2PtsStr(&pnt,arg2) ;
			if (!ok) continue ; 
			intPNTv(respnt,i) ; goto return_respnt ;
		    } ;
		 } ;
		v_Msg(ctx,NULL,"ListPos",intmodx,V4IM_Tag_Position,arg2,argpnts[1]) ; goto list_fail ;
	   case V4IM_Tag_Sample:
		num = v4im_GetPointInt(&ok,arg2,ctx) ; if (!ok) { v_Msg(ctx,NULL,"ModInvArg",intmodx,2) ; goto list_fail ; } ;
		INITLP(respnt,lp1,resdim)
		i = (rand() % num) ; if (i <= 0) i = 1 ;
		for(;v4l_ListPoint_Value(ctx,lp,i,&pnt) > 0;)	/* Loop thru each point in list */
		 { if (pnt.PntType == V4DPI_PntType_Isct)		/* If an ISCT then evaluate it */
		    { ipt = v4dpi_IsctEval(&pnt2,&pnt,ctx,V4DPI_EM_EvalQuote,NULL,NULL) ; }
		    else { ipt = &pnt ; } ;
		   if (ipt == NULL)
		    { v_Msg(ctx,NULL,"TagEvalFail",intmodx,tag,&pnt) ; goto list_fail ; } ;
		   if (!v4l_ListPoint_Modify(ctx,lp1,V4L_ListAction_Append,ipt,0)) { v_Msg(ctx,NULL,"LPModFail",intmodx) ; goto list_fail ; } ;
		   j = (rand() % (num*2)) ; i += (j == 0 ? 1 : j) ;
		 } ;
		ENDLP(respnt,lp1) goto return_respnt ;
	   case V4IM_Tag_To:
		INITLP(respnt,lp1,resdim)
		for(i=1;v4l_ListPoint_Value(ctx,lp,i,&pnt) > 0;i++)	/* Loop thru each point in list */
		 { if (pnt.PntType == V4DPI_PntType_Isct)		/* If an ISCT then evaluate it */
		    { ipt = v4dpi_IsctEval(&pnt2,&pnt,ctx,V4DPI_EM_EvalQuote,NULL,NULL) ; }
		    else { ipt = &pnt ; } ;
		   if (ipt == NULL)
		    { v_Msg(ctx,NULL,"TagEvalFail",intmodx,V4IM_Tag_To,&pnt) ; goto list_fail ; } ;
		   if (!v4l_ListPoint_Modify(ctx,lp1,V4L_ListAction_Append,ipt,0)) { v_Msg(ctx,NULL,"LPModFail",intmodx) ; goto list_fail ; } ;
		   if (memcmp(arg2,ipt,ipt->Bytes) == 0) break ;	/* Got match, quit */
		 } ;
		ENDLP(respnt,lp1) goto return_respnt ;
	   case V4IM_Tag_Append:
		DIMINFO(di,ctx,argpnts[1]->Dim) ;
		if (isPntIdx)						/* Is first argument a point ref? */
		 { lp = v4im_VerifyList(NULL,ctx,arg2,intmodx) ;
		   if (lp == NULL) { v_Msg(ctx,NULL,"ModInvArgList2",intmodx,arg2) ; goto list_fail ; } ;
		   lp1 = ALIGNLP(&argpnts[1]->Value) ;	/*  Yes- append to list it points to */
		   for(i=1;v4l_ListPoint_Value(ctx,lp,i,&pnt) > 0;i++)	/* Loop thru each point in list */
		    { if (pnt.PntType == V4DPI_PntType_Isct)		/* If an ISCT then evaluate it */
		       { ipt = v4dpi_IsctEval(&pnt2,&pnt,ctx,V4DPI_EM_EvalQuote,NULL,NULL) ; }
		       else { ipt = &pnt ; } ;
		      if (!v4l_ListPoint_Modify(ctx,lp1,((di->Flags & V4DPI_DimInfo_IsSet) ? V4L_ListAction_AppendUnique : V4L_ListAction_Append),&pnt,0)) { v_Msg(ctx,NULL,"LPModFail",intmodx) ; goto list_fail ; } ;
		    } ;
		   return(argpnts[1]) ;
		 } ;
		INITLP(respnt,lp1,di->DimId)
		vlma = (struct V4L__ListMultiAppend *)&lp1->Buffer ; vlma->Count = 0 ; vlma->Entries = 0 ;
		for(argnum=1;argnum<=argcnt;argnum++)
		 { if (argnum == 1)
		    { lp = v4im_VerifyList(&pnt,ctx,argpnts[argnum],intmodx) ;
		      if (lp == NULL) { v_Msg(ctx,NULL,"ModInvArgList2",intmodx,argpnts[argnum]) ; goto list_fail ; } ;
		    } else { switch (tag=v4im_CheckPtArgNew(ctx,argpnts[argnum],&cpt,&arg2buf))
			      { default:		v_Msg(ctx,NULL,"TagBadUse",intmodx) ; goto list_fail ;
			        case V4IM_Tag_Unk:	v_Msg(ctx,NULL,"TagUnknown",intmodx) ; goto list_fail ;
			        case V4IM_Tag_Append:
					lp = v4im_VerifyList(&pnt,ctx,cpt,intmodx) ;
					if (lp == NULL) { v_Msg(ctx,NULL,"ModInvArgList2",intmodx,cpt) ; goto list_fail ; } ;
					break ;
			      } ;
			   } ;
		   if(lp->Bytes == 0) continue ;	/* Skip empty lists */
		   { struct V4L__ListPoint *zzz ;
		     zzz = (struct V4L__ListPoint *)v4mm_AllocChunk(lp->Bytes,FALSE) ;
		     COPYPTR(vlma->Multi[vlma->Count].lp,zzz) ;
		     memcpy(zzz,lp,lp->Bytes) ; vlma->Multi[vlma->Count].Entries = lp->Entries ;
		   }
		   vlma->Entries += lp->Entries ;
		   vlma->Count++ ;
		 } ;
		if (vlma->Entries != 0)			/* If result is empty then just return an empty list */
		 { lp1->Bytes = (char *)&vlma->Multi[vlma->Count] - (char *)lp1 ;
		   lp1->Entries = vlma->Entries ; lp1->ListType = V4L_ListType_MultiAppend ;
		 } ;
		ENDLP(respnt,lp1)
		goto return_respnt ;
	   case V4IM_Tag_Num:
		numVal = v4im_GetPointInt(&ok,arg2,ctx) ; if (!ok) { v_Msg(ctx,NULL,"ModInvArg",intmodx,2) ; goto list_fail ; } ;
		if (numVal <= 0) { v_Msg(ctx,NULL,"ModArgVal",intmodx,2,arg2,0) ; goto list_fail ; } ;
		goto next_arg ;
	   case (V4DPI_TagFlag_Colon3|V4IM_Tag_Delete):
	   case V4IM_Tag_Delete:
	   case (V4DPI_TagFlag_Colon3|V4IM_Tag_Remove):
	   case V4IM_Tag_Remove:
		INITLP(respnt,lp1,resdim) ; ok = FALSE ;
		for(i=1;v4l_ListPoint_Value(ctx,lp,i,&pnt) > 0;i++)
		 { if (arg2 != NULL ? memcmp(&pnt,arg2,arg2->Bytes) == 0 : FALSE)
		    { if (numVal > 0) { numVal-- ; if (numVal == 0) arg2 = NULL ; ok = TRUE ; continue ; } ;
		    } ;
		   if (!v4l_ListPoint_Modify(ctx,lp1,V4L_ListAction_Append,&pnt,0)) { v_Msg(ctx,NULL,"LPModFail",intmodx) ; goto list_fail ; } ;
		 } ;
		if (!ok && (tag & V4DPI_TagFlag_Colon3) == 0) { v_Msg(ctx,NULL,"ListRemove",intmodx,V4IM_Tag_Delete,arg2,argpnts[1]) ; goto list_fail ; } ;
		ENDLP(respnt,lp1) goto return_respnt ;
	   case V4IM_Tag_Collapse:
		INITLP(respnt,lp1,resdim)
		num = v4im_GetPointInt(&ok,arg2,ctx) ; if (!ok) { v_Msg(ctx,NULL,"ModInvArg",intmodx,2) ; goto list_fail ; } ;
		if (!v4im_ListHandCollapse(ctx,lp1,argpnts[1],V4L_ListAction_Append,0,num)) { v_Msg(ctx,NULL,"LPModFail",intmodx) ; goto list_fail ; } ;
		ENDLP(respnt,lp1) goto return_respnt ;
	   case -V4IM_Tag_Collapse:
		INITLP(respnt,lp1,resdim)
		if (!v4im_ListHandCollapse(ctx,lp1,argpnts[1],V4L_ListAction_Append,0,UNUSED)) { v_Msg(ctx,NULL,"LPModFail",intmodx) ; goto list_fail ; } ;
		ENDLP(respnt,lp1) goto return_respnt ;
	   case V4IM_Tag_Pairs:
		switch (v4im_GetDictToEnumVal(ctx,arg2))
		 { default:		v_Msg(ctx,NULL,"ModTagValue",intmodx,2,V4IM_Tag_Pairs,arg2) ; goto list_fail ;
		   case _Self:		k = TRUE ; break ;
		   case _Others:	k = FALSE ; break ;
		 } ;
		 goto pair_entry ;
	   case -V4IM_Tag_Pairs:
		k = FALSE ;
pair_entry:	INITLP(respnt,lp1,resdim)			/* lp = source list, lp1 = resulting list */
		for(i=1;;i++)
		 { if (v4l_ListPoint_Value(ctx,lp,i,&pnt) <= 0) break ;
		   if (k)					/* Create a pair with self */
		    { tpt = &pnt3 ; INITLP(tpt,lp2,resdim)	/* lp2 = inner list holding next pair of points */
		      if (!v4l_ListPoint_Modify(ctx,lp2,V4L_ListAction_Append,&pnt,0)) { v_Msg(ctx,NULL,"LPModFail",intmodx) ; goto list_fail ; } ;
		      if (!v4l_ListPoint_Modify(ctx,lp2,V4L_ListAction_Append,&pnt,0))  { v_Msg(ctx,NULL,"LPModFail",intmodx) ; goto list_fail ; } ;
		      ENDLP(tpt,lp2) if (!v4l_ListPoint_Modify(ctx,lp1,V4L_ListAction_Append,tpt,0)) { v_Msg(ctx,NULL,"LPModFail",intmodx) ; goto list_fail ; } ;
		    } ;
		   for(j=i+1;;j++)
		    { if (v4l_ListPoint_Value(ctx,lp,j,&pnt2) <= 0) break ;
		      tpt = &pnt3 ; INITLP(tpt,lp2,resdim)	/* lp2 = inner list holding next pair of points */
		      if (!v4l_ListPoint_Modify(ctx,lp2,V4L_ListAction_Append,&pnt,0)) { v_Msg(ctx,NULL,"LPModFail",intmodx) ; goto list_fail ; } ;
		      if (!v4l_ListPoint_Modify(ctx,lp2,V4L_ListAction_Append,&pnt2,0)) { v_Msg(ctx,NULL,"LPModFail",intmodx) ; goto list_fail ; } ;
		      ENDLP(tpt,lp2) if (!v4l_ListPoint_Modify(ctx,lp1,V4L_ListAction_Append,tpt,0)) { v_Msg(ctx,NULL,"LPModFail",intmodx) ; goto list_fail ; } ;
		    } ;
		 } ;
		ENDLP(respnt,lp)
		goto return_respnt ;
	   case V4IM_Tag_Product:
		INITLP(respnt,lp,resdim) ;
		for(ix=1;ix<=argcnt;ix++) { indexes[ix] = 1 ; } ;	/* Set all interation indexes to 1 */
		for(;;)
		 { INITLP((&pnt),lp1,resdim) ;
		   for(ix=1;ix<=argcnt;ix++)
		    { P tlpnt ;
		      v4im_CheckPtArgNew(ctx,argpnts[ix],&tpt,NULL) ;
		      lp2 = v4im_VerifyList(&tlpnt,ctx,tpt,intmodx) ;
		      if (v4l_ListPoint_Value(ctx,lp2,indexes[ix],&pnt2) == 0) break ;	/* Get a value or end of list? */
		      if (!v4l_ListPoint_Modify(ctx,lp1,V4L_ListAction_Append,&pnt2,0)) { v_Msg(ctx,NULL,"LPModFail",intmodx) ; goto list_fail ; } ;
		    } ;
		   if (ix <= argcnt)					/* If terminated early then have to bump indexes */
		    { if (ix == 1) goto end_product ;
		      indexes[ix-1] ++ ; for(;ix<=argcnt;ix++) { indexes[ix] = 1 ; } ;
		    } else
		    { indexes[argcnt] ++ ;				/* Got good product, append to master point */
		      ENDLP((&pnt),lp1) ;
		      if (!v4l_ListPoint_Modify(ctx,lp,V4L_ListAction_Append,&pnt,0)) { v_Msg(ctx,NULL,"LPModFail",intmodx) ; goto list_fail ; } ;
		    } ;
		   if (lp->Bytes > V4DPI_AlphaVal_Max)
		    { v_Msg(ctx,NULL,"ListPtLen1",intmodx,lp->Bytes,V4DPI_AlphaVal_Max) ; goto list_fail ; } ;
		 } ;
end_product:
		ENDLP(respnt,lp) ; return(respnt) ;
	 } ;

return_respnt:	/* Here to return value in respnt */
	if (argnum <= argcnt)		/* Any other arguments to process ? */
	 { switch (respnt->PntType)
	    { default:
		if (ISQUOTED(respnt) || intmodx == V4IM_OpCode_ListNE) break ;
/*		Show we evaluate this result or just return as-is */
		if (intmodx == V4IM_OpCode_ListNE)
		 { if (!respnt->ForceEval) break ;		/* ListNE() - return as-is unless it is `point */
		 } ;
/*		Here to evaluate respnt (or if quoted then eval to strip off quote) */
		if (respnt->PntType == V4DPI_PntType_Isct || respnt->PntType == V4DPI_PntType_Special)
		 { memcpy(&pnt,respnt,respnt->Bytes) ;
		   respnt = v4dpi_IsctEval(respnt,&pnt,ctx,V4DPI_EM_EvalQuote,NULL,NULL) ;
		   if (respnt == NULL){ v_Msg(ctx,NULL,"ModArgEval2",intmodx,&pnt) ; goto list_fail ; } ;
		   goto return_respnt ;
		 } ;
		break ;
	      
	      CASEofChar
		if (v4imu_NestToModule(ctx,respnt,argcnt,argpnts,argnum,intmodx,v4im_DoStr,V4IM_OpCode_Str) == NULL) goto list_fail ;
		break ;
	      case V4DPI_PntType_List:
		if (v4imu_NestToModule(ctx,respnt,argcnt,argpnts,argnum,intmodx,v4im_DoList,V4IM_OpCode_List) == NULL) goto list_fail ;
		break ;
	    } ;
	 } ;
//	if ((respnt->PntType == V4DPI_PntType_Isct || respnt->PntType == V4DPI_PntType_Special) && !(ISQUOTED(respnt) || intmodx == V4IM_OpCode_ListNE))
/*	Show we evaluate this result or just return as-is */
	if (intmodx == V4IM_OpCode_ListNE ? respnt->ForceEval : TRUE)
	 { memcpy(&pnt,respnt,respnt->Bytes) ;	/* Here to evaluate respnt (or if quoted then eval to strip off quote) */
	   respnt = v4dpi_IsctEval(respnt,&pnt,ctx,V4DPI_EM_EvalQuote,NULL,NULL) ;
	   if (respnt == NULL){ v_Msg(ctx,NULL,"ModArgEval2",intmodx,&pnt) ; goto list_fail ; } ;
	 } ;
	return(respnt) ;

lcr_setup:	/* Assumptions: tpt = point, lcr & lp set up */
		lcr->Bytes = (char *)&lcr->Cmpnd[lcr->Count] - (char *)lcr ;
		lp->Entries = lcr->Entries ; lp->Bytes = (char *)&lp->Buffer[ALIGN(lcr->Bytes)] - (char *)lp ;
		tpt->Bytes = (char *)&tpt->Value.AlphaVal[lp->Bytes] - (char *)tpt ;
		if (tpt->Bytes < V4DPI_PointHdr_Bytes + ((char *)&lp->Buffer[0] - (char *)lp))
	 	 tpt->Bytes = V4DPI_PointHdr_Bytes + ((char *)&lp->Buffer[0] - (char *)lp) ;	/* Make sure min size */
		return(tpt) ;

list_fail:
	if (frameid != UNUSED) v4ctx_FramePop(ctx,frameid,NULL) ;
	REGISTER_ERROR(0) ; RETURNFAILURE ;
}



/*	v4im_ListSetHandler - Called to handle List()/Set operations when first arg to List() is Union?, Intersect?, ... */

P *v4im_ListSetHandler(ctx,respnt,argpnts,argcnt,intmodx,trace)
  struct V4C__Context *ctx ;
  P *respnt,*argpnts[] ;
  int argcnt,intmodx,trace ;
{
  P *cpt,*ipt ;
  struct V4L__ListPoint *lp ;
  struct V4L__ListBitMap *lbm ;
  struct V4L__ListBMData1 *lbm1[V4DPI_IntModArg_Max] ;		/* List of bitmap structures */
  struct V4L__ListBMData1 *nbm1 ;				/* Newly created map */
#define V4List_BMEntries 1000
  struct V4L__BMAllocTable {
    int NextX ;							/* Index to next entry to use */
    struct {
      int maxbit ;						/* Max number of bits in bitmap */
      struct V4L__ListBMData1 *nbm ;				/* Pointer to bitmap */
     } Entry[V4List_BMEntries] ;
   } ;
  static struct V4L__BMAllocTable *bmat=NULL ;
  int maxmap,max1,max2 ;
  struct V4IM__SetPoint *vsp ;
  int i,j,k,tag,targetdim ;

	if (argcnt < 2) { v_Msg(ctx,NULL,"ModArgMand",intmodx) ; goto fail ; } ;
	tag = -v4im_CheckPtArgNew(ctx,argpnts[1],&cpt,NULL) ;
	lp = v4im_VerifyList(NULL,ctx,argpnts[2],intmodx) ;
	if (lp == NULL) { v_Msg(ctx,NULL,"ModInvArgList",intmodx,2) ; goto fail ; } ;
	if (lp->ListType == V4L_ListType_BitMap)	/* If all arguments are BitMaps then do special here */
	 { lbm = (struct V4L__ListBitMap *)&lp->Buffer ;
		lbm1[2-2] = lbm->bm1 ; maxmap = lbm1[2-2]->MaxBit ;
	   targetdim = lp->Dim ;	
	   for(i=3;i<=argcnt;i++)
	    { lp = v4im_VerifyList(NULL,ctx,argpnts[i],intmodx) ;
	      if (lp == NULL)
	       { v_Msg(ctx,NULL,"ModInvArgList2",intmodx,argpnts[i]) ; goto fail ; } ;
	      if (lp->ListType != V4L_ListType_BitMap)
	       goto not_bm ;
	      lbm = (struct V4L__ListBitMap *)&lp->Buffer ;
	      lbm1[i-2] = lbm->bm1 ; if (lbm1[i-2]->MaxBit > maxmap) maxmap = lbm1[i-2]->MaxBit ;
	    } ;
/*	   Create new bitmap & set to value of first one we have (lbm1[0]) */
	   maxmap = BM1_CalcMaxBit(maxmap) ;
	   if (bmat == NULL) bmat = (struct V4L__BMAllocTable *)v4mm_AllocChunk(sizeof *bmat,TRUE) ;
	   if (maxmap <= bmat->Entry[bmat->NextX].maxbit)
	    { nbm1 = bmat->Entry[bmat->NextX].nbm ; memset(nbm1,0,BM1_StructBytes(maxmap)) ;
	    } else
	    { if (bmat->Entry[bmat->NextX].nbm != NULL)
	       v4mm_FreeChunk(bmat->Entry[bmat->NextX].nbm) ;
	      bmat->Entry[bmat->NextX].nbm = (struct V4L__ListBMData1 *)v4mm_AllocChunk(BM1_StructBytes(maxmap),TRUE) ;
	      bmat->Entry[bmat->NextX].maxbit = maxmap ;
	      nbm1 = bmat->Entry[bmat->NextX].nbm ;
	    } ;
	   bmat->NextX = (++bmat->NextX) % V4List_BMEntries ;
	   nbm1->MaxBit = maxmap ; max1 = BM1_MapWord32(nbm1->MaxBit) ;
	   memcpy(&nbm1->Seg32[0],&lbm1[0]->Seg32[0],BM1_MapBytes(maxmap)) ;

/*	   If got a big map & doing intersection then will be faster to do it this way */
	   if (maxmap > 100000 && tag == V4IM_Tag_Intersect && argcnt > 10)
	    { for(max2=max1,i=0;i<argcnt-2;i++) { if (BM1_MapWord32(lbm1[i]->MaxBit) < max2) max2 = BM1_MapWord32(lbm1[i]->MaxBit) ; } ;
	      for(j=0;j<max2;j++)
	       { for(i=0;nbm1->Seg32[j]!=0 && i<=argcnt-2;i++) nbm1->Seg32[j] &= lbm1[i]->Seg32[j] ;
	       } ;
	      for(j=max2;j<max1;j++) nbm1->Seg32[j] = 0 ;
	      goto return_map ;
	    } ;


	   for(i=0;i<=argcnt-2;i++)
	    { 
	      switch (tag)
	       { default:			goto not_bm ;
	         case V4IM_Tag_Union:
		   for(j=0;j<BM1_MapWord32(lbm1[i]->MaxBit);j++) nbm1->Seg32[j] |= lbm1[i]->Seg32[j] ; break ;
	         case V4IM_Tag_XUnion:
		   for(j=0;j<BM1_MapWord32(lbm1[i]->MaxBit);j++) nbm1->Seg32[j] ^= lbm1[i]->Seg32[j] ; break ;
	         case V4IM_Tag_Subtract:
		   for(j=0;j<BM1_MapWord32(lbm1[i]->MaxBit);j++) nbm1->Seg32[j] &= ~lbm1[i]->Seg32[j] ; break ;
	         case V4IM_Tag_Intersect:
		   max2 = BM1_MapWord32(lbm1[i]->MaxBit) ;
		   if (max1 <= max2) 
		    { for(j=0;j<max1;j++) nbm1->Seg32[j] &= lbm1[i]->Seg32[j] ; }
		    else { for(j=0;j<max2;j++) nbm1->Seg32[j] &= lbm1[i]->Seg32[j] ;
			   for(j=max2;j<max1;j++) nbm1->Seg32[j] = 0 ;
			 } ;
		   break ;
	       } ;
	    } ;
/*	   All done - return bitmap nbm1 as List, type V4L_ListType_BitMap */
return_map:
	   INITLP(respnt,lp,Dim_List) lp->ListType = V4L_ListType_BitMap ; lp->Dim = targetdim ;
	   lbm = (struct V4L__ListBitMap *)&lp->Buffer ;
	   memset(lbm,0,sizeof *lbm) ; lbm->LastIndex = UNUSED ; lbm->bm1 = nbm1 ;
	   lp->Bytes = (char *)&lp->Buffer[0] - (char *)lp + sizeof *lbm ;
	   respnt->Bytes = V4DPI_PointHdr_Bytes + lp->Bytes ;
	   return(respnt) ;
	 } ;
not_bm:	vsp = (struct V4IM__SetPoint *)v4mm_AllocChunk(sizeof *vsp,TRUE) ;
	for(i=2;i<=argcnt;i++)
	 { if (memcmp(argpnts[i],&protoNone,V4PS_Int) == 0) continue ;
	   lp = v4im_VerifyList(NULL,ctx,argpnts[i],intmodx) ;
	   if (lp == NULL)
	    { v_Msg(ctx,NULL,"ModInvArgList2",intmodx,argpnts[i]) ; goto fail ; } ;
	   if (!v4im_SetPointLoad(ctx,vsp,lp,argpnts[i]->Dim))
	    { v_Msg(ctx,NULL,"ModFailed2",intmodx) ; goto fail ; } ;
	   if (vsp->ListCount < 2) continue ;		/* Wait until we get at least two lists */
	   switch(tag)
	    { default:	v_Msg(ctx,NULL,"TagNotTag4",intmodx,i,argpnts[i],V4IM_Tag_Union,V4IM_Tag_XUnion,V4IM_Tag_Intersect,V4IM_Tag_Subtract) ; goto fail ;
	      case V4IM_Tag_Union:
		for(k=0;k<V4IM_SetPointMapMax;k++) { vsp->List[0].Map[k] |= vsp->List[vsp->ListCount-1].Map[k] ; } ; break ;
	      case V4IM_Tag_XUnion:
		for(k=0;k<V4IM_SetPointMapMax;k++) { vsp->List[0].Map[k] ^= vsp->List[vsp->ListCount-1].Map[k] ; } ; break ;
	      case V4IM_Tag_Subtract:
		for(k=0;k<V4IM_SetPointMapMax;k++) { vsp->List[0].Map[k] &= ~vsp->List[vsp->ListCount-1].Map[k] ; } ; break ;
	      case V4IM_Tag_Intersect:
		for(k=0;k<V4IM_SetPointMapMax;k++) { vsp->List[0].Map[k] &= vsp->List[vsp->ListCount-1].Map[k] ; } ; break ;
	    } ;
	   vsp->ListCount -- ;		/* We can get rid of last list since List[0] holds result */
	   memset(&vsp->List[vsp->ListCount].Map,0,sizeof vsp->List[vsp->ListCount].Map) ;
	 } ;
	ipt = (struct V4DPI__Point *)v4im_SetPointMakeList(ctx,respnt,vsp,0,TRUE) ; if (ipt == NULL){ v_Msg(ctx,NULL,"LPModFail",intmodx) ; goto fail ; } ;
	v4mm_FreeChunk(vsp) ;
	return(ipt) ;

fail:	REGISTER_ERROR(0) ; return(NULL) ;
}







/*	v4im_ListHandCollapse - Recursive module to collapse/flatten list of lists */

LOGICAL v4im_ListHandCollapse(ctx,lp,pt,action,curlvl,maxlvl)
  struct V4C__Context *ctx ;
  struct V4L__ListPoint *lp ;			/* Append points to this list */
  struct V4DPI__Point *pt ;			/* List of points to be collapsed */
  int action ;					/* How to append: V4L_ListAction_xxx */
  int curlvl ;					/* Current level of collapse */
  int maxlvl ;					/* Max level to collapse */
{ P pnt ;
  struct V4L__ListPoint *lp1 ;
  int i ;

	lp1 = v4im_VerifyList(NULL,ctx,pt,V4IM_OpCode_List) ;
	if (lp1 == NULL) return(TRUE) ;
	for(i=1;v4l_ListPoint_Value(ctx,lp1,i,&pnt) > 0;i++)	/* Loop thru each point in list */
	 { if (pnt.PntType == V4DPI_PntType_List && (maxlvl == UNUSED ? TRUE : curlvl < maxlvl))
	    { if (!v4im_ListHandCollapse(ctx,lp,&pnt,action,curlvl+1,maxlvl)) return(FALSE) ; }
	    else { if (!v4l_ListPoint_Modify(ctx,lp,action,&pnt,0)) return(FALSE) ; } ;
	 } ;
	return(TRUE) ;
}


/*	v4im_SetPointLoad - Loads list into structure		*/
/*	Call: ok = v4im_SetPointLoad( ctx , vsp , listp , dimid )
	  where ctx is context,
		vsp is pointer to V4IM__SetPoint,
		listp is list pointer to be loaded,
		dimid is dimension of the list			*/

int v4im_SetPointLoad(ctx,vsp,listp,dimid)
  struct V4C__Context *ctx ;
  struct V4IM__SetPoint *vsp ;
  struct V4L__ListPoint *listp ;
  int dimid ;
{ struct V4DPI__Point spnt,*tpt ;
  struct V4IM__SetPointBuf *vspb ;	/* Pointer to current point buffer */
  int j,k,hash,hx,*iptr ;

	if (vsp->ListCount >= V4IM_SetPointListMax)
	 { v_Msg(ctx,ctx->ErrorMsgAux,"ListTooMany",V4IM_SetPointListMax) ; return(FALSE) ; } ;
	if (vsp->vspb == NULL) vsp->vspb = (struct V4IM__SetPointBuf *)v4mm_AllocChunk(sizeof *vsp->vspb,TRUE) ;
	for(j=1;;j++)	/* Loop thru each point in list */
	 { 
	   if (v4l_ListPoint_Value(ctx,listp,j,&spnt) <= 0) break ;	/* Get next point in list */
	   hash = 0 ; iptr = (int *)&spnt ;
	   for(k=1;k<=(int)(spnt.Bytes/sizeof(int));k++) { hash += *(iptr++) * k ; } ; /* Hash the point */
	   if (hash < 0) hash &= 0x7fffffff ; hx = hash % V4IM_SetPointMax ;
	   for(;;)
	    { if (vsp->pt[hx] == NULL) break ;		/* Empty slot - use it */
	      if (vsp->Hash[hx] == hash)
	       { if (memcmp(vsp->pt[hx],&spnt,spnt.Bytes) == 0) break ; } ;	/* Got a match - use it */
	      hx = (hx + 1) % V4IM_SetPointMax ;	/* Try again */
	    } ;
	   if (vsp->pt[hx] == NULL)			/* Have to add new point? */
	    { if (++vsp->Count >= V4IM_SetPointMax)
	       { v_Msg(ctx,ctx->ErrorMsgAux,"ListPtMax",V4IM_SetPointMax) ; return(FALSE) ; } ;
	      if (vsp->vspb->NextFree + spnt.Bytes + 20 >= V4IM_SetPointBufSize)
	       { vspb = (struct V4IM__SetPointBuf *)v4mm_AllocChunk(sizeof *vsp->vspb,TRUE) ;
	         vspb->Prior = vsp->vspb ; vsp->vspb = vspb ;	/* No more room - link up to free one */
	       } ;
	      tpt = (struct V4DPI__Point *)&vsp->vspb->Buf[vsp->vspb->NextFree] ; memcpy(tpt,&spnt,spnt.Bytes) ;
	      vsp->vspb->NextFree += tpt->Bytes ;				/* Advance by number of bytes */
	      vsp->pt[hx] = tpt ; vsp->Hash[hx] = hash ;
	    } ;
	   vsp->List[vsp->ListCount].Map[hx/32] |= (1 << (hx%32)) ;		/* Set proper bit */
	 } ;
	vsp->List[vsp->ListCount].Dim = dimid ;
	vsp->ListCount++ ;			/* Increment list count */
	return(TRUE) ;
}

/*	v4im_SetPointMakeList - Creates list from one of the maps	*/
/*	Call: listpt = v4im_SetPointMakeList( ctx , respt , vsp , index , done )
	  where listpt is resulting list point,
		ctx is context,
		respt is point to point buffer to use,
		vsp is V4IM__SetPoint with appropriate info,
		index is index to list to use,
		done is TRUE to deallocate everything			*/

struct V4DPI__Point *v4im_SetPointMakeList(ctx,respt,vsp,index,done)
  struct V4C__Context *ctx ;
  struct V4DPI__Point *respt ;
  struct V4IM__SetPoint *vsp ;
  int index ;
  LOGICAL done ;
{
  struct V4IM__SetPointBuf *vspb,*vspbx ;
  struct V4L__ListPoint *lp ;
  int w,b,hx ;

	ZPH(respt) ;
	lp = ALIGNLP(&respt->Value) ;	/* Link up list structure */
	memset(lp,0,(char *)&lp->Buffer - (char *)lp) ; lp->ListType = V4L_ListType_Point ;
	respt->PntType = V4DPI_PntType_List ;
//	respt->Dim = vsp->List[index].Dim ;		VEH130819 - return point on Dim:List
	respt->Dim = Dim_List ;
	for(w=0;w<V4IM_SetPointMapMax;w++)		/* Got through map for wanted list & build new list */
	 { if (vsp->List[index].Map[w] == 0) continue ;	/* Nothing in these 32 bits of map */
	   for(b=0;b<32;b++)
	    { if (!(vsp->List[index].Map[w] & (1<<b))) continue ;
	      hx = (w*32 + b) ;				/* Convert map position to hx */
	      if (!v4l_ListPoint_Modify(ctx,lp,V4L_ListAction_Append,vsp->pt[hx],0)) return(NULL) ;
	    } ;
	 } ;
	respt->Bytes = ALIGN((char *)&respt->Value.AlphaVal[lp->Bytes] - (char *)respt) ;
	if (respt->Bytes < V4DPI_PointHdr_Bytes + ((char *)&lp->Buffer[0] - (char *)lp))
	respt->Bytes = V4DPI_PointHdr_Bytes + ((char *)&lp->Buffer[0] - (char *)lp) ;	/* Make sure min size */
	if (done)					/* If all done then deallocate stuff */
	 { for(vspb=vsp->vspb;vspb!=NULL;)
	    { vspbx = vspb->Prior ; v4mm_FreeChunk(vspb) ; vspb = vspbx ; } ;
	 } ;
	return(respt) ;
}

#ifdef WANTIMCACHE
/*	v4im_IMCache - Handles Cache() IntMod				*/
/*	Call:	respt = v4im_IMCache(ctx , respnt , respt , argcnt , argpnts , intmodx , trace )
	  where respt is resulting point/buffer,
		ctx is context,
		respnt is ptr for result,
		argcnt/argpnts are arguments to intmod,
		intmodx is opcode index,
		trace is trace flag					*/

#define V4IM_IMCachePointMax 3		/* Max number of points in cacheable isct */
#define V4IM_IMCacheEntryMax 5003	/* Number of entries in cache */

P *v4im_IMCache(ctx,respnt,argcnt,argpnts,intmodx,trace)
  struct V4C__Context *ctx ;
  P *respnt,*argpnts[] ;
  int argcnt,intmodx,trace ;
{ struct lcl__IMCacheEntry {
    int HashVal ;				/* Hash value for entry */
    int Count ;					/* Count of Dim/Pt's below */
    int Dims[V4IM_IMCachePointMax] ;		/* Dim Values for each */
    int PtIntVals[V4IM_IMCachePointMax] ;	/* Integer values for each dim */
    struct V4DPI__LittlePoint Value ;		/* Resulting value */
   } ;
  struct lcl__IMCache {
    struct lcl__IMCacheEntry Entry[V4IM_IMCacheEntryMax] ;
   } ;
  static struct lcl__IMCache *lic=NULL ;
  struct lcl__IMCacheEntry lice ;		/* Temp entry for building up from arguments */
  P isct,*tpt,*apt,*cpt ;
  int i,hx ;

	gpi->CacheCalls++ ;
	if (lic == NULL) lic = (struct lcl__IMCache *)v4mm_AllocChunk(sizeof *lic,TRUE) ;
	memset(&lice,0,sizeof lice) ;
	if (argcnt == 1 && argpnts[1]->PntType == V4DPI_PntType_Isct)	/* If first/only arg is isct then handle here */
	 { tpt = argpnts[1] ; apt = ISCT1STPNT(tpt) ;
	   lice.Count = tpt->Grouping ;
	   for(i=1;i<=lice.Count && i <= V4IM_IMCachePointMax;i++)	/* Loop thru each point in isct */
	    { if (apt->PntType == V4DPI_PntType_Special && apt->Grouping == V4DPI_Grouping_Current)
	       { DIMVAL(cpt,ctx,apt->Dim) ;
	         if (cpt == NULL) goto doEvalI ;
		 lice.PtIntVals[i-1] = cpt->Value.IntVal ;
		 if (cpt->PntType == V4DPI_PntType_AggRef) lice.PtIntVals[i-1] |= (cpt->Grouping << 24) ;	/* If AggRef, factor in area */
	       } else
	       { lice.PtIntVals[i-1] = apt->Value.IntVal ;
		 if (apt->PntType == V4DPI_PntType_AggRef) lice.PtIntVals[i-1] |= (apt->Grouping << 24) ;	/* If AggRef, factor in area */
	       } ;
	      lice.Dims[i-1] = apt->Dim ;
	      lice.HashVal += (lice.PtIntVals[i-1] + apt->Dim) * (apt->Dim - i) ;
	      ADVPNT(apt) ;
	    } ;
	   if (tpt->Grouping > V4IM_IMCachePointMax) goto doEvalI ;	/* Too many pts in isct - can't do it */
	   hx = lice.HashVal % V4IM_IMCacheEntryMax ; if (hx < 0) hx = -hx ;	/* Get hash index */
	   if (lice.HashVal == lic->Entry[hx].HashVal)			/* Hash values match? */
	    { if (memcmp(&lice.Dims,&lic->Entry[hx].Dims,sizeof lice.Dims) == 0 ?
			memcmp(&lice.PtIntVals,&lic->Entry[hx].PtIntVals,sizeof lice.PtIntVals) == 0 : FALSE)
	       { 
/* printf("Hit: %d  + %s = hx=%d\n",lice.PtIntVals[0],v4dpi_RevDictEntryGet(ctx,lice.PtIntVals[1]),hx) ; */
		 gpi->CacheHits++ ; return((P *)&lic->Entry[hx].Value) ;		/* Everything matches - return result in cache! */
	       } ;
	    } ;
/*	   If here did not find in cache - evaluate result & maybe save in cache */
doEvalI:
	   tpt = respnt ;
	   tpt = v4dpi_IsctEval(tpt,argpnts[1],ctx,V4DPI_EM_EvalQuote,NULL,NULL) ;
	   if (tpt == NULL) return(NULL) ;		/* Could not evaluate - then nothing to cache */
	   if (argpnts[1]->Grouping > V4IM_IMCachePointMax)
	    return(tpt) ;				/* If too many points then return - can't save in cache */
	   if (tpt->Bytes > V4DPI_PointHdr_Bytes + V4DPI_LittleAlpha_Max)
	    return(tpt) ;				/* Result is too large to store in cache */
	   memcpy(&lice.Value,tpt,tpt->Bytes) ;
/* printf(" %d  + %s = hx=%d -> %d + %s\n",lice.PtIntVals[0],v4dpi_RevDictEntryGet(ctx,lice.PtIntVals[1]),hx,lic->Entry[hx].PtIntVals[0],v4dpi_RevDictEntryGet(ctx,lic->Entry[hx].PtIntVals[1])) ; */
	   lic->Entry[hx] = lice ;			/* Copy entry into cache */
	   return(tpt) ;
	 } ;
/*	Loop thru arguments - build up isct & local cache entry (lice) */
	INITISCT(&isct) ; NOISCTVCD(&isct) ;
	for(i=1,tpt=ISCT1STPNT(&isct);i<=argcnt;i++)
	 { apt = argpnts[i] ;			/* Get next argument */
	   memcpy(tpt,apt,apt->Bytes) ; ADVPNT(tpt) ;
	   isct.Grouping ++ ;			/* Append next point in isct */
	   if (i > V4IM_IMCachePointMax) continue ;
	   lice.Dims[i-1] = apt->Dim ; lice.PtIntVals[i-1] = apt->Value.IntVal ;
	   if (apt->PntType == V4DPI_PntType_AggRef) lice.PtIntVals[i-1] |= (apt->Grouping << 24) ;	/* If AggRef, factor in area */
	   lice.HashVal += (lice.PtIntVals[i-1] + apt->Dim) * (apt->Dim - i) ;
	 } ; ISCTLEN(&isct,tpt) ;
	if (argcnt > V4IM_IMCachePointMax) goto doEval ;	/* Too many pts in isct - can't do it */
	hx = lice.HashVal % V4IM_IMCacheEntryMax ; if (hx < 0) hx = -hx ;	/* Get hash index */
	if (lice.HashVal == lic->Entry[hx].HashVal)	/* Hash values match? */
	 { if (memcmp(&lice.Dims,&lic->Entry[hx].Dims,sizeof lice.Dims) == 0
		 && memcmp(&lice.PtIntVals,&lic->Entry[hx].PtIntVals,sizeof lice.PtIntVals) == 0)
	    { gpi->CacheHits++ ; return((P *)&lic->Entry[hx].Value) ;		/* Everything matches - return result in cache! */
	    } ;
	 } ;
/*	If here did not find in cache - evaluate result & maybe save in cache */
doEval:
	tpt = respnt ;
	tpt = v4dpi_IsctEval(tpt,&isct,ctx,0,0,NULL) ;
	if (tpt == NULL) return(NULL) ;		/* Could not evaluate - then nothing to cache */
	if (argcnt > V4IM_IMCachePointMax)
	 return(tpt) ;				/* If too many points then return - can't save in cache */
	if (tpt->Bytes > V4DPI_PointHdr_Bytes + V4DPI_LittleAlpha_Max)
	 return(tpt) ;				/* Result is too large to store in cache */
	memcpy(&lice.Value,tpt,tpt->Bytes) ;
	lic->Entry[hx] = lice ;			/* Copy entry into cache */
	return(tpt) ;
}
#endif

/*	v4im_TagId - Returns V4 Tag Code Associated with a point	*/
/*	Call:	result = v4im_TagId( pt )
	  where result is +/-n if tagged value, 0 if not a tag,
		pt is point to be examined				*/

int v4im_TagId(pt)
  P *pt ;
{ struct V4DPI__TagVal *tv ;				/* Structure of a tagged value */

	if (pt->PntType != V4DPI_PntType_TagVal) return(0) ;
	tv = (struct V4DPI__TagVal *)&pt->Value ;
	return(pt->ForceEval ? -(tv->TagVal & V4DPI_TagFlag_MaskOut) : (tv->TagVal & V4DPI_TagFlag_MaskOut)) ;

}

int v4im_LastTagNum ;			/* Global set to last tag code (for v4im_LastTagName()) */

int v4im_CheckPtArgNew(ctx,pt,respt,evalpt)
  struct V4C__Context *ctx ;
  P *pt ;
  P **respt ;
  P *evalpt ;
{ P *rpt ;
  static struct V4DPI__Point *spnt ;
  struct V4DPI__TagVal *tv ;				/* Structure of a tagged value */
  int ok ;

	switch(pt->PntType)
	 { default:
	 	v_Msg(ctx,ctx->ErrorMsgAux,"TagPtNotTag",pt) ; return(V4IM_Tag_Unk) ;		/* Unknown point type */
	   case V4DPI_PntType_Dict:			/* Look for Dim:xxx */
		if (pt->Dim != Dim_Dim) { v_Msg(ctx,ctx->ErrorMsgAux,"TagPtNotTag",pt) ; return(V4IM_Tag_Unk) ; } ;
		if (respt != NULL) *respt = pt ;
		return(v4im_LastTagNum=V4IM_Tag_Dim) ;
	   case V4DPI_PntType_TagVal:
		tv = (struct V4DPI__TagVal *)&pt->Value ;
		if (pt->ForceEval) return(v4im_LastTagNum=-(tv->TagVal & V4DPI_TagFlag_MaskOut)) ;		/* If got tag? then return -index */
		rpt = &tv->TagPt ;
		if (evalpt != NULL)		/* Maybe evaluate tag point? */
		 { 
		   switch(tv->TagPt.PntType)
		    { 
		      case V4DPI_PntType_Special:
		      case V4DPI_PntType_SymDef:
		      case V4DPI_PntType_Isct:
			switch(tv->TagVal & V4DPI_TagFlag_MaskOut)
			 { default:
				if (ISQUOTED(&tv->TagPt)) break ;
				rpt = v4dpi_IsctEval(evalpt,&tv->TagPt,ctx,0,NULL,NULL) ;
				if (rpt == NULL) { v_Msg(ctx,ctx->ErrorMsgAux,"TagNoEval",pt) ; return(V4IM_Tag_Unk) ; } ;
				if (rpt->PntType == V4DPI_PntType_Shell) rpt = (P *)&rpt->Value ;
//veh121011 - If result is list then also carry forceeval flag (primarily for Message(Send::`List*))
if (rpt->PntType == V4DPI_PntType_List)
 rpt->ForceEval = tv->TagPt.ForceEval ;
				break ;
			   case V4IM_Tag_If: case V4IM_Tag_While: case V4IM_Tag_Parent: case V4IM_Tag_PIf:
			   case V4IM_Tag_Maximum: case V4IM_Tag_Minimum: case V4IM_Tag_Group: case V4IM_Tag_Error: break ;
			 }
			break ;
		    } ;
		 } else				/* Don't have evalpt - maybe evaluate isct if force-eval flag set */
		 { if (tv->TagPt.ForceEval && !ISQUOTED(&tv->TagPt))
		    { spnt = v4dpi_PntIdx_CvtIdxPtr(v4dpi_PntIdx_AllocPnt()) ;
		      rpt = v4dpi_IsctEval(spnt,&tv->TagPt,ctx,0,NULL,NULL) ;
		      if (rpt == NULL) { v_Msg(ctx,ctx->ErrorMsgAux,"TagNoEval",pt) ; return(V4IM_Tag_Unk) ; } ;
		    } ;
		 } ;
		if ((tv->TagVal & V4DPI_TagFlag_MaskOut) == V4IM_Tag_Dim)				/* Got Dim::xxx - try to make sense of it */
		 { if (rpt->Dim != Dim_Dim)
		    { UCCHAR dimname[V4DPI_DimInfo_DimNameMax+1] ;
		      P *dlp = v4dpi_PntIdx_CvtIdxPtr(v4dpi_PntIdx_AllocPnt()) ; ;
		      v4im_GetPointUC(&ok,dimname,V4DPI_DimInfo_DimNameMax,rpt,ctx) ;
		      if (!ok) { UCstrcpy(UCTBUF1,ctx->ErrorMsgAux) ; v_Msg(ctx,ctx->ErrorMsgAux,"TagNotDim",rpt,UCTBUF1) ; return(V4IM_Tag_Unk) ; } ;
		      if ((dlp->Value.IntVal = v4dpi_DimGet(ctx,dimname,DIMREF_IRT)) == 0)
		       { v_Msg(ctx,ctx->ErrorMsgAux,"TagNotDim2",dimname) ; return(V4IM_Tag_Unk) ; } ;
		      if (dlp->Dim != Dim_Dim) { dictPNT(dlp,Dim_Dim) ; } ;
		      if (respt != NULL) *respt = (P *)dlp ; return(v4im_LastTagNum=V4IM_Tag_Dim) ;
		    } ;
		 } ;
		if (respt != NULL) *respt = rpt ;
		return(v4im_LastTagNum=tv->TagVal) ;
	   case V4DPI_PntType_List:
		if (respt != NULL) *respt = pt ;
		return(v4im_LastTagNum=V4IM_Tag_List) ;
#ifdef NEWQUOTE
	   case V4DPI_PntType_Shell:
		if (pt->Dim != Dim_UQuote)
		 { v_Msg(ctx,ctx->ErrorMsgAux,"TagPtNotTag",pt) ; return(V4IM_Tag_Unk) ; } ;	/* Treat as unknown point type */
		if (respt != NULL) *respt = pt ;
		return(v4im_LastTagNum=V4IM_Tag_QIsct) ;	
#endif
	   case V4DPI_PntType_QIsct:
	   case V4DPI_PntType_Isct:
	   case V4DPI_PntType_BigIsct:
		if (respt != NULL) *respt = pt ;
		return(v4im_LastTagNum=V4IM_Tag_QIsct) ;
	 } ;
}

UCCHAR *v4im_LastTagName()
{
	return(v4im_TagName(v4im_LastTagNum)) ;
}


P *v4im_DoDTInfo(ctx,respnt,intmodx,argpnts,argcnt)
  struct V4C__Context *ctx ;
  P *respnt ;						/* Ptr for result */
  INTMODX intmodx ;
  P *argpnts[] ;
  COUNTER argcnt ;
{ P *ipt,*rpt,*cpt,pnt ;
  struct V4DPI__LittlePoint lpt,iptSave ;
  int ax,i,t,res=0,tres,m,d,y,w,h,s,ymd,ok,ud,delta,dtype,gotToByNum ; double dnum,fpart,ipart,lat,lon ; CALENDAR caldt ;
  int BaseDate=0,BaseMonth=0 ;
  struct V4Cal__Args cal,cal1 ;
#define CalNYI v_Msg(ctx,NULL,"CalPtNYI",intmodx) ; goto dtinfo_fail ;


	ipt = (P *)&iptSave ; memcpy(ipt,argpnts[1],argpnts[1]->Bytes) ;	/* Make copy of first argument because it can be updated for chaining */
	switch(ipt->PntType)
	 { default:
	    if (v4im_CheckPtArgNew(ctx,ipt,&cpt,&pnt) == V4IM_Tag_POSIX)	/* Allow first argument to be POSIX::nnnn */
	     { ipt->Value.IntVal = POSIXtoUDT(v4im_GetPointInt(&ok,cpt,ctx)) ;
	       if (!ok) { v_Msg(ctx,NULL,"ModInvArg",intmodx,1) ; goto dtinfo_fail ; } ;
	       ipt->PntType = V4DPI_PntType_UDT ; ipt->Dim = Dim_UDT ; dtype = 1 ;
	       if (argcnt == 1) { memcpy(respnt,ipt,ipt->Bytes) ; return(respnt) ; } ;
	       break ;
	     } ;
	    v_Msg(ctx,NULL,"DTInfo1stDim",intmodx,argpnts[1],argpnts[1]->PntType) ; goto dtinfo_fail ; 
	   case V4DPI_PntType_UDT:
	   case V4DPI_PntType_UDate:
	   case V4DPI_PntType_UWeek:
	   case V4DPI_PntType_UMonth:
	   case V4DPI_PntType_UPeriod:
	   case V4DPI_PntType_UQuarter:
	   case V4DPI_PntType_UYear:
	   case V4DPI_PntType_UTime:
	   case V4DPI_PntType_Time:		dtype = 1 ; break ;
	   case V4DPI_PntType_Calendar:		dtype = 2 ; break ;
	 } ;
	gotToByNum = FALSE ;
	for(ax=2,ok=TRUE;ok&&ax<=argcnt;ax++)
	 { tres = 0 ;
	   switch (t=v4im_CheckPtArgNew(ctx,argpnts[ax],&cpt,&pnt))
	    { default:			v_Msg(ctx,NULL,"TagBadUse",intmodx) ; goto dtinfo_fail ;
	      case V4IM_Tag_Unk:	v_Msg(ctx,NULL,"TagUnknown",intmodx) ; goto dtinfo_fail ;
	      case V4IM_Tag_Round:
		memcpy(&lpt,ipt,ipt->Bytes) ; ipt = (P *)&lpt ;	/* Get copy of ipt */
		switch(ipt->PntType)
		 { default:
			v_Msg(ctx,NULL,"DTInfoInvAdj",intmodx,V4IM_Tag_Round,ipt->PntType) ; goto dtinfo_fail ;
		   case V4DPI_PntType_UDT:			/* Round UDT to nearest number of minutes */
			ipt->Value.IntVal /= 60 ;		/* Get rid of seconds */
			t = v4im_GetPointInt(&ok,cpt,ctx) ; if (!ok) continue ;	/* t = minutes to round to */
			ipt->Value.IntVal += (t/2) ;
			ipt->Value.IntVal /= t ; ipt->Value.IntVal *= t ;
			ipt->Value.IntVal *= 60 ;		/* Put back seconds */
			break ;
		   case V4DPI_PntType_UTime:			/* Round Time to nearest number of minutes */
			GETREAL(dnum,ipt) ; ipt->Value.IntVal = dnum ;
			ipt->Value.IntVal /= 60 ;		/* Get rid of seconds */
			t = v4im_GetPointInt(&ok,cpt,ctx) ; if (!ok) continue ;	/* t = minutes to round to */
			ipt->Value.IntVal += (t/2) ;
			ipt->Value.IntVal /= t ; ipt->Value.IntVal *= t ;
			ipt->Value.IntVal *= 60 ;		/* Put back seconds */
			break ;
		 } ;
		break ;
	      case V4IM_Tag_Age:
		switch(ipt->PntType)
		 { default:			v_Msg(ctx,NULL,"DTInfoTagRes",intmodx,res,ipt->PntType) ; goto dtinfo_fail ; 
		   case V4DPI_PntType_Calendar:	GETREAL(caldt,ipt) ; break ;
		   case V4DPI_PntType_UDate:	caldt = ipt->Value.IntVal + VCal_MJDOffset ; break ;
		 } ;
		GregorianFromFixed((int)caldt,&cal) ;
		switch(cpt->PntType)
		 { default:			v_Msg(ctx,NULL,"DTInfoTagRes",intmodx,res,cpt->PntType) ; goto dtinfo_fail ; 
		   case V4DPI_PntType_Calendar:	GETREAL(caldt,cpt) ; break ;
		   case V4DPI_PntType_UDate:	caldt = cpt->Value.IntVal + VCal_MJDOffset ; break ;
		 } ;
		GregorianFromFixed((int)caldt,&cal1) ;
		if (cal.Month < cal1.Month ? TRUE : (cal.Month == cal1.Month ? cal.Day < cal1.Day : FALSE)) cal.Year-- ;
		intPNTv(respnt,cal.Year-cal1.Year) ;
		return(respnt) ;
	      case V4IM_Tag_Calc:
		switch (ipt->PntType)
		 { default:			v_Msg(ctx,NULL,"DTInfoTagRes",intmodx,t,ipt->PntType) ; goto dtinfo_fail ; 
		   case V4DPI_PntType_UDate:
		   case V4DPI_PntType_UMonth:
		   case V4DPI_PntType_UQuarter:
		   case V4DPI_PntType_UYear:	break ;
		 } ;
		{ UCCHAR calbuf[1024] ; int newVal ; PNTTYPE newPntType ;
		  v4im_GetPointUC(&ok,calbuf,UCsizeof(calbuf),cpt,ctx) ; if (!ok) break ;
		  if (v_CalCalc(ctx,calbuf,ipt->Value.IntVal,ipt->PntType,&newVal,&newPntType,TRUE) == NULL)
		   { v_Msg(ctx,NULL,"ModFailed2",intmodx) ; goto dtinfo_fail ; } ;
		  if (ipt->PntType != newPntType)
		   { ipt->PntType = newPntType ;	/* Have to flip point type AND dimension */
		     switch (ipt->PntType)
		      { case V4DPI_PntType_UDate:	ipt->Dim = Dim_UDate ; break ;
			case V4DPI_PntType_UMonth:	ipt->Dim = Dim_UMonth ; break ;
			case V4DPI_PntType_UQuarter:	ipt->Dim = Dim_UQuarter ; break ;
			case V4DPI_PntType_UYear:	ipt->Dim = Dim_UYear ; break ;
		      } ;
		   } ;
		  ipt->Value.IntVal = newVal ;
		}
		continue ;
	      case -V4IM_Tag_Num:	/* Handle all these tags via Num() */
	      case -V4IM_Tag_Number:
	      case V4IM_Tag_Num:
	      case V4IM_Tag_Number:
	      case -V4IM_Tag_To:
	      case V4IM_Tag_By:
		gotToByNum = TRUE ; break ;
	      case V4IM_Tag_To:
		if (cpt->PntType != argpnts[1]->PntType) { v_Msg(ctx,NULL,"DTInfoToVal",intmodx,V4IM_Tag_To,cpt,cpt->PntType,argpnts[1],argpnts[1]->PntType) ; goto dtinfo_fail ; } ;
		gotToByNum = TRUE ; break ;
	      case V4IM_Tag_LunarPhase:
		dnum = v4im_GetPointDbl(&ok,cpt,ctx) ; if (!ok) break ;
		switch(ipt->PntType)
		 { default:			v_Msg(ctx,NULL,"DTInfoTagRes",intmodx,res,ipt->PntType) ; goto dtinfo_fail ; 
		   case V4DPI_PntType_Calendar:	GETREAL(caldt,ipt) ; break ;
		   case V4DPI_PntType_UDate:	caldt = ipt->Value.IntVal + VCal_MJDOffset ; break ;
		   case V4DPI_PntType_UDT:	caldt = (double)ipt->Value.IntVal/(double)VCAL_SecsInDay + VCAL_UDTUDateOffset + VCal_MJDOffset ; break ;
		 } ;
		if (dnum >= 0.0) { dnum = LunarPhaseAfter(caldt,dnum) ; }
		 else { dnum = LunarPhaseBefore(caldt,-dnum) ; }
		memcpy(respnt,ipt,V4DPI_PointHdr_Bytes) ;
		switch(ipt->PntType)
		 { default:			v_Msg(ctx,NULL,"DTInfoTagRes",intmodx,res,ipt->PntType) ; goto dtinfo_fail ; 
		   case V4DPI_PntType_Calendar:	PUTREAL(respnt,dnum) ; break ;
		   case V4DPI_PntType_UDate:	respnt->Value.IntVal = vcal_CalToUDate(dnum,0,&ok) ; break ;
		   case V4DPI_PntType_UDT:	respnt->Value.IntVal = vcal_CalToUDT(dnum,0,&i) ;
						if (respnt->Value.IntVal < 0) respnt->Value.IntVal = VCAL_UDT_None ; break ;
		 } ;
		if (ok) return(respnt) ;
		break ;
	      case V4IM_Tag_SolarLongitude:
		dnum = v4im_GetPointDbl(&ok,cpt,ctx) ; if (!ok) break ;
		caldt = v4im_GetPointCal(&ok,ipt,ctx) ; if (!ok) break ;
		if (dnum >= 0.0) { dnum = SolarLongitudeAfter(caldt,dnum) ; }
		 else { dnum = SolarLongitudeBefore(caldt,-dnum) ; }
		memcpy(respnt,ipt,V4DPI_PointHdr_Bytes) ;
		switch(ipt->PntType)
		 { default:			v_Msg(ctx,NULL,"DTInfoTagRes",intmodx,res,ipt->PntType) ; goto dtinfo_fail ; 
		   case V4DPI_PntType_Calendar:	PUTREAL(respnt,dnum) ; break ;
		   case V4DPI_PntType_UDate:	respnt->Value.IntVal = vcal_CalToUDate(dnum,0,&ok) ; break ;
		   case V4DPI_PntType_UDT:	respnt->Value.IntVal = vcal_CalToUDT(dnum,0,&i) ;
						if (respnt->Value.IntVal < 0) respnt->Value.IntVal = VCAL_UDT_None ; break ;
		 } ;
		if (ok) return(respnt) ;
		break ;
	      case V4IM_Tag_LunarAltitude:
		if (cpt->PntType != V4DPI_PntType_GeoCoord) { v_Msg(ctx,NULL,"ModArgPntType2",intmodx,ax,cpt->PntType,V4DPI_PntType_GeoCoord) ; goto dtinfo_fail ; } ;
		lat = GETGEOLAT(&cpt->Value.GeoCoord) ;
		lon = GETGEOLON(&cpt->Value.GeoCoord.Coord2) ;
		caldt = v4im_GetPointCal(&ok,ipt,ctx) ; if (!ok) break ;
		dnum = LunarAltitude(caldt,lat,lon) ; dblPNTv(respnt,dnum) ;
		return(respnt) ;
	      case V4IM_Tag_UTime:
		if (cpt->PntType != ipt->PntType)
		 { v_Msg(ctx,NULL,"DTInfoToVal",intmodx,V4IM_Tag_UTime,cpt,cpt->PntType,ipt,ipt->PntType) ; goto dtinfo_fail ; } ;
		switch (ipt->PntType)
		 { default:	v_Msg(ctx,NULL,"DTInfoConvert",intmodx,ipt,V4DPI_PntType_UTime) ; goto dtinfo_fail ;
		   case V4DPI_PntType_UDate:
			dnum = (ipt->Value.IntVal - cpt->Value.IntVal) * (24 * 60 * 60) ; break ;
		   case V4DPI_PntType_UDT:
			dnum = (ipt->Value.IntVal - cpt->Value.IntVal) ; break ;
		   case V4DPI_PntType_Calendar:
			GETREAL(dnum,ipt) ; GETREAL(caldt,cpt) ;
			dnum = (dnum - caldt) * (24 * 60 * 60) ; break ;
		   case V4DPI_PntType_UTime:
			GETREAL(dnum,ipt) ; GETREAL(caldt,cpt) ;
			dnum = dnum - caldt ; break ;
		 } ;
		if (dnum < 0) dnum = -dnum ;		/* Always want absolute value */
		ZPH(respnt) ; PUTREAL(respnt,dnum) ;
		respnt->PntType = V4DPI_PntType_UTime ; respnt->Dim = Dim_UTime ; respnt->Bytes = V4PS_UTime ;
		return(respnt) ; 
	      case V4IM_Tag_DayOfWeek:
		delta = (cpt->PntType == V4DPI_PntType_Delta) ;
		d = v4im_GetPointInt(&ok,cpt,ctx) ; if (!ok) break ;
		if (d < -7 || d == 0 || d > 7)
		 { ok = FALSE ; v_Msg(ctx,ctx->ErrorMsgAux,"DTInfoTagVal2",intmodx,V4IM_Tag_DayOfWeek,d,1,7) ; continue ; } ;
		memcpy(&lpt,ipt,ipt->Bytes) ; ipt = (P *)&lpt ;	/* Get copy of ipt */
		switch(ipt->PntType)
		 { default:
			v_Msg(ctx,NULL,"DTInfoTagRes",intmodx,V4IM_Tag_DayOfWeek,ipt->PntType) ; goto dtinfo_fail ; 
		   case V4DPI_PntType_Calendar:
			GETREAL(dnum,ipt) ;
			fpart = modf(dnum,&ipart) ;
			if (delta || d < 0)
			 { if (d < 0) { dnum = (double)KDayOnOrBefore((int)ipart,-d) ; }
			    else { dnum = (double)KDayOnOrAfter((int)ipart,d) ; } ;
			 } else
			 { caldt = (double)KDayOnOrBefore((int)ipart,d) ;
			   if ((int)ipart - (int)caldt <= 3) { dnum = caldt ; }
			    else { dnum = (double)KDayOnOrAfter((int)ipart,d) ; } ;
			 } ;
			dnum += fpart ; PUTREAL(ipt,dnum) ;
			break ;
		   case V4DPI_PntType_UDate:
			if (delta || d < 0)
			{ if (d < 0) { d = -d ; ipt->Value.IntVal -= 6 ; } ;
			  t = ((ipt->Value.IntVal+1)%7)+1 ;	/* t = current day of week */
			  d -= t ; if (d < 0) d += 7 ;
			} else
			{ t = ((ipt->Value.IntVal+1)%7)+1 ; t = d - t ; if (t < 0) t += 7 ;
			  if (t <= 3) { d = t ; }
			   else { ipt->Value.IntVal -= 6 ; t = ((ipt->Value.IntVal+1)%7)+1 ; d -= t ; if (d < 0) d += 7 ; } ;
			} ;
			ipt->Value.IntVal += d ;
			break ;
		   case V4DPI_PntType_UDT:
			if (delta || d < 0)
			 { if (d < 0) { d = -d ; ipt->Value.IntVal -= (6 * VCAL_SecsInDay) ; } ;
			   t = (((ipt->Value.IntVal / VCAL_SecsInDay + VCAL_UDTUDateOffset)+1)%7)+1 ;
			   d -= t ; if (d < 0) d += 7 ;
			 } else
			 { t = (((ipt->Value.IntVal / VCAL_SecsInDay + VCAL_UDTUDateOffset)+1)%7)+1 ;
			   t = d - t ; if (t < 0) t += 7 ;
			  if (t <= 3) { d = t ; }
			   else { ipt->Value.IntVal -= (6 * VCAL_SecsInDay) ; t = (((ipt->Value.IntVal / VCAL_SecsInDay + VCAL_UDTUDateOffset)+1)%7)+1  ;
				  d -= t ; if (d < 0) d += 7 ;
				} ;
			 } ;
			ipt->Value.IntVal += (d * VCAL_SecsInDay) ; ;
			break ;
	         } ;
		continue ; 
	      case V4IM_Tag_Week:
		memcpy(&lpt,ipt,ipt->Bytes) ; ipt = (P *)&lpt ;	/* Get copy of ipt */
		switch(ipt->PntType)
		 { default:
			v_Msg(ctx,NULL,"DTInfoInvAdj",intmodx,V4IM_Tag_Week,ipt->PntType) ; goto dtinfo_fail ;
		   case V4DPI_PntType_UWeek:
			y = ipt->Value.IntVal/52 + VCAL_BaseYear ; w = ipt->Value.IntVal % 52 ;
			if (cpt->PntType == V4DPI_PntType_Delta)
			 { w += cpt->Value.IntVal ;
			 } else { w = cpt->Value.IntVal ; } ;
			if (w < 1 || w > 52) { v_Msg(ctx,NULL,"DTInfoTagVal",intmodx,V4IM_Tag_Week,w,1,52) ; goto dtinfo_fail ; } ;
			ipt->Value.IntVal = (y-VCAL_BaseYear)*52 + w-1 ;
			break ;
		 } ;
		break ;
	      case V4IM_Tag_Year:
		memcpy(&lpt,ipt,ipt->Bytes) ; ipt = (P *)&lpt ;	/* Get copy of ipt */
		switch(ipt->PntType)
		 { default:
			v_Msg(ctx,NULL,"DTInfoInvAdj",intmodx,V4IM_Tag_Year,ipt->PntType) ; goto dtinfo_fail ;
		   case V4DPI_PntType_UMonth:
			y = ipt->Value.IntVal / 12 + VCAL_BaseYear ; m = (ipt->Value.IntVal % 12) + 1 ;
			if (cpt->PntType == V4DPI_PntType_Delta)
			 { y += cpt->Value.IntVal ;
			 } else { y = cpt->Value.IntVal ; } ;
			ipt->Value.IntVal = YYMMtoUMONTH(y,m) ;
			break ;
		   case V4DPI_PntType_UDT:
			t = ipt->Value.IntVal % VCAL_SecsInDay ;
			i = mscu_udate_to_yyyymmdd(ipt->Value.IntVal / VCAL_SecsInDay + VCAL_UDTUDateOffset) ;
			y = i / 10000 ; m = (i / 100) % 100 ; d = i % 100 ;
			if (cpt->PntType == V4DPI_PntType_Delta)
			 { y += cpt->Value.IntVal ;
			 } else { y = cpt->Value.IntVal ; } ;
			ipt->Value.IntVal =  (mscu_ymd_to_ud(y,m,d) - VCAL_UDTUDateOffset) * VCAL_SecsInDay + t ;
			break ;
		   case V4DPI_PntType_Calendar:
			GETREAL(dnum,ipt) ;
			fpart = modf(dnum,&ipart) ;
			switch (VCAL_CalType_Gregorian)
			 { default:	CalNYI ;
			   case VCAL_CalType_Gregorian:	GregorianFromFixed((int)ipart,&cal) ; break ;
			   case VCAL_CalType_Julian:	JulianFromFixed((int)ipart,&cal) ; break ;
			   case VCAL_CalType_Islamic:	IslamicFromFixed((int)ipart,&cal) ; break ;
			   case VCAL_CalType_ISO:	ISOFromFixed((int)ipart,&cal) ; break ;
			   case VCAL_CalType_Hebrew:	HebrewFromFixed((int)ipart,&cal) ; break ;
			   case VCAL_CalType_Chinese:
			   case VCAL_CalType_Hindu:	CalNYI ;
			 } ;
			if (cpt->PntType == V4DPI_PntType_Delta)
			 { cal.Year += cpt->Value.IntVal ;
			 } else { cal.Year = cpt->Value.IntVal ; } ;
			switch (VCAL_CalType_Gregorian)
			 { default:	CalNYI ;
			   case VCAL_CalType_Gregorian:	dnum = (double)FixedFromGregorian(cal.Year,cal.Month,cal.Day) ; break ;
			   case VCAL_CalType_Julian:	dnum = (double)FixedFromJulian(cal.Year,cal.Month,cal.Day) ; break ;
			   case VCAL_CalType_Islamic:	dnum = (double)FixedFromIslamic(cal.Year,cal.Month,cal.Day) ; break ;
			   case VCAL_CalType_ISO:	dnum = (double)FixedFromISO(cal.Year,cal.Month,cal.Day) ; break ;
			   case VCAL_CalType_Hebrew:	dnum = (double)FixedFromHebrew(cal.Year,cal.Month,cal.Day) ; break ;
			   case VCAL_CalType_Chinese:
			   case VCAL_CalType_Hindu:	CalNYI ;
			 } ;
			dnum += fpart ; PUTREAL(ipt,dnum) ;
			break ;
		   case V4DPI_PntType_UDate:
			if (ipt->Value.IntVal == VCAL_UDate_None) { i = 00000101 ; }
			 else { i = mscu_udate_to_yyyymmdd(ipt->Value.IntVal) ; } ;
			y = i/10000 ; m = (i/100)%100 ; d = i % 100 ;
			if (cpt->PntType == V4DPI_PntType_Delta)
			 { y += cpt->Value.IntVal ;
			 } else { y = cpt->Value.IntVal ; } ;
			ipt->Value.IntVal = mscu_ymd_to_ud(y,m,d) ;	/* If absolute month then plug */
			break ;
		   case V4DPI_PntType_UPeriod:
			{ struct V4DPI__DimInfo *di ; int ppy ;
			  DIMINFO(di,ctx,ipt->Dim) ; ppy = (di->ds.UPeriod.periodsPerYear == 0 ? 13 : di->ds.UPeriod.periodsPerYear) ;
			  y = ipt->Value.IntVal/ppy + VCAL_BaseYear ; m = ipt->Value.IntVal % ppy ;
			  if (cpt->PntType == V4DPI_PntType_Delta)
			   { y += cpt->Value.IntVal ;
			   } else { y = cpt->Value.IntVal ; } ;
			  ipt->Value.IntVal = (y-VCAL_BaseYear)*ppy + m ;
			}
			break ;
		   case V4DPI_PntType_UWeek:
			y = ipt->Value.IntVal/52 + VCAL_BaseYear ; m = ipt->Value.IntVal % 52 ;
			if (cpt->PntType == V4DPI_PntType_Delta)
			 { y += cpt->Value.IntVal ;
			 } else { y = cpt->Value.IntVal ; } ;
			ipt->Value.IntVal = (y-VCAL_BaseYear)*52 + m ;
			break ;
		   case V4DPI_PntType_UQuarter:
			y = UQTRtoUYEAR(ipt->Value.IntVal) ; m = UQTRtoQTR(ipt->Value.IntVal) ;
			if (cpt->PntType == V4DPI_PntType_Delta)
			 { y += cpt->Value.IntVal ;
			 } else { y = cpt->Value.IntVal ; } ;
			ipt->Value.IntVal = YYQQtoUQTR(y,m) ;
			break ;
		 } ;
		continue ;
	      case V4IM_Tag_DayOfYear:
		memcpy(&lpt,ipt,ipt->Bytes) ; ipt = (P *)&lpt ;	/* Get copy of ipt */
		switch(ipt->PntType)
		 { default:
			v_Msg(ctx,NULL,"DTInfoInvAdj",intmodx,V4IM_Tag_DayOfYear,ipt->PntType) ; goto dtinfo_fail ;
		   case V4DPI_PntType_UMonth:
			y = ipt->Value.IntVal / 12 + VCAL_BaseYear ;
			ymd = mscu_ymd_to_ud(y,1,1) + cpt->Value.IntVal - 1 ;
			ipt = (P *)&lpt ; ZPH(ipt) ; ipt->PntType = V4DPI_PntType_UDate ; ipt->Dim = Dim_UDate ;
			res = -V4IM_Tag_UDate ; ipt->Value.IntVal = ymd ;
			break ;
		   case V4DPI_PntType_UYear:
			ymd = mscu_ymd_to_ud(ipt->Value.IntVal,1,1) + cpt->Value.IntVal - 1 ;
			ipt = (P *)&lpt ; ZPH(ipt) ; ipt->PntType = V4DPI_PntType_UDate ; ipt->Dim = Dim_UDate ;
			res = -V4IM_Tag_UDate ; ipt->Value.IntVal = ymd ;
			break ;
		   case V4DPI_PntType_Calendar:
			GETREAL(dnum,ipt) ;
			fpart = modf(dnum,&ipart) ;
			switch (VCAL_CalType_Gregorian)
			 { default:	CalNYI ;
			   case VCAL_CalType_Gregorian:	GregorianFromFixed((int)ipart,&cal) ; break ;
			   case VCAL_CalType_Julian:	JulianFromFixed((int)ipart,&cal) ; break ;
			   case VCAL_CalType_Islamic:	IslamicFromFixed((int)ipart,&cal) ; break ;
			   case VCAL_CalType_ISO:	ISOFromFixed((int)ipart,&cal) ; break ;
			   case VCAL_CalType_Hebrew:	HebrewFromFixed((int)ipart,&cal) ; break ;
			   case VCAL_CalType_Chinese:
			   case VCAL_CalType_Hindu:	CalNYI ;
			 } ;
			switch (VCAL_CalType_Gregorian)
			 { default:	CalNYI ;
			   case VCAL_CalType_Gregorian:
				ok = VerifyGregorianYMD(cal.Year,cal.Month,cal.Day,ctx->ErrorMsgAux) ; if (!ok) break ;
				dnum = (double)FixedFromGregorian(cal.Year,1,1) ; break ;
			   case VCAL_CalType_Julian:
				ok = VerifyGregorianYMD(cal.Year,cal.Month,cal.Day,ctx->ErrorMsgAux) ; if (!ok) break ;
				dnum = (double)FixedFromJulian(cal.Year,1,1) ; break ;
			   case VCAL_CalType_Islamic:
				ok = VerifyIslamicYMD(cal.Year,cal.Month,cal.Day,ctx->ErrorMsgAux) ; if (!ok) break ;
				dnum = (double)FixedFromIslamic(cal.Year,1,1) ; break ;
			   case VCAL_CalType_ISO:
				ok = VerifyISOYWD(cal.Year,cal.Month,cal.Day,ctx->ErrorMsgAux) ; if (!ok) break ;
				dnum = (double)FixedFromISO(cal.Year,1,1) ; break ;
			   case VCAL_CalType_Hebrew:
				ok = VerifyHebrewYMD(cal.Year,cal.Month,cal.Day,ctx->ErrorMsgAux) ; if (!ok) break ;
				dnum = (double)FixedFromHebrew(cal.Year,1,1) ; break ;
			   case VCAL_CalType_Chinese:
			   case VCAL_CalType_Hindu:	CalNYI ;
			 } ;
			dnum += fpart ; dnum += (cpt->Value.IntVal - 1) ;
			PUTREAL(ipt,dnum) ;
			break ;
		   case V4DPI_PntType_UDate:
			i = mscu_udate_to_yyyymmdd(ipt->Value.IntVal) ;
			y = i/10000 ;
			ipt->Value.IntVal = mscu_ymd_to_ud(y,1,1) + cpt->Value.IntVal - 1 ;
			res = -V4IM_Tag_UDate ; break ;
		   case V4DPI_PntType_UDT:
			i = mscu_udate_to_yyyymmdd(ipt->Value.IntVal / VCAL_SecsInDay + VCAL_UDTUDateOffset) ;
			y = i / 10000 ;
			i = ipt->Value.IntVal % VCAL_SecsInDay ;	/* i = time portion */
			ymd = mscu_ymd_to_ud(y,1,1) + cpt->Value.IntVal - 1 ;
			ipt->Value.IntVal = (ymd - VCAL_UDTUDateOffset) * VCAL_SecsInDay + i ;
			break ;
		 } ;
		continue ;
	      case V4IM_Tag_Hour:
		h = v4im_GetPointInt(&ok,cpt,ctx) ; if (!ok) break ;
		if (cpt->PntType != V4DPI_PntType_Delta)
		 { if (h < 0 || h > 23) { v_Msg(ctx,NULL,"DTInfoTagVal",intmodx,V4IM_Tag_Hour,h,0,23) ; goto dtinfo_fail ; } ; } ;
		memcpy(&lpt,ipt,ipt->Bytes) ; ipt = (P *)&lpt ;	/* Get copy of ipt */
		switch(ipt->PntType)
		 { default:
			v_Msg(ctx,NULL,"DTInfoInvAdj",intmodx,V4IM_Tag_Day,ipt->PntType) ; goto dtinfo_fail ;
		   case V4DPI_PntType_Calendar:
			GETREAL(dnum,ipt) ;
			fpart = modf(dnum,&ipart) ;
			if (cpt->PntType == V4DPI_PntType_Delta)
			 { fpart += ((double)(h * 3600) / (double)VCAL_SecsInDay) ;
			   dnum = ipart + fpart ;
			 } else
			 { t = fpart * VCAL_SecsInDay ;		/* t = number of seconds */
			   t = (h * 3600) + (t % 3600) ;
			   dnum = ipart + ((double)t / (double)VCAL_SecsInDay) ;
			 } ;
			 PUTREAL(ipt,dnum) ; break ;
		   case V4DPI_PntType_UDT:
			if (cpt->PntType == V4DPI_PntType_Delta)
			 { ipt->Value.IntVal += (h * 3600) ;
			 } else
			 { ipt->Value.IntVal = ((ipt->Value.IntVal / (24*3600)) * (24*3600)) + (h * 3600) + (ipt->Value.IntVal % 3600) ;
			 } ;
			break ;
		 } ;
		continue ;
	      case V4IM_Tag_Minute:
		m = v4im_GetPointInt(&ok,cpt,ctx) ; if (!ok) break ;
		if (cpt->PntType != V4DPI_PntType_Delta)
		 { if (m < 0 || m > 59) { v_Msg(ctx,NULL,"DTInfoTagVal",intmodx,V4IM_Tag_Minute,m,0,59) ; goto dtinfo_fail ; } ; } ;
		memcpy(&lpt,ipt,ipt->Bytes) ; ipt = (P *)&lpt ;	/* Get copy of ipt */
		switch(ipt->PntType)
		 { default:
			v_Msg(ctx,NULL,"DTInfoInvAdj",intmodx,V4IM_Tag_Day,ipt->PntType) ; goto dtinfo_fail ;
		   case V4DPI_PntType_Calendar:
			GETREAL(dnum,ipt) ;
			fpart = modf(dnum,&ipart) ;
			if (cpt->PntType == V4DPI_PntType_Delta)
			 { fpart += ((double)(m * 60) / (double)VCAL_SecsInDay) ;
			   dnum = ipart + fpart ;
			 } else
			 { t = fpart * VCAL_SecsInDay ;		/* t = number of seconds */
			   t = ((t / 3600) * 3600) + (m * 60) + (t % 60) ;
			   dnum = ipart + ((double)t / (double)VCAL_SecsInDay) ;
			 } ;
			 PUTREAL(ipt,dnum) ; break ;
		   case V4DPI_PntType_UDT:
			if (cpt->PntType == V4DPI_PntType_Delta)
			 { ipt->Value.IntVal += (m * 60) ;
			 } else
			 { ipt->Value.IntVal = ((ipt->Value.IntVal / 3600) * 3600) + (m * 60) + (ipt->Value.IntVal % 60) ;
			 } ;
			break ;
		 } ;
		continue ;
	      case V4IM_Tag_Second:
		s = v4im_GetPointInt(&ok,cpt,ctx) ; if (!ok) break ;
		if (cpt->PntType != V4DPI_PntType_Delta)
		 { if (s < 0 || s > 59) { v_Msg(ctx,NULL,"DTInfoTagVal",intmodx,V4IM_Tag_Second,s,0,59) ; goto dtinfo_fail ; } ; } ;
		memcpy(&lpt,ipt,ipt->Bytes) ; ipt = (P *)&lpt ;	/* Get copy of ipt */
		switch(ipt->PntType)
		 { default:
			v_Msg(ctx,NULL,"DTInfoInvAdj",intmodx,V4IM_Tag_Day,ipt->PntType) ; goto dtinfo_fail ;
		   case V4DPI_PntType_Calendar:
			GETREAL(dnum,ipt) ;
			fpart = modf(dnum,&ipart) ;
			if (cpt->PntType == V4DPI_PntType_Delta)
			 { fpart += ((double)s / (double)VCAL_SecsInDay) ;
			   dnum = ipart + fpart ;
			 } else
			 { t = fpart * VCAL_SecsInDay ;		/* t = number of seconds */
			   t = (t / 60) * 60 + s ;
			   dnum = ipart + ((double)t / (double)VCAL_SecsInDay) ;
			 } ;
			 PUTREAL(ipt,dnum) ; break ;
		   case V4DPI_PntType_UDT:
			if (cpt->PntType == V4DPI_PntType_Delta)
			 { ipt->Value.IntVal += s ;
			 } else
			 { ipt->Value.IntVal = ((ipt->Value.IntVal / 60) * 60) + s ;
			 } ;
			break ;
		 } ;
		continue ;
	      case V4IM_Tag_Day:
		memcpy(&lpt,ipt,ipt->Bytes) ; ipt = (P *)&lpt ;	/* Get copy of ipt */
		switch(ipt->PntType)
		 { default:
			v_Msg(ctx,NULL,"DTInfoInvAdj",intmodx,V4IM_Tag_Day,ipt->PntType) ; goto dtinfo_fail ;
		   case V4DPI_PntType_UMonth:
			y = ipt->Value.IntVal / 12 + VCAL_BaseYear ; m = (ipt->Value.IntVal % 12) + 1 ;
			d = cpt->Value.IntVal ;
			if (d >= 31)					/* Want last day of month */
			 { d = 1 ; m++ ; if (m > 12) { m = 1 ; y++ ; } ;
			   ymd = mscu_ymd_to_ud(y,m,d) - 1 ;
			 } else { ymd = mscu_ymd_to_ud(y,m,d) ; } ;
			ipt = (P *)&lpt ; ZPH(ipt) ; ipt->PntType = V4DPI_PntType_UDate ; ipt->Dim = Dim_UDate ;
			res = -V4IM_Tag_UDate ; ipt->Value.IntVal = ymd ;
			break ;
		   case V4DPI_PntType_Calendar:
			GETREAL(dnum,ipt) ;
			fpart = modf(dnum,&ipart) ;
			switch (VCAL_CalType_Gregorian)
			 { default:	CalNYI ;
			   case VCAL_CalType_Gregorian:	GregorianFromFixed((int)ipart,&cal) ; break ;
			   case VCAL_CalType_Julian:	JulianFromFixed((int)ipart,&cal) ; break ;
			   case VCAL_CalType_Islamic:	IslamicFromFixed((int)ipart,&cal) ; break ;
			   case VCAL_CalType_ISO:	ISOFromFixed((int)ipart,&cal) ; break ;
			   case VCAL_CalType_Hebrew:	HebrewFromFixed((int)ipart,&cal) ; break ;
			   case VCAL_CalType_Chinese:
			   case VCAL_CalType_Hindu:	CalNYI ;
			 } ;
			if (cpt->PntType == V4DPI_PntType_Delta)
			 { cal.Day += cpt->Value.IntVal ;
			 } else { cal.Day = cpt->Value.IntVal ; } ;
			switch (VCAL_CalType_Gregorian)
			 { default:	CalNYI ;
			   case VCAL_CalType_Gregorian:
				ok = VerifyGregorianYMD(cal.Year,cal.Month,cal.Day,ctx->ErrorMsgAux) ; if (!ok) break ;
				dnum = (double)FixedFromGregorian(cal.Year,cal.Month,cal.Day) ; break ;
			   case VCAL_CalType_Julian:
				ok = VerifyGregorianYMD(cal.Year,cal.Month,cal.Day,ctx->ErrorMsgAux) ; if (!ok) break ;
				dnum = (double)FixedFromJulian(cal.Year,cal.Month,cal.Day) ; break ;
			   case VCAL_CalType_Islamic:
				ok = VerifyIslamicYMD(cal.Year,cal.Month,cal.Day,ctx->ErrorMsgAux) ; if (!ok) break ;
				dnum = (double)FixedFromIslamic(cal.Year,cal.Month,cal.Day) ; break ;
			   case VCAL_CalType_ISO:
				ok = VerifyISOYWD(cal.Year,cal.Month,cal.Day,ctx->ErrorMsgAux) ; if (!ok) break ;
				dnum = (double)FixedFromISO(cal.Year,cal.Month,cal.Day) ; break ;
			   case VCAL_CalType_Hebrew:
				ok = VerifyHebrewYMD(cal.Year,cal.Month,cal.Day,ctx->ErrorMsgAux) ; if (!ok) break ;
				dnum = (double)FixedFromHebrew(cal.Year,cal.Month,cal.Day) ; break ;
			   case VCAL_CalType_Chinese:
			   case VCAL_CalType_Hindu:	CalNYI ;
			 } ;
			dnum += fpart ; PUTREAL(ipt,dnum) ;
			break ;
		   case V4DPI_PntType_UDate:
			if (cpt->PntType == V4DPI_PntType_Delta)
			 { ipt->Value.IntVal += cpt->Value.IntVal ; continue ; } ;
			if (cpt->Value.IntVal >= 31)			/* Wants last day of month? */
			 { i = mscu_udate_to_yyyymmdd(ipt->Value.IntVal) ;
			   y = i/10000 ; m = (i/100)%100 ; d = 1 ;
			   m++ ; if (m > 12) { m = 1 ; y++ ; } ;	/* Advance to first day of next month */
			   ipt->Value.IntVal = mscu_ymd_to_ud(y,m,d)-1 ;
			 } else
			 { i = mscu_udate_to_yyyymmdd(ipt->Value.IntVal) ;
			   y = i/10000 ; m = (i/100)%100 ; d = cpt->Value.IntVal ;
			  ipt->Value.IntVal = mscu_ymd_to_ud(y,m,d) ;	/* If absolute month then plug */
			 } ;
			break ;
		   case V4DPI_PntType_UDT:
			t = ipt->Value.IntVal % VCAL_SecsInDay ;
			if (cpt->PntType == V4DPI_PntType_Delta)
			 { d = ipt->Value.IntVal / VCAL_SecsInDay ; d += cpt->Value.IntVal ;
			   ipt->Value.IntVal = d * VCAL_SecsInDay + t ;
			 } else
			 { i = mscu_udate_to_yyyymmdd(ipt->Value.IntVal / VCAL_SecsInDay + VCAL_UDTUDateOffset) ;
			   y = i / 10000 ; m = (i / 100) % 100 ;
			   d = cpt->Value.IntVal ;
			   if (d >= 31)					/* Force last day of month */
			    { m++ ; if (m > 12) { m = 1 ; y++ ; } ;	/* Advance to first day of next month */
			      ipt->Value.IntVal = mscu_ymd_to_ud(y,m,1)-1 ;
			      ipt->Value.IntVal = (ipt->Value.IntVal - VCAL_UDTUDateOffset) * VCAL_SecsInDay + t ;
			    } else
			    { ipt->Value.IntVal =  (mscu_ymd_to_ud(y,m,d) - VCAL_UDTUDateOffset) * VCAL_SecsInDay + t ;
			    } ;
			 } ;
			break ;
		 } ;
		continue ;
	      case V4IM_Tag_Month:
		memcpy(&lpt,ipt,ipt->Bytes) ; ipt = (P *)&lpt ;	/* Get copy of ipt */
		switch(ipt->PntType)
		 { default: v_Msg(ctx,NULL,"DTInfoInvAdj",intmodx,V4IM_Tag_Month,ipt->PntType) ; goto dtinfo_fail ;
		   case V4DPI_PntType_UYear:
			m = YYMMtoUMONTH(ipt->Value.IntVal,cpt->Value.IntVal) ;
			ipt = (P *)&lpt ; ZPH(ipt) ;
			ipt->PntType = V4DPI_PntType_UMonth ; ipt->Bytes = V4PS_Int ; ipt->Dim = Dim_UMonth ;
			ipt->Value.IntVal = m ;
			break ;
		   case V4DPI_PntType_UMonth:
			y = ipt->Value.IntVal / 12 + VCAL_BaseYear ; m = (ipt->Value.IntVal % 12) + 1 ;
			if (cpt->PntType == V4DPI_PntType_Delta)
			 { m += cpt->Value.IntVal ;
			   for(;m<0;m+=12) { y-- ; } ; for(;m>12;m-=12) { y++ ; } ;
			 } else { m = cpt->Value.IntVal ; } ;
			ipt->Value.IntVal = YYMMtoUMONTH(y,m) ;
			break ;
		   case V4DPI_PntType_Calendar:
			GETREAL(dnum,ipt) ;
			fpart = modf(dnum,&ipart) ;
			switch (VCAL_CalType_Gregorian)
			 { default:	CalNYI ;
			   case VCAL_CalType_Gregorian:	GregorianFromFixed((int)ipart,&cal) ; break ;
			   case VCAL_CalType_Julian:	JulianFromFixed((int)ipart,&cal) ; break ;
			   case VCAL_CalType_Islamic:	IslamicFromFixed((int)ipart,&cal) ; break ;
			   case VCAL_CalType_ISO:	ISOFromFixed((int)ipart,&cal) ; break ;
			   case VCAL_CalType_Hebrew:	HebrewFromFixed((int)ipart,&cal) ; break ;
			   case VCAL_CalType_Chinese:
			   case VCAL_CalType_Hindu:	CalNYI ;
			 } ;
			if (cpt->PntType == V4DPI_PntType_Delta)
			 { cal.Month += cpt->Value.IntVal ;
			 } else { cal.Month = cpt->Value.IntVal ; } ;
			switch (VCAL_CalType_Gregorian)
			 { default:	CalNYI ;
			   case VCAL_CalType_Gregorian:
				ok = VerifyGregorianYMD(cal.Year,cal.Month,cal.Day,ctx->ErrorMsgAux) ; if (!ok) break ;
				dnum = (double)FixedFromGregorian(cal.Year,cal.Month,cal.Day) ; break ;
			   case VCAL_CalType_Julian:
				ok = VerifyGregorianYMD(cal.Year,cal.Month,cal.Day,ctx->ErrorMsgAux) ; if (!ok) break ;
				dnum = (double)FixedFromJulian(cal.Year,cal.Month,cal.Day) ; break ;
			   case VCAL_CalType_Islamic:
				ok = VerifyIslamicYMD(cal.Year,cal.Month,cal.Day,ctx->ErrorMsgAux) ; if (!ok) break ;
				dnum = (double)FixedFromIslamic(cal.Year,cal.Month,cal.Day) ; break ;
			   case VCAL_CalType_ISO:
				ok = VerifyISOYWD(cal.Year,cal.Month,cal.Day,ctx->ErrorMsgAux) ; if (!ok) break ;
				dnum = (double)FixedFromISO(cal.Year,cal.Month,cal.Day) ; break ;
			   case VCAL_CalType_Hebrew:
				ok = VerifyHebrewYMD(cal.Year,cal.Month,cal.Day,ctx->ErrorMsgAux) ; if (!ok) break ;
				dnum = (double)FixedFromHebrew(cal.Year,cal.Month,cal.Day) ; break ;
			   case VCAL_CalType_Chinese:
			   case VCAL_CalType_Hindu:	CalNYI ;
			 } ;
			dnum += fpart ; PUTREAL(ipt,dnum) ;
			break ;
		   case V4DPI_PntType_UDT:
			i = mscu_udate_to_yyyymmdd(UDTtoUD(ipt->Value.IntVal)) ;
			y = i/10000 ; m = (i/100)%100 ; d = i % 100 ;
			if (cpt->PntType == V4DPI_PntType_Delta)
			 { if (cpt->Value.IntVal == 0) d = 1 ;		/* If Month::0 then force to begin of current */
			   m += cpt->Value.IntVal ;			/*  else if +/- then do it */
			   for(;m<0;m+=12) { y-- ; } ; for(;m>12;m-=12) { y++ ; } ;
			 } else { m = cpt->Value.IntVal ; } ;
			if (m == 2 && d > 28) { d = (GregorianLeapYear(y) ? 29 : 28) ; }		/* Don't overflow days of month */
			 else if (d > 30) { switch (m) { case 4: case 6: case 9: case 11: d = 30 ; break ; } ; } ;
			ipt->Value.IntVal = UDtoUDT(mscu_ymd_to_ud(y,m,d)) + UDTtoSeconds(ipt->Value.IntVal) ;
			break ;
		   case V4DPI_PntType_UDate:
			i = mscu_udate_to_yyyymmdd(ipt->Value.IntVal) ;
			y = i/10000 ; m = (i/100)%100 ; d = i % 100 ;
			if (cpt->PntType == V4DPI_PntType_Delta)
			 { if (cpt->Value.IntVal == 0) d = 1 ;		/* If Month::0 then force to begin of current */
			   m += cpt->Value.IntVal ;			/*  else if +/- then do it */
			   for(;m<0;m+=12) { y-- ; } ; for(;m>12;m-=12) { y++ ; } ;
			 } else { m = cpt->Value.IntVal ; } ;
			if (m == 2 && d > 28) { d = (GregorianLeapYear(y) ? 29 : 28) ; }		/* Don't overflow days of month */
			 else if (d > 30) { switch (m) { case 4: case 6: case 9: case 11: d = 30 ; break ; } ; } ;
			ipt->Value.IntVal = mscu_ymd_to_ud(y,m,d) ;	/* If absolute month then plug */
			break ;
		 } ;
		continue ;
	      case -V4IM_Tag_SolarLongitude:
	      case -V4IM_Tag_LunarPhase:
	      case -V4IM_Tag_DaylightSavings:
	      case -V4IM_Tag_Easter:
	      case -V4IM_Tag_YomKippur:
	      case -V4IM_Tag_Passover:
	      case -V4IM_Tag_Day:
	      case -V4IM_Tag_DayOfWeek:
	      case -V4IM_Tag_UDate:
	      case -V4IM_Tag_UMonth:
	      case -V4IM_Tag_UTime:
	      case -V4IM_Tag_UYear:
	      case -V4IM_Tag_UWeek:
	      case -V4IM_Tag_UQuarter:
	      case -V4IM_Tag_Week:
	      case -V4IM_Tag_UPeriod:
	      case -V4IM_Tag_Period:
	      case -V4IM_Tag_Month:
	      case -V4IM_Tag_DayOfYear:
	      case -V4IM_Tag_Hour:
	      case -V4IM_Tag_Minute:
	      case -V4IM_Tag_Second:	tres = t ; break ;
	      case V4IM_Tag_BaseDate:	BaseDate = v4im_GetPointUD(&ok,cpt,ctx) ; if (!ok) continue ; break ;
	      case V4IM_Tag_BaseMonth:	BaseMonth = v4im_GetPointInt(&ok,cpt,ctx) ; if (!ok) continue ; break ;
	    } ;
	   if (tres != 0)
	    { switch (res)		/* If res already set via implied tag (e.g. Day::xxx) then allow it to change */
	       { case -V4IM_Tag_UDate:	if (ipt->PntType == V4DPI_PntType_UDate) res = 0 ; break ;
	         case -V4IM_Tag_UMonth:	if (ipt->PntType == V4DPI_PntType_UMonth) res = 0 ; break ;
	         case -V4IM_Tag_UYear:	if (ipt->PntType == V4DPI_PntType_UYear) res = 0 ; break ;
	       } ;
	      if (res != 0) { v_Msg(ctx,NULL,"TagOnlyOneRes",intmodx) ; goto dtinfo_fail ; } ;
	      res = tres ;
	    } ;
	 } ;
	if (!ok) { v_Msg(ctx,NULL,"ModInvArg",intmodx,ax-1) ; goto dtinfo_fail ; } ;
	if (gotToByNum) 
	 return(v4im_DoNum(ctx,respnt,argpnts,argcnt,intmodx)) ;
	rpt = respnt ; ZPH(rpt) ; rpt->Bytes = V4PS_Int ;
	switch (res)
	 { default:					/* No result tag given? - return ipt */
	     memcpy(rpt,ipt,ipt->Bytes) ; break ;
	   case -V4IM_Tag_LunarPhase:
	     switch(ipt->PntType)
	      { default:
		  v_Msg(ctx,NULL,"DTInfoTagRes",intmodx,res,ipt->PntType) ; goto dtinfo_fail ; 
		case V4DPI_PntType_Calendar:	GETREAL(dnum,ipt) ; break ;
		case V4DPI_PntType_UDate:	dnum = ipt->Value.IntVal + VCal_MJDOffset ; break ;
		case V4DPI_PntType_UDT:		dnum = (double)ipt->Value.IntVal/(double)VCAL_SecsInDay + VCAL_UDTUDateOffset + VCal_MJDOffset ; break ;
	      } ;
	     dnum = (double)LunarPhase(dnum) ;
	     dblPNTv(respnt,dnum) ; return(respnt) ;
	   case -V4IM_Tag_SolarLongitude:
	     switch(ipt->PntType)
	      { default:
		  v_Msg(ctx,NULL,"DTInfoTagRes",intmodx,res,ipt->PntType) ; goto dtinfo_fail ; 
		case V4DPI_PntType_Calendar:	GETREAL(dnum,ipt) ; break ;
		case V4DPI_PntType_UDate:	dnum = ipt->Value.IntVal + VCal_MJDOffset ; break ;
		case V4DPI_PntType_UDT:		dnum = (double)ipt->Value.IntVal/(double)VCAL_SecsInDay + VCAL_UDTUDateOffset + VCal_MJDOffset ; break ;
	      } ;
	     dnum = (double)SolarLongitude(dnum) ;
	     dblPNTv(respnt,dnum) ; return(respnt) ;
	   case -V4IM_Tag_Day:
	     switch(ipt->PntType)
	      { default:
		  v_Msg(ctx,NULL,"DTInfoTagRes",intmodx,res,ipt->PntType) ; goto dtinfo_fail ; 
		case V4DPI_PntType_Calendar:
		  GETREAL(dnum,ipt) ; fpart = modf(dnum,&ipart) ;
		  switch (VCAL_CalType_Gregorian)
		   { default:	CalNYI ;
		     case VCAL_CalType_Gregorian:	GregorianFromFixed((int)ipart,&cal) ; break ;
		     case VCAL_CalType_Julian:		JulianFromFixed((int)ipart,&cal) ; break ;
		     case VCAL_CalType_Islamic:		IslamicFromFixed((int)ipart,&cal) ; break ;
		     case VCAL_CalType_ISO:		ISOFromFixed((int)ipart,&cal) ; break ;
		     case VCAL_CalType_Hebrew:		HebrewFromFixed((int)ipart,&cal) ; break ;
		     case VCAL_CalType_Chinese:
		     case VCAL_CalType_Hindu:		CalNYI ;
		   } ;
		  rpt->Value.IntVal = cal.Day ; break ;
		case V4DPI_PntType_UDate:
		  i = mscu_udate_to_yyyymmdd(ipt->Value.IntVal) ;
		  rpt->Value.IntVal = i % 100 ; break ;
		case V4DPI_PntType_UDT:
		  i = mscu_udate_to_yyyymmdd(UDTtoUD(ipt->Value.IntVal)) ;
		  rpt->Value.IntVal = i % 100 ; break ;
	      } ;
	     rpt->PntType = V4DPI_PntType_Int ; rpt->Dim = Dim_Int ;
	     break ; 
	   case -V4IM_Tag_Hour:
	     switch(ipt->PntType)
	      { default:
		  v_Msg(ctx,NULL,"DTInfoTagRes",intmodx,res,ipt->PntType) ; goto dtinfo_fail ; 
		case V4DPI_PntType_Calendar:
		  CalNYI ;
		case V4DPI_PntType_UDT:
		  i = UDTtoSeconds(ipt->Value.IntVal) ;
		  rpt->Value.IntVal = i / (60*60) ; break ;
		case V4DPI_PntType_UTime:
		  GETREAL(dnum,ipt) ; t = dnum ;
		  rpt->Value.IntVal = t / (60*60) ; break ;
	      } ;
	     rpt->PntType = V4DPI_PntType_Int ; rpt->Dim = Dim_Int ;
	     break ; 
	   case -V4IM_Tag_Minute:
	     switch(ipt->PntType)
	      { default:
		  v_Msg(ctx,NULL,"DTInfoTagRes",intmodx,res,ipt->PntType) ; goto dtinfo_fail ; 
		case V4DPI_PntType_Calendar:
		  CalNYI ;
		case V4DPI_PntType_UDT:
		  i = UDTtoSeconds(ipt->Value.IntVal) ;
		  rpt->Value.IntVal = (i / 60) % 60 ; break ;
		case V4DPI_PntType_UTime:
		  GETREAL(dnum,ipt) ; t = dnum ;
		  rpt->Value.IntVal = (t / 60) % 60 ; break ;
	      } ;
	     rpt->PntType = V4DPI_PntType_Int ; rpt->Dim = Dim_Int ;
	     break ; 
	   case -V4IM_Tag_Second:
	     switch(ipt->PntType)
	      { default:
		  v_Msg(ctx,NULL,"DTInfoTagRes",intmodx,res,ipt->PntType) ; goto dtinfo_fail ; 
		case V4DPI_PntType_Calendar:
		  CalNYI ;
		case V4DPI_PntType_UDT:
		  i = UDTtoSeconds(ipt->Value.IntVal) ;
		  rpt->Value.IntVal = i % 60 ; break ;
		case V4DPI_PntType_UTime:
		  GETREAL(dnum,ipt) ; t = dnum ;
		  rpt->Value.IntVal = t % 60 ; break ;
	      } ;
	     rpt->PntType = V4DPI_PntType_Int ; rpt->Dim = Dim_Int ;
	     break ; 
	   case -V4IM_Tag_DayOfWeek:
	     switch(ipt->PntType)
	      { default:
		  v_Msg(ctx,NULL,"DTInfoTagRes",intmodx,res,ipt->PntType) ; goto dtinfo_fail ; 
		case V4DPI_PntType_Calendar:
		  GETREAL(dnum,ipt) ; fpart = modf(dnum,&ipart) ;
		  rpt->Value.IntVal = ((int)ipart % 7) ; if (rpt->Value.IntVal == 0) rpt->Value.IntVal = 7 ;
		  break ;
		case V4DPI_PntType_UDate:
		  rpt->Value.IntVal = ((ipt->Value.IntVal+1)%7)+1 ; break ;
		case V4DPI_PntType_UDT:
		  rpt->Value.IntVal = (((ipt->Value.IntVal / VCAL_SecsInDay + VCAL_UDTUDateOffset)+1)%7)+1 ; break ;
	      } ;
	     rpt->PntType = V4DPI_PntType_Int ; rpt->Dim = Dim_Int ;
	     break ; 
	   case -V4IM_Tag_Week:
	     switch(ipt->PntType)
	      { default:
		  v_Msg(ctx,NULL,"DTInfoTagRes",intmodx,res,ipt->PntType) ; goto dtinfo_fail ; 
		case V4DPI_PntType_Calendar:
		  GETREAL(dnum,ipt) ; fpart = modf(dnum,&ipart) ;
		  ISOFromFixed((int)ipart,&cal) ;
		  rpt->Value.IntVal = cal.Week ; break ;
		case V4DPI_PntType_UWeek:
		  rpt->Value.IntVal = (ipt->Value.IntVal % 52) + 1 ; break ;
	      } ;
	     rpt->PntType = V4DPI_PntType_Int ; rpt->Dim = Dim_Int ;
	     break ; 
	   case -V4IM_Tag_UDate:
	     switch(ipt->PntType)
	      { default:
		  v_Msg(ctx,NULL,"DTInfoTagRes",intmodx,res,ipt->PntType) ; goto dtinfo_fail ; 
		case V4DPI_PntType_CodedRange:
		case V4DPI_PntType_Int:
		  d = ipt->Value.IntVal%100 ; y = ipt->Value.IntVal / 10000 ; m = (ipt->Value.IntVal / 100) % 100 ;
		  rpt->Value.IntVal = vcal_UDateFromYMD(FALSE,y,m,d,ctx->ErrorMsgAux) ;
		  if (rpt->Value.IntVal != VCAL_BadVal) break ;
		  v_Msg(ctx,NULL,"DTInfoConvert2",intmodx,ipt,V4DPI_PntType_UDate) ; goto dtinfo_fail ; 
		case V4DPI_PntType_Calendar:
		  GETREAL(dnum,ipt) ; fpart = modf(dnum,&ipart) ;
		  rpt->Value.IntVal = (int)ipart - VCal_MJDOffset ;
		  if (rpt->Value.IntVal < 0) { v_Msg(ctx,NULL,"DTInfoConvert",intmodx,ipt,V4DPI_PntType_UDate) ; goto dtinfo_fail ; } ;
		  break ;
		case V4DPI_PntType_UDate:
		  rpt->Value.IntVal = ipt->Value.IntVal ; break ;
		case V4DPI_PntType_UMonth:
		  rpt->Value.IntVal = mscu_ymd_to_ud((ipt->Value.IntVal/12)+VCAL_BaseYear,(ipt->Value.IntVal%12)+1,1) ; break ;
		case V4DPI_PntType_UYear:
		  rpt->Value.IntVal = mscu_ymd_to_ud(ipt->Value.IntVal,1,1) ; break ;
		case V4DPI_PntType_UDT:
		  rpt->Value.IntVal = UDTtoUD(ipt->Value.IntVal) ; break ;
	      } ;
	     rpt->PntType = V4DPI_PntType_UDate ; rpt->Dim = Dim_UDate ;
	     break ; 
	   case -V4IM_Tag_UMonth:
	     switch(ipt->PntType)
	      { default:
		  v_Msg(ctx,NULL,"DTInfoTagRes",intmodx,res,ipt->PntType) ; goto dtinfo_fail ; 
		case V4DPI_PntType_CodedRange:
		case V4DPI_PntType_Int:
		  y = ipt->Value.IntVal / 100 ; VCALADJYEAR(FALSE,y) ; m = (ipt->Value.IntVal % 100) ;
		  rpt->Value.IntVal = YYMMtoUMONTH(y,m) ; break ;
		case V4DPI_PntType_Calendar:
		  GETREAL(dnum,ipt) ; fpart = modf(dnum,&ipart) ;
		  i = mscu_udate_to_yyyymmdd((int)ipart - VCal_MJDOffset) ;
		  if (i == 0) { v_Msg(ctx,NULL,"DTInfoConvert",intmodx,ipt,V4DPI_PntType_UMonth) ; goto dtinfo_fail ; } ;
		  rpt->Value.IntVal = YYMMtoUMONTH(i/10000,((i/100) % 100)) ; break ;
		case V4DPI_PntType_UDate:
		  UDtoUMONTH(rpt->Value.IntVal,ipt->Value.IntVal) ; break ;
		case V4DPI_PntType_UMonth:
		  rpt->Value.IntVal = ipt->Value.IntVal ; break ;
		case V4DPI_PntType_UDT:
		 UDtoUMONTH(rpt->Value.IntVal,UDTtoUD(ipt->Value.IntVal)) ; break ;
	      } ;
	     rpt->PntType = V4DPI_PntType_UMonth ; rpt->Dim = Dim_UMonth ;
	     break ; 
	   case -V4IM_Tag_UTime:
	     switch(ipt->PntType)
	      { default:
		  v_Msg(ctx,NULL,"DTInfoTagRes",intmodx,res,ipt->PntType) ; goto dtinfo_fail ; 
		case V4DPI_PntType_Calendar:
		  GETREAL(dnum,ipt) ;
		  i = vcal_CalToUDT(dnum,VCAL_TimeZone_Local,&ok) ;
		  if (i < 0 || !ok) { v_Msg(ctx,NULL,"DTInfoConvert2",ipt,V4DPI_PntType_UTime) ; goto dtinfo_fail ; } ;
		  dnum = i % VCAL_SecsInDay ; break ;
		case V4DPI_PntType_UDT:
		  dnum = ipt->Value.IntVal%VCAL_SecsInDay ; break ;
	      } ;
	     PUTREAL(rpt,dnum) ; rpt->PntType = V4DPI_PntType_UTime ; rpt->Dim = Dim_UTime ; rpt->Bytes = V4PS_UTime ;
	     break ; 
	   case -V4IM_Tag_UYear:
	     switch(ipt->PntType)
	      { default:
		 v_Msg(ctx,NULL,"DTInfoTagRes",intmodx,res,ipt->PntType) ; goto dtinfo_fail ; 
		case V4DPI_PntType_Calendar:
		  GETREAL(dnum,ipt) ;	fpart = modf(dnum,&ipart) ;
		  switch (VCAL_CalType_Gregorian)
		   { default:	CalNYI ;
		     case VCAL_CalType_Gregorian:	GregorianFromFixed((int)ipart,&cal) ; break ;
		     case VCAL_CalType_Julian:		JulianFromFixed((int)ipart,&cal) ; break ;
		     case VCAL_CalType_Islamic:		IslamicFromFixed((int)ipart,&cal) ; break ;
		     case VCAL_CalType_ISO:		ISOFromFixed((int)ipart,&cal) ; break ;
		     case VCAL_CalType_Hebrew:		HebrewFromFixed((int)ipart,&cal) ; break ;
		     case VCAL_CalType_Chinese:
		     case VCAL_CalType_Hindu:	CalNYI ;
		   } ;
		  rpt->Value.IntVal = cal.Year ; break ;
		case V4DPI_PntType_UDate:
		  i = mscu_udate_to_yyyymmdd(ipt->Value.IntVal) ;
		  rpt->Value.IntVal = i / 10000 ; break ;
		case V4DPI_PntType_UDT:
		  i = mscu_udate_to_yyyymmdd(UDTtoUD(ipt->Value.IntVal)) ;
		  rpt->Value.IntVal = i / 10000 ; break ;
		case V4DPI_PntType_UMonth:
		  rpt->Value.IntVal = (ipt->Value.IntVal / 12) + VCAL_BaseYear ; break ;
		case V4DPI_PntType_UQuarter:
		  rpt->Value.IntVal = UQTRtoUYEAR(ipt->Value.IntVal) ; break ;
		case V4DPI_PntType_UYear:
		  rpt->Value.IntVal = ipt->Value.IntVal ; break ;
		case V4DPI_PntType_UPeriod:
		  { struct V4DPI__DimInfo *di ; int ppy ;
		    DIMINFO(di,ctx,ipt->Dim) ; ppy = (di->ds.UPeriod.periodsPerYear == 0 ? 13 : di->ds.UPeriod.periodsPerYear) ;
		    if (ipt->Value.IntVal > 100000)		/* Got regular period or year end adjustment? */
		     { rpt->Value.IntVal = ipt->Value.IntVal / 100 ;
		     }  else { rpt->Value.IntVal = (ipt->Value.IntVal / ppy) + VCAL_BaseYear ; } ;
		  }
		  break ;
		case V4DPI_PntType_UWeek:
		  rpt->Value.IntVal = (ipt->Value.IntVal / 52) + VCAL_BaseYear ; break ;
	      } ;
	     rpt->PntType = V4DPI_PntType_UYear ; rpt->Dim = Dim_UYear ;
	     break ; 
	   case -V4IM_Tag_UWeek:
	     switch(ipt->PntType)
	      { default:
		  v_Msg(ctx,NULL,"DTInfoTagRes",intmodx,res,ipt->PntType) ; goto dtinfo_fail ; 
		case V4DPI_PntType_Calendar:
		  GETREAL(dnum,ipt) ; fpart = modf(dnum,&ipart) ;
		  ISOFromFixed((int)ipart,&cal) ;
		  if (cal.Year < VCAL_UYearMin || cal.Year > VCAL_UYearMax)
		   { v_Msg(ctx,NULL,"DTInfoConvert",intmodx,ipt,V4DPI_PntType_UWeek) ; goto dtinfo_fail ; } ;
		  rpt->Value.IntVal = (cal.Year-VCAL_BaseYear)*52 + cal.Week ; break ;
		case V4DPI_PntType_UDate:
		  rpt->Value.IntVal = mscu_udate_to_uweek(ipt->Value.IntVal,BaseDate) ;
		  if (rpt->Value.IntVal == VCAL_BadVal) { v_Msg(ctx,NULL,"UWeekBefore",intmodx,ipt->Value,V4DPI_PntType_UWeek) ;  goto dtinfo_fail ; } ;
		  break ;
		case V4DPI_PntType_UDT:
		  rpt->Value.IntVal = mscu_udate_to_uweek(UDTtoUD(ipt->Value.IntVal),BaseDate) ;
		  if (rpt->Value.IntVal == VCAL_BadVal) { v_Msg(ctx,NULL,"UWeekBefore",intmodx,ipt->Value,V4DPI_PntType_UWeek) ;  goto dtinfo_fail ; } ;
		  break ;
	      } ;
	     rpt->PntType = V4DPI_PntType_UWeek ; rpt->Dim = Dim_UWeek ;
	     break ; 
	   case -V4IM_Tag_UQuarter:
	     if (BaseMonth == 0) BaseMonth = 1 ;
	     switch(ipt->PntType)
	      { default:
		  v_Msg(ctx,NULL,"DTInfoTagRes",intmodx,res,ipt->PntType) ; goto dtinfo_fail ; 
		case V4DPI_PntType_Calendar:
		  GETREAL(dnum,ipt) ; fpart = modf(dnum,&ipart) ;
		  rpt->Value.IntVal = (int)ipart - VCal_MJDOffset ;
		  if (rpt->Value.IntVal < 0) { v_Msg(ctx,NULL,"DTInfoConvert",intmodx,ipt,V4DPI_PntType_UQuarter) ; goto dtinfo_fail ; } ;
		  i = mscu_udate_to_yyyymmdd(rpt->Value.IntVal) ;
		  y = i/10000 ; m = (i/100)%100 ;
		  break ;
		case V4DPI_PntType_UDate:
		  i = mscu_udate_to_yyyymmdd(ipt->Value.IntVal) ;
		  y = i/10000 ; m = (i/100)%100 ;
		  break ;
		case V4DPI_PntType_UDT:
		  i = mscu_udate_to_yyyymmdd(UDTtoUD(ipt->Value.IntVal)) ;
		  y = i/10000 ; m = (i/100)%100 ;
		  break ;
		case V4DPI_PntType_UMonth:
		  y = ipt->Value.IntVal / 12 + VCAL_BaseYear ; m = (ipt->Value.IntVal % 12) + 1 ;
		  break ;
	      } ;
	     m -= BaseMonth ; if (m < 0) { y-- ; m += 12 ; } ;
	     rpt->Value.IntVal = YYMMtoUQTR(y,m) ;
	     rpt->PntType = V4DPI_PntType_UQuarter ; rpt->Dim = Dim_UQuarter ;
	     break ; 
	   case -V4IM_Tag_Period:
	     switch(ipt->PntType)
	      { default:
		  v_Msg(ctx,NULL,"DTInfoTagRes",intmodx,res,ipt->PntType) ; goto dtinfo_fail ; 
		case V4DPI_PntType_UPeriod:
		  { struct V4DPI__DimInfo *di ; int ppy ;
		    DIMINFO(di,ctx,ipt->Dim) ; ppy = (di->ds.UPeriod.periodsPerYear == 0 ? 13 : di->ds.UPeriod.periodsPerYear) ;
		    if (ipt->Value.IntVal > 100000)		/* Got regular period or year end adjustment? */
		     { rpt->Value.IntVal = (ipt->Value.IntVal % 100) ;
		     }  else { rpt->Value.IntVal = (ipt->Value.IntVal % ppy) + 1 ; } ;
		  }
	      } ;
	     rpt->PntType = V4DPI_PntType_Int ; rpt->Dim = Dim_Int ;
	     break ;
	   case -V4IM_Tag_UPeriod:
	     if (BaseMonth == 0) BaseMonth = 1 ;
	     switch(ipt->PntType)
	      { default:
		  v_Msg(ctx,NULL,"DTInfoTagRes",intmodx,res,ipt->PntType) ; goto dtinfo_fail ; 
	      } ;
	     rpt->PntType = V4DPI_PntType_UPeriod ; rpt->Dim = Dim_UPeriod ;
	     break ; 
	   case -V4IM_Tag_Month:
	     switch(ipt->PntType)
	      { default:
		  v_Msg(ctx,NULL,"DTInfoTagRes",intmodx,res,ipt->PntType) ; goto dtinfo_fail ; 
		case V4DPI_PntType_Calendar:
		  GETREAL(dnum,ipt) ; fpart = modf(dnum,&ipart) ;
		  switch (VCAL_CalType_Gregorian)
		   { default:	CalNYI ;
		     case VCAL_CalType_Gregorian:	GregorianFromFixed((int)ipart,&cal) ; break ;
		     case VCAL_CalType_Julian:		JulianFromFixed((int)ipart,&cal) ; break ;
		     case VCAL_CalType_Islamic:		IslamicFromFixed((int)ipart,&cal) ; break ;
		     case VCAL_CalType_ISO:		v_Msg(ctx,NULL,"DTInfoISOMonth",intmodx,res) ; goto dtinfo_fail ; 
		     case VCAL_CalType_Hebrew:		HebrewFromFixed((int)ipart,&cal) ; break ;
		     case VCAL_CalType_Chinese:
		     case VCAL_CalType_Hindu:		CalNYI ;
		   } ;
		  rpt->Value.IntVal = cal.Month ; break ;
		case V4DPI_PntType_UDate:
		  i = mscu_udate_to_yyyymmdd(ipt->Value.IntVal) ;
		  rpt->Value.IntVal = (i/100) % 100 ; break ;
		case V4DPI_PntType_UDT:
		  i = mscu_udate_to_yyyymmdd(UDTtoUD(ipt->Value.IntVal)) ;
		  rpt->Value.IntVal = (i/100) % 100 ; break ;
		case V4DPI_PntType_UMonth:
		  rpt->Value.IntVal = (ipt->Value.IntVal % 12) + 1 ; break ;
	      } ;
	     rpt->PntType = V4DPI_PntType_Int ; rpt->Dim = Dim_Int ;
	     break ; 
	   case -V4IM_Tag_DayOfYear:
	     switch(ipt->PntType)
	      { default:
		  v_Msg(ctx,NULL,"DTInfoTagRes",intmodx,res,ipt->PntType) ; goto dtinfo_fail ; 
		case V4DPI_PntType_Calendar:
		  GETREAL(dnum,ipt) ; fpart = modf(dnum,&ipart) ;
		  switch (VCAL_CalType_Gregorian)
		   { default:	CalNYI ;
		     case VCAL_CalType_Gregorian:	GregorianFromFixed((int)ipart,&cal) ; i = FixedFromGregorian(cal.Year,1,1) ; break ;
		     case VCAL_CalType_Julian:		JulianFromFixed((int)ipart,&cal) ;  i = FixedFromJulian(cal.Year,1,1) ;break ;
		     case VCAL_CalType_Islamic:		IslamicFromFixed((int)ipart,&cal) ; i = FixedFromIslamic(cal.Year,1,1) ; break ;
		     case VCAL_CalType_ISO:		ISOFromFixed((int)ipart,&cal) ; i = FixedFromISO(cal.Year,1,1) ; break ;
		     case VCAL_CalType_Hebrew:		HebrewFromFixed((int)ipart,&cal) ; i = FixedFromHebrew(cal.Year,1,1) ; break ;
		     case VCAL_CalType_Chinese:
		     case VCAL_CalType_Hindu:		CalNYI ;
		   } ;
		  rpt->Value.IntVal = (int)ipart - i + 1 ; break ;
		case V4DPI_PntType_UDate:
		  i = mscu_udate_to_yyyymmdd(ipt->Value.IntVal) ;
		  rpt->Value.IntVal = ipt->Value.IntVal - mscu_ymd_to_ud(i/10000,1,1) + 1 ;
		  break ;
		case V4DPI_PntType_UDT:
		  i = mscu_udate_to_yyyymmdd(UDTtoUD(ipt->Value.IntVal)) ;
		  rpt->Value.IntVal = (ipt->Value.IntVal / VCAL_SecsInDay + VCAL_UDTUDateOffset) - mscu_ymd_to_ud(i/10000,1,1) + 1 ;
		  break ;
	      } ;
	     rpt->PntType = V4DPI_PntType_Int ; rpt->Dim = Dim_Int ;
	     break ; 
	   case -V4IM_Tag_DaylightSavings:
	     switch(ipt->PntType)
	      { default:
		  v_Msg(ctx,NULL,"DTInfoTagRes",intmodx,res,ipt->PntType) ; goto dtinfo_fail ; 
		case V4DPI_PntType_Calendar:
		  GETREAL(dnum,ipt) ; ud = vcal_CalToUDate(dnum,VCAL_TimeZone_Local,&ok) ; break ;
		case V4DPI_PntType_UDate:
		  ud = ipt->Value.IntVal ; break ;
		case V4DPI_PntType_UDT:
		  ud = UDTtoUD(ipt->Value.IntVal) ; break ;
	      } ;
	    i = mscu_udate_to_yyyymmdd(ud) ; y = i / 10000 ;
	    { int start,end ;		/* Start & End UDates for daylight savings in year y */
	      start = NthKDay(1,0,y,4,1) ; end = NthKDay(-1,0,y,10,31) ;
	      rpt->Value.IntVal = (start <= (ud + VCal_MJDOffset) && end > (ud + VCal_MJDOffset)) ;
	    }
	    rpt->Dim = Dim_Logical ; rpt->PntType = V4DPI_PntType_Logical ;
	    break ;
	      
	   case -V4IM_Tag_Easter:
	   case -V4IM_Tag_YomKippur:
	   case -V4IM_Tag_Passover:
	     switch(ipt->PntType)
	      { default:
		  v_Msg(ctx,NULL,"DTInfoTagRes",intmodx,res,ipt->PntType) ; goto dtinfo_fail ; 
		case V4DPI_PntType_Calendar:
		  GETREAL(dnum,ipt) ;
		  GregorianFromFixed((int)dnum,&cal) ; y = cal.Year ; break ;
		case V4DPI_PntType_UDate:
		  i = mscu_udate_to_yyyymmdd(ipt->Value.IntVal) ; y = i / 10000 ; break ;
		case V4DPI_PntType_UDT:
		  i = mscu_udate_to_yyyymmdd(UDTtoUD(ipt->Value.IntVal)) ;
		  y = i / 10000 ; break ;
		case V4DPI_PntType_UMonth:
		  y = (ipt->Value.IntVal / 12) + VCAL_BaseYear ; break ;
		case V4DPI_PntType_UQuarter:
		  y = UQTRtoUYEAR(ipt->Value.IntVal) ; break ;
		case V4DPI_PntType_UYear:
		  y = ipt->Value.IntVal ; break ;
		case V4DPI_PntType_UWeek:
		  y = (ipt->Value.IntVal / 52) + VCAL_BaseYear ; break ;
	      } ;
	     switch(res)
	      { default:
	        case -V4IM_Tag_Easter:		i = Easter(y) ; break ;
		case -V4IM_Tag_YomKippur:	i = YomKippur(y) ; break ;
		case -V4IM_Tag_Passover:	i = Passover(y) ; break ;
	      } ;
	     rpt->Dim = Dim_UDate ; rpt->PntType = V4DPI_PntType_UDate ; rpt->Value.IntVal = i - VCal_MJDOffset ; break ;
	 } ;
	return(rpt) ;

dtinfo_fail:
	 REGISTER_ERROR(0) ; return(NULL) ;
}


/*	v4imu_CompareTime - Performs comparisons (LT/LE/GT/GE/LEG) for time (UDT, Date, Week, ...)	*/
/*	Call:	result = v4imu_CompareTime( ctx , intmodx , tpt1, tpt2 , ok )
	  where result is logical TRUE/FALSE (1/0) result or -999 if compare not valid,
		ctx is context
		intmodx is V4IM_OpCode_xxx,
		tpt1 & tpt2 are two time points to compare,
		ok is updated to TRUE if all well, FALSE if problems					*/

int v4imu_CompareTime(ctx,intmodx,tpt1,tpt2,ok)
  struct V4C__Context *ctx ;
  INTMODX intmodx ; LOGICAL *ok ;
  P *tpt1, *tpt2 ;
{ struct V4DPI__DimInfo *di ;
  int i, t1val, t2val ; double dnum,dnum2 ;

	t2val = tpt2->Value.IntVal ;			/* Assume second point is int value until we have to assume otherwise */
	*ok = TRUE ;
	switch (tpt1->PntType)
	 {
	   case V4DPI_PntType_UDT:
		t1val = tpt1->Value.IntVal ;
		switch(tpt2->PntType)
		 { default: t2val = v4im_GetPointInt(ok,tpt2,ctx) ; break ;
		   case V4DPI_PntType_UDT:	break ;
		   case V4DPI_PntType_Calendar:
			GETREAL(dnum,tpt2) ;
			t2val = vcal_CalToUDT(dnum,VCAL_TimeZone_Local,ok) ; break ;
		   case V4DPI_PntType_UDate:
		   	t1val = UDTtoUD(t1val) ; break ;
		   case V4DPI_PntType_UWeek:	
			DIMINFO(di,ctx,tpt2->Dim) ;
			t1val = mscu_udate_to_uweek(UDTtoUD(t1val),di->ds.UWeek.baseUDate) ;
			if (t1val == VCAL_BadVal) return(-999) ;
			break ;
		   case V4DPI_PntType_UMonth:
			UDtoUMONTH(t1val,UDTtoUD(t1val)) ; break ;
		   case V4DPI_PntType_UQuarter:
			i = mscu_udate_to_yyyymmdd(UDTtoUD(t1val)) ;
			t1val = YYYYMMDDtoUQTR(i) ; break ;
		   case V4DPI_PntType_UYear:
			i = mscu_udate_to_yyyymmdd(UDTtoUD(t1val)) ;
			t1val = i / 10000 ; break ;
		 } ;
		break ;
	   case V4DPI_PntType_Calendar:
		GETREAL(dnum,tpt1) ;
		switch(tpt2->PntType)
		 { default: t2val = v4im_GetPointDbl(ok,tpt2,ctx) ; break ;
		   case V4DPI_PntType_UDT:
			GETREAL(dnum,tpt1) ;
			t1val = vcal_CalToUDT(dnum,VCAL_TimeZone_Local,ok) ; break ;
		   case V4DPI_PntType_Calendar:
			GETREAL(dnum2,tpt2) ;
			switch (intmodx)
			 {
			   case V4IM_OpCode_LT:		return(dnum < dnum2) ;
			   case V4IM_OpCode_LE:		return(dnum <= dnum2) ;
			   case V4IM_OpCode_GE:		return(dnum >= dnum2) ;
			   case V4IM_OpCode_GT:		return(dnum > dnum2) ;
			   case V4IM_OpCode_LEG:	return(dnum < dnum2 ? -1 : (dnum == dnum2 ? 0 : 1)) ;
			 } ;
		   case V4DPI_PntType_UDate:
		   	t1val = vcal_CalToUDate(dnum,VCAL_TimeZone_Local,ok) ; break ;
		   case V4DPI_PntType_UWeek:	
			DIMINFO(di,ctx,tpt2->Dim) ;
			t1val = mscu_udate_to_uweek(vcal_CalToUDate(dnum,VCAL_TimeZone_Local,ok),di->ds.UWeek.baseUDate) ; break ;
		   case V4DPI_PntType_UMonth:
			i = vcal_CalToUDate(dnum,VCAL_TimeZone_Local,ok) ; i = mscu_udate_to_yyyymmdd(i) ;
			UDtoUMONTH(t1val,i) ; break ;
		   case V4DPI_PntType_UQuarter:
			i = mscu_udate_to_yyyymmdd(vcal_CalToUDate(dnum,VCAL_TimeZone_Local,ok)) ;
			t1val = YYYYMMDDtoUQTR(i) ; break ;
		   case V4DPI_PntType_UYear:
			i = mscu_udate_to_yyyymmdd(vcal_CalToUDate(dnum,VCAL_TimeZone_Local,ok)) ;
			t1val = i / 10000 ; break ;
		 } ;
		break ;
	   case V4DPI_PntType_UDate:
		t1val = tpt1->Value.IntVal ;
		switch(tpt2->PntType)
		 { default: t2val = v4im_GetPointInt(ok,tpt2,ctx) ; break ;
		   case V4DPI_PntType_UDT:
		   	t2val = UDTtoUD(t2val) ; break ;
		   case V4DPI_PntType_Calendar:
			GETREAL(dnum,tpt2) ;
			t2val = vcal_CalToUDate(dnum,VCAL_TimeZone_Local,ok) ; break ;
		   case V4DPI_PntType_UDate:	break ;
		   case V4DPI_PntType_UWeek:	
			DIMINFO(di,ctx,tpt2->Dim) ;
			t1val = mscu_udate_to_uweek(t1val,di->ds.UWeek.baseUDate) ;
			if (t1val == VCAL_BadVal) return(-999) ;
			break ;
		   case V4DPI_PntType_UMonth:
			i = mscu_udate_to_yyyymmdd(t1val) ;
			UDtoUMONTH(t1val,t1val) ; break ;
		   case V4DPI_PntType_UQuarter:
			i = mscu_udate_to_yyyymmdd(t1val) ;
			t1val = YYYYMMDDtoUQTR(i) ; break ;
		   case V4DPI_PntType_UYear:
			i = mscu_udate_to_yyyymmdd(t1val) ;
			t1val = i / 10000 ; break ;
		 } ;
		break ;
	   case V4DPI_PntType_UWeek:
		t1val = tpt1->Value.IntVal ;
		DIMINFO(di,ctx,tpt1->Dim) ;
		switch(tpt2->PntType)
		 { default: t2val = v4im_GetPointInt(ok,tpt2,ctx) ; break ;
		   case V4DPI_PntType_UDT:
			t2val = mscu_udate_to_uweek(UDTtoUD(t2val),di->ds.UWeek.baseUDate) ;
			if (t1val == VCAL_BadVal) return(-999) ;
			break ;
		   case V4DPI_PntType_Calendar:
			GETREAL(dnum,tpt2) ;
			t2val = mscu_udate_to_uweek(vcal_CalToUDate(dnum,VCAL_TimeZone_Local,ok),di->ds.UWeek.baseUDate) ;
			if (t1val == VCAL_BadVal) return(-999) ;
			break ;
		   case V4DPI_PntType_UDate:
			t2val = mscu_udate_to_uweek(t2val,di->ds.UWeek.baseUDate) ;
			if (t1val == VCAL_BadVal) return(-999) ;
			break ;
		   case V4DPI_PntType_UWeek:	break ;
		   case V4DPI_PntType_UMonth:
			return(-999) ;
		   case V4DPI_PntType_UPeriod:
			return(-999) ;
		   case V4DPI_PntType_UQuarter:
			return(-999) ;
		   case V4DPI_PntType_UYear:
			t1val = (t1val / 52) + VCAL_BaseYear ; break ;
		 } ;
		break ;
	   case V4DPI_PntType_UMonth:
		t1val = tpt1->Value.IntVal ;
		switch(tpt2->PntType)
		 { default: t2val = v4im_GetPointInt(ok,tpt2,ctx) ; break ;
		   case V4DPI_PntType_UDT:
			UDtoUMONTH(t2val,UDTtoUD(t2val)) ; break ;
		   case V4DPI_PntType_Calendar:
			GETREAL(dnum,tpt2) ;
			t2val = vcal_CalToUDate(dnum,VCAL_TimeZone_Local,ok) ;
			UDtoUMONTH(t2val,t2val) ; break ;
		   case V4DPI_PntType_UDate:
			UDtoUMONTH(t2val,t2val) ; break ;
		   case V4DPI_PntType_UWeek:
			return(-999) ;
		   case V4DPI_PntType_UMonth:	break ;
		   case V4DPI_PntType_UPeriod:
			return(-999) ;
		   case V4DPI_PntType_UQuarter:
			t1val = UMONTHtoUQTR(t1val) ; break ;
		   case V4DPI_PntType_UYear:
			t1val = (t1val / 12) + VCAL_BaseYear ; break ;
		 } ;
		break ;
	   case V4DPI_PntType_UPeriod:
		t1val = tpt1->Value.IntVal ; DIMINFO(di,ctx,tpt1->Dim) ;
		switch(tpt2->PntType)
		 { default: t2val = v4im_GetPointInt(ok,tpt2,ctx) ; break ;
		   case V4DPI_PntType_UPeriod:
			{ int ppy1, ppy2 ; ppy1 = (di->ds.UPeriod.periodsPerYear == 0 ? 13 : di->ds.UPeriod.periodsPerYear) ;
			  DIMINFO(di,ctx,tpt2->Dim) ; ppy2 = (di->ds.UPeriod.periodsPerYear == 0 ? 13 : di->ds.UPeriod.periodsPerYear) ;
			  if (ppy1 != ppy2)
			   { v_Msg(ctx,ctx->ErrorMsgAux,"DTPeriodCmp",intmodx,tpt1->Dim,ppy1,tpt2->Dim,ppy2) ; *ok = FALSE ; return(FALSE) ; } ;
			}
			break ;
		   case V4DPI_PntType_UYear:
			t1val = t1val / (di->ds.UPeriod.periodsPerYear == 0 ? 13 : di->ds.UPeriod.periodsPerYear) + VCAL_BaseYear ; break ;
		 } ;
		break ;
	   case V4DPI_PntType_UQuarter:
		t1val = tpt1->Value.IntVal ;
		switch(tpt2->PntType)
		 { default: t2val = v4im_GetPointInt(ok,tpt2,ctx) ; break ;
		   case V4DPI_PntType_UDT:
			i = mscu_udate_to_yyyymmdd(UDTtoUD(t2val)) ;
			t2val = YYYYMMDDtoUQTR(i) ; break ;
		   case V4DPI_PntType_Calendar:
			GETREAL(dnum,tpt2) ;
			t2val = vcal_CalToUDate(dnum,VCAL_TimeZone_Local,ok) ;
			i = mscu_udate_to_yyyymmdd(t2val) ;
			t2val = YYYYMMDDtoUQTR(i) ; break ;
		   case V4DPI_PntType_UDate:
			i = mscu_udate_to_yyyymmdd(t2val) ;
			t2val = YYYYMMDDtoUQTR(i) ; break ;
		   case V4DPI_PntType_UWeek:	
			return(-999) ;
		   case V4DPI_PntType_UMonth:
			t2val = UMONTHtoUQTR(t2val) ;
		   case V4DPI_PntType_UQuarter:	break ;
		   case V4DPI_PntType_UYear:
			t1val = UQTRtoUYEAR(t1val) ; break ;
		 } ;
		break ;
	   case V4DPI_PntType_UYear:
		t1val = tpt1->Value.IntVal ;
		switch(tpt2->PntType)
		 { default: t2val = v4im_GetPointInt(ok,tpt2,ctx) ; break ;
		   case V4DPI_PntType_UDT:
			i = UDTtoUD(t2val) ; i = mscu_udate_to_yyyymmdd(i) ;
			t2val = i / 10000 ; break ;
		   case V4DPI_PntType_Calendar:
			GETREAL(dnum,tpt2) ;
			t2val = vcal_CalToUDate(dnum,VCAL_TimeZone_Local,ok) ;
			i = mscu_udate_to_yyyymmdd(t2val) ;
			t2val = i / 10000 ; break ;
		   case V4DPI_PntType_UDate:
			i = mscu_udate_to_yyyymmdd(t2val) ;
			t2val = i / 10000 ; break ;
		   case V4DPI_PntType_UWeek:
			t2val = (t2val / 52) + VCAL_BaseYear ; break ;
		   case V4DPI_PntType_UMonth:
			t2val = (t2val / 12) + VCAL_BaseYear ; break ;
		   case V4DPI_PntType_UPeriod:
			DIMINFO(di,ctx,tpt2->Dim) ;
			t2val = (t2val / (di->ds.UPeriod.periodsPerYear == 0 ? 13 : di->ds.UPeriod.periodsPerYear)) + VCAL_BaseYear ;
			break ;
		   case V4DPI_PntType_UQuarter:
			t2val = UQTRtoUYEAR(t2val) ; break ;
		   case V4DPI_PntType_UYear:	break ;
		 } ;
		break ;
	 } ;
	switch (intmodx)
	 { default:
	   case V4IM_OpCode_LT:		return(t1val < t2val) ;
	   case V4IM_OpCode_LE:		return(t1val <= t2val) ;
	   case V4IM_OpCode_GE:		return(t1val >= t2val) ;
	   case V4IM_OpCode_GT:		return(t1val > t2val) ;
	   case V4IM_OpCode_LEG:	return(t1val < t2val ? -1 : (t1val == t2val ? 0 : 1)) ;
	 } ;
	return(FALSE) ;			/* Return false as default */
}


/*	v4imu_Bits - Handles Bits() IntMod		*/

P *v4imu_Bits(ctx,respnt,intmodx,argpnts,argcnt)
  struct V4C__Context *ctx ;
  INTMODX intmodx ;
  P *respnt,*argpnts[] ;
  COUNTER argcnt ;
{ P *cpt,pnt ;
  struct V4DPI__Point_IntMix *pim ;
  int j,t,*ip ;
  COUNTER maxBit ; B64INT mask,tv ; INDEX ix ; LOGICAL ok,haveVal ; int imask ;

	ok = TRUE ; haveVal = FALSE ;
/*	Figure out what initial bitmap is (ip->bit map) */
	ip = (int *)UCTBUF1 ; 
	switch(argpnts[1]->PntType)
	 { default:
		memcpy((BYTE *)ip,(BYTE *)&argpnts[1]->Value,argpnts[1]->Bytes - V4DPI_PointHdr_Bytes) ;
		maxBit = (argpnts[1]->Bytes - V4DPI_PointHdr_Bytes) * sizeof(char) * 8 ;
		break ;
	   CASEofCharmU
		v4im_GetPointChar(&ok,(BYTE *)ip,V4TMBufMax,argpnts[1],ctx) ; maxBit = strlen((char *)ip) * sizeof(char) * 8 ;
		break ;
	   case V4DPI_PntType_UCChar:
		v4im_GetPointUC(&ok,(UCCHAR *)ip,V4TMBufMax,argpnts[1],ctx) ; maxBit = UCstrlen((UCCHAR *)ip) * sizeof(UCCHAR) * 8 ;
		break ;
	   case V4DPI_PntType_SegBitMap:
		maxBit = 0 ; break ;
	 } ;
	mask = *(B64INT *)ip ;		/* Mask is 32/64 bit representation of bitmap, used in various tests below */
	for(ix=2;ok&&ix<=argcnt;ix++)
	 { 
	   switch (t=v4im_CheckPtArgNew(ctx,argpnts[ix],&cpt,&pnt))
	    { default:			v_Msg(ctx,NULL,"TagBadUse",intmodx) ; goto fail ;
	      case V4IM_Tag_Unk:	v_Msg(ctx,NULL,"TagUnknown",intmodx) ; goto fail ;
	      case V4IM_Tag_And:	tv = v4im_GetPointFixed(&ok,cpt,ctx,0) ; mask &= tv ; haveVal = TRUE ; break ;
	      case V4IM_Tag_All:	tv = v4im_GetPointFixed(&ok,cpt,ctx,0) ; mask = (mask & tv) == tv ; haveVal = TRUE ; break ;
	      case V4IM_Tag_Any:	tv = v4im_GetPointFixed(&ok,cpt,ctx,0) ; mask = (mask & tv) != 0 ; haveVal = TRUE ; break ;
	      case V4IM_Tag_None:	tv = v4im_GetPointFixed(&ok,cpt,ctx,0) ; mask = (mask & tv) == 0 ; haveVal = TRUE ; break ;
	      case V4IM_Tag_Or:		tv = v4im_GetPointFixed(&ok,cpt,ctx,0) ; mask |= tv ; haveVal = TRUE ; break ;
	      case -V4IM_Tag_Not:	mask = ~mask ; haveVal = TRUE ; break ;
	      case V4IM_Tag_AndC:	tv = v4im_GetPointFixed(&ok,cpt,ctx,0) ; mask &= ~tv ; haveVal = TRUE ; break ;
	      case V4IM_Tag_XOR:	tv = v4im_GetPointFixed(&ok,cpt,ctx,0) ; mask ^= tv ; haveVal = TRUE ; break ;
	      case V4IM_Tag_Shift:	tv = v4im_GetPointFixed(&ok,cpt,ctx,0) ;
					mask = (tv < 0 ? (mask >> -tv) : (mask << tv)) ; haveVal = TRUE ; break ;
	      case V4IM_Tag_Else:	memcpy(respnt,cpt,cpt->Bytes) ; return(respnt) ;
	      case -V4IM_Tag_ListOf:
		{ struct V4DPI__LittlePoint lpnt ; struct V4L__ListPoint *lp ;
		  INITLP(respnt,lp,Dim_List) ; intPNT((P *)&lpnt) ;
		  for(j=1;j<=maxBit;j++)
		   { if ((*(ip + ((j-1)>>5)) & (1 << ((j-1) & 0x1f))) == 0) continue ;
		     lpnt.Value.IntVal = j ;
		     if (!v4l_ListPoint_Modify(ctx,lp,V4L_ListAction_Append,(P *)&lpnt,0)) { v_Msg(ctx,NULL,"LPModFail",intmodx) ; goto fail ; } ;
		   } ;
	          ENDLP(respnt,lp) ;
	        }
	        return(respnt) ;
	      case V4IM_Tag_Rotate:
		tv = v4im_GetPointFixed(&ok,cpt,ctx,0) ;
		if (maxBit <= 32)
		 { if (tv < 0) tv += 32 ; imask = mask ;
		   for(j=0;j<tv;j++) { imask = (imask < 0 ? (imask << 1) | 1 : (imask << 1)) ; } ;
		   mask = imask ;
		 } else
		 { if (tv < 0) tv += 64 ;
		   for(j=0;j<tv;j++) { mask = (mask < 0 ? (mask << 1) | 1 : (mask << 1)) ; } ;
		 } ;
		haveVal = TRUE ;
		break ;
	      case V4IM_Tag_Nth:
		if (cpt->Grouping == V4DPI_Grouping_Single)
	      	 { tv = v4im_GetPointInt(&ok,cpt,ctx) ; if (!ok) break ;
	      	   if (tv < 1 || tv > maxBit) { v_Msg(ctx,NULL,"BitReference",intmodx,tv,maxBit) ; goto fail ; } ;
	      	   mask = (*(ip + ((tv-1)>>5)) & (1 << ((tv-1) & 0x1f))) != 0 ;
		 } else
		 { pim = (struct V4DPI__Point_IntMix *)&cpt->Value ;
		   for(j=0;j<cpt->Grouping;j++)
	      	    { for(tv=pim->Entry[j].BeginInt;tv<=pim->Entry[j].EndInt;tv++)
		       { if (tv < 1 || tv > maxBit) { v_Msg(ctx,NULL,"BitReference",intmodx,tv,maxBit) ; goto fail ; } ;
			 mask = (*(ip + ((tv-1)>>5)) & (1 << ((tv-1) & 0x1f))) != 0 ;
			 if (mask) goto multiple_nth_end ;
		       } ;
		    } ;
multiple_nth_end:  mask = (j < cpt->Grouping) ;
		 } ;
		if (ix == argcnt)
		 { logPNTv(respnt,mask) ; return(respnt) ; } ;
		haveVal = TRUE ;
		break ;
	      case V4IM_Tag_Result:
	      case V4IM_Tag_Num:
		if (haveVal)
		 { if (mask > 0) { memcpy(respnt,cpt,cpt->Bytes) ; return(respnt) ; } ;
		 } else if (ix == argcnt)  { memcpy(respnt,cpt,cpt->Bytes) ; return(respnt) ; } ;
		haveVal = FALSE ;
		break ;		/*   otherwise keep plugging */
	    } ;
	 } ;
	if (!ok) { v_Msg(ctx,NULL,"ModInvArg",intmodx,ix-1) ; goto fail ; } ;
	if (maxBit <= 32) { intPNTv(respnt,mask) ; }
	 else { fixPNTv(respnt,mask) ; } ;
	return(respnt) ;

fail:	REGISTER_ERROR(0) ; return(NULL) ;
}









#ifdef OLDBITS
P *v4imu_Bits(ctx,respnt,intmodx,argpnts,argcnt)
  struct V4C__Context *ctx ;
  INTMODX intmodx ;
  P *respnt,*argpnts[] ;
  COUNTER argcnt ;
{ P *ipt,*rpt,pnt ;
  struct V4DPI__Point_IntMix *pim ;
  int mask,mask1,ok,i,j,tv,t,*ip ;
  COUNTER maxBit ;
#define CFM if (ip != NULL) goto no_intval
	ok = TRUE ;
	if (argpnts[1]->PntType == V4DPI_PntType_Char || argpnts[1]->PntType == V4DPI_PntType_BinObj)
	 { v4im_GetPointChar(&ok,ASCTBUF1,512,argpnts[1],ctx) ; ip = (int *)ASCTBUF1 ;
	 } else { mask1 = (mask = v4im_GetPointInt(&ok,argpnts[1],ctx)) ; ip = NULL ; } ;
	for(i=2;ok&&i<=argcnt;i++)
	 { 
	   switch (t=v4im_CheckPtArgNew(ctx,argpnts[i],&ipt,&pnt))
	    { default:			v_Msg(ctx,NULL,"TagBadUse",intmodx) ; goto fail ;
	      case V4IM_Tag_Unk:	v_Msg(ctx,NULL,"TagUnknown",intmodx) ; goto fail ;
	      case V4IM_Tag_And:	CFM ; tv = v4im_GetPointInt(&ok,ipt,ctx) ; mask &= tv ; break ;
	      case V4IM_Tag_All:	CFM ; tv = v4im_GetPointInt(&ok,ipt,ctx) ; mask = (mask & tv) == tv ; break ;
	      case V4IM_Tag_Any:	CFM ; tv = v4im_GetPointInt(&ok,ipt,ctx) ; mask = (mask & tv) != 0 ; break ;
	      case V4IM_Tag_None:	CFM ; tv = v4im_GetPointInt(&ok,ipt,ctx) ; mask = (mask & tv) == 0 ; break ;
	      case V4IM_Tag_Or:		CFM ; tv = v4im_GetPointInt(&ok,ipt,ctx) ; mask |= tv ; break ;
	      case -V4IM_Tag_Not:	CFM ; mask = ~mask ; break ;
	      case V4IM_Tag_AndC:	CFM ; tv = v4im_GetPointInt(&ok,ipt,ctx) ; mask &= ~tv ; break ;
	      case V4IM_Tag_XOR:	CFM ; tv = v4im_GetPointInt(&ok,ipt,ctx) ; mask ^= tv ; break ;
	      case V4IM_Tag_Shift:	CFM ; tv = v4im_GetPointInt(&ok,ipt,ctx) ;
					mask = (tv < 0 ? (mask >> -tv) : (mask << tv)) ; break ;
	      case V4IM_Tag_Rotate:
		CFM ; tv = v4im_GetPointInt(&ok,ipt,ctx) ; if (tv < 0) tv += 32 ;
		for(j=0;j<tv;j++) { mask = (mask < 0 ? (mask << 1) | 1 : (mask << 1)) ; } ;
		break ;
	      case V4IM_Tag_Nth:
		if (ipt->Grouping == V4DPI_Grouping_Single)
	      	 { tv = v4im_GetPointInt(&ok,ipt,ctx) ; if (!ok) break ;
		   if (ip != NULL)
		    { mask = (*(ip + ((tv-1)>>5)) & (1 << ((tv-1) & 0x1f))) != 0 ; }
		    else { if (tv < 1 || tv > 8*sizeof(mask)) { mask = 0 ; break ; } ;
			   mask = ((mask & (1 << (tv-1))) == 0 ? FALSE : TRUE) ;
		         } ;
		 } else
		 { pim = (struct V4DPI__Point_IntMix *)&ipt->Value ;
		   for(j=0;j<ipt->Grouping;j++)
	      	    { for(tv=pim->Entry[j].BeginInt;tv<=pim->Entry[j].EndInt;tv++)
		       { if (ip != NULL)
		          { if ((*(ip + ((tv-1)>>5)) & (1 << ((tv-1) & 0x1f))) != 0) goto multiple_nth_end ; }
		          else { if (tv < 1 || tv > 8*sizeof(mask)) { j = 99999 ; goto multiple_nth_end ; } ;
			         if ((mask & (1 << (tv-1))) != 0) goto multiple_nth_end ;
		               } ;
		       } ;
		    } ;
multiple_nth_end:  mask = (j < ipt->Grouping) ;
		 } ;
		if (i == argcnt)
		 { rpt = respnt ; ZPH(rpt) ; rpt->Bytes = V4PS_Int ; rpt->Dim = Dim_Logical ; rpt->Value.IntVal = mask ;
		   rpt->PntType = V4DPI_PntType_Logical ; return(rpt) ;
		 } ;
		ip = NULL ; break ;
	      case V4IM_Tag_Result:
	      case V4IM_Tag_Num:
		CFM ; if (mask > 0 || i == argcnt)	/* Return this value if mask > 0 */
		 { memcpy(respnt,ipt,ipt->Bytes) ; return(respnt) ; } ;
		mask = mask1 ; break ;		/*   otherwise keep plugging */
	    } ;
	 } ;
	if (!ok) { v_Msg(ctx,NULL,"ModInvArg",intmodx,i-1) ; goto fail ; } ;
	rpt = respnt ; intPNTv(rpt,mask) ;
	return(rpt) ;

no_intval: v_Msg(ctx,NULL,"BitsNotInt",intmodx,t,V4DPI_PntType_Int,argpnts[1]->PntType) ; goto fail ;

fail:	REGISTER_ERROR(0) ; return(NULL) ;
}
#endif

/*	v4imu_Trig - Handles Trig() IntMod		*/

P *v4im_DoTrig(ctx,respnt,argpnts,argcnt,intmodx,trace)
  struct V4C__Context *ctx ;
  INTMODX intmodx ;
  P *respnt,*argpnts[] ;
  COUNTER argcnt ; VTRACE trace ;
{ P *ipt,pnt ;
  int i,t,ok ; double radians,res,x,y,dsin,dcos,dtan ;

	radians = 0.0 ; y = 0.0 ; x = 0.0 ; dsin = UNUSED ; dcos = UNUSED ; dtan = UNUSED ;
	errno = 0 ;
	for(i=1,ok=TRUE;ok&&i<=argcnt;i++)
	 { 
	   switch (t=v4im_CheckPtArgNew(ctx,argpnts[i],&ipt,&pnt))
	    { default:			v_Msg(ctx,NULL,"TagBadUse",intmodx) ; goto fail ;
	      case V4IM_Tag_Unk:	v_Msg(ctx,NULL,"TagUnknown",intmodx) ; goto fail ;
	      case V4IM_Tag_Sin:	dsin = v4im_GetPointDbl(&ok,ipt,ctx) ; break ;
	      case V4IM_Tag_Cos:	dcos = v4im_GetPointDbl(&ok,ipt,ctx) ; break ;
	      case V4IM_Tag_Tan:	dtan = v4im_GetPointDbl(&ok,ipt,ctx) ; break ;
	      case V4IM_Tag_Degrees:	radians = PI * (v4im_GetPointDbl(&ok,ipt,ctx) / 180.0) ; break ;
	      case V4IM_Tag_Radians:	radians = v4im_GetPointDbl(&ok,ipt,ctx) ; break ;
	      case V4IM_Tag_X:		x = v4im_GetPointDbl(&ok,ipt,ctx) ; break ;
	      case V4IM_Tag_Y:		y = v4im_GetPointDbl(&ok,ipt,ctx) ; break ;
	      case -V4IM_Tag_Sin:	res = sin(radians) ; break ;
	      case -V4IM_Tag_Cos:	res = cos(radians) ; break ;
	      case -V4IM_Tag_Tan:	res = tan(radians) ; break ;
	      case -V4IM_Tag_ASin:	res = asin(dsin != UNUSED ? dsin : x) ; break ;
	      case -V4IM_Tag_ACos:	res = acos(dcos != UNUSED ? dcos : x) ; break ;
	      case -V4IM_Tag_ATan:	res = atan(dtan != UNUSED ? dtan : x) ; break ;
	      case -V4IM_Tag_ATan2:	res = atan2(y,x) ; break ;
	      case -V4IM_Tag_TanH:	res = tanh(radians) ; break ;
	      case -V4IM_Tag_CosH:	res = cosh(radians) ; break ;
	      case -V4IM_Tag_SinH:	res = sinh(radians) ; break ;
	      case -V4IM_Tag_Degrees:
	      case -V4IM_Tag_Radians:
		if (dsin != UNUSED) { res = asin(dsin) ; }
		 else if (dtan != UNUSED) { res = atan(dtan) ; }
		 else if (dcos != UNUSED) { res = acos(dcos) ; }
		 else { v_Msg(ctx,NULL,"TrigNoVal",intmodx) ; goto fail ; } ;
		if (t == -V4IM_Tag_Degrees) res = (res * 180.0) / PI ;
		break ;
			
	    } ;
	 } ;
	if (errno == EDOM)
	 { v_Msg(ctx,NULL,"TrigInvArg",intmodx,radians,x,y) ; goto fail ; } ;
	if (!ok) { v_Msg(ctx,NULL,"ModInvArg",intmodx,i-1) ; goto fail ; } ;
	ipt = respnt ; dblPNTv(ipt,res) ;
	return(ipt) ;

fail:	REGISTER_ERROR(0) ; return(NULL) ;
}

/*	v4imu_Log - Handles Log() IntMod		*/

P *v4im_DoLog(ctx,respnt,argpnts,argcnt,intmodx,trace)
  struct V4C__Context *ctx ;
  INTMODX intmodx ;
  P *respnt,*argpnts[] ;
  COUNTER argcnt ; VTRACE trace ;
{ P *ipt,pnt ;
  int i,ok,j ; double res,dnum ;

	ok = TRUE ; res = v4im_GetPointDbl(&ok,argpnts[1],ctx) ;
	for(i=2;ok&&i<=argcnt;i++)
	 { 
	   switch (v4im_CheckPtArgNew(ctx,argpnts[i],&ipt,&pnt))
	    { default:			v_Msg(ctx,NULL,"TagBadUse",intmodx) ; goto fail ;
	      case V4IM_Tag_Unk:	v_Msg(ctx,NULL,"TagUnknown",intmodx) ; goto fail ;
	      case -V4IM_Tag_Exp:	res = exp(res) ; break ;
	      case -V4IM_Tag_Exp2:	res = pow(2.0, res) ; break ;
	      case -V4IM_Tag_Exp10:	res = pow(10.0,res) ; break ;
	      case -V4IM_Tag_Log:	if (res <= 0) goto negfail ; res = log(res) ; break ;
	      case -V4IM_Tag_Log2:	if (res <= 0) goto negfail ; res = log10(res) * 3.32192809488736 ; break ;	/* log2(10) = factor to convert */
	      case -V4IM_Tag_Log10:	if (res <= 0) goto negfail ; res = log10(res) ; break ;
	      case V4IM_Tag_POW:	/* If exponent is integer, make effort to compute cheaply */
		if (ipt->PntType == V4DPI_PntType_Int)
		 { dnum = res ; res = 1.0 ;
		   if (ipt->Value.IntVal >= 0) { for(j=ipt->Value.IntVal;j>0;j--) { res *= dnum ; } ; }
		    else { for(j=ipt->Value.IntVal;j<0;j++) { res /= dnum ; } ; } ;
		 } else
		 { dnum = v4im_GetPointDbl(&ok,ipt,ctx) ; if (!ok) break ; res = pow(res,dnum) ; } ;
		break ;
	    } ;
	 } ;
	if (!ok) { v_Msg(ctx,NULL,"ModInvArg",intmodx,i-1) ; goto fail ; } ;
	ipt = respnt ; dblPNTv(ipt,res) ;
	return(ipt) ;
negfail:
	v_Msg(ctx,NULL,"LogOfNeg",intmodx,res) ; goto fail ;
	
fail:	REGISTER_ERROR(0) ; return(NULL) ;
}

/*	v4imu_DoArray - Handles Array() IntMod		*/

P *v4im_DoArray(ctx,respnt,argpnts,argcnt,intmodx)
  struct V4C__Context *ctx ;
  INTMODX intmodx ;
  P *respnt,*argpnts[] ;
  COUNTER argcnt ;
{ struct V4IM__MDArray *vmda,lvmda ;
  struct V4DPI__DimInfo *di ;
  struct V4L__ListMDArray *lmda ;
  struct V4IM__MDArrayIndexes *mdi ;
  P *ipt,*cpt,*vpt,*lopt,pnt ;
  struct V4L__ListPoint *lp ;
  struct V4DPI__Point_IntMix *pim ;
  char Range[V4DPI_MDArray_Max] ; LOGICAL GotRange ;
  int i,j,ok,index1,index2,num,frameid,listof ; char *bo ;
  INDEX distance[V4DPI_MDArray_Max] ; INDEX ix,entries ; LOGICAL isInc ;

	ipt = argpnts[1] ; vmda = NULL ; vpt = NULL ; memset(&lvmda,0,sizeof lvmda) ; GotRange = FALSE ; isInc = FALSE ;
	lopt = NULL ; distance[0] = UNUSED ; frameid = UNUSED ; listof = 1 ;
	if (ipt->PntType == V4DPI_PntType_MDArray)	/* 1st point is MDArray - set/get value */
	 { vmda = (struct V4IM__MDArray *)han_GetPointer(ipt->Value.IntVal,0) ;
	   if (vmda == NULL)
	    { v_Msg(ctx,NULL,"ModArgPntType",intmodx,1,ipt,V4DPI_PntType_MDArray) ; goto fail ; } ;
	 } else 
	 { DIMINFO(di,ctx,ipt->Dim) ;
	   if (di == NULL ? TRUE : (di->Flags & V4DPI_DimInfo_Dim) == 0)
	    { v_Msg(ctx,NULL,"Array1stArg",intmodx) ; goto fail ; } ;
	   DIMINFO(di,ctx,ipt->Value.IntVal) ;
	   if (di == NULL) { v_Msg(ctx,NULL,"ModArgNotDim",intmodx,1,ipt) ; goto fail ; } ;
	 } ;

	for(ix=2,ok=TRUE;ok&&ix<=argcnt;ix++)
	 { if ((ipt=argpnts[ix])->PntType != V4DPI_PntType_TagVal)	/* Get next dimension value(s) */
	    { 
/*	      Are we picking up dimension indexes (vmda != NULL) OR are we determining array boudaries (vmda == NULL) */
/*	      If vmda is NULL then try to force everything to list EXCEPT a single Dim:Int value which would be handled as number of elements */
/*	      If vmda is not NULL then treat single points as index value */
	      if (ipt->PntType == V4DPI_PntType_List || (vmda == NULL && !(argpnts[ix]->Dim == Dim_Int && argpnts[ix]->Grouping == V4DPI_Grouping_Single)))
	       { lp = v4im_VerifyList(NULL,ctx,ipt,intmodx) ;
	         num = SIZEofLIST(lp) ;
		 if (num <= 0) { v_Msg(ctx,NULL,"ArrayUnkLen",intmodx,ix) ; goto fail ; } ;
		 v4l_ListPoint_Value(ctx,lp,1,&pnt) ;			/* Get 1st point in list */
		 j = pnt.PntType ; lvmda.MDDim[lvmda.MDDimCount].BaseVal = v4im_GetPointInt(&ok,&pnt,ctx) ;
		 if (!ok)
		  { ok = TRUE ;
		    if (pnt.PntType == V4DPI_PntType_Dict || pnt.PntType == V4DPI_PntType_XDict)
		     { lvmda.MDDim[lvmda.MDDimCount].BaseVal = pnt.Value.IntVal ; }
		     else { v_Msg(ctx,NULL,"Array1stEl",intmodx,ix) ; goto fail ; } ;
		  } ;
		 v4l_ListPoint_Value(ctx,lp,num,&pnt) ;		/* Get last point in list */
		 if (j != pnt.PntType) { v_Msg(ctx,NULL,"ArrayLastEl",intmodx,ix) ; goto fail ; } ;
		 lvmda.MDDim[lvmda.MDDimCount].MaxNum = v4im_GetPointInt(&ok,&pnt,ctx) ;
		 if (!ok)
		  { ok = TRUE ;
		    if (pnt.PntType == V4DPI_PntType_Dict || pnt.PntType == V4DPI_PntType_XDict)
		     { lvmda.MDDim[lvmda.MDDimCount].MaxNum = pnt.Value.IntVal ; }
		     else { v_Msg(ctx,NULL,"ArrayLastEL2",intmodx,ix) ; goto fail ; } ;
		  } ;
		 if (num != lvmda.MDDim[lvmda.MDDimCount].MaxNum - lvmda.MDDim[lvmda.MDDimCount].BaseVal + 1)
		  { lvmda.MDDim[lvmda.MDDimCount].BaseVal = LONG_MAX ;	/* Have to search for range */
		    lvmda.MDDim[lvmda.MDDimCount].MaxNum = LONG_MIN ;
		    for(j=1;j<=num;j++)
		     { v4l_ListPoint_Value(ctx,lp,j,&pnt) ;
		       if (pnt.Value.IntVal < lvmda.MDDim[lvmda.MDDimCount].BaseVal) lvmda.MDDim[lvmda.MDDimCount].BaseVal = pnt.Value.IntVal ;
		       if (pnt.Value.IntVal > lvmda.MDDim[lvmda.MDDimCount].MaxNum) lvmda.MDDim[lvmda.MDDimCount].MaxNum = pnt.Value.IntVal ;
		     } ;
/*		    Check the range of point values compared to the number - if difference too large then save specific points */
		    if (lvmda.MDDim[lvmda.MDDimCount].MaxNum - lvmda.MDDim[lvmda.MDDimCount].BaseVal > 2 * num)
		     { mdi = (struct V4IM__MDArrayIndexes *)v4mm_AllocChunk(MDIndexBytes(num),FALSE) ;
		       mdi->Count = num ;
		       for(j=1;j<=num;j++)
		        { v4l_ListPoint_Value(ctx,lp,j,&pnt) ; mdi->Indexes[j-1] = pnt.Value.IntVal ;
			} ; lvmda.MDDim[lvmda.MDDimCount].vmdi = mdi ;
		       lvmda.MDDim[lvmda.MDDimCount].MaxNum = num ; lvmda.MDDim[lvmda.MDDimCount].BaseVal = 1 ;
		     } ;
		  } ;
		 ipt = &pnt ;
	       } else if (ipt->Grouping == V4DPI_Grouping_Single)
	       { lvmda.MDDim[lvmda.MDDimCount].MaxNum = v4im_GetPointInt(&ok,argpnts[ix],ctx) ;
		 if (!ok)
		  { if (argpnts[ix]->PntType == V4DPI_PntType_Dict || argpnts[ix]->PntType == V4DPI_PntType_XDict)
		     { lvmda.MDDim[lvmda.MDDimCount].MaxNum = argpnts[ix]->Value.IntVal ; ok = TRUE ; }
		  } ;
	         lvmda.MDDim[lvmda.MDDimCount].BaseVal = 1 ;
/*		 If we got an explicit list of dimension values (vmdi not NULL) then find the correct point */
		 if (vmda == NULL ? FALSE : (mdi = vmda->MDDim[lvmda.MDDimCount].vmdi) != NULL)
		  { for(j=0;j<mdi->Count;j++) { if (mdi->Indexes[j] == argpnts[ix]->Value.IntVal) break ; } ;
		    if (j >= mdi->Count)
		     { v_Msg(ctx,NULL,"ArrayNotFnd",intmodx,ix,argpnts[ix]) ; goto fail ; } ;
		    lvmda.MDDim[lvmda.MDDimCount].MaxNum = j+1 ;
		  } ;
	       } else
	       { pim = (struct V4DPI__Point_IntMix *)&ipt->Value ;
	         if (ipt->Grouping > 1) { v_Msg(ctx,NULL,"ArrayNYI",intmodx,ipt) ; goto fail ; } ;
	         lvmda.MDDim[lvmda.MDDimCount].MaxNum = pim->Entry[0].EndInt ;
	         lvmda.MDDim[lvmda.MDDimCount].BaseVal = pim->Entry[0].BeginInt ;
		 if (!GotRange) { GotRange = TRUE ; memset(Range,FALSE,V4DPI_MDArray_Max) ; } ;
		 Range[lvmda.MDDimCount] = TRUE ;
	       } ;
	      lvmda.MDDim[lvmda.MDDimCount].PntType = ipt->PntType ;
	      lvmda.MDDim[lvmda.MDDimCount].dimId = ipt->Dim ;
	      lvmda.MDDimCount++ ;
	      continue ;
	    } ;
	   switch (v4im_CheckPtArgNew(ctx,argpnts[ix],&cpt,&pnt))
	    { default:			v_Msg(ctx,NULL,"TagBadUse",intmodx) ; goto fail ;
	      case V4IM_Tag_Unk:	v_Msg(ctx,NULL,"TagUnknown",intmodx) ; goto fail ;
	      case V4IM_Tag_Distance:	if (cpt->PntType == V4DPI_PntType_List)
					 { lp = v4im_VerifyList(NULL,ctx,cpt,intmodx) ;
					   for(i=0;i<V4DPI_MDArray_Max;i++)
					    { if (v4l_ListPoint_Value(ctx,lp,i+1,&pnt) <= 0) break ;
					      distance[i] = v4im_GetPointInt(&ok,&pnt,ctx) ;
					      if (distance[i] <= 0) { v_Msg(ctx,NULL,"ModArgPos",intmodx,i,cpt) ; goto fail ; } ;
					    } ;
					   for(;i<V4DPI_MDArray_Max;i++) { distance[i] = distance[i-1] ; } ;
					 } else		/* Argument is scaler - make all elements of distance[] the same */
					 { distance[0] = v4im_GetPointInt(&ok,cpt,ctx) ; if (!ok) break ;
					   if (distance[0] <= 0) { v_Msg(ctx,NULL,"ModArgPos",intmodx,ix,cpt) ; goto fail ; } ;
					   for(i=1;i<V4DPI_MDArray_Max;i++) { distance[i] = distance[i-1] ; } ;
					 } ;
					break ;
	      case V4IM_Tag_If:		lopt = cpt ; break ;
	      case V4IM_Tag_ListOf:	if (cpt->PntType == V4DPI_PntType_Int)
					 { INDEX dx ; struct V4DPI__LittlePoint lpnt ;
					   if (vmda == NULL) { v_Msg(ctx,NULL,"ArrayUndef",intmodx,argpnts[ix]) ; goto fail ; } ;
					   dx = v4im_GetPointInt(&ok,cpt,ctx) ; if (!ok) break ;
					   if (dx < 1 || dx > vmda->MDDimCount) { v_Msg(ctx,NULL,"ArraySlot",intmodx,dx,vmda->MDDimCount) ; goto fail ; } ;
					   dx-- ;
					   if (vmda->MDDim[dx].vmdi == NULL)
					    { ZPH(respnt) ; respnt->Dim = vmda->MDDim[dx].dimId ; respnt->PntType = vmda->MDDim[dx].PntType ;
					      pim = (struct V4DPI__Point_IntMix *)&respnt->Value ;
					      if (respnt->PntType == V4DPI_PntType_Dict || respnt->PntType == V4DPI_PntType_XDict)
					       { respnt->Grouping = 1 ;
					       } else
					       { pim->Entry[0].BeginInt = vmda->MDDim[dx].BaseVal ; pim->Entry[0].EndInt = vmda->MDDim[dx].BaseVal + vmda->MDDim[dx].MaxNum - 1 ;
						 respnt->Grouping = 1 ; SETBYTESGRPINT(respnt) ;
					       } ;
					      return(respnt) ;
//					      v_Msg(ctx,NULL,"ArraySlot",intmodx,dx+1,vmda->MDDimCount) ; goto fail ;
					    } ;
					   DIMINFO(di,ctx,vmda->MDDim[dx].vmdi->dimId) ;
					   INITLP(respnt,lp,Dim_List) ;
					   ZPH(&lpnt) ; lpnt.Dim = di->DimId ; lpnt.PntType = di->PointType ; lpnt.Bytes = gpi->PointBytes[di->PointType] ;
					   for(i=0;i<vmda->MDDim[dx].vmdi->Count;i++)
					    { lpnt.Value.IntVal = vmda->MDDim[dx].vmdi->Indexes[i] ;
					      if (!v4l_ListPoint_Modify(ctx,lp,V4L_ListAction_Append,(P *)&lpnt,0)) { v_Msg(ctx,NULL,"LPModFail",intmodx) ; goto fail ; } ;
					    } ;
					   ENDLP(respnt,lp) ; return(respnt) ;
					 } ; 
					switch (v4im_GetDictToEnumVal(ctx,cpt))
					 { default:		v_Msg(ctx,NULL,"ArrayListOfVal",intmodx,V4IM_Tag_ListOf,cpt) ; goto fail ;
					   case _Indexes:	listof = 1 ; break ;
					   case _Values:	listof = 2 ; break ;
					 } ;
					break ;
	      case -V4IM_Tag_Release:	if (vmda != NULL ? vmda->Data != NULL : FALSE) { v4mm_FreeChunk(vmda->Data) ;  vmda->Data = NULL ; } ;
					break ;
	      case V4IM_Tag_Add:	isInc = TRUE ;		/* Fall thru to Value:: */
	      case V4IM_Tag_Value:	vpt = cpt ;
					if (vpt->PntType == V4DPI_PntType_Shell) vpt = (P *)&vpt->Value ;
					break ;
	    } ;
	 } ;
	if (!ok) { v_Msg(ctx,NULL,"ModInvArg",intmodx,ix-1) ; goto fail ; } ;
	if (distance[0] != UNUSED && GotRange) { v_Msg(ctx,NULL,"ArrayRange",intmodx,V4IM_Tag_Distance,distance[0]) ; goto fail ; } ;

/*	D E F I N E   N E W   A R R A Y		*/
	if (vmda == NULL)			/* If NULL then defining a new point */
	 { lvmda.ElBytes = gpi->PointBytes[di->PointType] - V4DPI_PointHdr_Bytes ;
	   lvmda.Dim = di->DimId ; lvmda.PntType = di->PointType ;
	   lvmda.MDDim[lvmda.MDDimCount-1].Offset = lvmda.ElBytes ;
	   lvmda.Elements = 1 ;
	   for(i=0;i<lvmda.MDDimCount;i++)		/* Convert MaxNum to actual maximum number */
	    { lvmda.MDDim[i].MaxNum = (lvmda.MDDim[i].MaxNum - lvmda.MDDim[i].BaseVal + 1) ;
	      lvmda.Elements *= lvmda.MDDim[i].MaxNum ;
	    } ;
	   for(i=lvmda.MDDimCount-2;i>=0;i--)	/* Determine sizes of subsets of array */
	    { lvmda.MDDim[i].Offset = lvmda.MDDim[i+1].Offset * lvmda.MDDim[i+1].MaxNum ; } ;
	   lvmda.Bytes = lvmda.MDDim[0].Offset * lvmda.MDDim[0].MaxNum ;
	   if (lvmda.Bytes > 9000000000 || lvmda.Bytes < 1)
	    { char dbuf[128] ; ZS(dbuf) ;
	      for(i=0;i<lvmda.MDDimCount;i++)
	       { char nbuf[32] ; sprintf(nbuf,"%d",lvmda.MDDim[i].MaxNum) ;
		 if (i > 0) strcat(dbuf," * ") ; strcat(dbuf,nbuf) ;
	       } ;
	      v_Msg(ctx,NULL,"ArrayMaxSize",intmodx,dbuf) ; goto fail ;
	    } ; 
	   lvmda.Data = v4mm_AllocChunk(lvmda.Bytes,TRUE) ;
	   vmda = (struct V4IM__MDArray *)v4mm_AllocChunk(sizeof lvmda,FALSE) ;
	   memcpy(vmda,&lvmda,sizeof lvmda) ;
	   ZPH(respnt) ; respnt->Dim = Dim_UArray ; respnt->PntType = V4DPI_PntType_MDArray ;
	   respnt->Bytes = gpi->PointBytes[V4DPI_PntType_MDArray] ;
	   respnt->Value.IntVal = han_Make() ; han_SetPointer(respnt->Value.IntVal,0,vmda) ;
	   return(respnt) ;
	 } ;

/*	Got vmda - get/set an element in existing array */
	if (vmda->Data == NULL)
	 { v_Msg(ctx,NULL,"ArrayDealloc",intmodx,V4IM_Tag_Release) ; goto fail ; } ;
	if (vmda->MDDimCount != lvmda.MDDimCount)
	 { if (lvmda.MDDimCount == 0)			/* If no indexes assume wants list of entire array */
	    { for(i=0;i<vmda->MDDimCount;i++)
	       { Range[i] = TRUE ;
	         lvmda.MDDim[i].BaseVal = vmda->MDDim[i].BaseVal ; lvmda.MDDim[i].MaxNum = vmda->MDDim[i].BaseVal + vmda->MDDim[i].MaxNum - 1 ;
	       } ;
	      GotRange = TRUE ;
	    } else { v_Msg(ctx,NULL,"ArrayMissX",intmodx,vmda->MDDimCount,lvmda.MDDimCount) ; goto fail ; } ;
	 } ;

/*	Looking for list of indexes within specified distance of current index satifying lopt condition */
/*	Result is going to be list of indexes lists */
	if (distance[0] != UNUSED && lopt != NULL)
	 { P lolpnt,pnt2 ; int hits = 0 ;
	   struct V4L__ListPoint *lp2 ;
	   struct {
	    int dimxvals[V4IM_MDArrayIndexesMax] ;	/* Current dimension index value */
	    int dimxbegin[V4IM_MDArrayIndexesMax] ;	/* Starting dimension index value */
	    int dimxend[V4IM_MDArrayIndexesMax] ;	/* Max dimension index value */
	   } dix ;					/* Dimension-Iterating-Indexes */
	   for(i=vmda->MDDimCount-1;i>=0;i--)
	    { j = lvmda.MDDim[i].MaxNum - vmda->MDDim[i].BaseVal ;
	      dix.dimxbegin[i] = (j - distance[i] < 0 ? 0 : j - distance[i])  ;	/* Set initial starting index */
	      dix.dimxend[i] = (j + distance[i] >= vmda->MDDim[i].MaxNum ? vmda->MDDim[i].MaxNum - 1 : j + distance[i]) ;
/*	      Initialize "current" values so we start up properly */
	      if (vmda->MDDimCount == 1) { dix.dimxvals[i] = dix.dimxbegin[i] - 1 ; }
	       else { dix.dimxvals[i] = (i > 0 ? dix.dimxend[i] : dix.dimxbegin[i] - 1) ; } ;
	    } ;
/*	   Now iterate through all the combinations looking for acceptable array values */
	   INITLP(respnt,lp,Dim_List) ;			/* respnt/lp = main result list */
	   ZPH(&pnt) ; pnt.Dim = vmda->Dim ; pnt.PntType = vmda->PntType ; pnt.Bytes = gpi->PointBytes[vmda->PntType] ;
	   frameid = v4ctx_FramePush(ctx,NULL) ;		/* Start new context frame */
	   for(;;)
	    { for(i=vmda->MDDimCount-1;i>=0;i--)
	       { if (++dix.dimxvals[i] <= dix.dimxend[i]) break ;
	         dix.dimxvals[i] = dix.dimxbegin[i] ; continue ;
	       } ; if (i < 0) break ;			/* All done */
/*	      Construct address (bo) for current cell */
	      for(bo=vmda->Data,i=vmda->MDDimCount-1;i>=0;i--) { bo += vmda->MDDim[i].Offset * dix.dimxvals[i] ; } ;
	      memcpy(&pnt.Value,bo,vmda->ElBytes) ;			/* pnt = point corresponding to this element */
	      if (!v4ctx_FrameAddDim(ctx,0,&pnt,0,0)) goto fail ;	/* Add the point to the context */
	      ipt = v4dpi_IsctEval(&pnt2,lopt,ctx,V4DPI_EM_EvalQuote,NULL,NULL) ;
	      if (ipt == NULL) { v_Msg(ctx,NULL,"ModArgEval2",intmodx,lopt) ; goto fail ; } ;
	      j = v4im_GetPointLog(&ok,ipt,ctx) ; if (!ok) { v_Msg(ctx,NULL,"ModFailed2",intmodx) ; goto fail ; } ;
	      if (!j) continue ;
/*	      Got a hit - append to list */
	      switch (listof)
	       { case 1:
		   INITLP((&lolpnt),lp2,Dim_List) ; intPNT(&pnt2) ;
		   for(i=0;i<vmda->MDDimCount;i++)
		    { pnt2.Value.IntVal = dix.dimxvals[i] + 1 ;
		      if (!v4l_ListPoint_Modify(ctx,lp2,V4L_ListAction_Append,&pnt2,0)) { v_Msg(ctx,NULL,"LPModFail",intmodx) ; goto fail ; } ;
		    } ;
		   ENDLP((&lolpnt),lp2) ; if (!v4l_ListPoint_Modify(ctx,lp,V4L_ListAction_Append,&lolpnt,0)) { v_Msg(ctx,NULL,"LPModFail",intmodx) ; goto fail ; } ;
		   break ;
	         case 2:
		   if (!v4l_ListPoint_Modify(ctx,lp,V4L_ListAction_Append,&pnt,0)) { v_Msg(ctx,NULL,"LPModFail",intmodx) ; goto fail ; } ;
	       } ; hits++ ;
	    } ;
	   if (hits == 0) { v_Msg(ctx,NULL,"ArrayNoCells",intmodx) ; goto fail ; } ;
	   if (!v4ctx_FramePop(ctx,frameid,NULL)) { v_Msg(ctx,NULL,"ModCtxPopFrame",intmodx,frameid) ; goto fail ; } ;
	   ENDLP(respnt,lp) ; return(respnt) ;
	 } ;

	if (!GotRange)					/* Addressing single element ? */
	 { for(bo=vmda->Data,i=vmda->MDDimCount-1;i>=0;i--)
	    { j = lvmda.MDDim[i].MaxNum - vmda->MDDim[i].BaseVal ;
	      if (j < 0 || j >= vmda->MDDim[i].MaxNum)
	       { v_Msg(ctx,NULL,"ArrayXBad",intmodx,i+1,lvmda.MDDim[i].MaxNum,vmda->MDDim[i].BaseVal,vmda->MDDim[i].BaseVal+vmda->MDDim[i].MaxNum-1) ;
	         goto fail ;
	       } ;
	      bo += vmda->MDDim[i].Offset * j ;
	    } ;
	   if (vpt == NULL)			/* No Data::xxx => returning point */
	    { ZPH(respnt) ; respnt->Dim = vmda->Dim ; respnt->PntType = vmda->PntType ;
	      respnt->Bytes = gpi->PointBytes[vmda->PntType] ; memcpy(&respnt->Value,bo,vmda->ElBytes) ;
	      return(respnt) ;
	    } ;
/*	   Here to update value */
	   if (vmda->PntType != vpt->PntType)
	    { v_Msg(ctx,NULL,"ArrayPntType",intmodx,vpt,vpt->PntType,vmda->PntType) ; goto fail ; } ;
	   if (isInc)
	    { int *inum ; double dnum,dnum1 ;
	      switch (vmda->PntType)
	       { default:
	         CASEofINT	inum = (int *)bo ; *inum += vpt->Value.IntVal ; intPNTv(respnt,*inum) ; break ;
	         CASEofDBL	memcpy(&dnum,bo,sizeof(double)) ; GETREAL(dnum1,vpt) ; dnum1 += dnum ; memcpy(bo,&dnum1,sizeof(double)) ; dblPNTv(respnt,dnum1) ; break ;
	       } ;
	    } else
	    { memcpy(bo,&vpt->Value,vmda->ElBytes) ; memcpy(respnt,vpt,vpt->Bytes) ;
	    } ;
	   return(respnt) ;
	 } ;
/*	Here if range of indexes given - return list or update multiple values */
	INITLP(respnt,lp,Dim_List) lp->ListType = V4L_ListType_MDArray ; lp->Dim = vmda->Dim ; entries = 1 ;
	lmda = (struct V4L__ListMDArray *)&lp->Buffer ;
	lp->Bytes = (char *)&lp->Buffer[0] - (char *)lp + sizeof *lmda ;
	lmda->han_MDArray = argpnts[1]->Value.IntVal ;
	lmda->MDDimCount = vmda->MDDimCount ;
	for(i=0;i<vmda->MDDimCount;i++)
	 { if (!Range[i]) lvmda.MDDim[i].BaseVal = lvmda.MDDim[i].MaxNum ;
	   lmda->MDDim[i].Start = lvmda.MDDim[i].BaseVal - vmda->MDDim[i].BaseVal ;
	   lmda->MDDim[i].End = lvmda.MDDim[i].MaxNum - vmda->MDDim[i].BaseVal ;
	   entries *= (lmda->MDDim[i].End - lmda->MDDim[i].Start + 1) ;
	   if (lmda->MDDim[i].Start < 0 || lmda->MDDim[i].End > vmda->MDDim[i].MaxNum)
	    { v_Msg(ctx,NULL,"ArrayXBad2",intmodx,i+1,lvmda.MDDim[i].BaseVal,vmda->MDDim[i].BaseVal,
		   lvmda.MDDim[i].MaxNum,vmda->MDDim[i].BaseVal+vmda->MDDim[i].MaxNum) ;
	      goto fail ;
	    } ;
	 } ;
	lp->Entries = entries ;
	if (vpt == NULL && lopt == NULL)			/* If no Value::xxx and no If::xxx then return list */
	 { respnt->Bytes = V4DPI_PointHdr_Bytes + lp->Bytes ;
	   return(respnt) ;
	 } ;
/*	Have to enumerate through all points & set to Value */
	if (vpt != NULL)
	 { for(index1=0;index1<lp->Entries;index1++)	/* Not the most efficient code - taken from v4l_ListPoint_Value() */
	    { bo = vmda->Data ; index2 = index1 ;
	      for(i=1;i<vmda->MDDimCount;i++)
	       { for(num=1,j=i;j<vmda->MDDimCount;j++) { num *= (lmda->MDDim[j].End - lmda->MDDim[j].Start + 1)  ; } ;
	         bo += ((index2 / num) + lmda->MDDim[i-1].Start) * vmda->MDDim[i-1].Offset ; index2 = (index2 % num) ;
	       } ;
	      bo += index2 * vmda->MDDim[i-1].Offset ;
	      memcpy(bo,&vpt->Value,vmda->ElBytes) ;
	    } ;
	   memcpy(respnt,vpt,vpt->Bytes) ; return(respnt) ;
	 } ;
/*	Have to conditional list */
	INITLP(respnt,lp,Dim_List) ;
	ZPH(&pnt) ; pnt.Dim = vmda->Dim ; pnt.PntType = vmda->PntType ; pnt.Bytes = gpi->PointBytes[pnt.PntType] ;
	for(index1=0;index1<entries;index1++)	/* Not the most efficient code - taken from v4l_ListPoint_Value() */
	 { struct V4DPI__Point pnt2,lolpnt ;
	   struct V4L__ListPoint *lp2 ;
	   int dimxvals[V4IM_MDArrayIndexesMax] ;	/* Current dimension index value */
	   bo = vmda->Data ; index2 = index1 ;
	   for(i=1;i<vmda->MDDimCount;i++)
	    { for(num=1,j=i;j<vmda->MDDimCount;j++) { num *= (lmda->MDDim[j].End - lmda->MDDim[j].Start + 1)  ; } ;
	      dimxvals[i] = index2 / num + lmda->MDDim[i-1].Start ;
	      bo += ((index2 / num) + lmda->MDDim[i-1].Start) * vmda->MDDim[i-1].Offset ; index2 = (index2 % num) ;
	    } ;
	   bo += index2 * vmda->MDDim[i-1].Offset ; dimxvals[0] = index2 ;
	   memcpy(&pnt.Value,bo,vmda->ElBytes) ;		/* pnt = current element value as point */

	   if (!v4ctx_FrameAddDim(ctx,0,&pnt,0,0)) goto fail ;	/* Add the point to the context */
	   ipt = v4dpi_IsctEval(&pnt2,lopt,ctx,V4DPI_EM_EvalQuote,NULL,NULL) ;
	   if (ipt == NULL) { v_Msg(ctx,NULL,"ModArgEval2",intmodx,lopt) ; goto fail ; } ;
	   j = v4im_GetPointLog(&ok,ipt,ctx) ; if (!ok) { v_Msg(ctx,NULL,"ModFailed2",intmodx) ; goto fail ; } ;
	   if (!j) continue ;
	   switch(listof)
	    {
	      case 1:		/* Indexes */

		INITLP((&lolpnt),lp2,Dim_List) ; intPNT(&pnt2) ;
		for(i=0;i<vmda->MDDimCount;i++)
		 { pnt2.Value.IntVal = dimxvals[i] + 1 ;
		   if (!v4l_ListPoint_Modify(ctx,lp2,V4L_ListAction_Append,&pnt2,0)) { v_Msg(ctx,NULL,"LPModFail",intmodx) ; goto fail ; } ;
		 } ;
		ENDLP((&lolpnt),lp2) ; if (!v4l_ListPoint_Modify(ctx,lp,V4L_ListAction_Append,&lolpnt,0)) { v_Msg(ctx,NULL,"LPModFail",intmodx) ; goto fail ; } ;
		break ;
	      case 2:		/* Values */
		if (!v4l_ListPoint_Modify(ctx,lp,V4L_ListAction_Append,&pnt,0)) { v_Msg(ctx,NULL,"LPModFail",intmodx) ; goto fail ; } ;
		break ;
	    } ;
	 } ;
	ENDLP(respnt,lp) ;
	return(respnt) ;





fail:	if (frameid != UNUSED) v4ctx_FramePop(ctx,frameid,NULL) ;
	REGISTER_ERROR(0) ; return(NULL) ;
}

/*	v4im_BaAParse - Parses a Before/After Expression			*/
/*	Call: v4im_BaAParse( ctx , baf , intmodx, argnum, argpt , condcode , ok )
	  where ctx is current context,
		baf is pointer to BaA structure,
		intmodx is calling module index,
		argnum is argument number,
		argpt is pointer to argument point (s/b 2 element list),
		condcode is condition code we are parsing (Begin/End/Before/After),
		ok is updated TRUE/FALSE if ok or not				*/

void v4im_BaAParse(ctx,baf,intmodx,argnum,argpt,condcode,ok)
  struct V4C__Context *ctx ;
  struct V4IM__BaA *baf ;
  P *argpt ;
  int condcode,intmodx,argnum ; LOGICAL *ok ;
{ struct V4L__ListPoint *lp ;
  P listp ;
  int i ;

	if (baf->Count >= V4IM_BaA_CondMax)
	 { v_Msg(ctx,ctx->ErrorMsgAux,"BaAMaxCond",V4IM_BaA_CondMax,V4IM_Tag_Before,V4IM_Tag_After,V4IM_Tag_End) ; *ok = FALSE ; return ; } ;
	lp = v4im_VerifyList(NULL,ctx,argpt,intmodx) ;
	if (lp == NULL) { *ok = FALSE ; return ; } ;		/* ctx->ErrorMsgAux has error */
	for(i=1;v4l_ListPoint_Value(ctx,lp,i,&listp) > 0;i++)
	 { switch(i)
	    { case 1:	memcpy(&baf->Cond[baf->Count].TestPt,&listp,listp.Bytes) ; break ;
	      case 2:	memcpy(&baf->Cond[baf->Count].DoPt,&listp,listp.Bytes) ; break ;
	    } ;
	 } ;
	if (i != 3) { v_Msg(ctx,ctx->ErrorMsgAux,"BaATwoEls",V4IM_Tag_Before,V4IM_Tag_After) ; *ok = FALSE ; return ; } ;
	baf->Cond[baf->Count].CondCode = condcode ;
	*ok = TRUE ; baf->Count++ ;
}

/*	v4im_BaATest - Tests for Before/After Changes on a Value		*/
/*	Call: ok = v4im_BaATest( ctx , baf , newpt , condcode , step , intmodx )
	  where ok is TRUE if all is well, FALSE if a problem,
		ctx is current context,
		baf is pointer to BaA structure,
		newpt is point to be tested for,
		condcode is which condition to test V4IM_BaA_Condxxx,
		step is test step (1 for first, 2 for second...,
		intmodx is module index calling this routine			 */

int v4im_BaATest(ctx,baf,newpt,condcode,step,intmodx)
  struct V4C__Context *ctx ;
  struct V4IM__BaA *baf ;
  P *newpt ;
  int condcode,step,intmodx ;
{ P xpnt,dpnt,*ipt, *tpt ;
  int i,reset ; int befores[V4IM_BaA_CondMax] ;

	baf->CurCond = condcode ;
	switch(condcode)
	 { case V4IM_BaA_CondBefore:
		for(i=0;i<baf->Count;i++) { befores[i] = FALSE ; } ;
		for(reset=FALSE,i=0;i<baf->Count;i++)
		 { if (baf->Cond[i].CondCode != V4IM_BaA_CondBefore) continue ;
		   if (!reset)				/* If first one then add newpt to current context */
		    { 
		      if (!v4ctx_FrameAddDim(ctx,0,newpt,0,0)) { v_Msg(ctx,NULL,"CtxAddFail",intmodx) ; goto fail ; } ;
		      reset = TRUE ;
		    } ;
		   ipt = v4dpi_IsctEval(&xpnt,&baf->Cond[i].TestPt,ctx,V4DPI_EM_EvalQuote,NULL,NULL) ;
		   if (ipt == NULL)
		    { v_Msg(ctx,NULL,"BaABeforeFail",intmodx,&baf->Cond[i].TestPt) ; goto fail ; } ;
		   befores[i] = (memcmp(ipt,&baf->Cond[i].TestRes,ipt->Bytes) != 0) ;
		   memcpy(&baf->Cond[i].TestRes,ipt,ipt->Bytes) ;
		 } ;
		if (step>1 && reset)			/* If changed context point then reset to prior value */
		 { 
		   if (!v4ctx_FrameAddDim(ctx,0,&baf->CurPt,0,0)) { v_Msg(ctx,NULL,"CtxAddFail",intmodx) ; goto fail ; } ;
		   for(i=0;i<baf->Count;i++)
		    { if (!befores[i]) continue ;	/* Have to do this one? */
		      ipt = v4dpi_IsctEval(&dpnt,&baf->Cond[i].DoPt,ctx,V4DPI_EM_EvalQuote,NULL,NULL) ;
		      if (ipt == NULL)
		       { v_Msg(ctx,NULL,"BaABeforeDo",intmodx,&baf->Cond[i].DoPt) ; goto fail ; } ;
		    } ;
		 } ;
		break ;
	   case V4IM_BaA_CondAfter:
		for(i=0;i<baf->Count;i++)
		 { if (baf->Cond[i].CondCode != V4IM_BaA_CondAfter) continue ;
		   ipt = v4dpi_IsctEval(&xpnt,&baf->Cond[i].TestPt,ctx,V4DPI_EM_EvalQuote,NULL,NULL) ;
		   if (ipt == NULL)
		    { v_Msg(ctx,NULL,"BaAAfterFail",intmodx,&baf->Cond[i].TestPt) ; goto fail ; } ;
		   if (memcmp(ipt,&baf->Cond[i].TestRes,ipt->Bytes) != 0)
		    { tpt = v4dpi_IsctEval(&dpnt,&baf->Cond[i].DoPt,ctx,V4DPI_EM_EvalQuote,NULL,NULL) ;
		      if (tpt == NULL)
		       { v_Msg(ctx,NULL,"BaAAfterDo",intmodx,&baf->Cond[i].DoPt) ; goto fail ; } ;
		    } ;
		   memcpy(&baf->Cond[i].TestRes,ipt,ipt->Bytes) ;
		 } ;
		memcpy(&baf->CurPt,newpt,newpt->Bytes) ; /* Copy newpt into current for next round of "Before" tests */
		break ;
	   case V4IM_BaA_CondEnd1:
/*		Don't do this if baf does not belong to current frame */
		if (ctx->Frame[ctx->FrameCnt-1].baf == NULL && ctx->Frame[ctx->FrameCnt-2].baf == NULL) break ;
		for(i=0;i<baf->Count;i++)		/* First do all "Afters" to get subtotals */
		 { if (baf->Cond[i].CondCode != V4IM_BaA_CondBefore) continue ;
		   ipt = v4dpi_IsctEval(&dpnt,&baf->Cond[i].DoPt,ctx,V4DPI_EM_EvalQuote,NULL,NULL) ;
		   if (ipt == NULL) { v_Msg(ctx,NULL,"BaAEnd1Fail",intmodx,&baf->Cond[i].DoPt) ; goto fail ; } ;
		 } ;
		break ;
	   case V4IM_BaA_CondBegin:
/*		Don't do this if baf does not belong to current frame */
		if (ctx->Frame[ctx->FrameCnt-1].baf == NULL && ctx->Frame[ctx->FrameCnt-2].baf == NULL) break ;
		baf->CurLevel = 1 ;			/* Set Current Level for "grand totals" */
		baf->CurCol = 0 ;
		for(i=0;i<baf->Count;i++)
		 { if (baf->Cond[i].CondCode != V4IM_BaA_CondBegin) continue ;
		   ipt = v4dpi_IsctEval(&xpnt,&baf->Cond[i].TestPt,ctx,V4DPI_EM_EvalQuote,NULL,NULL) ;
		   if (ipt == NULL) { v_Msg(ctx,NULL,"BaABeginFail",intmodx,&baf->Cond[i].TestPt) ; goto fail ; } ;
		   if (ipt->Value.IntVal > 0)		/* Execute if tests TRUE */
		    { tpt = v4dpi_IsctEval(&xpnt,&baf->Cond[i].DoPt,ctx,V4DPI_EM_EvalQuote,NULL,NULL) ;
		      if (tpt == NULL) { v_Msg(ctx,NULL,"BaABeginDoFail",intmodx,&baf->Cond[i].DoPt) ; goto fail ; } ;
		    } ;
		 } ;
		break ;
	   case V4IM_BaA_CondEnd2:
/*		Don't do this if baf does not belong to current frame */
		if (ctx->Frame[ctx->FrameCnt-1].baf == NULL && ctx->Frame[ctx->FrameCnt-2].baf == NULL) break ;
/*		Look to see if this is a nested BAF. If so then don't trigger CondEnd2 because that will set up report footers prematurely. */
		for(i=ctx->FrameCnt-2;i>=0;i--)
		 { if (ctx->Frame[i].baf != NULL) { baf->CurCond = V4IM_BaA_CondEnd1 ; break ; } ; } ;
		baf->CurLevel = 1 ;			/* Set Current Level for "grand totals" */
		baf->CurCol = 0 ;
		for(i=0;i<baf->Count;i++)
		 { if (baf->Cond[i].CondCode != V4IM_BaA_CondEnd1) continue ;
		   ipt = v4dpi_IsctEval(&xpnt,&baf->Cond[i].TestPt,ctx,V4DPI_EM_EvalQuote,NULL,NULL) ;
		   if (ipt == NULL) { v_Msg(ctx,NULL,"BaAEnd2Fail",intmodx,&baf->Cond[i].TestPt) ; goto fail ; } ;
		   if (ipt->Value.IntVal > 0)		/* Execute if tests TRUE */
		    { ipt = v4dpi_IsctEval(&xpnt,&baf->Cond[i].DoPt,ctx,V4DPI_EM_EvalQuote,NULL,NULL) ; } ;
		   if (ipt == NULL)
		    { v_Msg(ctx,NULL,"BaAEndDoFail",intmodx,&baf->Cond[i].DoPt) ; goto fail ; } ;
		 } ;
		break ;
	 } ;
	baf->CurCond = V4IM_BaA_Disable ;			/* Turn off "current condition" */
	return(TRUE) ;

fail:	REGISTER_ERROR(0) ; return(FALSE) ;
}

/*	v4im_BaAIncrement - Increments proper column with current value */
/*	Call: v4im_BaAIncrement( ctx , baf , incpt , column, forceit )
	  where ctx is current context,
		baf is pointer to BaA structure,
		incpt is point to be tested for,
		column is current column (1 is first column)
		forceit is TRUE to force inclusion in totals, FALSE to inhibit, UNUSED to ignore flag	*/

#ifdef NEWBAFSTUFF
void v4im_BaAIncrement(ctx,baf,incpt,column,forceit)
  struct V4C__Context *ctx ;
  struct V4IM__BaA *baf ;
  P *incpt ;
  int column,forceit ;
{ INDEX i ; double dnum ; B64INT b64 ;

	if (forceit == FALSE) return ;
	if (column > baf->baaColMax) return ;
	if (forceit == UNUSED && baf->CurCond != 0) return ;
	column-- ;			/* Convert to 0-based indexing */

//	for(i=0;i<V4IM_BaA_LevelMax;i++) { baf->Col[column].Count[i] ++ ; } ;
	for(i=0;i<baf->baaLevelMax;i++)
	 { baf->ccTot[i]->colCalc[column].count++ ; } ;
	switch(incpt->PntType)
	 { CASEofINT
//		for(i=0;i<V4IM_BaA_LevelMax;i++)
//		 { baf->Col[column].SubTotals[i] += incpt->Value.IntVal ; } ;
		for(i=0;i<baf->baaLevelMax;i++)
		 { baf->ccTot[i]->colCalc[column].dblSubTotal += incpt->Value.IntVal ; } ;
		break ;
	   case V4DPI_PntType_UOM:
		memcpy(&dnum,&incpt->Value.UOMVal.Num,sizeof dnum) ;
		if (baf->ccInfo->colCalc[column].ref == UNUSED)
		 { baf->ccInfo->colCalc[column].ref = incpt->Value.UOMVal.Ref ; baf->ccInfo->colCalc[column].index = incpt->Value.UOMVal.Index ;
		   baf->ccInfo->colCalc[column].dim = incpt->Dim ;
		 } ;
		if (baf->ccInfo->colCalc[column].ref != incpt->Value.UOMVal.Ref)	/* Make sure same UOM */
		 { if (v4dpi_UOMAttemptCoerce(ctx,traceGlobal,baf->ccInfo->colCalc[column].ref,baf->ccInfo->colCalc[column].index,incpt,&dnum))
		    { for(i=0;i<baf->baaLevelMax;i++) { baf->ccTot[i]->colCalc[column].dblSubTotal += dnum ; } ;
		    } ;
		 } else
		 { if (incpt->Value.UOMVal.Index < baf->ccInfo->colCalc[column].index)	/* Track smallest Index */
		    baf->ccInfo->colCalc[column].index = incpt->Value.UOMVal.Index ;
		   for(i=0;i<baf->baaLevelMax;i++) { baf->ccTot[i]->colCalc[column].dblSubTotal += dnum ; } ;
		 } ;
		break ;
	   case V4DPI_PntType_Fixed:
		memcpy(&b64,&incpt->Value.FixVal,sizeof b64) ;
		if (baf->ccInfo->colCalc[column].dim == UNUSED) baf->ccInfo->colCalc[column].dim = incpt->Dim ;
		if (baf->ccInfo->colCalc[column].decimals == UNUSED) baf->ccInfo->colCalc[column].decimals = incpt->LHSCnt ;
		for(;baf->ccInfo->colCalc[column].decimals<incpt->LHSCnt;baf->ccInfo->colCalc[column].decimals++)
		 { for(i=0;i<baf->baaLevelMax;i++) { baf->ccTot[i]->colCalc[column].fixSubTotal *= 10 ; } ;
		 } ;
		SCALEFIX(b64,incpt->LHSCnt,baf->ccInfo->colCalc[column].decimals)
		for(i=0;i<baf->baaLevelMax;i++) { baf->ccTot[i]->colCalc[column].fixSubTotal += b64 ; } ;
		break ;
	   case V4DPI_PntType_Real:
		GETREAL(dnum,incpt) ;
		for(i=0;i<baf->baaLevelMax;i++) { baf->ccTot[i]->colCalc[column].dblSubTotal += dnum ; } ;
		break ;
	 } ;
}
#else
void v4im_BaAIncrement(ctx,baf,incpt,column,forceit)
  struct V4C__Context *ctx ;
  struct V4IM__BaA *baf ;
  P *incpt ;
  int column,forceit ;
{ int i ; double dnum ; B64INT b64 ;

	if (forceit == FALSE) return ;
	if (column > V4IM_BaA_ColMax) return ;
	if (forceit == UNUSED && baf->CurCond != 0) return ;

	for(i=0;i<V4IM_BaA_LevelMax;i++) { baf->Col[column-1].Count[i] ++ ; } ;
	switch(incpt->PntType)
	 { CASEofINT
		for(i=0;i<V4IM_BaA_LevelMax;i++)
		 { baf->Col[column-1].SubTotals[i] += incpt->Value.IntVal ; } ;
		break ;
	   case V4DPI_PntType_UOM:
		memcpy(&dnum,&incpt->Value.UOMVal.Num,sizeof dnum) ;
		if (baf->Col[column-1].Ref == UNUSED)
		 { baf->Col[column-1].Ref = incpt->Value.UOMVal.Ref ; baf->Col[column-1].Index = incpt->Value.UOMVal.Index ;
		   baf->Col[column-1].Dim = incpt->Dim ;
		 } ;
		if (baf->Col[column-1].Ref != incpt->Value.UOMVal.Ref)	/* Make sure same UOM */
		 { if (v4dpi_UOMAttemptCoerce(ctx,traceGlobal,baf->Col[column-1].Ref,baf->Col[column-1].Index,incpt,&dnum))
		    { for(i=0;i<V4IM_BaA_LevelMax;i++) { baf->Col[column-1].SubTotals[i] += dnum ; } ;
		    } ;
		 } else
		 { if (incpt->Value.UOMVal.Index < baf->Col[column-1].Index)	/* Track smallest Index */
		    baf->Col[column-1].Index = incpt->Value.UOMVal.Index ;
		   for(i=0;i<V4IM_BaA_LevelMax;i++) { baf->Col[column-1].SubTotals[i] += dnum ; } ;
		 } ;
		break ;
	   case V4DPI_PntType_Fixed:
		memcpy(&b64,&incpt->Value.FixVal,sizeof b64) ;
		if (baf->Col[column-1].Dim == UNUSED) baf->Col[column-1].Dim = incpt->Dim ;
		if (baf->Col[column-1].Decimals == UNUSED) baf->Col[column-1].Decimals = incpt->LHSCnt ;
		for(;baf->Col[column-1].Decimals<incpt->LHSCnt;baf->Col[column-1].Decimals++)
		 { for(i=0;i<V4IM_BaA_LevelMax;i++) { baf->Col[column-1].fSubTotals[i] *= 10 ; } ;
		 } ;
		SCALEFIX(b64,incpt->LHSCnt,baf->Col[column-1].Decimals)
		for(i=0;i<V4IM_BaA_LevelMax;i++) { baf->Col[column-1].fSubTotals[i] += b64 ; } ;
		break ;
	   case V4DPI_PntType_Real:
		GETREAL(dnum,incpt) ;
		for(i=0;i<V4IM_BaA_LevelMax;i++) { baf->Col[column-1].SubTotals[i] += dnum ; } ;
		break ;
	 } ;
}
#endif

/*	v4im_DoRCV - Row/Column Value with BaA stuff */

P *v4im_DoRCV(ctx,respnt,intmodx,argpnts,argcnt,dim)
  struct V4C__Context *ctx ;
  P *respnt ;						/* Ptr for result */
  INTMODX intmodx ;
  P *argpnts[] ;
  COUNTER argcnt ;
  DIMID dim ;
{ struct V4IM__BaA *baf ;
  P *cpt,pnt ;
  struct V4DPI__DimInfo *di ;
  int t,calc ; INDEX ax,row,col,level,valtype ; PNTTYPE pnttype ; LOGICAL ok ; double dnum ;

	baf = v4ctx_FrameBaAInfo(ctx) ;
	if (baf == NULL)
	{ v_Msg(ctx,NULL,"RCVNoInfo",intmodx) ; goto ret_undef ; } ;	/* If no BaA in frame then return 0 */
	row = baf->CurRow ; col = UNUSED ; calc = UNUSED ; level = baf->CurLevel ; valtype = 1 ;
	if (dim != UNUSED) { DIMINFO(di,ctx,dim) ; pnttype = di->PointType ; } ;
	for(ok=TRUE,ax=1;ax<=argcnt;ax++)
	 { if (argpnts[ax]->PntType == V4DPI_PntType_Int)
	    { col = argpnts[ax]->Value.IntVal ; if (dim == UNUSED) { dim = argpnts[ax]->Dim ; pnttype = V4DPI_PntType_Int ; } ; continue ; } ;
	   if (argpnts[ax]->PntType == V4DPI_PntType_Real)
	    { col = v4im_GetPointInt(&ok,argpnts[ax],ctx) ; if (!ok) break ; if (dim == UNUSED) { dim = argpnts[ax]->Dim ; DIMINFO(di,ctx,dim) ; pnttype = V4DPI_PntType_Real ; } ; continue ; } ;
	   if (argpnts[ax]->PntType == V4DPI_PntType_Dict && gpi->rriCur != NULL && argpnts[ax]->Dim != Dim_Dim)
	    { INDEX i ;
	      for (i=0;i<gpi->rriCur->numCols;i++) { if (memcmp(&gpi->rriCur->col[i].idCol,argpnts[ax],argpnts[ax]->Bytes) == 0) break ; } ;
	      if (i >= gpi->rriCur->numCols)
	       { if (gpi->rriCur->idPnt.Dim != 0) { v_Msg(ctx,NULL,"RCVNoCol2",intmodx,argpnts[ax],V4IM_OpCode_RCV,&gpi->rriCur->idPnt) ; }
	          else  { v_Msg(ctx,NULL,"RCVNoCol",intmodx,argpnts[ax],V4IM_OpCode_RCV) ; } ;
	         goto ret_undef ;
	       } ;
	      if (gpi->rriCur->col[i].colRedef != UNUSED)
	       i = gpi->rriCur->col[i].colRedef ;
	      col = i+1 ;			/* Add 1 because we always subtract below */
	      if (dim == UNUSED)
	       { dim = gpi->rriCur->col[col-1].valDim ; if (dim == Dim_Alpha) dim = Dim_Num ;
	         DIMINFO(di,ctx,dim) ; pnttype = (di == NULL ? V4DPI_PntType_Int : di->PointType) ;
	         if (pnttype == V4DPI_PntType_Char)		/* VEH111108 - If pnttype is Char (i.e. dim not Alpha but another dimension of type alpha) */
	          { dim = Dim_Num ; DIMINFO(di,ctx,dim) ; pnttype = di->PointType ;
	          } ;
	       } ;
	      continue ;
	    } ;
	   switch (t=v4im_CheckPtArgNew(ctx,argpnts[ax],&cpt,&pnt))
	    { default:			v_Msg(ctx,NULL,"TagBadUse",intmodx) ; goto ret_undef ;
	      case V4IM_Tag_Unk:	v_Msg(ctx,NULL,"TagUnknown",intmodx) ; goto ret_undef ;
	      case V4IM_Tag_Dim:
		dim = cpt->Value.IntVal ; ISVALIDDIM(dim,ax,"RCV()") ; DIMINFO(di,ctx,dim) ;
		pnttype = di->PointType ; break ;
	      case -V4IM_Tag_Sum:	valtype = 1 ; break ;
	      case -V4IM_Tag_Count:	valtype = 2 ; break ;
	      case V4IM_Tag_Sum:
		if (cpt->PntType == V4DPI_PntType_Delta)
		 { level = baf->CurLevel + cpt->Value.IntVal ;
		 } else { level = cpt->Value.IntVal ; } ;
		valtype = 1 ; break ;
	      case V4IM_Tag_Count:
		if (cpt->PntType == V4DPI_PntType_Delta)
		 { level = baf->CurLevel + cpt->Value.IntVal ;
		 } else { level = cpt->Value.IntVal ; } ;
		valtype = 2 ; break ;
	      case V4IM_Tag_Column:
		if (cpt->PntType == V4DPI_PntType_Delta)
		 { col = baf->CurCol + cpt->Value.IntVal ;
		 } else { col = cpt->Value.IntVal ; } ;
		break ;
	      case V4IM_Tag_Calc:
		if (cpt->PntType == V4DPI_PntType_Delta)
		 { calc = baf->CurCalc + cpt->Value.IntVal ;
		 } else { calc = cpt->Value.IntVal ; } ;
		valtype = 3 ; break ;
	      case V4IM_Tag_Row:
		if (cpt->PntType == V4DPI_PntType_Delta)
		 { row = baf->CurRow + cpt->Value.IntVal ;
		 } else { row = cpt->Value.IntVal ; } ;
		break ;
	    } ;
	 } ;
	if (!ok) { v_Msg(ctx,NULL,"ModInvArg",intmodx,ax-1) ; goto ret_undef ; } ;
	if (level < 1) level = 2 ;				/* Default to level 2 */
	if (level < 1 || level > baf->baaLevelMax)
	 { v_Msg(ctx,NULL,"RCVLvlMax",intmodx,level,baf->baaLevelMax) ; goto ret_undef ; } ;
#ifdef NEWBAFSTUFF
	switch(valtype)
	 { case 1:
		if (col == UNUSED) col = ++baf->CurCol ;	/* If no column specified then increment from last */
		if (col < 1 || col > baf->baaColMax) goto ret_colMax ;
		if (dim != UNUSED)					/* If defaulting dim then maybe flip to UOM/Fixed */
		 { if (baf->ccInfo->colCalc[col-1].ref != UNUSED) { t = V4DPI_PntType_UOM ; }
		    else if (baf->ccInfo->colCalc[col-1].decimals != UNUSED) { t = V4DPI_PntType_Fixed ; } ;
		   if (t == V4DPI_PntType_UOM && pnttype != V4DPI_PntType_UOM)
		    { v_Msg(ctx,NULL,"RCVNotUOM",intmodx,col,pnttype) ; goto ret_undef ; } ;
		 } else 
		 { if (baf->ccInfo->colCalc[col-1].ref != UNUSED) { pnttype = V4DPI_PntType_UOM ; dim = baf->ccInfo->colCalc[col-1].dim ; }
		    else if (baf->ccInfo->colCalc[col-1].decimals != UNUSED) { pnttype = V4DPI_PntType_Fixed ; dim = baf->ccInfo->colCalc[col-1].dim ; } ;
		 } ;
		if (dim == UNUSED) { dim = Dim_Num ; pnttype = V4DPI_PntType_Real ; } ;
		ZPH(respnt) ; DIMINFO(di,ctx,dim) ;
		switch(pnttype)
		 { default:
		   CASEofINT
			respnt->Bytes = V4PS_Int ;
			respnt->Value.IntVal = DtoI(baf->ccTot[level-1]->colCalc[col-1].dblSubTotal) ;
			break ;
		   case V4DPI_PntType_UOM:
			respnt->Bytes = V4PS_UOM ; memcpy(&respnt->Value.UOMVal.Num,&baf->ccTot[level-1]->colCalc[col-1].dblSubTotal,sizeof(double)) ;
			respnt->Value.UOMVal.Ref = baf->ccInfo->colCalc[col-1].ref ; respnt->Value.UOMVal.Index = baf->ccInfo->colCalc[col-1].index ;
			break ;
		   case V4DPI_PntType_Fixed:
			SCALEFIX(baf->ccTot[level-1]->colCalc[col-1].fixSubTotal,baf->ccInfo->colCalc[col-1].decimals,di->Decimals) ;
			if (baf->ccTot[level-1]->colCalc[col-1].dblSubTotal != 0)		/* Add in any (double) value */
			 { dnum = baf->ccTot[level-1]->colCalc[col-1].dblSubTotal ;
			   dnum += (dnum < 0 ? -vRound[di->Decimals] : vRound[di->Decimals]) ;
			   dnum = dnum * powers[di->Decimals] ; baf->ccTot[level-1]->colCalc[col-1].fixSubTotal += (B64INT)dnum ;
			 } ;
			respnt->Bytes = V4PS_Fixed ; respnt->LHSCnt = di->Decimals ;
			memcpy(&respnt->Value.FixVal,&baf->ccTot[level-1]->colCalc[col-1].fixSubTotal,sizeof(B64INT)) ;
			break ;
		   case V4DPI_PntType_Real:
			respnt->Bytes = V4PS_Real ;
			if (baf->ccTot[level-1]->colCalc[col-1].fixSubTotal != 0)		/* Add in any (fixed) value */
			 { baf->ccTot[level-1]->colCalc[col-1].dblSubTotal += (double)baf->ccTot[level-1]->colCalc[col-1].fixSubTotal/powers[baf->ccInfo->colCalc[col-1].decimals] ;
			 } ;
			if (di->Decimals == 0)			/* If decimals associated with this then maybe round to 0 */
			 { PUTREAL(respnt,baf->ccTot[level-1]->colCalc[col-1].dblSubTotal) ;
			 } else
			 { dnum = baf->ccTot[level-1]->colCalc[col-1].dblSubTotal ;
			   if (dnum < 0.00001 && dnum > -0.00001) dnum = 0 ;
			   PUTREAL(respnt,dnum) ;
			 } ;
			break ;
		 } ;
		break ;
	   case 2:
		if (col == UNUSED) col = ++baf->CurCol ;	/* If no column specified then increment from last */
		if (col < 1 || col > baf->baaColMax) goto ret_colMax ;
		ZPH(respnt) ;
		if (dim == UNUSED) { dim = Dim_Int ; pnttype = V4DPI_PntType_Int ; } ;
		switch(pnttype)
		 { default:
		   CASEofINT
			respnt->Bytes = V4PS_Int ;
			respnt->Value.IntVal = baf->ccTot[level-1]->colCalc[col-1].count ;
			break ;
		   case V4DPI_PntType_Real:
			respnt->Bytes = V4PS_Real ;
			dnum = baf->ccTot[level-1]->colCalc[col-1].count ;
			PUTREAL(respnt,dnum) ;
			break ;
		 } ;
		break ;
	   case 3:
		if (calc < 1 || calc > baf->baaCalcMax) goto ret_colMax ;
		ZPH(respnt) ;
		if (dim == UNUSED) { dim = Dim_Num ; pnttype = V4DPI_PntType_Real ; } ;
		switch(pnttype)
		 { default:
		   CASEofINT
			respnt->Bytes = V4PS_Int ;
			respnt->Value.IntVal = DtoI(baf->ccTot[level-1]->colCalc[baf->baaColMax+calc-1].dblSubTotal) ;
			break ;
		   case V4DPI_PntType_Real:
			respnt->Bytes = V4PS_Real ;
			PUTREAL(respnt,baf->ccTot[level-1]->colCalc[baf->baaColMax+calc-1].dblSubTotal) ;
			break ;
		 } ;
		break ;
	 } ;
#else
	switch(valtype)
	 { case 1:
		if (col == UNUSED) col = ++baf->CurCol ;	/* If no column specified then increment from last */
		if (col < 1 || col > V4IM_BaA_ColMax) goto ret_colMax ;
		if (dim != UNUSED)					/* If defaulting dim then maybe flip to UOM/Fixed */
		 { if (baf->Col[col-1].Ref != UNUSED) { t = V4DPI_PntType_UOM ; }
		    else if (baf->Col[col-1].Decimals != UNUSED) { t = V4DPI_PntType_Fixed ; } ;
		   if (t == V4DPI_PntType_UOM && pnttype != V4DPI_PntType_UOM)
		    { v_Msg(ctx,NULL,"RCVNotUOM",intmodx,col,pnttype) ; goto ret_undef ; } ;
		 } else 
		 { if (baf->Col[col-1].Ref != UNUSED) { pnttype = V4DPI_PntType_UOM ; dim = baf->Col[col-1].Dim ; }
		    else if (baf->Col[col-1].Decimals != UNUSED) { pnttype = V4DPI_PntType_Fixed ; dim = baf->Col[col-1].Dim ; } ;
		 } ;
		if (dim == UNUSED) { dim = Dim_Num ; pnttype = V4DPI_PntType_Real ; } ;
		ZPH(respnt) ; DIMINFO(di,ctx,dim) ;
		switch(pnttype)
		 { default:
		   CASEofINT
			respnt->Bytes = V4PS_Int ;
			respnt->Value.IntVal = DtoI(baf->Col[col-1].SubTotals[level-1]) ;
			break ;
		   case V4DPI_PntType_UOM:
			respnt->Bytes = V4PS_UOM ; memcpy(&respnt->Value.UOMVal.Num,&baf->Col[col-1].SubTotals[level-1],sizeof(double)) ;
			respnt->Value.UOMVal.Ref = baf->Col[col-1].Ref ; respnt->Value.UOMVal.Index = baf->Col[col-1].Index ;
			break ;
		   case V4DPI_PntType_Fixed:
			SCALEFIX(baf->Col[col-1].fSubTotals[level-1],baf->Col[col-1].Decimals,di->Decimals) ;
			if (baf->Col[col-1].SubTotals[level-1] != 0)		/* Add in any (double) value */
			 { dnum = baf->Col[col-1].SubTotals[level-1] ;
			   dnum += (dnum < 0 ? -vRound[di->Decimals] : vRound[di->Decimals]) ;
			   dnum = dnum * powers[di->Decimals] ; baf->Col[col-1].fSubTotals[level-1] += (B64INT)dnum ;
			 } ;
			respnt->Bytes = V4PS_Fixed ; respnt->LHSCnt = di->Decimals ;
			memcpy(&respnt->Value.FixVal,&baf->Col[col-1].fSubTotals[level-1],sizeof(B64INT)) ;
			break ;
		   case V4DPI_PntType_Real:
			respnt->Bytes = V4PS_Real ;
			if (baf->Col[col-1].fSubTotals[level-1] != 0)		/* Add in any (fixed) value */
			 { baf->Col[col-1].SubTotals[level-1] += (double)baf->Col[col-1].fSubTotals[level-1]/powers[baf->Col[col-1].Decimals] ;
			 } ;
			if (di->Decimals == 0)			/* If decimals associated with this then maybe round to 0 */
			 { PUTREAL(respnt,baf->Col[col-1].SubTotals[level-1]) ;
			 } else
			 { dnum = baf->Col[col-1].SubTotals[level-1] ;
			   if (dnum < 0.00001 && dnum > -0.00001) dnum = 0 ;
			   PUTREAL(respnt,dnum) ;
			 } ;
			break ;
		 } ;
		break ;
	   case 2:
		if (col == UNUSED) col = ++baf->CurCol ;	/* If no column specified then increment from last */
		if (col < 1 || col > V4IM_BaA_ColMax) goto ret_colMax ;
		ZPH(respnt) ;
		if (dim == UNUSED) { dim = Dim_Int ; pnttype = V4DPI_PntType_Int ; } ;
		switch(pnttype)
		 { default:
		   CASEofINT
			respnt->Bytes = V4PS_Int ;
			respnt->Value.IntVal = baf->Col[col-1].Count[level-1] ;
			break ;
		   case V4DPI_PntType_Real:
			respnt->Bytes = V4PS_Real ;
			dnum = baf->Col[col-1].Count[level-1] ;
			PUTREAL(respnt,dnum) ;
			break ;
		 } ;
		break ;
	   case 3:
		if (calc < 1 || calc > V4IM_BaA_CalcMax) { col = calc ; goto ret_colMax ; } ;
		ZPH(respnt) ;
		if (dim == UNUSED) { dim = Dim_Num ; pnttype = V4DPI_PntType_Real ; } ;
		switch(pnttype)
		 { default:
		   CASEofINT
			respnt->Bytes = V4PS_Int ;
			respnt->Value.IntVal = DtoI(baf->Calc[calc-1].SubTotals[level-1]) ;
			break ;
		   case V4DPI_PntType_Real:
			respnt->Bytes = V4PS_Real ;
			PUTREAL(respnt,baf->Calc[calc-1].SubTotals[level-1]) ;
			break ;
		 } ;
		break ;
	 } ;
#endif
	baf->CurRow = row ; if (col != UNUSED) baf->CurCol = col ; baf->CurLevel = level ; if (calc != UNUSED) baf->CurCalc = calc ;
	respnt->Dim = dim ; respnt->PntType = pnttype ;
	return(respnt) ;
ret_colMax:
	v_Msg(ctx,NULL,"RCVColMax",intmodx,col,V4IM_BaA_CalcMax) ; goto ret_undef ;
ret_undef:
	 REGISTER_ERROR(0) ; return(NULL) ;
}

struct V4DPI__Point *v4im_DoFlatten(ctx,respnt,argpnts,argcnt,intmodx)
  struct V4C__Context *ctx ;
  P *respnt ;						/* Ptr for result */
  INTMODX intmodx ;
  P *argpnts[] ;
  COUNTER argcnt ;
{ P *cpt,tbfisct,*tbfp,tgtVal ;
  struct V4DPI__DimInfo *di ;
  struct V4DPI__Flatten ftn ;
  int i,j,fbytes,useHash ;

	ftn.TargetDimId = UNUSED ; ftn.Count = 0 ; ZPH(&tbfisct) ; fbytes = 0 ; useHash = UNUSED ; tgtVal.Bytes = 0 ;
	for(i=1;i<=argcnt;i++)				/* Grab the arguments */
	 { if (argpnts[i]->PntType != V4DPI_PntType_TagVal)
	    { 
/*	      If not a dimension point then assume we are gonna flatten a bunch of points - keep track of them */
	      if (argpnts[i]->Dim != Dim_Dim)
	       { if (tbfisct.Grouping == 0)		/* If first time then init tbfisct point */
	          { INITISCT(&tbfisct) ; NOISCTVCD(&tbfisct) ; tbfp = ISCT1STPNT(&tbfisct) ; } ;
		 if (argpnts[i]->Bytes + tbfisct.Bytes > V4DPI_AlphaVal_Max)
		  { v_Msg(ctx,NULL,"ModArgMaxIsct",intmodx,i,argpnts[i]->Bytes,tbfisct.Bytes,V4DPI_AlphaVal_Max) ; goto fail ; } ;
		 memcpy(tbfp,argpnts[i],argpnts[i]->Bytes) ; tbfisct.Bytes += argpnts[i]->Bytes ;
		 ADVPNT(tbfp) ; tbfisct.Grouping ++ ;
	         continue ;
	       } ;
	      if (ftn.Count >= V4DPI_IsctDimMax) { v_Msg(ctx,NULL,"MaxNumModArgs",intmodx,V4DPI_IsctDimMax) ; goto fail ; } ;
	      DIMINFO(di,ctx,argpnts[i]->Value.IntVal) ;
	      switch (di->PointType)
	       { default:	v_Msg(ctx,NULL,"FlattenDimPT",intmodx,argpnts[i],di->PointType) ; goto fail ;
	         case V4DPI_PntType_Dict:
			if (di->DimId == Dim_NId) { v_Msg(ctx,NULL,"FlattenNoNId",intmodx,di->DimId) ; goto fail ; } ;
	         case V4DPI_PntType_XDict:
		 CASEofINT
			ftn.Entry[ftn.Count].Bytes = sizeof cpt->Value.IntVal ; ftn.Entry[ftn.Count].Transform = V4DPI_FTran_Copy ; break ;
		 case V4DPI_PntType_Real:
		 case V4DPI_PntType_Calendar:
		 case V4DPI_PntType_Int2:
		 case V4DPI_PntType_Fixed:
			ftn.Entry[ftn.Count].Bytes = sizeof cpt->Value.RealVal ; ftn.Entry[ftn.Count].Transform = V4DPI_FTran_Copy ; break ;
		 case V4DPI_PntType_TeleNum:
			ftn.Entry[ftn.Count].Bytes = sizeof (UB64INT) ; ftn.Entry[ftn.Count].Transform = V4DPI_FTran_AlphaToHash64 ; break ;
		 CASEofChar
			ftn.Entry[ftn.Count].Bytes = sizeof (UB64INT) ; ftn.Entry[ftn.Count].Transform = V4DPI_FTran_AlphaToHash64 ; break ;
	       } ;
	      for(j=0;j<ftn.Count;j++)
	       { if (di->DimId != ftn.Entry[j].DimId) continue ;
	         v_Msg(ctx,NULL,"FlattenDupDim",intmodx,i,argpnts[i],j+1) ; goto fail ;
	       } ;
	      di->rtFlags |= V4DPI_rtDimInfo_Flatten ;	/* Mark dimension as potentially flattenable */
	      ftn.Entry[ftn.Count].DimId = di->DimId ; fbytes += ftn.Entry[ftn.Count].Bytes ;
	      ftn.Count++ ; continue ;
	    } ;
	   switch (v4im_CheckPtArgNew(ctx,argpnts[i],&cpt,&tgtVal))
	    { default:				v_Msg(ctx,NULL,"TagBadUse",intmodx) ; goto fail ;
	      case V4IM_Tag_Unk:		v_Msg(ctx,NULL,"TagUnknown",intmodx) ; goto fail ;
	      case -V4IM_Tag_Hash32:		useHash = 32 ; break ;
	      case -V4IM_Tag_Hash64:		useHash = 64 ; break ;
	      case V4IM_Tag_Target:
//		if (cpt->Dim != Dim_Dim) { v_Msg(ctx,NULL,"ModArgNotDim",intmodx,i,cpt) ; goto fail ; } ;
/*		If not a dimension then we are most likely going to expand a target back into its component dimensions (reverse of flatten) */
		if (cpt->Dim != Dim_Dim) { memcpy(&tgtVal,cpt,cpt->Bytes) ; break ; } ;
		DIMINFO(di,ctx,cpt->Value.IntVal) ;
		ftn.TargetDimId = di->DimId ; ftn.TargetPntType = di->PointType ;
		break ;
	    }
	 } ;

/*	Are we trying to unflatten a point back into its components? */
	if (tgtVal.Bytes > 0)
	 { struct V4DPI__Flatten *ftn1 ;
	   struct V4L__ListPoint *lp ;
	   INDEX i,i1 ; BYTE *tgt ; COUNTER matched ;
	   for(ftn1=gpi->ftn;ftn1!=NULL;ftn1=ftn1->nftn)	/* Iterate through all structures (most likely only 1 or 2) */
	    { if (ftn1->TargetDimId != tgtVal.Dim) continue ;
	      matched = 0 ;
	      for(i=0;i<ftn.Count;i++)
	       { for(i1=0;i1<ftn1->Count;i1++)
		  { if (ftn.Entry[i].DimId == ftn1->Entry[i1].DimId) break ;
		  } ; if (i1 >= ftn1->Count) continue ;
		 matched++ ; if (matched < ftn.Count) continue ;
/*		 Found a match - expand it */
		 INITLP(respnt,lp,Dim_List)
		 tgt = (BYTE *)&tgtVal.Value ;
		 for(i1=0;i1<ftn1->Count;i1++)
		  { P lpnt ; ZPH(&lpnt) ; lpnt.Dim = ftn1->Entry[i1].DimId ; lpnt.Bytes = (ftn1->Entry[i1].Bytes + V4DPI_PointHdr_Bytes) ;
		    DIMINFO(di,ctx,lpnt.Dim) ; lpnt.PntType = di->PointType ;
		    memcpy(&lpnt.Value,tgt,ftn1->Entry[i1].Bytes ) ; if (!v4l_ListPoint_Modify(ctx,lp,V4L_ListAction_Append,&lpnt,0)) { v_Msg(ctx,NULL,"LPModFail",intmodx) ; goto fail ; } ;
		    tgt += ftn1->Entry[i1].Bytes  ;
		  } ;
		 ENDLP(respnt,lp) return(respnt) ;
	       } ;
	    } ;
	   v_Msg(ctx,NULL,"FlattenNoPatU",intmodx,&tgtVal) ; goto fail ;
	 } ;

/*	Cannot be both defining a flatten set AND trying to flatten points at same time */
	if (ftn.Count > 0 && tbfisct.Grouping > 0) { v_Msg(ctx,NULL,"FlattenDefMake",intmodx) ; goto fail ; } ;

/*	Define a new flatten pattern */
	if (ftn.Count > 0)
	 { if (ftn.TargetDimId == UNUSED)			/* If no Target:: then look for kernel dimension UBlob */
	    { ftn.TargetDimId = Dim_UBLOB ; ftn.TargetPntType = V4DPI_PntType_BinObj ;
	      if (ftn.TargetDimId == 0) { v_Msg(ctx,NULL,"TagMissing",intmodx,V4IM_Tag_Target) ; goto fail ; } ;
	    } ;
	   if (useHash != UNUSED)
	    { fbytes = (useHash == 64 ? 8 : 4) ;
	      for(i=0;i<ftn.Count;i++) { ftn.Entry[i].Transform = (useHash == 64 ? V4DPI_FTran_Hash64 : V4DPI_FTran_Hash32) ; } ;
	    } ;
	   if (gpi->PointBytes[ftn.TargetPntType] != 0 && gpi->PointBytes[ftn.TargetPntType]-V4DPI_PointHdr_Bytes < fbytes)
	    { v_Msg(ctx,NULL,"FlattenTooSmall",intmodx,ftn.TargetDimId,gpi->PointBytes[ftn.TargetPntType]-V4DPI_PointHdr_Bytes,fbytes,-V4IM_Tag_Hash32,-V4IM_Tag_Hash64) ; goto fail ; } ;

/*	   Now make copy & link up to gpi->ftn */
	   ftn.nftn = gpi->ftn ;
	   i = (char *)&ftn.Entry[ftn.Count] - (char *)&ftn ;
	   gpi->ftn = (struct V4DPI__Flatten *)v4mm_AllocChunk(i,FALSE) ; memcpy(gpi->ftn,&ftn,i) ;
/*	   Now maybe reorder the chain - we need to have them in decreasing ftn->Count order */
	   { COUNTER gap,num,i,j ; struct V4DPI__Flatten *ftn1 ;
	     struct { int Count ; struct V4DPI__Flatten *ftn ; } sort[V4DPI_Flatten_MaxEntry+1] ;
	     for(num=0,ftn1=gpi->ftn;ftn1!=NULL&&num<V4DPI_Flatten_MaxEntry;num++,ftn1=ftn1->nftn)
	      { sort[num].Count = ftn1->Count ; sort[num].ftn = ftn1 ; } ;
	     for(gap=num/2;gap>0;gap=gap/2)
	      { for(i=gap;i<num;i++)
		 { for(j=i-gap;j>=0;j-=gap)
		    { if (sort[j].Count <= sort[j+gap].Count) break ;
		      sort[V4DPI_Flatten_MaxEntry] = sort[j] ; sort[j] = sort[j+gap] ; sort[j+gap] = sort[V4DPI_Flatten_MaxEntry] ;
		    } ;
		 } ;
	      } ;
	     gpi->ftn = NULL ;
	     for(i=0;i<num;i++) { ftn1 = sort[i].ftn ; ftn1->nftn = gpi->ftn ; gpi->ftn = ftn1 ; } ;
	   }
	   return((P *)&Log_True) ;
	 } ;

/*	Here to flatten a bunch of argument points and previously defined flatten pattern */
	if (!v4dpi_FlattenIsct(ctx,&tbfisct,&tbfisct,FALSE)) { v_Msg(ctx,NULL,"FlattenNoPat",intmodx,&tbfisct) ; goto fail ; } ;
/*	If result is single point intersection then just return the one component point otherwise return entire isct */
	if (tbfisct.Grouping > 1)
	 { memcpy(respnt,&tbfisct,tbfisct.Bytes) ; }
	 else { tbfp = ISCT1STPNT(&tbfisct) ; memcpy(respnt,tbfp,tbfp->Bytes) ; } ;
	return(respnt) ;

fail:	REGISTER_ERROR(0) ; return(NULL) ;
}


/*	v4im_DoOptimize - Handles Optimize Module		*/


   
struct V4DPI__Point *v4im_DoOptimize(ctx,respnt,argpnts,argcnt,intmodx,trace)
  struct V4C__Context *ctx ;
  P *respnt ;						/* Ptr for result */
  INTMODX intmodx ;
  P *argpnts[] ;
  COUNTER argcnt ; VTRACE trace ;
{ P *cpt ;
  struct V__Optimize lo ;
  int i ;

	lo.Count = 0 ; lo.intmodx = intmodx ;
	for(i=1;i<=argcnt;i++)				/* Grab the arguments */
	 { switch (v4im_CheckPtArgNew(ctx,argpnts[i],&cpt,NULL))
	    { default:				v_Msg(ctx,NULL,"TagBadUse",intmodx) ; goto fail ;
	      case V4IM_Tag_Unk:		v_Msg(ctx,NULL,"TagUnknown",intmodx) ; goto fail ;
	      case V4IM_Tag_Enum:
		if (lo.Count >= OptimizeDimMax)
		 { v_Msg(ctx,NULL,"StatMaxVals",intmodx,OptimizeDimMax,V4IM_Tag_Enum) ; goto fail ; } ;
		lo.Level[lo.Count].lp = v4im_VerifyList(&lo.Level[lo.Count].ePnt,ctx,cpt,intmodx) ;
		lo.Count ++ ; break ;
	      case V4IM_Tag_Maximum:		lo.vpt = cpt ; lo.isMax = TRUE ; lo.MinMax = -DBL_MAX ; break ;
	      case V4IM_Tag_Minimum:		lo.vpt = cpt ; lo.isMax = FALSE ; lo.MinMax = DBL_MAX ; break ;
	    } ;
	 } ;
/*	Now iterate thru everything & remember the min/max */
	lo.FrameId = v4ctx_FramePush(ctx,NULL) ;		/* Start new context frame */	
	if (!v4im_DoOptimizeIter(ctx,&lo,0)) { goto fail ; } ;
	if (!v4ctx_FramePop(ctx,lo.FrameId,NULL)) { v_Msg(ctx,NULL,"ModCtxPopFrame",intmodx,lo.FrameId) ; goto fail ; } ;
/*	Done - put optimized values into context, return lowest point as value */
	for(i=0;i<lo.Count;i++)
	 { if (!v4ctx_FrameAddDim(ctx,0,&lo.Level[i].oPnt,0,0)) { v_Msg(ctx,NULL,"CtxAddFail",intmodx) ; goto fail ; } ;
	 } ;
	memcpy(respnt,&lo.Level[lo.Count-1].oPnt,lo.Level[lo.Count-1].oPnt.Bytes) ;
	return(respnt) ;

fail:	REGISTER_ERROR(0) ; return(NULL) ;
}

LOGICAL v4im_DoOptimizeIter(ctx,lo,level)
  struct V4C__Context *ctx ;
  struct V__Optimize *lo ;
  int level ;
{ P lpt,*ipt ;
  struct V4L__ListPoint *lp ;
  int i,j,res ; double dnum ;

	if (level < lo->Count-1)
	 { for(lo->Level[level].Index=1;;lo->Level[level].Index++)
	    { if (!v4l_ListPoint_Value(ctx,lo->Level[level].lp,lo->Level[level].Index,&lo->Level[level].curPnt)) return(TRUE) ;
	      if (!v4ctx_FrameAddDim(ctx,lo->FrameId,&lo->Level[level].curPnt,0,0)) return(FALSE) ;
	      if (!v4im_DoOptimizeIter(ctx,lo,level+1)) return(FALSE) ;
	    } ;
	 } ;
/*	Lowest level - test min/max/whatever */
	lp = lo->Level[level].lp ;
	for(i=1;;i++)
	 { if (!v4l_ListPoint_Value(ctx,lp,i,&lo->Level[level].curPnt)) break ;
	   if (!v4ctx_FrameAddDim(ctx,lo->FrameId,&lo->Level[level].curPnt,0,0)) return(FALSE) ;
	   ipt = v4dpi_IsctEval(lo->vpt,&lpt,ctx,V4DPI_EM_EvalQuote,NULL,NULL) ;
	   if (ipt == NULL) { v_Msg(ctx,NULL,"ModArgEval2",lo->intmodx,&lpt) ; return(FALSE) ; } ;
	   dnum = v4im_GetPointDbl(&res,ipt,ctx) ;
 	   if (!res) { v_Msg(ctx,NULL,"ModFailed2",lo->intmodx) ; return(FALSE) ; } ;
	   if (lo->isMax) { if (dnum <= lo->MinMax) continue ; }
	    else { if (dnum >= lo->MinMax) continue ; } ;
/*	   If here have current min/max - save it */
	   lo->MinMax = dnum ;
	   for(j=0;j<lo->Count;j++) { lo->Level[j].oPnt = lo->Level[j].curPnt ; } ;
	 } ;
	return(TRUE) ;
}

struct V4DPI__Point *v4im_DoSort(ctx,respnt,argpnts,argcnt,intmodx)
  struct V4C__Context *ctx ;
  P *respnt ;						/* Ptr for result */
  INTMODX intmodx ;
  P *argpnts[] ;
  COUNTER argcnt ;
{ 
  P *ifpt,*dopt,*whilept,*ipt,*cpt,*tpt,*sortpt,*parpt,*pifpt,*sumpt,*ctxpt,*ctxPpt ;
  P sortPtBuf,ptbuf,oldptbuf,isctbuf,oldpar,oldpif,spnt ;
  struct V4DPI__LittlePoint rowpt ;
  struct V4L__ListPoint *lp,*lp1,*lpctx ;
  struct VSRT__KeyList vs ;
  struct V4L__ListPoint *lpsum ;
  FILE *vsfp ;
#define FDBUFMAX 255
  UCCHAR fdbuf[FDBUFMAX+1] ;
#define LCLSORTMAX 10
  struct lcl__Sort {
    int Count ;			/* Number of sort arguments */
    struct {
      int RevSort ;		/* True if sorting Reverse::xxx */
      P Argpt ;			/* What to sort on */
     } Arg[LCLSORTMAX] ;
   } ls ;
  double *dptr,dnum ; char *bp1,*recptr ; UCCHAR *ubp ;
  int i,j,k,tagX,ix,bytes,frameid,revsort,num,bx,ic,shellDimId,max,firstsum,sx,maxalign,pop,ok,indexDimId,dupok ; INDEX indexStart ; DIMID indexPntType ;

	bytes = -1 ;					/* If > 0 then number of bytes in sort buffer */
	lp = v4im_VerifyList(NULL,ctx,ipt = argpnts[1],intmodx) ;
	frameid = v4ctx_FramePush(ctx,NULL) ;		/* Start new context frame */
	if (lp == NULL) { v_Msg(ctx,NULL,"ModInvArgList2",intmodx,argpnts[1]) ; goto sort_fail ; } ;
	sortpt = &sortPtBuf ;				/* Allocate temp point area to hold sort points */
	memset(&vs,0,sizeof vs) ; revsort = FALSE ;
	num = 0 ;					/* Total number in sort list */
	max = UNUSED ;					/* Max number of points to output */
	ls.Count = 0 ;
	ifpt = NULL ;					/* If If::pt then will be set */
	dopt = NULL ;					/* If Do::pt then will be set */
	maxalign = 0 ;					/* No record alignment necessary (yet) */
	indexDimId = UNUSED ;
	dupok = TRUE ;					/* Allow duplicate points */
	whilept = NULL ; pifpt = NULL ; parpt = NULL ; sumpt = NULL ; ctxpt = NULL ; ctxPpt = NULL ; pop = FALSE ;
	vsfp = NULL ; shellDimId = UNUSED ; ZPH(&oldpar) ; ok = TRUE ;
	for(ix=2;ok && ix<=argcnt;ix++)			/* Grab the arguments */
	 { revsort = FALSE ;
	   switch (tagX=v4im_CheckPtArgNew(ctx,argpnts[ix],&cpt,NULL))
	    { default:			v_Msg(ctx,NULL,"TagBadUse",intmodx) ; goto sort_fail ;
	      case V4IM_Tag_Unk:	v_Msg(ctx,NULL,"TagUnknown",intmodx) ; goto sort_fail ;
	      case V4IM_Tag_Reverse:	revsort = TRUE ;
	      case V4IM_Tag_By:
		if (ls.Count >= LCLSORTMAX) { v_Msg(ctx,NULL,"StatMaxVals",intmodx,LCLSORTMAX,V4IM_Tag_By) ; goto sort_fail ; } ;
		ls.Arg[ls.Count].RevSort = revsort ;
		memcpy(&ls.Arg[ls.Count].Argpt,cpt,cpt->Bytes) ;	/* Save argument */
		ls.Count++ ; break ;
	      case V4IM_Tag_Context:	ctxpt = cpt ; break ;
	      case V4IM_Tag_ContextP:	ctxPpt = cpt ; break ;
	      case V4IM_Tag_Duplicate:	dupok = v4im_GetPointLog(&ok,cpt,ctx) ; break ;
	      case V4IM_Tag_Index:	{ struct V4DPI__DimInfo *di ;
					  indexDimId = v4dpi_DimIndexDimId(&ok,ctx,cpt,&indexStart) ;
					  DIMINFO(di,ctx,indexDimId) ; indexPntType = di->PointType ;
					}
					break ;
	      case V4IM_Tag_If:		ifpt = cpt ; break ;
	      case V4IM_Tag_While:	whilept = cpt ; break ;
	      case V4IM_Tag_Do:		dopt = cpt ; break ; ;
	      case V4IM_Tag_Num:	max = v4im_GetPointInt(&ok,cpt,ctx) ; break ;
	      case V4IM_Tag_Parent:	parpt = cpt ; break ;
	      case V4IM_Tag_PIf:	pifpt = cpt ; break ;
	      case -V4IM_Tag_Pop:	pop = TRUE ; break ;
	      case V4IM_Tag_Shell:	shellDimId = v4dpi_DimShellDimId(&ok,ctx,cpt) ; break ;
	      case V4IM_Tag_Sum:
		sumpt = cpt ;
		if (sumpt->PntType != V4DPI_PntType_List) { lpsum = NULL ; }
		 else { lpsum = v4im_VerifyList(NULL,ctx,sumpt,intmodx) ;
			if (lpsum == NULL) { v_Msg(ctx,NULL,"ModInvArgList2",intmodx,sumpt) ; goto sort_fail ; } ;
		      } ;
		firstsum = TRUE ; break ;
	    } ;
	 } ;
	if (!ok) { v_Msg(ctx,NULL,"ModInvArg",intmodx,ix-1) ; goto sort_fail ; } ;
	if (ls.Count == 0) { v_Msg(ctx,NULL,"SortNoByRev",intmodx,V4IM_Tag_By,V4IM_Tag_Reverse) ; goto sort_fail ; } ;
	if (pifpt != NULL && parpt == NULL) { v_Msg(ctx,NULL,"TallyTagWithTag",intmodx,V4IM_Tag_PIf,V4IM_Tag_Parent) ; goto sort_fail ; } ;
	if (pifpt == NULL && parpt != NULL) { v_Msg(ctx,NULL,"TallyTagWthTag2",intmodx,V4IM_Tag_Parent,V4IM_Tag_PIf,V4IM_Tag_Context) ; goto sort_fail ; } ;
	for(i=1;(ic=v4l_ListPoint_Value(ctx,lp,i,&isctbuf)) > 0;i++)	/* Loop thru each point in list */
	 {
	   if (isctbuf.PntType == V4DPI_PntType_Isct)		/* If an ISCT then evaluate it */
	    { ic = 0 ; ipt = v4dpi_IsctEval(sortpt,&isctbuf,ctx,V4DPI_EM_EvalQuote,NULL,NULL) ;
	      if (ipt == NULL) { v_Msg(ctx,NULL,"ModArgEval2",intmodx,&isctbuf) ; goto sort_fail ; } ;
	    } else { ipt = &isctbuf ; } ;
	   if (pop && i > 1)					/* If Pop? then pop frame & repush to reset context */
	    { if (!v4ctx_FramePop(ctx,frameid,NULL)) { v_Msg(ctx,NULL,"ModCtxPopFrame",intmodx,frameid) ; goto sort_fail ; } ; frameid = v4ctx_FramePush(ctx,NULL) ; } ;
	   if (shellDimId == UNUSED)				/* Do we have a Shell? */
	    { if (ic != 2)
	       { 
		 if (!v4ctx_FrameAddDim(ctx,0,ipt,0,0)) { v_Msg(ctx,NULL,"CtxAddFail",intmodx) ; goto sort_fail ; } ;
		 CLEARCACHE ;
	       } ;
	    } else
	    { 
	      if (!v4ctx_FrameAddDim(ctx,0,&isctbuf,(shellDimId != isctbuf.Dim ? shellDimId : 0),0)) { v_Msg(ctx,NULL,"CtxAddFail",intmodx) ; goto sort_fail ; } ;
	    } ;
	   if (indexDimId > 0)						/* If got a Index dimension then update */
	    { tpt = (P *)&rowpt ; intPNTv(tpt,(indexStart + i - 1)) ; tpt->Dim = indexDimId ; tpt->PntType = indexPntType ;
	      if (!v4ctx_FrameAddDim(ctx,0,tpt,0,0)) goto sort_fail ;
	    } ;
	   
	   if (ctxpt != NULL)
	    { if (ctxpt->PntType == V4DPI_PntType_List)
	       { lpctx = v4im_VerifyList(NULL,ctx,ctxpt,intmodx) ;
		 for(sx=1;;sx++)
	          { if (v4l_ListPoint_Value(ctx,lpctx,sx,&spnt) <= 0) break ;
		    tpt = v4dpi_IsctEval(respnt,&spnt,ctx,V4DPI_EM_EvalQuote,NULL,NULL) ;
		    if (tpt == NULL) break ;
		    if (!v4ctx_FrameAddDim(ctx,0,tpt,0,0)) { v_Msg(ctx,NULL,"CtxAddFail",intmodx) ; goto sort_fail ; } ;
		    CLEARCACHE
		  } ;
	       } else
	       { tpt = v4dpi_IsctEval(&ptbuf,ctxpt,ctx,V4DPI_EM_EvalQuote,NULL,NULL) ;
	         if (tpt != NULL)
		  { if (memcmp(tpt,&protoSkip,protoSkip.Bytes) == 0) continue ;	/* If result is UV4:Skip then skip this point */
		    if (ctxpt->ForceEval) ipt->ForceEval = TRUE ;
		    if (!v4ctx_FrameAddDim(ctx,0,tpt,0,0)) { v_Msg(ctx,NULL,"CtxAddFail",intmodx) ; goto sort_fail ; } ;
		    CLEARCACHE
		  } ;
	       } ;
	      if (tpt == NULL) { v_Msg(ctx,NULL,"TagEvalFail",intmodx,V4IM_Tag_Context,ctxpt) ; goto sort_fail ; } ;
	    } ;
	   if (ctxPpt != NULL)
	    { 
	      tpt = v4dpi_IsctEval(&ptbuf,ctxPpt,ctx,V4DPI_EM_EvalQuote,NULL,NULL) ;
	      if (tpt == NULL) { v_Msg(ctx,NULL,"TagEvalFail",intmodx,V4IM_Tag_Context,ctxPpt) ; goto sort_fail ; } ;
	      if (memcmp(tpt,&protoSkip,protoSkip.Bytes) == 0) continue ;	/* If result is UV4:Skip then skip this point */
	      if (ctxPpt->PntType == V4DPI_PntType_List)
	       { lpctx = v4im_VerifyList(NULL,ctx,ctxpt,intmodx) ;
		 for(sx=1;;sx++)
	          { if (v4l_ListPoint_Value(ctx,lpctx,sx,&spnt) <= 0) break ;
		    tpt = v4dpi_IsctEval(respnt,&spnt,ctx,V4DPI_EM_EvalQuote,NULL,NULL) ;
		    if (tpt == NULL) { v_Msg(ctx,NULL,"TagEvalFail",intmodx,V4IM_Tag_Context,ctxPpt) ; goto sort_fail ; } ;
		    if (!v4ctx_FrameAddDim(ctx,0,tpt,0,0)) { v_Msg(ctx,NULL,"CtxAddFail",intmodx) ; goto sort_fail ; } ;
		    CLEARCACHE
		  } ;
	       } else
	       { if (ctxpt->ForceEval) ipt->ForceEval = TRUE ;
		 if (!v4ctx_FrameAddDim(ctx,0,tpt,0,0)) { v_Msg(ctx,NULL,"CtxAddFail",intmodx) ; goto sort_fail ; } ;
		 CLEARCACHE
	       } ;
	    } ;
	   if (pifpt != NULL)					/* Have PIf:xxx point? */
	    { tpt = v4dpi_IsctEval(&ptbuf,parpt,ctx,V4DPI_EM_EvalQuote,NULL,NULL) ;
	      if (tpt == NULL) { v_Msg(ctx,NULL,"TagEvalFail",intmodx,V4IM_Tag_Parent,parpt) ; goto sort_fail ; } ;
	      if (memcmp(&oldpar,tpt,tpt->Bytes) != 0)		/* Parent different? */
	       { memcpy(&oldpar,tpt,tpt->Bytes) ;		/* Copy for next go-around */
		 if (!v4ctx_FrameAddDim(ctx,0,tpt,0,0)) { v_Msg(ctx,NULL,"CtxAddFail",intmodx) ; goto sort_fail ; } ;
		 CLEARCACHE
	         tpt = v4dpi_IsctEval(&oldpif,pifpt,ctx,V4DPI_EM_EvalQuote,NULL,NULL) ;
		 if (tpt == NULL) { v_Msg(ctx,NULL,"TagEvalFail",intmodx,V4IM_Tag_PIf,pifpt) ; goto sort_fail ; } ;
	       } else { tpt = &oldpif ; } ;
	      if (tpt->Value.IntVal <= 0) continue ;		/* If FALSE then try next point */
	    } ;
	   if (whilept != NULL)
	    { tpt = whilept ; tpt = v4dpi_IsctEval(&ptbuf,tpt,ctx,V4DPI_EM_EvalQuote,0,NULL) ;
	      if (tpt == NULL) { v_Msg(ctx,NULL,"TagEvalFail",intmodx,V4IM_Tag_While,whilept) ; goto sort_fail ; } ;
	      if (tpt->Value.IntVal < 1) break ;		/*  else if defined then best be integer > 0 */
	    } ;
	   if (ifpt != NULL)
	    { tpt = ifpt ; tpt = v4dpi_IsctEval(&ptbuf,tpt,ctx,V4DPI_EM_EvalQuote,0,NULL) ;
	      if (tpt == NULL) { v_Msg(ctx,NULL,"TagEvalFail",intmodx,V4IM_Tag_If,ifpt) ; goto sort_fail ; } ;
	      if (tpt->Value.IntVal < 1) continue ;		/*  else if defined then best be integer > 0 */
	    } ;
	   memcpy(sortpt,ipt,ipt->Bytes) ;			/* Copy ipt (point in returned sort list) into sortpt */
	   XDBSAVEROW(ipt)					/* If this point associated with 'current' XDB row then save the row */
	   if (sumpt != NULL)
	    { for(sx=1;;sx++)
	       { if (lpsum != NULL)
	          { if (v4l_ListPoint_Value(ctx,lpsum,sx,&spnt) <= 0) break ; tpt = &spnt ; }
		  else { tpt = sumpt ; } ;
	         tpt = v4dpi_IsctEval(&ptbuf,tpt,ctx,V4DPI_EM_EvalQuote,NULL,NULL) ;
		 if (tpt == NULL) { v_Msg(ctx,NULL,"TagEvalFail",intmodx,V4IM_Tag_Sum,sumpt) ; goto sort_fail ; } ;
		 if (firstsum)					/* If first time then just add to context */
		  { 
		    if (!v4ctx_FrameAddDim(ctx,0,tpt,0,0)) { v_Msg(ctx,NULL,"CtxAddFail",intmodx) ; goto sort_fail ; } ;
		    CLEARCACHE
		  } else
		  { DIMVAL(ipt,ctx,tpt->Dim) ;		/* Get current dimension value */
		    ok = TRUE ; dnum = (ipt == NULL ? 0 : v4im_GetPointDbl(&ok,ipt,ctx)) ;
		    if (!ok) { v_Msg(ctx,NULL,"ModInvArg2",intmodx,ipt) ; goto sort_fail ; } ;
		    dnum += v4im_GetPointDbl(&ok,tpt,ctx) ;	/* Add current value to context value */
		    if (!ok) { v_Msg(ctx,NULL,"ModInvArg2",intmodx,ipt) ; goto sort_fail ; } ;
		    v4im_SetPointValue(ctx,tpt,dnum) ;
		    if (!v4ctx_FrameAddDim(ctx,0,tpt,0,0)) { v_Msg(ctx,NULL,"CtxAddFail",intmodx) ; goto sort_fail ; } ;
		  } ;
	         if (lpsum == NULL) break ;			/* Don't have list */
	       } ;
	      firstsum = FALSE ;
	    } ;
	   for(j=0,k=0;j<ls.Count;j++)
	    { ipt = &ls.Arg[j].Argpt ; revsort = ls.Arg[j].RevSort ;
	      ipt = v4dpi_IsctEval(&isctbuf,ipt,ctx,V4DPI_EM_EvalQuote,NULL,NULL) ;
	      if (ipt == NULL)
	       { v_Msg(ctx,NULL,"SortByRevFail",intmodx,V4IM_Tag_By,V4IM_Tag_Reverse,&ls.Arg[j].Argpt) ; goto sort_fail ; } ;
	      if (ipt->PntType == V4DPI_PntType_Shell) ipt = (P *)&ipt->Value ;
	      if (k == vs.Count)
	       { if (vs.Count == 0)			/* First make room for the point that is being sorted (i.e. one of the points in first argument list) */
	          { vs.FreeOffset = ALIGN(sortpt->Bytes) ;
		    switch (sortpt->PntType)		/* sortpt is sort point (not by/reverse point) */
		     { case V4DPI_PntType_UCChar:
			vs.FreeOffset = ALIGN((V4DPI_AlphaUC_SortValMax*sizeof(UCCHAR))+V4DPI_PointHdr_Bytes) ;
			break ;
		       case V4DPI_PntType_List:
		       CASEofCharmU
			vs.FreeOffset = ALIGN(V4DPI_AlphaUC_SortValMax+V4DPI_PointHdr_Bytes) ;
			break ;
		     } ;
		    if (sortpt->Bytes > vs.FreeOffset)
		     { v_Msg(ctx,UCTBUF1,"SortTooBig",intmodx,sortpt->Bytes,vs.FreeOffset,sortpt) ; goto sort_fail ; } ;
	          } ;
		 vs.Keys[vs.Count].Offset = vs.FreeOffset ; vs.Keys[vs.Count].Descending = revsort ;
		 switch (ipt->PntType)
		  { default:
			v_Msg(ctx,NULL,"SortByRevPntTyp",intmodx,V4IM_Tag_By,V4IM_Tag_Reverse,&ls.Arg[j].Argpt,ipt,ipt->PntType) ;
			goto sort_fail ;
		    case V4DPI_PntType_Color:
		    case V4DPI_PntType_Country:
		    case V4DPI_PntType_XDict:
			vs.FreeOffset += (vs.Keys[vs.Count].Bytes = (sizeof(UCCHAR) * (V4DPI_XDictEntryVal_Max+1))) ;
			vs.FreeOffset = (vs.FreeOffset+maxalign) & (~maxalign) ;
			vs.Keys[vs.Count].Type = VSRT_KeyType_UCChar ; break ;
		    case V4DPI_PntType_Dict:
			vs.FreeOffset += (vs.Keys[vs.Count].Bytes = (sizeof(UCCHAR) * (V4DPI_DictEntryVal_Max+1))) ;
			vs.FreeOffset = (vs.FreeOffset+maxalign) & (~maxalign) ;
			vs.Keys[vs.Count].Type = VSRT_KeyType_UCChar ; break ;
		    CASEofCharmU
			vs.FreeOffset += (vs.Keys[vs.Count].Bytes = V4DPI_AlphaUC_SortByMax+1) ;
			vs.FreeOffset = (vs.FreeOffset+maxalign) & (~maxalign) ;
			vs.Keys[vs.Count].Type = VSRT_KeyType_Alpha ; break ;
		    case V4DPI_PntType_UCChar:
			vs.FreeOffset += ((vs.Keys[vs.Count].Bytes = V4DPI_AlphaUC_SortByMax+1) * sizeof(UCCHAR)) ;
			vs.FreeOffset = (vs.FreeOffset+maxalign) & (~maxalign) ;
			vs.Keys[vs.Count].Type = VSRT_KeyType_UCChar ; break ;
		    case V4DPI_PntType_Fixed:
			vs.FreeOffset = (vs.FreeOffset+ALIGN_DOUBLE)&(~ALIGN_DOUBLE) ; maxalign |= ALIGN_DOUBLE ;
			vs.Keys[vs.Count].Offset = vs.FreeOffset ;		/* Realign for double */
			vs.Keys[vs.Count].Bytes = sizeof (B64INT) ; vs.FreeOffset += sizeof (B64INT) ;
			vs.Keys[vs.Count].Type = VSRT_KeyType_Fixed ; break ;
		    case V4DPI_PntType_UTime:
		    case V4DPI_PntType_UOM:
		    case V4DPI_PntType_UOMPer:
		    case V4DPI_PntType_Calendar:
		    case V4DPI_PntType_Real:
			vs.FreeOffset = (vs.FreeOffset+ALIGN_DOUBLE)&(~ALIGN_DOUBLE) ; maxalign |= ALIGN_DOUBLE ;
			vs.Keys[vs.Count].Offset = vs.FreeOffset ;		/* Realign for double */
			vs.Keys[vs.Count].Bytes = sizeof (double) ; vs.FreeOffset += sizeof (double) ;
			vs.Keys[vs.Count].Type = VSRT_KeyType_Double ; break ;
		    CASEofINT
		    case V4DPI_PntType_SSVal:
			vs.FreeOffset = (vs.FreeOffset+ALIGN_DOUBLE)&(~ALIGN_DOUBLE) ; maxalign |= ALIGN_DOUBLE ;
			vs.Keys[vs.Count].Offset = vs.FreeOffset ;		/* Realign for double */
			vs.Keys[vs.Count].Bytes = sizeof (double) ; vs.FreeOffset += sizeof (double) ;
			vs.Keys[vs.Count].Type = VSRT_KeyType_Double ; break ;
/*				vs.Keys[vs.Count].Bytes = sizeof (int) ; vs.FreeOffset += sizeof (int) ; */
/*				vs.Keys[vs.Count].Type = VSRT_KeyType_Int ; break ; */
		  } ; vs.Count ++ ; revsort = FALSE ;
	       } ;
	      switch (ipt->PntType)
	       {
		 CASEofINT
/*				iptr = (int *)(((char *)sortpt)+vs.Keys[k].Offset) ; *iptr = ipt->Value.IntVal ; break ; */
		 case V4DPI_PntType_UTime:
		 case V4DPI_PntType_Fixed:
		 case V4DPI_PntType_Real:
		 case V4DPI_PntType_Calendar:
		 case V4DPI_PntType_UOM:
		 case V4DPI_PntType_UOMPer:
		 case V4DPI_PntType_SSVal:
			if ((vs.Keys[k].Offset & ALIGN_DOUBLE) != 0)
			{ v_Msg(ctx,UCTBUF2,"*SortWarn1",intmodx,ipt) ; vout_UCText(VOUT_Trace,0,UCTBUF2) ;
			  v_Msg(ctx,UCTBUF2,"*SortWarn2",intmodx) ; vout_UCText(VOUT_Trace,0,UCTBUF2) ;
			  break ;
			} ;
			dptr = (double *)((char *)sortpt+vs.Keys[k].Offset) ;
			*dptr = v4im_GetPointDbl(&ok,ipt,ctx) ;
			if (!ok) { v_Msg(ctx,NULL,"ModInvArg2",intmodx,ipt) ; goto sort_fail ; } ;
/*				memcpy(dptr,&ipt->Value.RealVal,sizeof(double)) ; */
			break ;
		 case V4DPI_PntType_Color:
			ubp = (UCCHAR *)((char *)(sortpt)+vs.Keys[k].Offset) ;	/* Off set in bytes! */
			UCstrcpy(ubp,v_ColorRefToName(ipt->Value.IntVal)) ;
			break ;
		 case V4DPI_PntType_Country:
			ubp = (UCCHAR *)((char *)(sortpt)+vs.Keys[k].Offset) ;
			UCstrcpy(ubp,v_CountryRefToName(ipt->Value.IntVal)) ;
			break ;
		 case V4DPI_PntType_XDict:
			ubp = (UCCHAR *)((char *)(sortpt)+vs.Keys[k].Offset) ;
			UCstrcpy(ubp,v4dpi_RevXDictEntryGet(ctx,ipt->Dim,ipt->Value.IntVal)) ;
			break ;
		 case V4DPI_PntType_Dict:
			ubp = (UCCHAR *)((char *)(sortpt)+vs.Keys[k].Offset) ;
			UCstrcpy(ubp,v4dpi_RevDictEntryGet(ctx,ipt->Value.IntVal)) ;
			break ;
		 CASEofCharmU
			bp1 = ((char *)sortpt)+vs.Keys[k].Offset ;
			if ((bx = CHARSTRLEN(ipt)) > V4DPI_AlphaUC_SortByMax)
			 { v_Msg(ctx,UCTBUF1,"*SortWarn3",intmodx,V4IM_Tag_By,V4IM_Tag_Reverse,V4DPI_AlphaUC_SortByMax,ipt) ; vout_UCText(VOUT_Warn,0,UCTBUF1) ;
			   bx = V4DPI_AlphaUC_SortByMax ;
			 } ;
			strncpy(bp1,&ipt->Value.AlphaVal[1],bx) ; *(bp1+bx) = 0 ;
			break ;
		 case V4DPI_PntType_UCChar:
			ubp = (UCCHAR *)((char *)(sortpt)+vs.Keys[k].Offset) ;
			if ((bx = UCCHARSTRLEN(ipt)) > V4DPI_AlphaUC_SortByMax)
			 { v_Msg(ctx,UCTBUF1,"*SortWarn3",intmodx,V4IM_Tag_By,V4IM_Tag_Reverse,V4DPI_AlphaUC_SortByMax,ipt) ; vout_UCText(VOUT_Warn,0,UCTBUF1) ;
			   bx = V4DPI_AlphaUC_SortByMax ;
			 } ;
			UCstrncpy(ubp,&ipt->Value.UCVal[1],bx) ; ubp[bx] = UCEOS ;
			break ;
	       } ; k++ ;
	    } ;
	   num ++ ;
	   if (bytes == -1)					/* Have to decide to go to file or internal buffer */
	    { bytes = vs.FreeOffset * SIZEofLIST(lp) ;
	      if (bytes < 100000 && bytes > 0)			/* If everything will fit then go internal */
	       { recptr = (char *)v4mm_AllocChunk(bytes+sizeof(P),FALSE) ;	/* Allocate what we need (bytes) + additional 'point' because we don't know how this point buffer may be used */
	         UCstrcpy(fdbuf,UClit("v4imsort.t")) ;
		 memcpy(recptr,sortpt,vs.FreeOffset) ; sortpt = (P *)recptr ;
	       } else						/*  otherwise go to external file */
	       { 
		 vsfp = v_MakeOpenTmpFile(UClit("v4srt1"),fdbuf,UCsizeof(fdbuf),"wb",ctx->ErrorMsgAux) ;
		 if (vsfp == NULL) { v_Msg(ctx,NULL,"ModFailed2",intmodx) ; goto sort_fail ; } ;
	         bytes = 0 ;
	       } ;
	    } ;
	   if (vsfp != NULL) { fwrite(sortpt,vs.FreeOffset,1,vsfp) ; }
	    else { sortpt = (P *)((char *)sortpt + vs.FreeOffset) ; } ;
	   continue ;
	 } ;
	if (!v4ctx_FramePop(ctx,frameid,NULL)) { v_Msg(ctx,NULL,"ModCtxPopFrame",intmodx,frameid) ; goto sort_fail ; } ; frameid = UNUSED ;	/* Pop off frame context */
	if (vsfp != NULL) fclose(vsfp) ;
	if (num == 0)						/* Nothing to sort? */
	 { INITLP(respnt,lp1,Dim_List) ENDLP(respnt,lp1)
	   return(respnt) ;
	 } ;

	UCsprintf(UCTBUF1,1024,UClit("-d -q -l%d"),vs.FreeOffset) ;
	for(i=0;i<vs.Count;i++)
	 { switch(vs.Keys[i].Type)
	    { case VSRT_KeyType_Int:
		v_Msg(ctx,UCTBUF2,"@ -k%1Ui%2d",(vs.Keys[i].Descending ? UClit("r") : UClit("")),vs.Keys[i].Offset) ; break ;
	      case VSRT_KeyType_Alpha:
		v_Msg(ctx,UCTBUF2,"@ -k%1Ua%2d.%3d",(vs.Keys[i].Descending ? UClit("r") : UClit("")),vs.Keys[i].Offset,vs.Keys[i].Bytes) ; break ;
	      case VSRT_KeyType_UCChar:
		v_Msg(ctx,UCTBUF2,"@ -k%1Uu%2d.%3d",(vs.Keys[i].Descending ? UClit("r"): UClit("")),vs.Keys[i].Offset,vs.Keys[i].Bytes/2) ; break ;
	      case VSRT_KeyType_Double:
		v_Msg(ctx,UCTBUF2,"@ -k%1Ud%2d",(vs.Keys[i].Descending ? UClit("r") : UClit("")),vs.Keys[i].Offset) ; break ;
	    } ; UCstrcat(UCTBUF1,UCTBUF2) ;
	 } ;
	UCstrcat(UCTBUF1,UClit(" ")) ; UCstrcat(UCTBUF1,fdbuf) ; UCstrcat(UCTBUF1,UClit(" ")) ;
	v_MakeOpenTmpFile(UClit("v4srt2"),fdbuf,UCsizeof(fdbuf),NULL,NULL) ;
	UCstrcat(UCTBUF1,fdbuf) ;
	if (bytes > 0)	/* Sort internally */
	 { bytes = vs.FreeOffset * num ;			/* Recalc bytes based on records selected for sorting */
	   if (!vsort_entry(UCTBUF1,recptr,bytes,ctx->ErrorMsgAux)) { v_Msg(ctx,NULL,"SortSpawnErr",intmodx,ASCTBUF1) ; goto sort_fail ; } ;
	 } else
	 { 
	   if (!v_SpawnSort(UCTBUF1,gpi->sortWaitFlag,ctx->ErrorMsgAux)) { v_Msg(ctx,NULL,"SortSpawnErr",intmodx,ASCTBUF1) ; goto sort_fail ; } ;
	   vsfp = UCfopen(fdbuf,"rb") ;			/* (Re)open sorted file */
	   if (vsfp == NULL)
	    { v_Msg(ctx,NULL,"SortNoResFile2",intmodx,ASCTBUF1,errno) ; goto sort_fail ; } ;
	 } ;
	ZPH(&oldptbuf) ;
	if (dopt != NULL)					/* Did we get Do:xxx */
	 { 
	   frameid = v4ctx_FramePush(ctx,NULL) ;		/* Start new context frame */
	   if (vsfp != NULL)
	    { for(;max!=0;max--)
	       { if (fread(&ptbuf,vs.FreeOffset,1,vsfp) <= 0) break ;
	         if (!dupok)
		  { if (memcmp(&ptbuf,&oldptbuf,ptbuf.Bytes) == 0) continue ;	/* Skip duplicates */
		    memcpy(&oldptbuf,&ptbuf,ptbuf.Bytes) ;
		  } ;
		 if (!v4ctx_FrameAddDim(ctx,0,&ptbuf,0,0)) { v_Msg(ctx,NULL,"CtxAddFail",intmodx) ; goto sort_fail ; } ;
		 CLEARCACHE
		 if (dopt->PntType == V4DPI_PntType_List)
		  { lp1 = ALIGNLP(&dopt->Value) ;
		    for(j=1;v4l_ListPoint_Value(ctx,lp1,j,&isctbuf) > 0;j++)
		     { if(v4dpi_IsctEval(&ptbuf,&isctbuf,ctx,V4DPI_EM_EvalQuote,NULL,NULL) == NULL)
			{ v_Msg(ctx,NULL,"TagEvalFail",intmodx,V4IM_Tag_Do,&isctbuf) ; goto sort_fail ; } ;
		     } ;
		  } else { if (v4dpi_IsctEval(&ptbuf,dopt,ctx,V4DPI_EM_EvalQuote,NULL,NULL) == NULL)
			    { v_Msg(ctx,NULL,"TagEvalFail",intmodx,V4IM_Tag_Do,dopt) ; goto sort_fail ; } ;
			 } ;
	       } ;
	      fclose(vsfp) ;
	    } else
	    { for(bp1=recptr;num>0&&max!=0;max--,num--,bp1+=vs.FreeOffset)
	       { ipt = (P *)bp1 ;
	         if (!dupok)
		  { if (memcmp(ipt,&oldptbuf,ipt->Bytes) == 0) continue ;	/* Skip duplicates */
		    memcpy(&oldptbuf,ipt,ipt->Bytes) ;
		  } ;
		 if (!v4ctx_FrameAddDim(ctx,0,ipt,0,0)) { v_Msg(ctx,NULL,"CtxAddFail",intmodx) ; goto sort_fail ; } ;
		 CLEARCACHE
		 if (dopt->PntType == V4DPI_PntType_List)
		  { lp1 = ALIGNLP(&dopt->Value) ;
		    for(j=1;v4l_ListPoint_Value(ctx,lp1,j,&isctbuf) > 0;j++)
		     { if (v4dpi_IsctEval(&ptbuf,&isctbuf,ctx,V4DPI_EM_EvalQuote,NULL,NULL) == NULL)
			{ v_Msg(ctx,NULL,"TagEvalFail",intmodx,V4IM_Tag_Do,&isctbuf) ; goto sort_fail ; } ;
		     } ;
		  } else
		  { if (v4dpi_IsctEval(&ptbuf,dopt,ctx,V4DPI_EM_EvalQuote,NULL,NULL) != NULL) continue ;
		    v_Msg(ctx,NULL,"TagEvalFail",intmodx,V4IM_Tag_Do,dopt) ; goto sort_fail ;
		  } ;
	       } ;
	      v4mm_FreeChunk(recptr) ;			/* Free up sort buffer */
	    } ;
	   if (!v4ctx_FramePop(ctx,frameid,NULL)) { v_Msg(ctx,NULL,"ModCtxPopFrame",intmodx,frameid) ; goto sort_fail ; } ;		/* Pop off frame context */
	   return((P *)&Log_True) ;
	 } ;
	INITLP(respnt,lp1,Dim_List)
	if (vsfp != NULL)
	 { for(;max!=0;max--)
	    { if (fread(&ptbuf,vs.FreeOffset,1,vsfp) <= 0) break ;
	      if (!dupok)
	       { if (memcmp(&ptbuf,&oldptbuf,ptbuf.Bytes) == 0) continue ;	/* Skip duplicates */
	         memcpy(&oldptbuf,&ptbuf,ptbuf.Bytes) ;
	       } ;
	      if (!v4l_ListPoint_Modify(ctx,lp1,V4L_ListAction_Append,&ptbuf,0)) { v_Msg(ctx,NULL,"LPModFail",intmodx) ; goto sort_fail ; } ;
	    } ;
	   fclose(vsfp) ; UCremove(fdbuf) ;
	 } else
	 { for(bp1=recptr;num>0&&max!=0;max--,num--,bp1+=vs.FreeOffset)
	    { ipt = (P *)bp1 ;
	      if (!dupok)
	       { 
	         if (memcmp(ipt,&oldptbuf,ipt->Bytes) == 0) continue ;	/* Skip duplicates */
	         memcpy(&oldptbuf,ipt,ipt->Bytes) ;
	       } ;
	      if (!v4l_ListPoint_Modify(ctx,lp1,V4L_ListAction_Append,ipt,0)) { v_Msg(ctx,NULL,"LPModFail",intmodx) ; goto sort_fail ; } ;
	    } ;
	   v4mm_FreeChunk(recptr) ;			/* Free up sort buffer */
	 } ;
	ENDLP(respnt,lp1)
	return(respnt) ;
sort_fail:
	if (frameid != UNUSED) v4ctx_FramePop(ctx,frameid,NULL) ;
	REGISTER_ERROR(0) ; return(NULL) ;
}


struct V4DPI__Point *v4im_DoTry(ctx,respnt,argpnts,argcnt,intmodx,trace)
  struct V4C__Context *ctx ;
  P *respnt ;						/* Ptr for result */
  INTMODX intmodx ;
  P *argpnts[] ;
  COUNTER argcnt ; VTRACE trace ;
{
  P *rpt,*cpt,isctbuf,lstbuf ;
  struct V4IM__CatchExcept *vce ;
  struct V4L__ListPoint *lp ;
  int frameid,argcntDo,i,ix,tag,ok,ncnt,lx ; UCCHAR name[V4DPI_DimInfo_DimNameMax+1] ;

	frameid = v4ctx_FramePush(ctx,NULL) ;		/* Start new context frame */

/*	Look through all arguments and handle any Catch::xxx tags */
	for(ix=1;ix<=argcnt;ix++)
	 { if (argpnts[ix]->PntType != V4DPI_PntType_TagVal) continue ;
	   tag = v4im_CheckPtArgNew(ctx,argpnts[ix],&cpt,NULL) ;
	   if (tag == V4IM_Tag_Catch) break ;
	 } ;
	if (ix < argcnt)				/* Did we get any Catch::xxx tags ? */
	 { argcntDo = ix - 1 ;				/* Do() argument count up to first Catch::xxx */
	   ctx->Frame[ctx->FrameCnt - 1].vce = (vce = (struct V4IM__CatchExcept *)v4mm_AllocChunk(sizeof *vce,FALSE)) ;
	   vce->CatchCnt = 0 ;
	   for (ncnt=0;ncnt<V4IM_CatchExceptNameMax;ncnt++) { ZUS(vce->Catch[vce->CatchCnt].exceptionName[ncnt]) ; } ; ncnt = 0 ;
	   for(ok=TRUE;ok&&ix<=argcnt;ix++)			/* Go thru the remaining arguments */
	    { switch(v4im_CheckPtArgNew(ctx,argpnts[ix],&cpt,&isctbuf))
	       { default:		v_Msg(ctx,NULL,"TagBadUse",intmodx) ; goto fail ;
	         case V4IM_Tag_Unk:	v_Msg(ctx,NULL,"TagUnknown",intmodx) ; goto fail ;
	         case V4IM_Tag_Do:
	         case V4IM_Tag_QIsct:
	         case V4IM_Tag_List:
			if (ncnt == 0) { v_Msg(ctx,NULL,"TryNoCatch",intmodx,ix,V4IM_Tag_Catch) ; goto fail ; } ;
			memcpy(&vce->Catch[vce->CatchCnt].excpnt,cpt,cpt->Bytes) ;
			if (vce->CatchCnt == V4IM_CatchExceptMax && ix < argcnt)
			 { v_Msg(ctx,NULL,"TryCatchMax",intmodx,V4IM_CatchExceptMax,V4IM_Tag_Catch) ; goto fail ; } ;
			vce->CatchCnt++ ;
			for (ncnt=0;ncnt<V4IM_CatchExceptNameMax;ncnt++) { ZUS(vce->Catch[vce->CatchCnt].exceptionName[ncnt]) ; } ; ncnt = 0 ;
			break ;
		 case V4IM_Tag_Catch:
			lp = (cpt->PntType == V4DPI_PntType_List ? v4im_VerifyList(NULL,ctx,cpt,intmodx) : NULL) ;
			for(lx=1;(lx>1?lp!=NULL:TRUE);lx++)
			 { if (lp != NULL) { if(v4l_ListPoint_Value(ctx,lp,lx,&lstbuf) <= 0) break ; cpt = &lstbuf ; } ;
			   v4im_GetPointUC(&ok,name,sizeof name,cpt,ctx) ; if (!ok) break ;
			   if (ncnt >= V4IM_CatchExceptNameMax)
			    { v_Msg(ctx,NULL,"TryCatchNameMax",intmodx,V4IM_CatchExceptNameMax,V4IM_Tag_Catch) ; goto fail ; } ;
			   if (ix == argcnt) { v_Msg(ctx,NULL,"TryNoEvalPt",intmodx,ix) ; goto fail ; } ;
			   UCstrcpy(vce->Catch[vce->CatchCnt].exceptionName[ncnt],name) ;
			   i = UCstrlen(name) ; vce->Catch[vce->CatchCnt].excpartial[ncnt] = (name[i-1] == UClit('*') ? i - 1: 0) ;
			   ncnt++ ;
			 } ;
			break ;
	       } ;
	    } ;	if (!ok) { v_Msg(ctx,NULL,"ModInvArg",intmodx,ix-1) ; goto fail ; } ;
	 } else
	 { argcntDo = argcnt ;				/* No Catch::xxx tags - then make same as Do() */
	   ctx->Frame[ctx->FrameCnt - 1].vce = NULL ;
	 } ;

/*	Now simply call handle as Do() - with argcnt reduced so it does not "see" any of the Catch::xxx stuff */
	rpt = v4im_DoDo(ctx,respnt,argcntDo,argpnts,intmodx) ;
	if (ctx->Frame[ctx->FrameCnt - 1].vce != NULL)
	 { v4mm_FreeChunk(ctx->Frame[ctx->FrameCnt - 1].vce) ; ctx->Frame[ctx->FrameCnt - 1].vce = NULL ; } ;
	if (!v4ctx_FramePop(ctx,frameid,NULL)) { v_Msg(ctx,NULL,"ModCtxPopFrame",intmodx,frameid) ; goto fail ; } ;
	return(rpt) ;

fail:	REGISTER_ERROR(0) ; v4ctx_FramePop(ctx,frameid,NULL) ;
	return(NULL) ;

}

struct V4DPI__Point *v4im_ThrowException(ctx,respnt,intmodx,exception,pntcnt,pntarray)
  struct V4C__Context *ctx ;
  P *respnt ;						/* Ptr for result */
  INTMODX intmodx ;
  UCCHAR *exception ;
  int pntcnt ;
  P *pntarray[] ;
{ P *ipt, lstbuf ;
  struct V4L__ListPoint *lp ;
  struct V4IM__CatchExcept *vce ;
  int exccnt ; UCCHAR exceptionUC[32][V4DPI_DimInfo_DimNameMax+1] ;
  int frameid,ex,fx,cx,nx,ix,lx ; UCCHAR *sp, *dp ;

	frameid = UNUSED ;
	for(sp=exception,dp=exceptionUC[0],exccnt=1,ix=0;*sp!=UCEOS && exccnt<32;sp++)
	 { if (*sp == UClit(',')) { *dp = UCEOS ; dp = exceptionUC[exccnt++] ; continue ; } ;
	   *(dp++) = UCTOUPPER(*sp) ;
	 } ; *dp = '\0' ;
/*	Start scanning back through context frames for this exception */
	for (ex=0;ex<exccnt;ex++)
	 { for (fx=ctx->FrameCnt-1;fx>=0;fx--)
	    { if ((vce = ctx->Frame[fx].vce) == NULL) continue ;
	      for(cx=0;cx<vce->CatchCnt;cx++)
	       { for(nx=0;nx<V4IM_CatchExceptNameMax&&vce->Catch[cx].exceptionName[nx][0]!=UCEOS;nx++)
		  { 
		    if (vce->Catch[cx].excpartial[nx] > 0 ?
		      UCstrncmpIC(exceptionUC[ex],vce->Catch[cx].exceptionName[nx],vce->Catch[cx].excpartial[nx]) != 0 : UCstrcmpIC(exceptionUC[ex],vce->Catch[cx].exceptionName[nx]) != 0) continue ;
   /*		    Got a match - evaluate the corresponding point */
		    frameid = v4ctx_FramePush(ctx,NULL) ;
   /*		    Put Throw exception in context as UDim:"xxx" point */
		    ZPH(&lstbuf) ; lstbuf.PntType = V4DPI_PntType_Shell ; lstbuf.Dim = Dim_UDim ;
		    ipt = (P *)&lstbuf.Value ; uccharPNTv(ipt,exceptionUC[ex]) ; lstbuf.Bytes = V4DPI_PointHdr_Bytes + ipt->Bytes ;
		    if (!v4ctx_FrameAddDim(ctx,0,&lstbuf,0,0)) { v_Msg(ctx,NULL,"CtxAddFail",intmodx) ; goto fail ; } ;
		    for(ix=0;ix<pntcnt;ix++)
		     { ipt = v4dpi_IsctEval(&lstbuf,pntarray[ix],ctx,V4DPI_EM_EvalQuote,NULL,NULL) ;
		       if (ipt == NULL) { v_Msg(ctx,NULL,"ModArgEval2",intmodx,pntarray[ix]) ; goto fail ; } ;
		       if (!v4ctx_FrameAddDim(ctx,0,ipt,0,0)) { v_Msg(ctx,NULL,"CtxAddFail",intmodx) ; goto fail ; } ;
		     } ;
		    if (vce->Catch[cx].excpnt.PntType == V4DPI_PntType_List)
		     { lp = v4im_VerifyList(NULL,ctx,&vce->Catch[cx].excpnt,intmodx) ;
		       for(lx=1;v4l_ListPoint_Value(ctx,lp,lx,&lstbuf)>0;lx++)
			{ ipt = v4dpi_IsctEval(respnt,&lstbuf,ctx,V4DPI_EM_EvalQuote,NULL,NULL) ;
			  if (ipt == NULL) break ;
			} ;
		     } else { ipt = v4dpi_IsctEval(respnt,&vce->Catch[cx].excpnt,ctx,V4DPI_EM_EvalQuote,NULL,NULL) ; } ;
		    if (ipt == NULL) { v_Msg(ctx,NULL,"ModArgEval2",intmodx,&vce->Catch[cx].excpnt) ; goto fail ; } ;
		    if (frameid != UNUSED) { if (!v4ctx_FramePop(ctx,frameid,NULL)) { v_Msg(ctx,NULL,"ModCtxPopFrame",intmodx,frameid) ; goto fail ; } ; } ;
   /*		    Now what? - look at result (ipt) and figure out how to continue */
		    return(ipt) ;
		  } ;
	       } ;
	    } ;
	 } ;
	v_Msg(ctx,NULL,"ThrowNoExcept",intmodx,exception,V4IM_OpCode_Try) ; goto fail ;

fail:	REGISTER_ERROR(0) ;
	if (frameid != UNUSED) v4ctx_FramePop(ctx,frameid,NULL) ;
	return(NULL) ;
}

struct V4DPI__Point *v4im_ThrowLastErrorMnemonic(ctx,respnt,intmodx)
  struct V4C__Context *ctx ;
  P *respnt ;
  INTMODX intmodx ;
{ 
  char *errmne ;

	errmne = gpi->mi->Entry[gpi->mi->LastMsgIndex].Mnemonic ;
	return(v4im_ThrowException(ctx,respnt,intmodx,ASCretUC(errmne),0,NULL)) ;
}

struct V4DPI__Point *v4im_DoThrow(ctx,respnt,argpnts,argcnt,intmodx)
  struct V4C__Context *ctx ;
  P *respnt ;						/* Ptr for result */
  INTMODX intmodx ;
  P *argpnts[] ;
  COUNTER argcnt ;
{ int ok ; UCCHAR excep[V4DPI_DimInfo_DimNameMax+1] ;

	v4im_GetPointUC(&ok,excep,UCsizeof(excep),argpnts[1],ctx) ;
	if (!ok) { v_Msg(ctx,NULL,"ModInvArg",intmodx,1) ; goto fail ; } ;
/*	Just call ThrowException routine with pointer to second argument */
	return(v4im_ThrowException(ctx,respnt,intmodx,excep,argcnt-1,&argpnts[2])) ;

fail:	REGISTER_ERROR(0) ;
	return(NULL) ;
}


struct V4DPI__Point *v4im_DoEnum(ctx,respnt,argpnts,argcnt,intmodx,trace,extended)
  struct V4C__Context *ctx ;
  P *respnt ;						/* Ptr for result */
  INTMODX intmodx ;
  P *argpnts[] ;
  COUNTER argcnt ; VTRACE trace,extended ;
{ struct V4L__ListPoint *lp,*lp1,*lpev,*calclp,*lpctx ;
  P *wpt,*spt,*cpt,*tpt,*ipt,*lstpt,*parpt,*pifpt,*awpt,*calcpt,*nonept ;
//x  P *untilpt,*ctxpt,*fpt,*trypt,*sumpt ;
//x  struct V4L__ListPoint *lpsum ;
  struct V4DPI__LittlePoint idpt ;
  struct V4IM__AggLookAhead *ala = NULL ;
  P *thenpt ;
  P ptbuf,spnt,isctbuf,oldpar,oldpif ;
#define V4IM_MaxEnumAct 30
  struct lcl__EnumActList {
     int Count ;
     struct {
       ETYPE Tag ;			/* Tag value V4IM_Tag_xxx */
       COUNTER Counter ;
       LOGICAL notFirst ;
       struct V4DPI__Point *pt ;	/* Value point */
      } Act[V4IM_MaxEnumAct] ;
   } enal ;
#define ENUMACT \
 if (enal.Count >= V4IM_MaxEnumAct) { v_Msg(ctx,ctx->ErrorMsgAux,"EnumMaxAct",V4IM_MaxEnumAct) ; ok = FALSE ; break ; } ;\
 memset(&enal.Act[enal.Count],0,sizeof enal.Act[0]) ; enal.Act[enal.Count].Tag = tx ; enal.Act[enal.Count++].pt = cpt ;
#define V4IM_MaxEnumNest 5
  struct lcl__nestenum {
    int Count ;				/* Number of nested levels */
    struct {
      struct V4DPI__Point *npt ;	/* Point containing list */
      struct V4L__ListPoint *lp ;	/* List for this level */
      int lIndex ;			/* List (or count) index for this level */
      int MaxCount ;			/* Count for this level (instead of iterating thru list, will enumerate MaxCount times) */
      int frameid ;			/* Context frame id for this level */
     } Nest[V4IM_MaxEnumNest] ;
   } lne ;
  struct V4IM__XMLNest xml ;
  struct V4IM__BaA *baf ;
  int pntX,enalX,ix,j,k,frameid,frameidbaf,resdim,ic,sx,nx,lx,every,cx,stx,selected,totalPnts,nestRCV,optok,pop,first ;
  LOGICAL lastTag ;
#ifdef NEWBAFSTUFF
 LENMAX skip, lvlMax = V4IM_BaA_LevelDfltMax,colMax = V4IM_BaA_ColDfltMax,calcMax = V4IM_BaA_CalcDfltMax ;
#endif
//  int firstsum ;
  UCCHAR id[32] ; double dnum ; LOGICAL ok,traceProgress ;

	if (argcnt == 1)
	 { cpt = argpnts[1] ;
	   switch (cpt->PntType)
	    { 
	      case V4DPI_PntType_Isct:
		for(lx=1;;lx++)
		 { if (v4dpi_IsctEval(&ptbuf,cpt,ctx,V4DPI_EM_EvalQuote,NULL,NULL) == NULL) break ; } ;
		intPNTv(respnt,lx-1) ; return(respnt) ;
	      default:
	      case V4DPI_PntType_List:
		lp = v4im_VerifyList(NULL,ctx,cpt,intmodx) ;
		if (lp == NULL) { } ;
		for(lx=1;;lx++)
		 { if (v4l_ListPoint_Value(ctx,lp,lx,&spnt) <= 0) break ;
		   XDBSAVEROW(&spnt)					/* If this point associated with 'current' XDB row then save the row */
		 } ;
		intPNTv(respnt,lx-1) ;					/* Return number of points enumerated */
		return(respnt) ;
	    } ;
	 } ;




	frameid = UNUSED ; frameidbaf = UNUSED ; baf = NULL ; resdim = UNUSED ; lp = NULL ;
	every = UNUSED ; nestRCV = FALSE ; optok = FALSE ; pop = FALSE ; traceProgress = ((trace & V4TRACE_Progress) != 0) ;
	wpt = NULL ;					/* No "While:xxx" specified yet */
	spt = NULL ;					/* No "Select:xxx" specified */
	calcpt = NULL ; lstpt = NULL ; nonept = NULL ;
	thenpt = NULL ; parpt = NULL ; pifpt = NULL ; awpt = NULL ; xml.Count = 0 ; skip = UNUSED ;
	lne.Count = 0 ;	nx = 0 ;			/* No nested Enum::xxx (yet) */
	totalPnts = 0 ;					/* Total number of points to Enum through (needed for traces, Last:: tag) */
	lastTag = FALSE ;				/* TRUE if Last::xxx tag seen */
	selected = 0 ; ZPH(&oldpar) ; ZUS(id) ; ZPH(&idpt) ;
	enal.Count = 0 ;
	ZPH(respnt) ;					/* Zero this out (it will only get set if we have a result to return) */
	for(ok=TRUE,ix=1;ok&&ix<=argcnt;ix++)
	 { INDEX tx ;
	   if (ix == 1 && argpnts[ix]->PntType != V4DPI_PntType_TagVal)
	    { lne.Nest[lne.Count].npt = argpnts[ix] ; lne.Count++ ; continue ; } ;
	   switch (tx=v4im_CheckPtArgNew(ctx,argpnts[ix],&cpt,NULL))
	    { default:			v_Msg(ctx,NULL,"TagBadUse",intmodx) ; goto enum_fail ;
	      case V4IM_Tag_Unk:	v_Msg(ctx,NULL,"TagUnknown",intmodx) ; goto enum_fail ;
	      case V4IM_Tag_Shell:	ONCEU(resdim) ; resdim = v4dpi_DimShellDimId(&ok,ctx,cpt) ; break ;
	      case V4IM_Tag_Columns:	colMax = v4im_GetPointInt(&ok,cpt,ctx) ; if (!ok) break ;
					if (colMax < 10 || colMax > V4IM_BaA_ColMax) { v_Msg(ctx,NULL,"ModArgRange",intmodx,ix,cpt,10,V4IM_BaA_ColMax) ; goto enum_fail ; } ;
					break ;
	      case V4IM_Tag_Recap:	lvlMax = v4im_GetPointInt(&ok,cpt,ctx) ; if (!ok) break ;
					if (lvlMax < 2 || lvlMax > V4IM_BaA_LevelMax) { v_Msg(ctx,NULL,"ModArgRange",intmodx,ix,cpt,2,V4IM_BaA_LevelMax) ; goto enum_fail ; } ;
					break ;
	      case V4IM_Tag_Context:	ENUMACT ; break ;
	      case V4IM_Tag_ContextP:	ENUMACT ; break ;
	      case V4IM_Tag_While:	ENUMACT ; break ;
	      case V4IM_Tag_Do:
	      case V4IM_Tag_QIsct:
	      case V4IM_Tag_List:	tx = V4IM_Tag_Do ; ENUMACT ; break ;
	      case V4IM_Tag_Index:	v4dpi_DimIndexDimId(&ok,ctx,cpt,NULL) ;		/* Check it out before we save it */
					ENUMACT ; break ;
	      case V4IM_Tag_Enum:	if (lne.Count >= V4IM_MaxEnumNest)
					 { v_Msg(ctx,NULL,"EnumMaxNest",intmodx,ix,V4IM_MaxEnumNest,V4IM_Tag_Enum) ; goto enum_fail ; } ;
					lne.Nest[lne.Count].npt = cpt ; lne.Count++ ;
					break ;
	      case V4IM_Tag_First:	ENUMACT ; break ;
	      case V4IM_Tag_Last:	ENUMACT ; lastTag = TRUE ; break ;
	      case V4IM_Tag_If:		ENUMACT ; break ;
	      case V4IM_Tag_IfOnce:	v_Msg(ctx,NULL,"ModTagNYI",intmodx,V4IM_Tag_IfOnce) ; ipt = NULL ; goto enum_fail ;
	      case V4IM_Tag_Id:		if (cpt->Bytes > sizeof idpt) { v_Msg(ctx,NULL,"DoInvIdVal",intmodx,ix,cpt,cpt->PntType) ; ipt = NULL ; goto enum_fail ; } ;
					if (memcmp(cpt,&protoNone,V4PS_Int) == 0) { traceProgress = FALSE ; }
					 else {	memcpy(&idpt,cpt,cpt->Bytes) ;
						v4im_GetPointUC(&ok,id,UCsizeof(id),cpt,ctx) ;
						if (UCempty(id)) traceProgress = FALSE ;		/* If no Id then disable tracing */
					      } ;
					continue ;
	      case V4IM_Tag_Num:	ENUMACT ; enal.Act[enal.Count-1].Counter = v4im_GetPointInt(&ok,cpt,ctx) ; break ;
	      case V4IM_Tag_Skip:	skip = v4im_GetPointInt(&ok,cpt,ctx) ; break ;
	      case V4IM_Tag_Parent:	ONCE(parpt) ; parpt = cpt ; break ;
	      case V4IM_Tag_PIf:	ENUMACT ; pifpt = cpt ; break ;
	      case -V4IM_Tag_Pop:	pop = TRUE ; break ;
	      case V4IM_Tag_AWhile:	ONCE(awpt) ; awpt = cpt ; break ;
	      case V4IM_Tag_Try:	ENUMACT ; break ;
	      case V4IM_Tag_Calc:	if (cpt->PntType == V4DPI_PntType_Int)		/* Are we specifying max number of calcs allowed or a calc value? */
					 { calcMax = v4im_GetPointInt(&ok,cpt,ctx) ; if (!ok) break ;
					   if (calcMax < 2 || calcMax > V4IM_BaA_CalcMax) { v_Msg(ctx,NULL,"ModArgRange",intmodx,ix,cpt,2,V4IM_BaA_CalcMax) ; goto enum_fail ; } ;
					 } else { ENUMACT ; } ;
					break ;
	      case V4IM_Tag_Every:	ONCEU(every) ; every = v4im_GetPointInt(&ok,cpt,ctx) ; ; break ;
	      case V4IM_Tag_Until:	ENUMACT ; break ;
	      case V4IM_Tag_Then:	ONCE(thenpt) ; thenpt = cpt ; break ;
	      case V4IM_Tag_NestRCV:	nestRCV = v4im_GetPointLog(&ok,cpt,ctx) ; break ;
	      case V4IM_Tag_None:	ONCE(nonept) ; nonept = cpt ; break ;
	      case -V4IM_Tag_Prefetch:	
		if (lne.Count != 1) { v_Msg(ctx,ctx->ErrorMsgAux,"ModPrefetch") ; ok = FALSE ; break ; } ;
		if ((ala = v4im_ALA_InitALA(ctx,NULL,lne.Nest[lne.Count-1].npt)) == NULL) { ok = FALSE ; break ; } ;
		break ;
	      case V4IM_Tag_XML:
		switch (v4imu_XMLSTART(ctx,&xml,ctx->Frame[ctx->FrameCnt - 1].DataStreamFileX,cpt,TRUE,intmodx,NULL))
		 { default:			goto enum_fail ;
		   case XMLSTART_None:		break ;
		   case XMLSTART_Normal:	break ;
		   case XMLSTART_Defer:		v_Msg(ctx,NULL,"XMLDeferInv",intmodx) ; goto enum_fail ;
		 } ;
		break ;
	      case V4IM_Tag_Sum:
		 ENUMACT
		 break ;
	      case V4IM_Tag_By:
	      case V4IM_Tag_Reverse:
		return(v4im_DoSort(ctx,respnt,argpnts,argcnt,intmodx)) ;
	      case V4IM_Tag_Before:
	      case V4IM_Tag_Begin:
	      case V4IM_Tag_End:
	      case V4IM_Tag_After:
#ifdef NEWBAFSTUFF
		if (baf == NULL)
		 { frameidbaf = v4ctx_FramePush(ctx,NULL) ; v4ctx_FrameBaASet(ctx,nestRCV,lvlMax,colMax,calcMax) ; baf = v4ctx_FrameBaAInfo(ctx) ; } ;
#else
		if (baf == NULL)
		 { frameidbaf = v4ctx_FramePush(ctx,NULL) ; v4ctx_FrameBaASet(ctx,nestRCV) ; baf = v4ctx_FrameBaAInfo(ctx) ; } ;
#endif
		switch (tx)
		 { case V4IM_Tag_Before:	tx = V4IM_BaA_CondBefore ; break ;
		   case V4IM_Tag_Begin:		tx = V4IM_BaA_CondBegin ; break ;
		   case V4IM_Tag_End:		tx = V4IM_BaA_CondEnd1 ; break ;
		   case V4IM_Tag_After:		tx = V4IM_BaA_CondAfter ; break ;
		 } ;
		v4im_BaAParse(ctx,baf,intmodx,ix,cpt,tx,&ok) ;
		break ;
	    } ;
	 } ;
	if (!ok) { v_Msg(ctx,NULL,"ModInvArg",intmodx,ix-1) ; goto enum_fail ; } ;
	if (pifpt != NULL && parpt == NULL) { v_Msg(ctx,NULL,"TallyTagWithTag",intmodx,V4IM_Tag_PIf,V4IM_Tag_Parent) ; goto enum_fail ; } ;
	if (pifpt == NULL && parpt != NULL)
	 { v_Msg(ctx,NULL,"TallyTagWthTag2",intmodx,V4IM_Tag_Parent,V4IM_Tag_PIf,V4IM_Tag_Context) ; goto enum_fail ; } ;
	if (lne.Count > 0)
	 { if (lastTag || traceProgress)
	    { totalPnts = 1 ;
	      for(ix=0;ix<lne.Count;ix++)
	       { COUNTER size ;
	         lp = v4im_VerifyList(NULL,ctx,ipt=lne.Nest[ix].npt,intmodx) ;
	         if (lp == NULL) { v_Msg(ctx,NULL,"ModFailed2",intmodx) ; goto enum_fail ; } ;
	         size = SIZEofLIST(lp) ; if (size < 0) size = 0 ;
	         totalPnts *= size ;			/* Build up total number of points, if at any point we don't know size then force to zero */
	       } ;
	      if (gpi->traceProgressMin > 0)		/* If we only want to trace if minimum number of points then check and maybe disable */
	       { if (totalPnts > 0 && totalPnts < gpi->traceProgressMin) traceProgress = 0 ; } ;
	    } ;
	   for(ix=0;ix<lne.Count;ix++)
	    { lne.Nest[ix].lIndex = (ix == 0 ? 0 : UNUSED) ; } ;
	 } else { lp = NULL ; } ;
	frameid = v4ctx_FramePush(ctx,NULL) ;		/* Start new context frame */
	if (baf != NULL)
	 { if (!v4im_BaATest(ctx,baf,&spnt,V4IM_BaA_CondBegin,0,intmodx)) return(NULL) ; } ;
	if (lastTag)				/* Need to figure out the last point */
	 { if (totalPnts <= 0)
	    { v_Msg(ctx,UCTBUF1,"*EnumLastDis",intmodx,V4IM_Tag_Last) ; vout_UCText(VOUT_Warn,0,UCTBUF1) ;
	      lastTag = FALSE ;			/* Disable handling of Last::xxx tags */
	    } ;
	 } ;
//x	for(pntX=1;pntX<=maxNum;pntX++)				/* Loop thru each point in list */
	for(pntX=1;;pntX++)				/* Loop thru each point in list */
	 { 
	   if (pop && pntX > 1)					/* If Pop? then pop frame & repush to reset context */
	    { if (!v4ctx_FramePop(ctx,frameid,NULL)) { v_Msg(ctx,NULL,"ModCtxPopFrame",intmodx,frameid) ; goto enum_fail ; } ; frameid = v4ctx_FramePush(ctx,NULL) ; } ;
	   if (every != UNUSED)				/* If doing Every::n */
	    { tpt = &oldpif ; INITLP(tpt,lpev,Dim_List)
	      if (pntX == 1 && lne.Count > 0)		/* Have list - if first time the init */
	       { lp = v4im_VerifyList(NULL,ctx,ipt=lne.Nest[nx].npt,intmodx) ;
		 if (lp == NULL) { v_Msg(ctx,NULL,"ModInvArgList2",intmodx,ipt) ; goto enum_fail ; } ;
		 lne.Nest[nx].lp = lp ;
	       } ;
	      if (lp != NULL)				/* Got a list */
	       { for(j=1;j<=every;j++)			/* Have list - append next "every" to lpev */
	          { if ((ic = v4l_ListPoint_Value(ctx,lp,j+pntX-1,&isctbuf)) <= 0) { break ; } ;
		    if (!v4l_ListPoint_Modify(ctx,lpev,V4L_ListAction_Append,&isctbuf,0)) { v_Msg(ctx,NULL,"LPModFail",intmodx) ; goto enum_fail ; } ;
		  } ;
		 if (ic == LISTVALERR)
		  { v_Msg(ctx,NULL,"ListGetErr1",intmodx,j,argpnts[1]) ; goto enum_fail ; } ;
		 if (j == 1) break ;
	       } else
	       { intPNT(&spnt) ;
	         for(j=1;j<=every;j++)			/* Have Enum(Num::nnn) - make integer list of next subset */
	          { spnt.Value.IntVal = j + pntX - 1 ;
		    if (!v4l_ListPoint_Modify(ctx,lpev,V4L_ListAction_Append,&spnt,0)) { v_Msg(ctx,NULL,"LPModFail",intmodx) ; goto enum_fail ; } ;
		  } ;
	       } ;
	      pntX += (every - 1) ;
	      ENDLP(tpt,lpev)
#ifndef NEWQUOTE
	      QUOTE(&oldpif) ;
#endif
	      if (!v4ctx_FrameAddDim(ctx,0,&oldpif,0,0)) { v_Msg(ctx,NULL,"CtxAddFail",intmodx) ; goto enum_fail ; } ;
	      CLEARCACHE
	    } ;
	   if (lne.Count > 0 && every == UNUSED)
	    { for(nx=lne.Count-1;nx>=0;nx--)
	       { P vlpnt ;
	         if (lne.Nest[nx].lIndex < 0 && nx > 0) continue ;
		 lp = lne.Nest[nx].lp ; lx = ++lne.Nest[nx].lIndex ;		/* Determine next list & position */


		 if (lx == 1)							/* First time? then init list */
		  { lp = v4im_VerifyList(&vlpnt,ctx,ipt=lne.Nest[nx].npt,intmodx) ;
		    if (lp == NULL) { v_Msg(ctx,NULL,"ModInvArgList2",intmodx,ipt) ; goto enum_fail ; } ;
		    lne.Nest[nx].lp = lp ;
		    if (traceProgress && nx == 0 && lne.Nest[0].lIndex == 1)
		     { totalPnts = SIZEofLIST(lp) ;					/* Output trace on first time */
		       if (totalPnts > 1000)
		        { v_Msg(ctx,UCTBUF2,"*TraceEnum",intmodx,id,totalPnts) ; vout_UCText(VOUT_Progress,0,UCTBUF2) ;  }
			else if (totalPnts < 0)
			 { v_Msg(ctx,UCTBUF2,"*TraceEnum2",intmodx,id) ; vout_UCText(VOUT_Progress,0,UCTBUF2) ; } ;
		     } ;
		  } ;

	         if ((ic=v4l_ListPoint_Value(ctx,lp,lx,&isctbuf)) <= 0)	/* Grab the point */
		  { if (ic == LISTVALERR)
		   { v_Msg(ctx,NULL,"ListGetErr1",intmodx,lx,argpnts[1]) ; goto enum_fail ; } ;
		    if (nx == 0)
		     goto end_enum_loop ;					/* If failed & top level then done */
		    continue ;							/* Otherwise pop up level */
		  } ;
		 if (skip > 0) { skip-- ; goto enum_continue ; } ;		/* Want to skip first n points */
/*		 If point is isct or special then evaluate */
//VEH091115 - But don't evaluate it if also have Shell::dim - in this case through the 'raw' point into shell
		 if ((isctbuf.PntType == V4DPI_PntType_Isct || isctbuf.PntType == V4DPI_PntType_Special) && resdim == UNUSED)
		  { ipt = v4dpi_IsctEval(&ptbuf,&isctbuf,ctx,V4DPI_EM_EvalQuote,NULL,NULL) ; }
		  else { ipt = &isctbuf ; } ;
		 if (ipt == NULL)
		  { v_Msg(ctx,NULL,"ModArgEval2",intmodx,&isctbuf) ; goto enum_fail ; } ;
		 if (nx == lne.Count - 1) break ;				/* If lowest level drop out & continue Enum() */
		 if (ic != 2)							/* Add point to context */
		  { 
		    if (!v4ctx_FrameAddDim(ctx,0,ipt,0,0)) { v_Msg(ctx,NULL,"CtxAddFail",intmodx) ; goto enum_fail ; } ;
		    CLEARCACHE
		  } ;
		 lne.Nest[nx+1].lIndex = 0 ;					/* Set next lower level to "begin-of-list" */
		 nx += 2 ;							/* Advance to lower element (for(;;) will subtract 1) */
	       } ;
	      if (baf != NULL)
	       { baf->CurLevel = UNUSED ; baf->CurCol = 0 ;
	         if (!v4im_BaATest(ctx,baf,ipt,V4IM_BaA_CondBefore,pntX,intmodx)) { goto enum_fail2 ; } ;
	       } ;
	      if (resdim > 0)
	       { if (!v4ctx_FrameAddDim(ctx,0,ipt,(resdim == ipt->Dim ? 0 :	resdim),0)) goto enumctx_fail ;/* Add point as dummy point */
	       } else
	       { if (ic != 2)
	          { 
		    FASTCTXADD(ipt,1) ;
	          } ;
	       } ;
#ifdef NEWBAFSTUFF
	      if (baf != NULL)
	       { baf->CurCol = 0 ;
	         if (!v4im_BaATest(ctx,baf,ipt,V4IM_BaA_CondAfter,pntX,intmodx))
		  { goto enum_fail2 ; } ;
	         if (baf->CurLevel != UNUSED)
	          { for(k=baf->CurLevel-1;k<baf->baaLevelMax;k++)		/* Clear out the subtotals */
		     { memset(baf->ccTot[k],0,(sizeof(baf->ccTot[0]->colCalc[0]) * (baf->baaCalcMax + baf->baaColMax))) ; } ;
	          } ;
	       } ;
	    } ;
#else
	      if (baf != NULL)
	       { baf->CurCol = 0 ;
	         if (!v4im_BaATest(ctx,baf,ipt,V4IM_BaA_CondAfter,pntX,intmodx))
		  { goto enum_fail2 ; } ;
	         if (baf->CurLevel != UNUSED)
	          { for(j=0;j<V4IM_BaA_ColMax;j++)		/* Clear out the subtotals */
	             { for(k=baf->CurLevel-1;k<V4IM_BaA_LevelMax;k++)
		        { baf->Col[j].Count[k] = 0 ; baf->Col[j].SubTotals[k] = 0 ; baf->Col[j].fSubTotals[k] = 0 ; } ;
		     } ;
	            for(j=0;j<V4IM_BaA_CalcMax;j++)		/* Clear out the subtotals */
	             { for(k=baf->CurLevel-1;k<V4IM_BaA_LevelMax;k++)
		        { baf->Calc[j].Count[k] = 0 ; baf->Calc[j].SubTotals[k] = 0 ; /* baf->Calc[j].fSubTotals[k] = 0 ; */ } ;
		     } ;
	          } ;
	       } ;
	    } ;
#endif
	   if (gpi->PointMax > 0 && pntX > gpi->PointMax)
	    { v_Msg(ctx,UCTBUF2,"*TraceQuit",pntX-1) ; vout_UCText(VOUT_Trace,0,UCTBUF2) ; break ; } ;
	  for(first=FALSE,enalX=0;enalX<enal.Count;enalX++)			/* Go for any order-dependent extended actions */
	   { switch(enal.Act[enalX].Tag)
	      { case V4IM_Tag_Context:
		   if (enal.Act[enalX].pt->ForceEval) ipt->ForceEval = TRUE ;
		   if (enal.Act[enalX].pt->PntType == V4DPI_PntType_List)
		    { lpctx = v4im_VerifyList(NULL,ctx,enal.Act[enalX].pt,intmodx) ;
		      for(sx=1;;sx++)
		       { if (v4l_ListPoint_Value(ctx,lpctx,sx,&spnt) <= 0) break ;
		         ipt = v4dpi_IsctEval(&ptbuf,&spnt,ctx,V4DPI_EM_EvalQuote,NULL,NULL) ;
		         if (ipt == NULL) break ;
		         if (!v4ctx_FrameAddDim(ctx,0,ipt,0,0)) goto enumctx_fail ; CLEARCACHE
		       } ;
		    } else
		    { ipt = v4dpi_IsctEval(&ptbuf,enal.Act[enalX].pt,ctx,V4DPI_EM_EvalQuote,NULL,NULL) ;
		      if (ipt == NULL) { v_Msg(ctx,NULL,"TagEvalFail",intmodx,V4IM_Tag_Context,enal.Act[enalX].pt) ; goto enum_fail ; } ;
		      if (memcmp(ipt,&protoSkip,protoSkip.Bytes) == 0) goto enum_continue ;	/* If result is UV4:Skip then skip this point */
		      if (!v4ctx_FrameAddDim(ctx,0,ipt,0,0)) goto enumctx_fail ; CLEARCACHE
		    } ;
		  break ;
	        case V4IM_Tag_ContextP:
		   if (enal.Act[enalX].pt->ForceEval) ipt->ForceEval = TRUE ;
		   ipt = v4dpi_IsctEval(&ptbuf,enal.Act[enalX].pt,ctx,V4DPI_EM_EvalQuote,NULL,NULL) ;
		   if (ipt == NULL) { v_Msg(ctx,NULL,"TagEvalFail",intmodx,V4IM_Tag_ContextP,enal.Act[enalX].pt) ; goto enum_fail ; } ;
		   if (memcmp(ipt,&protoSkip,protoSkip.Bytes) == 0) goto enum_continue ;	/* If result is UV4:Skip then skip this point */
		   if (ipt->PntType == V4DPI_PntType_List)
		    { lpctx = v4im_VerifyList(NULL,ctx,ipt,intmodx) ;
		      for(sx=1;;sx++)
		       { if (v4l_ListPoint_Value(ctx,lpctx,sx,&spnt) <= 0) break ;
		         ipt = v4dpi_IsctEval(&ptbuf,&spnt,ctx,V4DPI_EM_EvalQuote,NULL,NULL) ;
		         if (ipt == NULL) break ;
		         if (!v4ctx_FrameAddDim(ctx,0,ipt,0,0)) goto enumctx_fail ; CLEARCACHE
		       } ;
		    } else
		    { 
		      if (!v4ctx_FrameAddDim(ctx,0,ipt,0,0)) goto enumctx_fail ; CLEARCACHE
		    } ;
		  break ;
		case V4IM_Tag_Calc:
		  lp1 = v4im_VerifyList(NULL,ctx,enal.Act[enalX].pt,intmodx) ; 
		  for(cx=1;lp1!=NULL;cx++)	/* Evaluate each calculation point */
		   { if (v4l_ListPoint_Value(ctx,lp1,cx,&spnt) < 1) break ;
		     ipt = v4dpi_IsctEval(&ptbuf,&spnt,ctx,V4DPI_EM_EvalQuote,NULL,NULL) ;
		     if (ipt == NULL) { v_Msg(ctx,NULL,"TagEvalFail",intmodx,V4IM_Tag_Calc,&spnt) ; goto enum_fail ; } ;
		     if (baf == NULL) continue ;/* If no BaA then continue */
#ifdef NEWBAFSTUFF
		     if (cx < baf->baaCalcMax)
	              { switch (ipt->PntType)			/* Save matrix value */
			 { CASEofINT
				for(stx=0;stx<baf->baaLevelMax;stx++) { baf->ccTot[stx]->colCalc[baf->baaColMax+cx-1].dblSubTotal += ipt->Value.IntVal ; } ;
				break ;
			   case V4DPI_PntType_Real:	/* Have to play games because RealVal may not be (double) aligned */
				GETREAL(dnum,ipt) ;
				for(stx=0;stx<baf->baaLevelMax;stx++) { baf->ccTot[stx]->colCalc[baf->baaColMax+cx-1].dblSubTotal += dnum ; } ;
				break ;
			 } ;
		      } ;
#else
		     if (cx < V4IM_BaA_CalcMax)
	              { switch (ipt->PntType)			/* Save matrix value */
			 { CASEofINT
				for(stx=0;stx<V4IM_BaA_LevelMax;stx++) { baf->Calc[cx-1].SubTotals[stx] += ipt->Value.IntVal ; } ;
				break ;
			   case V4DPI_PntType_Real:	/* Have to play games because RealVal may not be (double) aligned */
				GETREAL(dnum,ipt) ;
				for(stx=0;stx<V4IM_BaA_LevelMax;stx++) { baf->Calc[cx-1].SubTotals[stx] += dnum ; } ;
				break ;
			 } ;
		      } ;
#endif
		   } ;
		  break ;
		case V4IM_Tag_First:
		  if (enal.Act[enalX].notFirst) continue ;
		  first = TRUE ; enal.Act[enalX].notFirst = TRUE ; goto do_entry ;
	        case V4IM_Tag_Last:
		  if (pntX != totalPnts) continue ;
		  goto do_entry ;
	        case V4IM_Tag_Do:
		  if (first) continue ;
		  if (lastTag ? (pntX == totalPnts) : FALSE) continue ;	/* Skip last point if Last:: tag given */
do_entry:	  ipt = enal.Act[enalX].pt ;
		  if (ipt->PntType == V4DPI_PntType_List)
		   { lp1 = ALIGNLP(&ipt->Value) ;
		     for(j=1;v4l_ListPoint_Value(ctx,lp1,j,&isctbuf) > 0;j++)	/* Loop thru each point in list */
		      { ipt = v4dpi_IsctEval(respnt,&isctbuf,ctx,V4DPI_EM_EvalQuote,NULL,NULL) ;
		        if (ipt == NULL) { v_Msg(ctx,NULL,"ModArgEval2",intmodx,&isctbuf) ; goto enum_fail ; } ;
			if (ipt->PntType == V4DPI_PntType_TagVal) { if (v4im_DoEnum_CheckTags(respnt,ipt,(P *)&idpt,pntX)) goto end_enum_loop ; } ;
		      } ;
		   } else
		   { P *tpt = ipt ;
		     ipt = v4dpi_IsctEval(respnt,ipt,ctx,V4DPI_EM_EvalQuote,NULL,NULL) ;
		     if (ipt == NULL) {  v_Msg(ctx,NULL,"ModArgEval2",intmodx,tpt) ; goto enum_fail ; } ;
		     if (ipt->PntType == V4DPI_PntType_TagVal)
		      { if (v4im_DoEnum_CheckTags(respnt,ipt,(P *)&idpt,pntX)) goto end_enum_loop ; } ;
		   } ;
		  continue ;
		case V4IM_Tag_Index:
		  tpt = &ptbuf ;
		  { struct V4DPI__DimInfo *di ; INDEX startIndex ; DIMID dimId = v4dpi_DimIndexDimId(&ok,ctx,enal.Act[enalX].pt,&startIndex) ; DIMINFO(di,ctx,dimId) ;
		    intPNTv(tpt,(startIndex + (++enal.Act[enalX].Counter) - 1)) ; tpt->Dim = dimId ; tpt->PntType = di->PointType ;
		  }
		  if (!v4ctx_FrameAddDim(ctx,0,tpt,0,0)) goto enumctx_fail ;
		  break ;
	        case V4IM_Tag_IfOnce:
	        case V4IM_Tag_If:
		  FASTISCTEVAL(enal.Act[enalX].pt,ipt,&ptbuf) ;
		  if (ipt == NULL) { v_Msg(ctx,NULL,"TagEvalFail",intmodx,V4IM_Tag_If,enal.Act[enalX].pt) ; goto enum_fail ; } ;
		  if (thenpt != NULL)				/* Have If/Then/Else ? */
		   { if (ipt->Value.IntVal > 0)
	              { ipt = v4dpi_IsctEval(respnt,thenpt,ctx,V4DPI_EM_EvalQuote,NULL,NULL) ;
			if (!v4ctx_FramePop(ctx,frameid,NULL)) { v_Msg(ctx,NULL,"ModCtxPopFrame",intmodx,frameid) ; goto enum_fail ; } ; frameid = UNUSED ;
			if (ipt == NULL) { v_Msg(ctx,NULL,"TagEvalFail",intmodx,V4IM_Tag_Then,thenpt) ; goto enum_fail ; } ;
//#ifdef WANTMYSQL
///*			If we are interrupting a mySQL fetch then make sure to spin through the remaining records otherwise we get the infamous error 2014 */
//			if (lp->ListType == V4L_ListType_XDBGet)
//			 { struct V4L__ListXDBGet *log ;
//			   log = (struct V4L__ListXDBGet *)&lp->Buffer[0] ;
//			   if (XDBGETDBACCESS(log->xdbId) == XDBMYSQL)
//			    { INDEX sx ;
//			      for(sx=1,ok=TRUE;ok&&sx>0;)
//			       { sx = v4mysql_Fetch(ctx,log->xdbId,V4ODBC_FetchNext,&ok,0,&spnt) ; } ;
//			    } ;
//			 } ;
//#endif
			if (lp != NULL) v4l_ListClose(ctx,lp) ;			/* Make sure we release any resources associated with the list */
			return(ipt) ;
		      } ;
		   } ;
		  if (ipt->Value.IntVal <= 0) goto enum_continue ;		/* FALSE = continue with next point */
		  break ;
		case V4IM_Tag_Num:
		  if ((enal.Act[enalX].Counter--) <= 0) goto end_enum_loop ;	/* If ran out of Counter then want to kick out */
		  break ;
		case V4IM_Tag_PIf:
		  ipt = v4dpi_IsctEval(&ptbuf,parpt,ctx,V4DPI_EM_EvalQuote,NULL,NULL) ;
		  if (ipt == NULL) { v_Msg(ctx,NULL,"TagEvalFail",intmodx,V4IM_Tag_Parent,parpt) ; goto enum_fail ; } ;
		  if (memcmp(&oldpar,ipt,ipt->Bytes) != 0)		/* Parent different? */
		   { memcpy(&oldpar,ipt,ipt->Bytes) ;		/* Copy for next go-around */
		     if (!v4ctx_FrameAddDim(ctx,0,ipt,0,0)) goto enumctx_fail ;
		     CLEARCACHE
		     ipt = v4dpi_IsctEval(&oldpif,enal.Act[enalX].pt,ctx,V4DPI_EM_EvalQuote,NULL,NULL) ;
		     if (ipt == NULL) { v_Msg(ctx,NULL,"TagEvalFail",intmodx,V4IM_Tag_PIf,pifpt) ; goto enum_fail ; } ;
		   } else { ipt = &oldpif ; } ;
		  if (ipt->Value.IntVal <= 0) goto enum_continue ;		/* If FALSE then try next point */
		  break ;
	        case V4IM_Tag_Sum:
		  lp1 = (enal.Act[enalX].pt->PntType == V4DPI_PntType_List ? v4im_VerifyList(NULL,ctx,enal.Act[enalX].pt,intmodx) : NULL) ; 
		  for(sx=1;;sx++)
		   { if (lp1 != NULL)
		      { if (v4l_ListPoint_Value(ctx,lp1,sx,&spnt) <= 0) break ; ipt = &spnt ; }
		      else { ipt = enal.Act[enalX].pt ; } ;
		     tpt = v4dpi_IsctEval(&ptbuf,ipt,ctx,V4DPI_EM_EvalQuote,NULL,NULL) ;
		     if (tpt == NULL) { v_Msg(ctx,NULL,"TagEvalFail",intmodx,V4IM_Tag_Sum,ipt) ; goto enum_fail ; } ;
		     if (enal.Act[enalX].Counter == 0)					/* If first time then just add to context */
		      { if (!v4ctx_FrameAddDim(ctx,0,tpt,0,0)) goto enumctx_fail ; CLEARCACHE
		      } else
		      { DIMVAL(ipt,ctx,tpt->Dim) ;		/* Get current dimension value */
			dnum = (ipt == NULL ? 0 : v4im_GetPointDbl(&ok,ipt,ctx)) ;
			if (!ok) { v_Msg(ctx,NULL,"ModInvArg2",intmodx,ipt) ; goto enum_fail ; } ;
			dnum += v4im_GetPointDbl(&ok,tpt,ctx) ;	/* Add current value to context value */
			if (!ok) { v_Msg(ctx,NULL,"ModInvArg2",intmodx,ipt) ; goto enum_fail ; } ;
			v4im_SetPointValue(ctx,tpt,dnum) ;
			if (!v4ctx_FrameAddDim(ctx,0,tpt,0,0)) goto enumctx_fail ;		/* Add updated point back into context */
		      } ;
		     if (lp1 == NULL) break ;			/* Don't have list */
		   } ;
		  enal.Act[enalX].Counter ++ ;
		  break ;
		case V4IM_Tag_Try:
		  ipt = v4dpi_IsctEval(respnt,enal.Act[enalX].pt,ctx,V4DPI_EM_EvalQuote,NULL,NULL) ;
		  if (ipt != NULL) { if (!v4ctx_FramePop(ctx,frameid,NULL)) { v_Msg(ctx,NULL,"ModCtxPopFrame",intmodx,frameid) ; goto enum_fail ; } ; return(ipt) ; } ;
		  continue ;
		case V4IM_Tag_While:
		  ipt = v4dpi_IsctEval(&ptbuf,enal.Act[enalX].pt,ctx,V4DPI_EM_EvalQuote,NULL,NULL) ;
		  if (ipt == NULL) { v_Msg(ctx,NULL,"TagEvalFail",intmodx,V4IM_Tag_While,enal.Act[enalX].pt) ; goto enum_fail ; } ;
//x		  if (ipt->Value.IntVal <= 0) { pntX = maxNum ; goto enum_continue ; } ;		/* FALSE = quit now! */
		  if (ipt->Value.IntVal <= 0) { goto end_enum_loop ; } ;				/* FALSE = quit now! */
		  break ;
		case V4IM_Tag_Until:
		  ipt = v4dpi_IsctEval(&ptbuf,enal.Act[enalX].pt,ctx,V4DPI_EM_EvalQuote,NULL,NULL) ;
		  if (ipt == NULL) { v_Msg(ctx,NULL,"TagEvalFail",intmodx,V4IM_Tag_While,enal.Act[enalX].pt) ; goto enum_fail ; } ;
//x		  if (ipt->Value.IntVal > 0) { pntX = maxNum ; goto enum_continue ; } ;		/* FALSE = quit now! */
		  if (ipt->Value.IntVal <= 0) { goto end_enum_loop ; } ;				/* FALSE = quit now! */
		  break ;
	      } ;
	   } ;



	   selected++ ;
//x	   if (rowdim > 0)						/* If got a Index dimension then update */
//x	    { tpt = &ptbuf ; intPNTv(tpt,selected) ; tpt->Dim = rowdim ;
//x	      if (!v4ctx_FrameAddDim(ctx,0,tpt,0,0)) goto enumctx_fail ;
//x	    } ;
//x	   if (sumpt != NULL)
//x	    { for(sx=1;;sx++)
//x	       { if (lpsum != NULL)
//x	          { if (v4l_ListPoint_Value(ctx,lpsum,sx,&spnt) <= 0) break ; ipt = &spnt ; }
//x		  else { ipt = sumpt ; } ;
//x	         tpt = v4dpi_IsctEval(&ptbuf,ipt,ctx,V4DPI_EM_EvalQuote,NULL,NULL) ;
//x		  if (tpt == NULL) { v_Msg(ctx,NULL,"TagEvalFail",intmodx,V4IM_Tag_Sum,ipt) ; goto enum_fail ; } ;
//x		 if (firstsum)					/* If first time then just add to context */
//x		  { if (!v4ctx_FrameAddDim(ctx,0,tpt,0,0)) goto enumctx_fail ; CLEARCACHE
//x		  } else
//x		  { DIMVAL(ipt,ctx,tpt->Dim) ;		/* Get current dimension value */
//x		    ok = TRUE ; dnum = (ipt == NULL ? 0 : v4im_GetPointDbl(&ok,ipt,ctx)) ;
//x		    if (!ok) { v_Msg(ctx,NULL,"ModInvArg2",intmodx,ipt) ; goto enum_fail ; } ;
//x		    dnum += v4im_GetPointDbl(&ok,tpt,ctx) ;	/* Add current value to context value */
//x		    if (!ok) { v_Msg(ctx,NULL,"ModInvArg2",intmodx,tpt) ; goto enum_fail ; } ;
//x		    v4im_SetPointValue(ctx,tpt,dnum) ;
//x		    if (!v4ctx_FrameAddDim(ctx,0,tpt,0,0)) goto enumctx_fail ;		/* Add updated point back into context */
//x		  } ;
//x	         if (lpsum == NULL) break ;			/* Don't have list */
//x	       } ;
//x	      firstsum = FALSE ;
//x	    } ;
	   if (calcpt == NULL) { calclp = NULL ; }
	    else { calclp = v4im_VerifyList(NULL,ctx,calcpt,intmodx) ;
		   if (calclp == NULL) { v_Msg(ctx,NULL,"TagValue",intmodx,V4IM_Tag_Calc,calcpt) ; goto enum_fail ; } ;
		 } ;
	   for(cx=1;calclp!=NULL;cx++)	/* Evaluate each calculation point */
	    { if (v4l_ListPoint_Value(ctx,calclp,cx,&spnt) < 1) break ;
	      ipt = v4dpi_IsctEval(&ptbuf,&spnt,ctx,V4DPI_EM_EvalQuote,NULL,NULL) ;
	      if (ipt == NULL) { v_Msg(ctx,NULL,"TagEvalFail",intmodx,V4IM_Tag_Calc,&spnt) ; goto enum_fail ; } ;
	      if (baf == NULL) continue ;/* If no BaA then continue */
#ifdef NEWBAFSTUFF
	      if (cx < baf->baaCalcMax)
               { switch (ipt->PntType)			/* Save matrix value */
		  {
	            CASEofINT
			for(stx=0;stx<baf->baaLevelMax;stx++)
			 {baf->ccTot[stx]->colCalc[baf->baaColMax+cx-1].dblSubTotal += ipt->Value.IntVal ; } ;
			break ;
		    case V4DPI_PntType_Real:	/* Have to play games because RealVal may not be (double) aligned */
			GETREAL(dnum,ipt) ;
			for(stx=0;stx<baf->baaLevelMax;stx++)
			 { baf->ccTot[stx]->colCalc[baf->baaColMax+cx-1].dblSubTotal += dnum ; } ;
			break ;
		  } ;
	       } ;
#else
	      if (cx < V4IM_BaA_CalcMax)
               { switch (ipt->PntType)			/* Save matrix value */
		  {
	            CASEofINT
			for(stx=0;stx<V4IM_BaA_LevelMax;stx++)
			 { baf->Calc[cx-1].SubTotals[stx] += ipt->Value.IntVal ; } ;
			break ;
		    case V4DPI_PntType_Real:	/* Have to play games because RealVal may not be (double) aligned */
			GETREAL(dnum,ipt) ;
			for(stx=0;stx<V4IM_BaA_LevelMax;stx++)
			 { baf->Calc[cx-1].SubTotals[stx] += dnum ; } ;
			break ;
		  } ;
	       } ;
#endif
	    } ;
enum_continue: continue ;
	 } ;
end_enum_loop:
	if (lp != NULL) v4l_ListClose(ctx,lp) ;			/* Release any resources associated with this list */
	if (!v4imu_XMLEND(ctx,&xml,ctx->Frame[ctx->FrameCnt - 1].DataStreamFileX,intmodx,NULL)) goto enum_fail ;
	if (ala != NULL) { v4im_ALA_Cleanup(ala) ; ala = NULL ; } ;
//x	if ((selected == 0 || trypt != NULL) && nonept != NULL)
	if ((selected == 0) && nonept != NULL)
	 { ipt = v4dpi_IsctEval(respnt,nonept,ctx,V4DPI_EM_EvalQuote,NULL,NULL) ;
	   if (!v4ctx_FramePop(ctx,frameid,NULL)) { v_Msg(ctx,NULL,"ModCtxPopFrame",intmodx,frameid) ; goto enum_fail ; } ; frameid = UNUSED ;
	   if (ipt == NULL) { v_Msg(ctx,NULL,"TagEvalFail",intmodx,V4IM_Tag_None,nonept) ; goto enum_fail ; } ;
	   return(ipt) ;
	 } ;
	if (baf != NULL && selected > 0)			/* Maybe do final recaps */
	 { baf->CurCol = 0 ;
	   if (!v4im_BaATest(ctx,baf,&spnt,V4IM_BaA_CondEnd1,0,intmodx)) return(NULL) ;
	 } ;
	if (!v4ctx_FramePop(ctx,frameid,NULL)) { v_Msg(ctx,NULL,"ModCtxPopFrame",intmodx,frameid) ; goto enum_fail ; } ; frameid = UNUSED ;
	if (baf != NULL && frameidbaf != UNUSED)		/* Maybe do grand totals */
	 { baf->CurCol = 0 ;
	   if (!v4im_BaATest(ctx,baf,&spnt,V4IM_BaA_CondEnd2,0,intmodx)) return(NULL) ;
	   if (!v4ctx_FramePop(ctx,frameidbaf,NULL)) { v_Msg(ctx,NULL,"ModCtxPopFrame",intmodx,frameid) ; goto enum_fail ; } ; frameidbaf = UNUSED ;			/* Pop off frame context */
	 } ;
/*	If we drop out of here with Try:xxx then return fail */
//x	if(trypt != NULL) { v_Msg(ctx,NULL,"EnumNoTry",intmodx,V4IM_Tag_Try) ; goto enum_fail ; } ;
	if(thenpt != NULL)
	 { v_Msg(ctx,NULL,"EnumNoPoints",intmodx) ; goto enum_fail ; } ;
	if (respnt->Bytes == 0)
	 { if (selected == 0) { memcpy(respnt,&Log_False,Log_False.Bytes) ; }
	    else { v_Msg(ctx,NULL,"EnumNoPoints",intmodx) ; goto enum_fail ; } ;
	 } ;
	if (traceProgress && cpt != NULL && (selected == 0 ? pntX > 1000 : selected > 1000))
	 { v_Msg(ctx,UCTBUF2,"*TraceEnum6",intmodx,id,selected) ; vout_UCText(VOUT_Progress,0,UCTBUF2) ;  } ;
	return(respnt) ;
enum_fail:
	REGISTER_ERROR(0) ;
enum_fail2:
	if (frameid != UNUSED) v4ctx_FramePop(ctx,frameid,NULL) ;
	if (ala != NULL) v4im_ALA_Cleanup(ala) ;
	if (frameidbaf != UNUSED) v4ctx_FramePop(ctx,frameidbaf,NULL) ;
	return(NULL) ;
enumctx_fail:
	v_Msg(ctx,NULL,"CtxAddFail",intmodx) ; goto enum_fail ;

}

/*	v4im_DoEnum_CheckTags - Checks Enum Do::xxx result for Continue/End Tags	*/
/*	Call:	res = v4im_DoEnum_CheckTags( respnt, tagpt, idpt, index )
	  where res = TRUE if calling Enum() is to exit, FALSE if to continue,
		respnt is updated with appropriate value if res = TRUE,
		tagpt is tag point to be checked,
		idpt is Enum()'s current Id:xxx point,
		index is Enum()'s current iteration index				*/

LOGICAL v4im_DoEnum_CheckTags(respnt,tagpt,idpt,index)
  P *respnt, *tagpt, *idpt ;
  int index ;
{
  struct V4DPI__TagVal *tv ;				/* Structure of a tagged value */

	tv = (struct V4DPI__TagVal *)&tagpt->Value ;
	switch (tv->TagVal & V4DPI_TagFlag_MaskOut)
	 { default:			return(FALSE) ;
	   case V4IM_Tag_End:
		if (tagpt->ForceEval)			/* Quit & return index within first argument */
		 { intPNTv(respnt,index) ; return(TRUE) ; } ;
		if (idpt->Bytes > 0 && memcmp(idpt,&tv->TagPt,idpt->Bytes) == 0) /* Got End::name which matches Enum()'s Id::name */
		 { intPNTv(respnt,index) ; return(TRUE) ; } ;
		memcpy(respnt,tagpt,tagpt->Bytes) ;	/* Got another End:xxx - exit with that value */
		return(TRUE) ;
	   case V4IM_Tag_Continue:
		if (tagpt->ForceEval)		/* Really should not get this but quit & return index within first argument */
		 { intPNTv(respnt,index) ; return(TRUE) ; } ;
		if (idpt->Bytes > 0 && memcmp(idpt,&tv->TagPt,idpt->Bytes) == 0) /* Got Continue::name which matches Enum()'s Id::name */
		 { intPNTv(respnt,index) ; return(FALSE) ; } ;
		memcpy(respnt,tagpt,tagpt->Bytes) ;	/* Got another Continue:xxx - exit with that value */
		return(TRUE) ;
	 } ;

}


struct V4DPI__Point *v4im_DoEnumCL(ctx,respnt,argpnts,argcnt,intmodx,trace,lzlli,retok)
  struct V4C__Context *ctx ;
  P *respnt ;						/* Ptr for result */
  INTMODX intmodx ;
  P *argpnts[] ;
  COUNTER argcnt ; VTRACE trace ; LOGICAL *retok ;
  struct V4L__ListLazyInfo *lzlli ;			/* Pointer to "current" argument block (ONLY if from lazy list) */
{ P *cpt, *ipt ; P isctbuf, ptbuf ;
  struct V4L__ListPoint *lp,*lpres ;
  struct V4DPI__DimInfo *di ;
  struct V4L__ListLazyInfo lliFirst ;			/* Structure for "first" argument block */
  struct V4L__ListLazyInfo *lli ;			/* Pointer to "current" argument block */
  struct V4IM__BaA *baf ;
  LOGICAL ok,lazyeval,first,last,loop ; INDEX ax, ix ; FRAMEID frameid ; ETYPE tag ;

/*	If called from lazy list then by-pass argument parsing, etc. */
	frameid = UNUSED ;
	if (lzlli != NULL)
	 { lli = (lzlli->lliCur != NULL ? lzlli->lliCur : lzlli) ;	/* Link to "current" lli if we have a chain of them */
	   goto lazy_list_entry ;
	 } ;

	lli = &lliFirst ; memset(lli,0,sizeof *lli) ;	/* Init first argument block */

	ix=1 ;						/* Init the argument index variable */

init_lli:						/* Here to init current (or next) lli structure */
	lli->shellDim = UNUSED ; lli->DimId = Dim_List ; lazyeval = FALSE ;
	lli->startIndex = 1 ;				/* Starting index for enumerating list (used for Lazy lists) */
	lli->needInitEnumList = TRUE ;

	memset(lli->gotTag,FALSE,V4IM_Tag_MaxValue) ;

	for(ok=TRUE;ok&&ix<=argcnt;ix++)
	 { 
	   if (argpnts[ix]->PntType != V4DPI_PntType_TagVal && (ix == 1 || argpnts[ix]->Dim != Dim_Dim))
	    { if (ix == 1)
	       { 
#ifdef NEWQUOTE
//VEH100607 SHOULD NOT HAVE TO DO UNQUOTEPTR AFTER WE MAKE THIS LIVE (change stuff like dotdottolist=<@xxxx> to just <xxx>)
		 lli->elpt = (ISQUOTED(argpnts[ix]) ? UNQUOTEPTR(argpnts[ix]) : argpnts[ix]) ;
#else
	         lli->elpt = argpnts[ix] ;
#endif
	       } else
	       { if (lli->actCount >= V4L_LLInfo_actMAX) { v_Msg(ctx,NULL,"TallyMaxAction",intmodx,V4L_LLInfo_actMAX) ; goto enumcl_fail ; } ;
		 lli->Act[lli->actCount].Tag = V4IM_Tag_Do ; lli->Act[lli->actCount].pt = argpnts[ix] ;
		 lli->actCount++ ; lli->gotValue = TRUE ; lli->gotTag[V4IM_Tag_Do] = TRUE ; continue ;
	       } ;
	      continue ;
	    } ;
	   switch (tag = v4im_CheckPtArgNew(ctx,argpnts[ix],&cpt,NULL))
	    { default:			v_Msg(ctx,NULL,"TagBadUse",intmodx) ; goto enumcl_fail ;
	      case V4IM_Tag_Unk:	v_Msg(ctx,NULL,"TagUnknown",intmodx) ; goto enumcl_fail ;

	      case V4IM_Tag_QIsct:
	      case V4IM_Tag_Do:
	      case V4IM_Tag_List:
		if (lli->actCount >= V4L_LLInfo_actMAX) { v_Msg(ctx,NULL,"TallyMaxAction",intmodx,V4L_LLInfo_actMAX) ; goto enumcl_fail ; } ;
		lli->Act[lli->actCount].Tag = V4IM_Tag_Do ; lli->Act[lli->actCount].pt = cpt ;
		lli->actCount++ ; lli->gotValue = TRUE ; lli->gotTag[V4IM_Tag_Do] = TRUE ; break ;

	      case V4IM_Tag_Enum:
		if (lli->elpt == NULL) { lli->elpt = cpt ; break ; } ;
/*		Already have enumerating point - create another lli & link to it */
		{ struct V4L__ListLazyInfo *nlli ;
		  nlli = v4mm_AllocChunk(sizeof *nlli,TRUE) ; nlli->lliPrior = lli ; lli->lliNext = nlli ;
		  lli = nlli ; lli->elpt = cpt ; 
		  ix++ ; goto init_lli ;
		}

	      case V4IM_Tag_Num:
	      case V4IM_Tag_Ignore:
	      case V4IM_Tag_While:
	      case V4IM_Tag_Until:
	      case V4IM_Tag_Index:
	      case V4IM_Tag_First:
	      case V4IM_Tag_None:
	      case V4IM_Tag_Last:
	      case V4IM_Tag_Parent:
	      case V4IM_Tag_PIf:
	      case V4IM_Tag_Sum:
	      case V4IM_Tag_IfOnce:
	      case V4IM_Tag_If:
	      case V4IM_Tag_Context:
	      case V4IM_Tag_ContextP:
		if (lli->actCount >= V4L_LLInfo_actMAX) { v_Msg(ctx,NULL,"TallyMaxAction",intmodx,V4L_LLInfo_actMAX) ; goto enumcl_fail ; } ;
		lli->Act[lli->actCount].Tag = tag ; lli->Act[lli->actCount].pt = cpt ;
		if (tag == V4IM_Tag_Num) { lli->Act[lli->actCount].Counter = v4im_GetPointInt(&ok,cpt,ctx) ; } ;	/* Set Counter to max number allowed */
		lli->actCount++ ; break ;
	      case V4IM_Tag_Dim:
		DIMINFO(di,ctx,cpt->Value.IntVal) ;
		if (di->PointType != V4DPI_PntType_List)
		 { v_Msg(ctx,NULL,"ModArgPntType2",intmodx,ix,di->PointType,V4DPI_PntType_List) ; goto enumcl_fail ; } ;
		lli->DimId = di->DimId ; break ;

	      case V4IM_Tag_Shell:	lli->shellDim = v4dpi_DimShellDimId(&ok,ctx,cpt) ; break ;
	      case -V4IM_Tag_Evaluate:	lli->evalResVal = TRUE ; break ;
	      case -V4IM_Tag_Pop:	lli->popFrame = TRUE ; break ;
	      case -V4IM_Tag_SetOf:	lli->setOf = TRUE ; break ;
	      case -V4IM_Tag_Lazy:	lazyeval = TRUE ; break ;

	      case -V4IM_Tag_NoError:	lli->aggNoError = TRUE ; break ;
	      case V4IM_Tag_Agg:
		if (cpt->PntType == V4DPI_PntType_List)
		 { int lx ;
		   lp = v4im_VerifyList(NULL,ctx,cpt,intmodx) ;
		   for(lx=1;v4l_ListPoint_Value(ctx,lp,lx,&isctbuf)>0;lx++)
		    { v4im_GetPointUC(&ok,UCTBUF1,V_FileName_Max,&isctbuf,ctx) ; if (!ok) break ;
		      lli->Area[lli->aggCount].areaName = v4mm_AllocUC(V_FileName_Max) ;
		      UCstrcpy(lli->Area[lli->aggCount].areaName,UCTBUF1) ;
		      lli->aggCount++ ;
		    } ;
		 } else
		 { if (lli->aggCount >= V4L_LLInfo_areaMAX) { v_Msg(ctx,NULL,"V4MaxAggs",intmodx,V4L_LLInfo_areaMAX) ; goto enumcl_fail ; } ;
		   v4im_GetPointUC(&ok,UCTBUF1,V_FileName_Max,cpt,ctx) ;
		   lli->Area[lli->aggCount].areaName = v4mm_AllocUC(V_FileName_Max) ;
		   UCstrcpy(lli->Area[lli->aggCount].areaName,UCTBUF1) ;
		   lli->aggCount++ ;
		 } ;
		lli->needAggLoad = TRUE ; break ;	

	      case V4IM_Tag_Column:
		baf = (struct V4IM__BaA *)v4ctx_FrameBaAInfo(ctx) ;	/* See if we have before/after tests to do */
		if (baf != NULL) baf->CurCol = v4im_GetPointInt(&ok,cpt,ctx) - 1 ;
		break ;
	    } ; lli->gotTag[tag] = lli->actCount ;		/* gotTag = index of action for that tag + 1 */
	 } ;
	if (!ok) { v_Msg(ctx,NULL,"ModInvArg",intmodx,ix-1) ; goto enumcl_fail ; } ;

	if (lli->gotTag[V4IM_Tag_PIf] && !lli->gotTag[V4IM_Tag_Parent])
	 { v_Msg(ctx,NULL,"TallyTagWithTag",intmodx,V4IM_Tag_PIf,V4IM_Tag_Parent) ; goto enumcl_fail ; } ;
	if (!lli->gotTag[V4IM_Tag_PIf] && lli->gotTag[V4IM_Tag_Parent])
	 { v_Msg(ctx,NULL,"TallyTagWthTag2",intmodx,V4IM_Tag_Parent,V4IM_Tag_PIf,V4IM_Tag_Context) ; goto enumcl_fail ; } ;

	lli = &lliFirst ;				/* Link back to first lli */


/*	If doing lazy-evaluation then just return "list" that triggers point-by-point evaluation */
	if (lazyeval)
	 { struct V4L__ListLazy *vll ; int i ;
	   if (lli->popFrame) { v_Msg(ctx,NULL,"ModOnlyOne",intmodx,-V4IM_Tag_Pop,-V4IM_Tag_Lazy) ; goto enumcl_fail ; } ;
/*	   Before setting up final lazy list we have to copy all argument pointers into permanent locations */
#define SAVEPT(pt) { P *tpt ; tpt = pt ; pt = v4mm_AllocChunk(tpt->Bytes,FALSE) ; memcpy(pt,tpt,tpt->Bytes) ; }
	   for(;lli!=NULL;lli=lli->lliNext)
	    { SAVEPT(lli->elpt) ; for(i=0;i<lli->actCount;i++) SAVEPT(lli->Act[i].pt) ;
	    } ; lli = &lliFirst ;
	   ZPH(respnt) ; respnt->Dim = Dim_List ; respnt->PntType = V4DPI_PntType_List ;
	   respnt->Bytes = V4DPI_PointHdr_Bytes + sizeof(*lp) ;
	   INITLP(respnt,lp,Dim_List) ; lp->ListType = V4L_ListType_Lazy ;
	   vll = (struct V4L__ListLazy *)&lp->Buffer ; lp->Bytes = (char *)&lp->Buffer - (char *)lp + sizeof *vll ;
	   { struct V4L__ListLazyInfo *tlli ;
	     tlli = (struct V4L__ListLazyInfo *)v4mm_AllocChunk(sizeof *tlli,FALSE) ; COPYPTR(vll->lli,tlli) ;
	     memcpy(tlli,lli,sizeof *lli) ;	/* Copy temp lli into allocated space */
	     if (tlli->lliNext != NULL)		/* If this has "next" link, then have to set next's "prior" link back to this newly allocated lli */
	      tlli->lliNext->lliPrior = tlli ;
	   }
	   ENDLP(respnt,lp) ;
	   if (retok != NULL) *retok = TRUE ;
	   return(respnt) ;
	 } ;

/*	Only do this chunk on first lli */
	if (lli->lliPrior == NULL)
	 { frameid = v4ctx_FramePush(ctx,NULL) ;		/* Start new context frame */
	   DIMINFO(di,ctx,lli->DimId) ;
	   ZPH(respnt) ; respnt->Dim = di->DimId ; respnt->PntType = di->PointType ;
	   INITLP(respnt,lpres,lli->DimId)			/* lpres = resulting list linked to respnt */
	 } ;

/*	Jump to this point if called via lazy list */
lazy_list_entry:

/*	If we got any Aggs to load in then do it now */
	if (lli->needAggLoad)
	 { for(ax=0;ax<lli->aggCount;ax++)
	    { struct V4IS__ParControlBlk pcb ; int i ;
	      memset(&pcb,0,sizeof pcb) ; strcpy(pcb.V3name,"v4agg") ; pcb.DfltDataMode = V4IS_PCB_DataMode_Auto ; pcb.AccessMode = -1 ;
	      pcb.OpenMode = V4IS_PCB_OM_Read ; UCstrcpy(pcb.UCFileName,lli->Area[ax].areaName) ; pcb.AreaFlags = V4IS_PCB_OF_NoError ;
//v_Msg(ctx,UCTBUF1,"@*--lazy load area=%1U, ax=%2d\n",pcb.UCFileName,ax) ; vout_UCText(VOUT_Trace,0,UCTBUF1) ;
	      if (!v4is_Open(&pcb,NULL,ctx->ErrorMsgAux))
	       { if (lli->aggNoError) continue ; v_Msg(ctx,NULL,"ModFailed2",intmodx) ; goto enumcl_fail ; } ;
	      if (pcb.AreaId == V4IS_AreaId_SeqOnly)
	       { if (lli->aggNoError) continue ; v_Msg(ctx,NULL,"V4NotValidAgg",intmodx,pcb.UCFileName) ; goto enumcl_fail ; } ;
	      for(i=0;i<gpi->AreaAggCount;i++)
	       { if (gpi->AreaAgg[i].pcb == NULL) continue ; if (UCstrcmp(pcb.UCFileName,gpi->AreaAgg[i].pcb->UCFileName) == 0) break ; } ;
	      if (i >= gpi->AreaAggCount)			/* Got a new area? */
	       { if ((lli->Area[ax].AggUId = v4im_AggLoadArea(ctx,&pcb,NULL)) == UNUSED) { v_Msg(ctx,NULL,"V4AggLoadFail",intmodx,pcb.UCFileName) ; goto enumcl_fail ; } ;
	       } else { v4is_Close(&pcb) ; } ;		/* Already got the aggregate - close file */
	    } ;
	   lli->needAggLoad = FALSE ;
	 } ;

/*	Figure out our enumerating list from lli->elpt */
	if (lli->needInitEnumList)
	 { if (lli->elpt != NULL)
	    { 
//VEH120322 - Not sure why this was here, don't think we want it any more
//	      if (lli->elpt->Dim == Dim_Dim && lli->elpt->Grouping == V4DPI_Grouping_Single)		/* Got Enum::Dim:xxx */
//	       { ipt = v4dpi_DimUniqueToList(&lli->elptbuf,ctx,lli->elpt->Value.IntVal,Dim_List,lli->elpt,FALSE) ;
//	         if (ipt == NULL) { v_Msg(ctx,NULL,"ModInvArg",intmodx,1) ; goto enumcl_fail ; } ;
//	         lli->elpt = ipt ;
//	       } ;
	      lli->lp = v4im_VerifyList(&lli->elptbuf,ctx,lli->elpt,intmodx) ;
	      if (lli->lp == NULL) { v_Msg(ctx,NULL,"ModInvArgList",intmodx,1) ; goto enumcl_fail ; } ;
	      if (lli->gotTag[V4IM_Tag_Last])				/* Need to figure out the last point */
	       { lli->lastNum =  SIZEofLIST(lli->lp) ;
	         if (lli->lastNum <= 0) { v_Msg(ctx,UCTBUF1,"*EnumLastDis",intmodx,V4IM_Tag_Last) ; vout_UCText(VOUT_Warn,0,UCTBUF1) ; } ;
	       } ;
	    } else				/* No explicit point given - better have While::xxx or Num::nnn arguments */
	    { lli->lp = NULL ;
	    } ;
	   lli->needInitEnumList = FALSE ;
	 } ;


/*	Main enumeration loop */
	for(ix=lli->startIndex,loop=TRUE;loop;ix++,lli->startIndex++)
	 { P *ept ;						/* ept = Current enumerating point (also injected into ctx) */
	   if (lli->popFrame && ix > 1)				/* If Pop? then pop frame & repush to reset context */
	    { if (!v4ctx_FramePop(ctx,frameid,NULL)) { v_Msg(ctx,NULL,"ModCtxPopFrame",intmodx,frameid) ; goto enumcl_fail ; } ; frameid = v4ctx_FramePush(ctx,NULL) ; } ;
	   if (lli->lp != NULL)
	    { INDEX res = v4l_ListPoint_Value(ctx,lli->lp,ix,&isctbuf) ;
	      if (res == 0) break ;
	      if (res == LISTVALERR)
	       { v_Msg(ctx,NULL,"ListGetErr1",intmodx,ix,lli->elpt) ; goto enumcl_fail ; } ;
	      if (isctbuf.PntType == V4DPI_PntType_Isct && lli->shellDim == UNUSED)		/* If an ISCT then evaluate it */
	       { ept = v4dpi_IsctEval(&ptbuf,&isctbuf,ctx,V4DPI_EM_EvalQuote,NULL,NULL) ; }
	       else { ept = &isctbuf ; } ;
	      if (ept == NULL) { v_Msg(ctx,NULL,"ModArgEval2",intmodx,&isctbuf) ; goto enumcl_fail ; } ;
	      if (lli->shellDim != UNUSED)
	       { if (!v4ctx_FrameAddDim(ctx,0,ept,(lli->shellDim != ept->Dim ? lli->shellDim : 0),0)) goto enumclctx_fail ;
	       } else
	       { if (ept->PntType != V4DPI_PntType_Isct)
	          { FASTCTXADD(ept,1) ; } ; 
	       } ;
	      XDBSAVEROW(ept)
	      CLEARCACHE
	    } ;
	   for(first=FALSE,last=FALSE,ax=0;ax<lli->actCount;ax++)			/* Go for any order-dependent extended actions */
	    { switch(lli->Act[ax].Tag)
	       { 
	         case V4IM_Tag_Context:
		   if (lli->Act[ax].pt->PntType == V4DPI_PntType_List)
		    { P ctxptbuf, lpptbuf ; int sx ; struct V4L__ListPoint *lpctx ;
		      lpctx = v4im_VerifyList(&ctxptbuf,ctx,lli->Act[ax].pt,intmodx) ;
		      for(sx=1;;sx++)
		       { if (v4l_ListPoint_Value(ctx,lpctx,sx,&lpptbuf) <= 0) break ;
		         ipt = v4dpi_IsctEval(&isctbuf,&lpptbuf,ctx,V4DPI_EM_EvalQuote,NULL,NULL) ;
			 if (ipt == NULL) { v_Msg(ctx,NULL,"TagEvalFail",intmodx,V4IM_Tag_Context,&lpptbuf) ; goto enumcl_fail ; } ;
		         if (!v4ctx_FrameAddDim(ctx,0,ipt,0,0)) goto enumcl_fail ; CLEARCACHE
		       } ;
		    } else
		    { ipt = v4dpi_IsctEval(&isctbuf,lli->Act[ax].pt,ctx,V4DPI_EM_EvalQuote,NULL,NULL) ;
		      if (ipt == NULL) { v_Msg(ctx,NULL,"TagEvalFail",intmodx,V4IM_Tag_Context,lli->Act[ax].pt) ; goto enumcl_fail ; } ;
		      if (memcmp(ipt,&protoSkip,protoSkip.Bytes) == 0) goto enumcl_continue ;	/* If result is UV4:Skip then skip this point */
		      if (ipt != NULL) { if (lli->Act[ax].pt->ForceEval) ipt->ForceEval = TRUE ; if (!v4ctx_FrameAddDim(ctx,0,ipt,0,0)) goto enumcl_fail ; CLEARCACHE } ;
		    } ;
		  if (ipt == NULL) { v_Msg(ctx,NULL,"TagEvalFail",intmodx,V4IM_Tag_Context,lli->Act[ax].pt) ; goto enumcl_fail ; } ;
		  break ;
	         case V4IM_Tag_ContextP:
		   ipt = v4dpi_IsctEval(&isctbuf,lli->Act[ax].pt,ctx,V4DPI_EM_EvalQuote,NULL,NULL) ;
		   if (ipt == NULL) { v_Msg(ctx,NULL,"TagEvalFail",intmodx,V4IM_Tag_ContextP,lli->Act[ax].pt) ; goto enumcl_fail ; } ;
		   if (memcmp(ipt,&protoSkip,protoSkip.Bytes) == 0) goto enumcl_continue ;	/* If result is UV4:Skip then skip this point */
		   if (ipt->PntType == V4DPI_PntType_List)
		    { P ctxptbuf, lpptbuf ; int sx ; struct V4L__ListPoint *lpctx ;
		      lpctx = v4im_VerifyList(&ctxptbuf,ctx,ipt,intmodx) ;
		      for(sx=1;;sx++)
		       { if (v4l_ListPoint_Value(ctx,lpctx,sx,&lpptbuf) <= 0) break ;
		         ipt = v4dpi_IsctEval(&isctbuf,&lpptbuf,ctx,V4DPI_EM_EvalQuote,NULL,NULL) ;
		          if (ipt == NULL) { v_Msg(ctx,NULL,"TagEvalFail",intmodx,V4IM_Tag_ContextP,lli->Act[ax].pt) ; goto enumcl_fail ; } ;
		         if (!v4ctx_FrameAddDim(ctx,0,ipt,0,0)) goto enumcl_fail ; CLEARCACHE
		       } ;
		    } else
		    { if (lli->Act[ax].pt->ForceEval) ipt->ForceEval = TRUE ; if (!v4ctx_FrameAddDim(ctx,0,ipt,0,0)) goto enumcl_fail ; CLEARCACHE
		    } ;
		  break ;
		 case V4IM_Tag_First:
		  if (++lli->Act[ax].Counter != 1) continue ;
		  first = TRUE ; goto do_entry ;
		 case V4IM_Tag_Last:
		  if (ix != lli->lastNum) continue ;
		  last = TRUE ; goto do_entry ;
	         case V4IM_Tag_Do:
		  if (first || last) continue ;
do_entry:	  ipt = lli->Act[ax].pt ;
		  if (ipt->PntType == V4DPI_PntType_List)
		   { struct V4L__ListPoint *lp1 = ALIGNLP(&ipt->Value) ; int lx ;
		     for(lx=1;v4l_ListPoint_Value(ctx,lp1,lx,&isctbuf) > 0;lx++)	/* Loop thru each point in list */
		      { ipt = v4dpi_IsctEval((lzlli!=NULL ? respnt : &ptbuf),&isctbuf,ctx,V4DPI_EM_EvalQuote,NULL,NULL) ;
		        if (ipt == NULL) { v_Msg(ctx,NULL,"ModArgEval2",intmodx,&isctbuf) ; goto enumcl_fail ; } ;
		        if (lli->ignpt != NULL) { if (memcmp(lli->ignpt,ipt,lli->ignpt->Bytes) == 0) continue ; } ;
/*			Add point to result list OR immediately return "next" point if called via lazy list */
			if (lzlli != NULL) { if (retok != NULL) *retok = TRUE ; lli->startIndex++ ; return(ipt) ; } ;
		        if (!v4l_ListPoint_Modify(ctx,lpres,((di->Flags & V4DPI_DimInfo_IsSet)||lli->setOf ? V4L_ListAction_AppendUnique : V4L_ListAction_Append),ipt,0)) { v_Msg(ctx,NULL,"LPModFail",intmodx) ; goto enumcl_fail ; } ;
		      } ;
		   } else
		   { P *tpt = ipt ;
		     ipt = v4dpi_IsctEval((lzlli!=NULL ? respnt : &ptbuf),ipt,ctx,V4DPI_EM_EvalQuote,NULL,NULL) ;
		     if (ipt == NULL) {  v_Msg(ctx,NULL,"ModArgEval2",intmodx,tpt) ; goto enumcl_fail ; } ;
		     if (lli->ignpt != NULL) { if (memcmp(lli->ignpt,ipt,lli->ignpt->Bytes) == 0) continue ; } ;
/*		     Add point to result list OR immediately return "next" point if called via lazy list */
		     lli->resNum++ ;
		     if (lzlli != NULL) { if (retok != NULL) *retok = TRUE ; lli->startIndex++ ; return(ipt) ; } ;
		     if (!v4l_ListPoint_Modify(ctx,lpres,((di->Flags & V4DPI_DimInfo_IsSet)||lli->setOf ? V4L_ListAction_AppendUnique : V4L_ListAction_Append),ipt,0)) { v_Msg(ctx,NULL,"LPModFail",intmodx) ; goto enumcl_fail ; } ;
		   } ;
		  continue ;
		 case V4IM_Tag_Index:
		  ipt = &ptbuf ;
		  { struct V4DPI__DimInfo *di ; INDEX startIndex ; DIMID dimId = v4dpi_DimIndexDimId(&ok,ctx,lli->Act[ax].pt,&startIndex) ; DIMINFO(di,ctx,dimId) ; 
		    intPNTv(ipt,(startIndex + (++lli->Act[ax].Counter) - 1)) ; ipt->Dim = dimId ; ipt->PntType = di->PointType ;
		  }
		  if (!v4ctx_FrameAddDim(ctx,0,ipt,0,0)) goto enumcl_fail ;
		  break ;
	         case V4IM_Tag_IfOnce:
		  ipt = v4dpi_IsctEval(&ptbuf,lli->Act[ax].pt,ctx,V4DPI_EM_EvalQuote,NULL,NULL) ;
		  if (ipt == NULL) { v_Msg(ctx,NULL,"TagEvalFail",intmodx,V4IM_Tag_If,lli->Act[ax].pt) ; goto enumcl_fail ; } ;
		  if (ipt->Value.IntVal <= 0) goto enumcl_continue ;		/* FALSE = continue with next point */
		  loop = FALSE ;						/* Continue this point but then quit */
		  break ;
	         case V4IM_Tag_If:
		  ipt = v4dpi_IsctEval(&ptbuf,lli->Act[ax].pt,ctx,V4DPI_EM_EvalQuote,NULL,NULL) ;
		  if (ipt == NULL) { v_Msg(ctx,NULL,"TagEvalFail",intmodx,V4IM_Tag_If,lli->Act[ax].pt) ; goto enumcl_fail ; } ;
		  if (ipt->Value.IntVal <= 0) goto enumcl_continue ;		/* FALSE = continue with next point */
		  break ;
		 case V4IM_Tag_Ignore:
		  lli->ignpt = lli->Act[ax].pt ;
		  break ;
		 case V4IM_Tag_Num:
		  --lli->Act[ax].Counter ;
		  if (lli->Act[ax].Counter < 0) { loop = FALSE ; goto enumcl_continue ; } ;		/* If our counter goes negative then all done */
		  break ;
		 case V4IM_Tag_Parent:
		  break ;			/* Don't do anything here - see PIf */
		 case V4IM_Tag_PIf:
		  { P *parpt = lli->Act[lli->gotTag[V4IM_Tag_Parent]-1].pt ;
		    ipt = v4dpi_IsctEval(&ptbuf,parpt,ctx,V4DPI_EM_EvalQuote,NULL,NULL) ;
		    if (ipt == NULL) { v_Msg(ctx,NULL,"TagEvalFail",intmodx,V4IM_Tag_Parent,parpt) ; goto enumcl_fail ; } ;
		    if (memcmp(&lli->oldparptbuf,ipt,ipt->Bytes) != 0)		/* Parent different? */
		     { memcpy(&lli->oldparptbuf,ipt,ipt->Bytes) ;		/* Copy for next go-around */
		       if (!v4ctx_FrameAddDim(ctx,0,ipt,0,0)) goto enumcl_fail ;
		       CLEARCACHE
		       ipt = v4dpi_IsctEval(&ptbuf,lli->Act[ax].pt,ctx,V4DPI_EM_EvalQuote,NULL,NULL) ;
		       if (ipt == NULL) { v_Msg(ctx,NULL,"TagEvalFail",intmodx,V4IM_Tag_PIf,lli->Act[ax].pt) ; goto enumcl_fail ; } ;
		       lli->oldparptPIfres = ipt->Value.IntVal > 0 ;
		     } ;
		    if (!lli->oldparptPIfres) goto enumcl_continue ;		/* If FALSE then try next point */
		  }
		  break ;
	        case V4IM_Tag_Sum:
		  { struct V4L__ListPoint *lp1 = (lli->Act[ax].pt->PntType == V4DPI_PntType_List ? v4im_VerifyList(NULL,ctx,lli->Act[ax].pt,intmodx) : NULL) ; 
		    int sx ; double dnum ;
		    for(sx=1;;sx++)
		     { if (lp1 != NULL)
		        { if (v4l_ListPoint_Value(ctx,lp1,sx,&ptbuf) <= 0) break ; ipt = &ptbuf ; }
		        else { ipt = lli->Act[ax].pt ; } ;
		       ipt = v4dpi_IsctEval(&ptbuf,ipt,ctx,V4DPI_EM_EvalQuote,NULL,NULL) ;
		       if (ipt == NULL) { v_Msg(ctx,NULL,"TagEvalFail",intmodx,V4IM_Tag_Sum,lli->Act[ax].pt) ; goto enumcl_fail ; } ;
		       if (lli->Act[ax].Counter == 0)					/* If first time then just add to context */
		        { if (!v4ctx_FrameAddDim(ctx,0,ipt,0,0)) goto enumcl_fail ; CLEARCACHE
		        } else
		        { ok = TRUE ; dnum = (ipt == NULL ? 0 : v4im_GetPointDbl(&ok,ipt,ctx)) ;
			  if (!ok) { v_Msg(ctx,NULL,"ModInvArg2",intmodx,ipt) ; goto enumcl_fail ; } ;
			  DIMVAL(ipt,ctx,ipt->Dim) ;		/* Get current dimension value */
			  dnum += v4im_GetPointDbl(&ok,ipt,ctx) ;	/* Add current value to context value */
			  if (!ok) { v_Msg(ctx,NULL,"ModInvArg2",intmodx,ipt) ; goto enumcl_fail ; } ;
			  v4im_SetPointValue(ctx,ipt,dnum) ;
			  if (!v4ctx_FrameAddDim(ctx,0,ipt,0,0)) goto enumcl_fail ;		/* Add updated point back into context */
		        } ;
		       if (lp1 == NULL) break ;			/* Don't have list */
		     } ;
		    lli->Act[ax].Counter ++ ;
		  }
		  break ;
		case V4IM_Tag_While:
		  ipt = v4dpi_IsctEval(&ptbuf,lli->Act[ax].pt,ctx,V4DPI_EM_EvalQuote,NULL,NULL) ;
		  if (ipt == NULL) { v_Msg(ctx,NULL,"TagEvalFail",intmodx,V4IM_Tag_While,lli->Act[ax].pt) ; goto enumcl_fail ; } ;
		  if (ipt->Value.IntVal <= 0)
		   { loop = FALSE ; goto enumcl_continue ; } ;		/* FALSE = quit now! */
		  break ;
		case V4IM_Tag_Until:
		  ipt = v4dpi_IsctEval(&ptbuf,lli->Act[ax].pt,ctx,V4DPI_EM_EvalQuote,NULL,NULL) ;
		  if (ipt == NULL) { v_Msg(ctx,NULL,"TagEvalFail",intmodx,V4IM_Tag_While,lli->Act[ax].pt) ; goto enumcl_fail ; } ;
		  if (ipt->Value.IntVal > 0) { loop = FALSE ; goto enumcl_continue ; } ;	/* FALSE = quit now! */
		  break ;
	      } ;
	    } ;
	   if (!lli->gotValue)		/* If no explicit result point to append then append enumerating point */
	    { if (lli->ignpt != NULL ? (memcmp(lli->ignpt,ept,lli->ignpt->Bytes) != 0) : TRUE)
	       { lli->resNum++ ;
	         if (lzlli != NULL) { if (retok != NULL) *retok = TRUE ; lli->startIndex++ ; return(ept) ; } ;
	         if (!v4l_ListPoint_Modify(ctx,lpres,((di->Flags & V4DPI_DimInfo_IsSet)||lli->setOf ? V4L_ListAction_AppendUnique : V4L_ListAction_Append),ept,0)) { v_Msg(ctx,NULL,"LPModFail",intmodx) ; goto enumcl_fail ; } ;
	       } ;
	    } ;

enumcl_continue:
	   continue ;

	 } ;
/*	If we broke out early (loop = FALSE) then be sure & release any list resources */
	if (!loop && lli->lp != NULL)
	 v4l_ListClose(ctx,lli->lp) ;
/*	If we got any Aggs to load then unload & close now */
	for(ax=0;ax<lli->aggCount;ax++)
	 { int i ;
	   for(i=0;i<gpi->AreaAggCount;i++)
	    { if (lli->Area[ax].AggUId != gpi->AreaAgg[i].AggUId) continue ;
	      v4ctx_AreaClose(ctx,gpi->AreaAgg[i].pcb->AreaId) ; break ;
	    } ;
	 } ;

/*	If not points returned/appened and got None::xxx point then evaluate it */
	if (lli->resNum == 0)
	 { for(ax=0;ax<lli->actCount;ax++)			/* Look for any None::xxx tags */
	    { if (lli->Act[ax].Tag != V4IM_Tag_None) continue ;
	      ipt = v4dpi_IsctEval(&ptbuf,lli->Act[ax].pt,ctx,V4DPI_EM_EvalQuote,NULL,NULL) ;
	      if (ipt == NULL) { v_Msg(ctx,NULL,"TagEvalFail",intmodx,V4IM_Tag_None,lli->Act[ax].pt) ; goto enumcl_fail ; } ;
	    } ;
	 } ;

/*	If have link to "next" lli then link to it & continue */
	if (lli->lliNext != NULL)
	 { struct V4L__ListLazyInfo *tlli ;
	   lli = lli->lliNext ;				/* Link to next one */
/*	   Link tlli back thru all prior lli's and set lliCur to the new current lli */
	   for(tlli=lli->lliPrior;tlli!=NULL;tlli=tlli->lliPrior) { tlli->lliCur = lli ; } ;
	   goto lazy_list_entry ;
	 } ;

/*	If lazy list then return NULL to indicate end-of-list */
	if (lzlli != NULL) { if (retok != NULL) *retok = TRUE ; return(NULL) ; } ;

	ENDLP(respnt,lpres)
	if (!v4ctx_FramePop(ctx,frameid,NULL)) { v_Msg(ctx,NULL,"ModCtxPopFrame",intmodx,frameid) ; goto enumcl_fail ; } ;
	if (retok != NULL) *retok = TRUE ;
	return(respnt) ;				/* Remember cpt == respnt */
enumcl_fail:
	if (frameid != UNUSED) v4ctx_FramePop(ctx,frameid,NULL) ;
	if (retok != NULL) *retok = FALSE ;
	REGISTER_ERROR(0) ; return(NULL) ;

enumclctx_fail:
	v_Msg(ctx,NULL,"CtxAddFail",intmodx) ; goto enumcl_fail ;
}

#ifndef DISABLETALLYM
struct V4DPI__Point *v4im_DoTallyM(ctx,respnt,argpnts,argcnt,intmodx,trace,isct)
  struct V4C__Context *ctx ;
  P *respnt ;						/* Ptr for result */
  INTMODX intmodx ;
  P *argpnts[],*isct ;
  COUNTER argcnt ; VTRACE trace ;
{ struct V4L__ListPoint *lp,*alp ;
  P spnt,isctbuf ; P *ipt,*cpt ;
  struct V4IM__TallyMaster *vtm ;
  struct V4IM__TallyEntry *vte ;
  struct V4IM__TallyEntryWith *vtew ;
  struct V4IM_TallyEnumEnvironment *vtee ;
  struct V4DPI__DimInfo *di ;
  FILE *fp ;
  int seqx,bx,px,lx,i,j,k,ok ; char fbuf[256] ; double dnum,dnum2 ;
  UCCHAR dimname[32],fname[128],*ubp ;

	vtm = (struct V4IM__TallyMaster *)v4mm_AllocChunk(sizeof *vtm,TRUE) ;
	vte = (struct V4IM__TallyEntry *)v4mm_AllocChunk(sizeof *vte,TRUE) ;
	vtm->TallyEntryMax = V4IM_TallyHash_Max ;		/* Default number of tally values/combos */
	vtew = NULL ;
	for(ok=TRUE,bx=1,seqx=-1;ok&&bx<=argcnt;bx++)
	 { 
	   switch (v4im_CheckPtArgNew(ctx,argpnts[bx],&cpt,&spnt))
	    { default:			v_Msg(ctx,NULL,"TagBadUse",intmodx) ; goto fail ;
	      case V4IM_Tag_Unk:	v_Msg(ctx,NULL,"TagUnknown",intmodx) ; goto fail ;
	      case V4IM_Tag_Area:	if (cpt->PntType == V4DPI_PntType_List)
					 { alp = v4im_VerifyList(NULL,ctx,cpt,intmodx) ; }
					 else { alp = NULL ; v4im_GetPointFileName(&ok,fname,UCsizeof(fname),cpt,ctx,NULL) ; } ;
					continue ;
	      case V4IM_Tag_List:	break ;
	      case V4IM_Tag_Values:	k = v_CvtToPrime(v4im_GetPointInt(&ok,cpt,ctx)) ;
					vtm->TallyEntryMax = k ;
					continue ;
	    } ;if (!ok) break ;
	   seqx++ ; vtm->Action[seqx].ActionType = UNUSED ;
	   lp = v4im_VerifyList(NULL,ctx,ipt = argpnts[bx],intmodx) ;
	   for(i=1;;i++)
	    { if (v4l_ListPoint_Value(ctx,lp,i,&isctbuf) <= 0) break ;
	      switch (v4im_CheckPtArgNew(ctx,&isctbuf,&ipt,NULL))
	       { default:			v_Msg(ctx,NULL,"TagBadUse",intmodx) ; goto fail ;
	         case V4IM_Tag_Unk:		v_Msg(ctx,NULL,"TagUnknown",intmodx) ; goto fail ;
	         case V4IM_Tag_Bind:
			cpt = (struct V4DPI__Point *)v4mm_AllocChunk(ipt->Bytes,FALSE) ; memcpy(cpt,ipt,ipt->Bytes) ;
			vtm->Action[seqx].p3 = cpt ; break ;
	         case V4IM_Tag_ByList:
			cpt = (struct V4DPI__Point *)v4mm_AllocChunk(ipt->Bytes,FALSE) ; memcpy(cpt,ipt,ipt->Bytes) ;
			vtm->Action[seqx].p4 = cpt ; break ;
		 case V4IM_Tag_Dim:		vtm->Action[seqx].ResDim = ipt->Value.IntVal ; continue ;
 	         case V4IM_Tag_Count:		vtm->Action[seqx].ActionType = V4IM_ActType_Count ; break ;
 	         case V4IM_Tag_Sum:		vtm->Action[seqx].ActionType = V4IM_ActType_Sum ; break ;
	         case V4IM_Tag_Sub:		vtm->Action[seqx].ActionType = V4IM_ActType_Sub ; break ;
	         case V4IM_Tag_Minimum:		vtm->Action[seqx].ActionType = V4IM_ActType_Min ; break ;
	         case V4IM_Tag_Maximum:		vtm->Action[seqx].ActionType = V4IM_ActType_Max ; break ;
	         case V4IM_Tag_StdDev:		vtm->Action[seqx].ActionType = V4IM_ActType_StdDev ; break ;
	         case V4IM_Tag_Average:		vtm->Action[seqx].ActionType = V4IM_ActType_Avg ; break ;
	         case V4IM_Tag_By:		break ;
		 case V4IM_Tag_ByIf:		break ;
	         case V4IM_Tag_If:		break ;
	         case V4IM_Tag_IfOnce:		break ;
	         case V4IM_Tag_IFa:		break ;
	         case V4IM_Tag_IFb:		break ;
	         case V4IM_Tag_IFc:		break ;
	         case -V4IM_Tag_IFa:		break ;
	         case -V4IM_Tag_IFb:		break ;
	         case -V4IM_Tag_IFc:		break ;
	         case V4IM_Tag_Values:		break ;
//VEH040116 May want to implement these at later date
//	         case V4IM_Tag_ListOf:
//	         case V4IM_Tag_SetOf:
//		 case V4IM_Tag_UCount:
//		 case V4IM_Tag_Bits:
//		 case V4IM_Tag_Cache:
//	         case V4IM_Tag_With:
//	         case V4IM_Tag_WBind:
//			sprintf(ctx->ErrorMsg,"%s Tag(%s) not supported",v4im_ModFailStr(intmodx),v4im_LastTagName()) ;
//			goto fail ;
	       } ;
	    } ;
	   if (i == 1) { v_Msg(ctx,NULL,"TallyActionMT",intmodx,bx,argpnts[bx]) ; goto fail ; } ;
	 } ;
	if (!ok) { v_Msg(ctx,NULL,"ModInvArg",intmodx,bx-1) ; goto fail ; } ;
	vtm->teb = (struct V4IM__TallyEntryBuf *)v4mm_AllocChunk(vtm->TallyEntryMax*(sizeof vtm->teb->Entry[0]),TRUE) ;
	for(lx=1;;lx++)				/* Go through each area in area list */
	 { if (alp == NULL)
	    { if (lx > 1) break ;		/* If no list then only go thru once */
	    } else
	    { if (v4l_ListPoint_Value(ctx,alp,lx,&isctbuf) <= 0) break ;
	      ipt = &isctbuf ; v4im_GetPointUC(&ok,fname,UCsizeof(fname),ipt,ctx) ;
	    } ;
	   ubp = v_UCLogicalDecoder(fname,VLOGDECODE_Exists,0,ctx->ErrorMsgAux) ;
	   if (ubp == NULL) { v_Msg(ctx,NULL,"ModFailed2",intmodx) ; goto fail ; } ;
	   if ((fp = UCfopen(ubp,"r")) == NULL) { v_Msg(ctx,NULL,"TallyReadErr",intmodx,errno,ubp) ; goto fail ; } ;
	   if (fgets(fbuf,sizeof fbuf,fp) == NULL) { fclose(fp) ; v_Msg(ctx,NULL,"TallyPreEOF",intmodx,1,fname) ; goto fail ;
	    } ;
	   if (fbuf[0] != 'H') { fclose(fp) ; v_Msg(ctx,NULL,"TallyNoHVP","H",intmodx,fname) ; goto fail ; } ;
	   for(;;)				/* Go thru all C (setup) records in this area file */
	    { if (fgets(fbuf,sizeof fbuf,fp) == NULL) { fclose(fp) ; v_Msg(ctx,NULL,"TallyPreEOF",intmodx,2,fname) ; goto fail ; } ;
	      if (fbuf[0] != 'C') break ;	/* End of setup lines */
	      sscanf(fbuf,"C,%d,%d,%d,%d",&seqx,&i,&j,&k) ;
	      if (vtm->Action[seqx].ActionType != UNUSED ? vtm->Action[seqx].ActionType != k : FALSE)
	       { fclose(fp) ; v_Msg(ctx,NULL,"TallyBadAction",intmodx,seqx+1,fname,intmodx) ; goto fail ; } ;
	      vtm->ActionCount = seqx+1 ;	/* Set action count */
	      vtm->Action[seqx].NumValues = j ; vtm->Action[seqx].NumComboPoints = i ; vtm->Action[seqx].ActionType = k ;
	    } ;
	   for(;;)				/* Go thru V/P records */
	    { 
	      for(px=0;px<vtm->Action[seqx].NumValues;px++)
	       { if (fgets(fbuf,sizeof fbuf,fp) == NULL) { fclose(fp) ; v_Msg(ctx,NULL,"TallyPreEOF",intmodx,3,fname) ; goto fail ; } ;
		 if (fbuf[0] != 'V')
		  { fclose(fp) ;
		    if (fbuf[0] == 'Z') goto endfile ;	/* End of this area, maybe try another */
		    v_Msg(ctx,NULL,"TallyNoHVP",intmodx,"V",fname) ; goto fail ;
		  } ;
		 sscanf(fbuf,"V,%d,%d,%lg,%lg",&seqx,&i,&dnum,&dnum2) ;
		 vte->Entry[px].Count = i ; vte->ActionX = seqx ;
		 v_Msg(ctx,NULL,"@Need to replace TallyM logic with new structure") ; goto fail ;
//		 vte->Entry[px].Sum = dnum ; vte->Entry[px].SumSq = dnum2 ;
	       } ;
	      vte->Offset = (char *)&vte->Entry[vtm->Action[seqx].NumValues] - (char *)vte ;
	      vte->Bytes = vte->Offset ;
	      ipt = (P *)((char *)vte + vte->Offset) ;
	      for(px=0;px<vtm->Action[seqx].NumComboPoints;px++)
	       { if (fgets(fbuf,sizeof fbuf,fp) == NULL) { fclose(fp) ; v_Msg(ctx,NULL,"TallyPreEOF",intmodx,4,fname) ; goto fail ; } ;
		 if (fbuf[0] != 'P')
		  { fclose(fp) ; v_Msg(ctx,NULL,"TallyNoHVP",intmodx,"P",fname) ; goto fail ; } ;
		 UCsscanf(ASCretUC(fbuf),UClit("P,%d,%16s"),&i,&dimname) ;
		 DIMINFO(di,ctx,v4dpi_DimGet(ctx,dimname,DIMREF_IRT)) ;
		 ZPH(ipt) ; ipt->Dim = di->DimId ; ipt->PntType = di->PointType ; ipt->Value.IntVal = i ;
		 ipt->Bytes = V4PS_Int ;
		 ipt = (P *)((char *)ipt + ipt->Bytes) ;	/* Advance to next slot in PointBuf */
	       } ;
	      vte->Bytes = (char *)ipt - (char *)vte ;
	      if (!v4im_TallyEntryInsert(ctx,vtee,vte,NULL,seqx))
	       { v_Msg(ctx,NULL,"TallySubSysFail",intmodx,"TallyEntryInsert") ; goto fail ; } ;
	    } ;
endfile:   continue ;
	 } ;
	for(i=0;i<vtm->ActionCount;i++)
	 { switch (vtm->Action[i].ActionType)
	    { default:						/* Here unless a list */
		if (vtm->Action[i].p3 == NULL)			/* Null if returning a list */
		 { if (vtm->Action[i].p4 != NULL)		/* Make a list of all points we tallied on? */
		    { if (!v4im_TallyMakeByList(ctx,vtm,i,vtm->Action[i].ByIf)) { v_Msg(ctx,NULL,"LPModFail",intmodx) ; goto fail ; } ; } ;
		 } else						/* Here to make bindings */
		 { if (!v4im_TallyMakeBinds(ctx,vtm,i,vtm->Action[i].ByIf))	/* do it */
		    { v_Msg(ctx,NULL,"TallySubSysFail",intmodx,"TallyMakeBinds") ; goto fail ; } ;
		   if (vtm->Action[i].p4 != NULL)		/* Make a list of all points we tallied on? */
		    { if (!v4im_TallyMakeByList(ctx,vtm,i,vtm->Action[i].ByIf)) { v_Msg(ctx,NULL,"LPModFail",intmodx) ; goto fail ; } ; } ;
		 } ;
		break ;
	      case V4IM_ActType_UList:
	      case V4IM_ActType_List:
		if (!v4im_TallyListMake(ctx,vtm,i,vtm->Action[i].ActionType,vtm->Action[i].BindIf))
		 { v_Msg(ctx,NULL,"ModFailed2",intmodx) ; goto fail ; } ;
		if (vtm->Action[i].p4 != NULL)			/* Make a list of all points we tallied on? */
		 { if (!v4im_TallyMakeByList(ctx,vtm,i,vtm->Action[i].ByIf)) { v_Msg(ctx,NULL,"LPModFail",intmodx) ; goto fail ; } ; } ;
		break ;
	      case V4IM_ActType_UCount:
		if (!v4im_TallyUCount(ctx,vtm,i,vtm->Action[i].ActionType))
		 { v_Msg(ctx,NULL,"ModFailed2",intmodx) ; goto fail ; } ;
		if (vtm->Action[i].p4 != NULL)			/* Make a list of all points we tallied on? */
		 { if (!v4im_TallyMakeByList(ctx,vtm,i,vtm->Action[i].ByIf)) { v_Msg(ctx,NULL,"LPModFail",intmodx) ; goto fail ; } ; } ;
		break ;
	    } ;
	 } ;
	ipt = (P *)&Log_True ;
tallym_end:
	if (vtm != NULL)
	 { if (vtm->teb != NULL) v4mm_FreeChunk(vtm->teb) ; v4mm_FreeChunk(vtm) ; } ;
	if (vte != NULL) v4mm_FreeChunk(vte) ; if (vtew != NULL) v4mm_FreeChunk(vtew) ;
	if (ipt != NULL) { return(ipt) ; } else { RETURNFAILURE ; } ;

fail:	REGISTER_ERROR(0) ; ipt = NULL ; goto tallym_end ;
}
#endif

struct V4DPI__Point *v4im_DoTally(ctx,respnt,argpnts,argcnt,intmodx,trace,isct)
  struct V4C__Context *ctx ;
  struct V4DPI__Point *respnt ;
  INTMODX intmodx ;
  P *argpnts[],*isct ;
  COUNTER argcnt ; VTRACE trace ;
{ struct V4L__ListPoint *lp ;
  struct V4IM__TallyMaster *vtm ;
  struct V4IM__TallyEntry *vte ;
// struct V4DPI__Point_IntMix *pim ;
  struct V4IM__TallyBuf *obuf ;
  struct V4DPI__DimInfo *di ;
  struct V4IM__AggLookAhead *ala = NULL ;
  struct V4IM_TallyEnumEnvironment vtee ;
  P *cpt,*tpt,*ipt ; P ptbuf,isctbuf,oldpar ;
  union lcl__SleezyUnionToMapPointerToInt {
    int intpart ;
    char *ptrpart ;
   } lsupi ;
//  struct lcl__index {
//    int Count ;
//    int Begin[20],End[20] ;
//   } lix ;
  int i,k,argx,bx,seqx,frameid,ok,firstsum,skip,gotlist ; UCCHAR utb[512],id[32+1] ; LOGICAL showProgress ;

#define CL if (gotlist) goto misplaced_global_tag ;
	vtm = (struct V4IM__TallyMaster *)v4mm_AllocChunk(sizeof *vtm,TRUE) ;
#ifdef V4ENABLEMULTITHREADS
	vtm->Threads = -1 ;					/* Default to single thread */
#endif
	vte = (struct V4IM__TallyEntry *)v4mm_AllocChunk(sizeof *vte + V4IM_TallyEntryValue_Max,TRUE) ;
	vtm->TallyEntryMax = V4IM_TallyHash_Max ;		/* Default number of tally values/combos */
	vtm->indexDimId = UNUSED ; 
	memset(&vtee,0,sizeof vtee) ;
//	lix.Count = UNUSED ;
	ZPH(&oldpar) ; frameid = UNUSED ; gotlist = FALSE ; ok = TRUE ;
	ZUS(id) ; skip = UNUSED ;
	for(bx=2,seqx=-1;ok && bx<=argcnt;bx++)			/* Loop thru each action in Tally() */
	 { 
	   switch (v4im_CheckPtArgNew(ctx,argpnts[bx],&cpt,NULL))
	    { default:			v_Msg(ctx,NULL,"TagBadUse",intmodx) ; goto tally_fail ;
	      case V4IM_Tag_Unk:	v_Msg(ctx,NULL,"TagUnknown",intmodx) ;  goto tally_fail ;
	      case V4IM_Tag_Dim:	vtm->GlobalResDim = cpt->Value.IntVal ; continue ;
	      case V4IM_Tag_Do:
	      	CL ; vtm->dopt = cpt ;
		if (vtm->dopt->PntType != V4DPI_PntType_List) { vtm->lpdo = NULL ; }
	         else { vtm->lpdo = ALIGNLP(&vtm->dopt->Value) ; } ;
		continue ;
	      case V4IM_Tag_Area:	CL ; v4im_GetPointFileName(&ok,utb,UCsizeof(utb),cpt,ctx,NULL) ;
					if (gpi->RestrictionMap & V_Restrict_FileRead) { v_Msg(ctx,NULL,"RestrictMod",intmodx) ; goto tally_fail ; } ;
					if (!v_UCFileOpen(&vtm->UCFile,utb,UCFile_Open_Write,TRUE,ctx->ErrorMsgAux,intmodx))
					 { v_Msg(ctx,NULL,"TallyArea",intmodx,V4IM_Tag_Area,utb) ; goto tally_fail ; } ;
					continue ;
	      case V4IM_Tag_While:	CL ; vtm->GlobalWhile = cpt ; continue ;
	      case V4IM_Tag_AWhile:	CL ; vtm->awpt = cpt ; continue ;
	      case V4IM_Tag_Id:		CL ;
					if (memcmp(cpt,&protoNone,V4PS_Int) == 0) { trace &= ~(V4TRACE_Progress) ; }
					 else { v4im_GetPointUC(&ok,id,UCsizeof(id),cpt,ctx) ; } ;
					continue ;
#ifdef V4_BUILD_SECURITY
	      case V4IM_Tag_Hold:	CL ; vtm->GlobalHold = cpt ; continue ;
#else
	      case V4IM_Tag_Hold:	v_Msg(ctx,NULL,"V4NotThisBuild",intmodx,argpnts[bx]) ; goto tally_fail ;
#endif
	      case V4IM_Tag_Shell:	CL ; vtm->resDim = v4dpi_DimShellDimId(&ok,ctx,cpt) ; continue ;
	      case V4IM_Tag_Count:
		CL ; DIMINFO(di,ctx,cpt->Value.IntVal) ;
		if (di == NULL) { v_Msg(ctx,NULL,"ModArgNotDim",intmodx,bx,argpnts[bx]) ; goto tally_fail ; } ;
		intPNT(&vtm->cntpt) ; vtm->cntpt.Dim = di->DimId ; vtm->wantCount = TRUE ; continue ;
	      case -V4IM_Tag_Prefetch:	
		CL
		if ((ala = v4im_ALA_InitALA(ctx,NULL,argpnts[1])) == NULL) { ok = FALSE ; break ; } ;
		continue ;
#ifdef V4ENABLEMULTITHREADS
	      case -V4IM_Tag_Threads:	vtm->Threads = 0 ; continue ;
	      case V4IM_Tag_Threads:	vtm->Threads = v4im_GetPointInt(&ok,cpt,ctx) ; continue ;
#else
	      case -V4IM_Tag_Threads:		
	      case V4IM_Tag_Threads:	v_Msg(ctx,NULL,"MTNotAvail") ; goto tally_fail ;
#endif
	      case V4IM_Tag_Index:	vtm->indexDimId = v4dpi_DimIndexDimId(&ok,ctx,cpt,&vtm->indexStart) ;
					DIMINFO(di,ctx,vtm->indexDimId) ; vtm->indexPntType = di->PointType ;
					break ;
//	      case V4IM_Tag_Index:
//		CL ; lix.Count = 0 ;
//		switch (cpt->Grouping)
//		 { default: goto no_relindex ;
//		   case V4DPI_Grouping_Single:	lix.Begin[0] = lix.End[0] = v4im_GetPointInt(&ok,cpt,ctx) ; break ;
//		   case V4DPI_Grouping_GT:	lix.Begin[0] = v4im_GetPointInt(&ok,cpt,ctx)+1 ; lix.End[0] = V4LIM_BiggestPositiveInt ; break ;
//		   case V4DPI_Grouping_GE:	lix.Begin[0] = v4im_GetPointInt(&ok,cpt,ctx) ; lix.End[0] = V4LIM_BiggestPositiveInt ; break ;
//		   case V4DPI_Grouping_LT:	lix.Begin[0] = 0 ; lix.End[0] = v4im_GetPointInt(&ok,cpt,ctx)-1 ; break ;
//		   case V4DPI_Grouping_LE:	lix.Begin[0] = 0 ; lix.End[0] = v4im_GetPointInt(&ok,cpt,ctx) ; break ;
//		   case V4DPI_Grouping_NE:
//			lix.Begin[0] = 0 ; lix.End[0] = v4im_GetPointInt(&ok,cpt,ctx)-1 ;	
//			lix.Begin[1] = lix.End[0]+2 ; lix.End[1] = V4LIM_BiggestPositiveInt ; lix.Count++ ; break ;
//		 } ; lix.Count ++ ; continue ;
//no_relindex:
//		pim = (struct V4DPI__Point_IntMix *)&cpt->Value ;
//		for(i=0;i<cpt->Grouping;i++)
//		 { lix.Begin[i] = pim->Entry[i].BeginInt ; lix.End[i] = pim->Entry[i].EndInt ; } ;
//		lix.Count = cpt->Grouping ; continue ;
	      case V4IM_Tag_Sum:
		CL ; vtm->sumpt = cpt ;
		if (vtm->sumpt->PntType != V4DPI_PntType_List) { vtm->lpsum = NULL ; }
		 else { vtm->lpsum = v4im_VerifyList(NULL,ctx,vtm->sumpt,intmodx) ; } ;
		firstsum = TRUE ; continue ;
	      case V4IM_Tag_Context:	CL ; if (memcmp(cpt,&protoNone,V4PS_Int) != 0) vtm->GlobalContext = cpt ; continue ;
	      case V4IM_Tag_List:	gotlist = TRUE ; break ;
	      case V4IM_Tag_If:		CL ; if (memcmp(cpt,&protoNone,V4PS_Int) != 0) vtm->GlobalSelect = cpt ; continue ;
	      case V4IM_Tag_Parent:	CL ; if (memcmp(cpt,&protoNone,V4PS_Int) != 0) vtm->parpt = cpt ; continue ;
	      case V4IM_Tag_PIf:	CL ; if (memcmp(cpt,&protoNone,V4PS_Int) != 0) vtm->pifpt = cpt ; continue ;
	      case V4IM_Tag_Sample:	{ LENMAX pm = v4im_GetPointInt(&ok,cpt,ctx) ;
					  if (gpi->PointMax > 0) { v_Msg(ctx,NULL,"TallySamMax",intmodx,DE(PointMax),gpi->PointMax,V4IM_Tag_Sample,pm) ; goto tally_fail ; } ;
					  CL ; vtm->Sample = pm ; continue ;
					}
	      case V4IM_Tag_Num:	{ LENMAX pm = v4im_GetPointInt(&ok,cpt,ctx) ;
					  CL ; vtm->maxNum = pm ; continue ;
					}
	      case V4IM_Tag_Skip:	CL ; skip = v4im_GetPointInt(&ok,cpt,ctx) ; continue ;
	      case V4IM_Tag_Values:	CL ; k = v_CvtToPrime(v4im_GetPointInt(&ok,cpt,ctx)) ;
					vtm->TallyEntryMax = k ;
					continue ;
	    } ;
	   if (vtm->pifpt != NULL && vtm->parpt == NULL)
	    { v_Msg(ctx,NULL,"TallyTagWithTag",intmodx,V4IM_Tag_PIf,V4IM_Tag_Parent) ;  goto tally_fail ; } ;
	   if (vtm->pifpt == NULL && vtm->parpt != NULL)
	    { v_Msg(ctx,NULL,"TallyTagWthTag2",intmodx,V4IM_Tag_Parent,V4IM_Tag_PIf,V4IM_Tag_Context) ; goto tally_fail ; } ;
	   lp = v4im_VerifyList(NULL,ctx,ipt = argpnts[bx],intmodx) ;
	   if (lp == NULL) { v_Msg(ctx,NULL,"ModInvArgList",intmodx,bx) ; goto tally_fail ; } ;
	   seqx++ ;
	   vtm->Action[seqx].biMax = V4LIM_BiggestPositiveInt ; vtm->Action[seqx].biMin = UNUSED ;
	   if (seqx >= V4IM_TallyAction_Max)
	    { v_Msg(ctx,NULL,"TallyMaxAction",intmodx,V4IM_TallyAction_Max) ; goto tally_fail ; } ;

	   for(i=1;ok;i++)
	    { if (v4l_ListPoint_Value(ctx,lp,i,&isctbuf) <= 0) break ;
	      argx = 0 ;					/* argx = p[n] for this argument */
	      switch (v4im_CheckPtArgNew(ctx,&isctbuf,&ipt,NULL))
	       { default:			v_Msg(ctx,NULL,"TagBadUse",intmodx) ; goto tally_fail ;
	         case V4IM_Tag_Unk:		v_Msg(ctx,NULL,"TagUnknown",intmodx) ; goto tally_fail ;
		 case V4IM_Tag_Dim:		vtm->Action[seqx].ResDim = ipt->Value.IntVal ; continue ;
 	         case V4IM_Tag_Count:		argx = 1 ; vtm->Action[seqx].ActionType = V4IM_ActType_Count ; break ;
 	         case V4IM_Tag_Sum:		argx = 1 ; vtm->Action[seqx].ActionType = V4IM_ActType_Sum ; break ;
	         case V4IM_Tag_Sub:		argx = 1 ; vtm->Action[seqx].ActionType = V4IM_ActType_Sub ; break ;
	         case V4IM_Tag_Minimum:		argx = 1 ; vtm->Action[seqx].ActionType = V4IM_ActType_Min ; break ;
	         case V4IM_Tag_Maximum:		argx = 1 ; vtm->Action[seqx].ActionType = V4IM_ActType_Max ; break ;
	         case V4IM_Tag_StdDev:		argx = 1 ; vtm->Action[seqx].ActionType = V4IM_ActType_StdDev ; break ;
	         case V4IM_Tag_Average:		argx = 1 ; vtm->Action[seqx].ActionType = V4IM_ActType_Avg ; break ;
	         case V4IM_Tag_ListOf:
			argx = 1 ; vtm->Action[seqx].ActionType = V4IM_ActType_List ;
			if (vtm->Action[seqx].sfp == NULL)			/* Create temp file */
			 { vtm->Action[seqx].sfp = v_MakeOpenTmpFile(UClit("v4tly1"),vtm->Action[seqx].FileName,UCsizeof(vtm->Action[seqx].FileName),"wb",ctx->ErrorMsgAux) ; } ;
			if (vtm->Action[seqx].sfp == NULL) { v_Msg(ctx,NULL,"ModFailed2",intmodx) ; goto tally_fail ; } ;
			break ;
	         case V4IM_Tag_SetOf:
			argx = 1 ; vtm->Action[seqx].ActionType = V4IM_ActType_UList ;
			if (vtm->Action[seqx].sfp == NULL)			/* Create temp file */
			 { vtm->Action[seqx].sfp = v_MakeOpenTmpFile(UClit("v4tly2"),vtm->Action[seqx].FileName,UCsizeof(vtm->Action[seqx].FileName),"wb",ctx->ErrorMsgAux) ; } ;
			if (vtm->Action[seqx].sfp == NULL) { v_Msg(ctx,NULL,"ModFailed2",intmodx) ; goto tally_fail ; } ;
			break ;
		 case V4IM_Tag_UCount:
			argx = 1 ; vtm->Action[seqx].ActionType = V4IM_ActType_UCount ;
			if (vtm->Action[seqx].sfp == NULL)			/* Create temp file */
			 { vtm->Action[seqx].sfp = v_MakeOpenTmpFile(UClit("v4tly3"),vtm->Action[seqx].FileName,UCsizeof(vtm->Action[seqx].FileName),"wb",ctx->ErrorMsgAux) ; } ;
			if (vtm->Action[seqx].sfp == NULL) { v_Msg(ctx,NULL,"ModFailed2",intmodx) ; goto tally_fail ; } ;
			break ;
		 case V4IM_Tag_Bits:
			switch (vtm->Action[seqx].ActionType)
			 { default:
				v_Msg(ctx,NULL,"TallyTagWthTag3",intmodx,V4IM_Tag_Bits,V4IM_Tag_ListOf,V4IM_Tag_SetOf,V4IM_Tag_UCount) ; goto tally_fail ;
			   case V4IM_ActType_UList: case V4IM_ActType_List: case V4IM_ActType_UCount:
				break ;
			 } ;
			vtm->Action[seqx].bitsInMap = v4im_GetPointDbl(&ok,ipt,ctx) ;
			break ;
		 case V4IM_Tag_Cache:
			switch (vtm->Action[seqx].ActionType)
			 { default:
				v_Msg(ctx,NULL,"TallyTagWthTag3",intmodx,V4IM_Tag_Cache,V4IM_Tag_ListOf,V4IM_Tag_SetOf,V4IM_Tag_UCount) ; goto tally_fail ;
			   case V4IM_ActType_UList: case V4IM_ActType_List: case V4IM_ActType_UCount:
				break ;
			 } ;
			vtm->Action[seqx].Cache = v4im_GetPointDbl(&ok,ipt,ctx) ;
			 break ;
	         case V4IM_Tag_Array:		argx = 13 ; break ;
	         case V4IM_Tag_BindIf:		argx = 12 ; break ;
	         case V4IM_Tag_Do:		argx = 10 ; break ;
		 case V4IM_Tag_By:		argx = 2 ; break ;
		 case V4IM_Tag_ByIf:		argx = 7 ; break ;
	         case V4IM_Tag_Bind:		argx = 3 ; break ;
	         case V4IM_Tag_ByList:		argx = 4 ; break ;
	         case V4IM_Tag_If:		argx = 5 ; break ;
	         case V4IM_Tag_IfOnce:		argx = 5 ; vtm->Action[seqx].SelectOnce = TRUE ; break ;
	         case V4IM_Tag_IFa:		argx = 5 ; vtm->Action[seqx].IFabc = 1 ; break ;
	         case V4IM_Tag_IFb:		argx = 5 ; vtm->Action[seqx].IFabc = 2 ; break ;
	         case V4IM_Tag_IFc:		argx = 5 ; vtm->Action[seqx].IFabc = 3 ; break ;
	         case -V4IM_Tag_IFa:		vtm->Action[seqx].IFabc = -1 ; continue ;
	         case -V4IM_Tag_IFb:		vtm->Action[seqx].IFabc = -2 ; continue ;
	         case -V4IM_Tag_IFc:		vtm->Action[seqx].IFabc = -3 ; continue ;
	         case V4IM_Tag_Values:		argx = 6 ; break ;
	         case V4IM_Tag_With:		argx = 8 ; break ;
	         case V4IM_Tag_WBind:		argx = 9 ; break ;
		 case V4IM_Tag_Project:		argx = 11 ; break ;
	       } ; if (!ok) break ;
	      if (ipt->ForceEval)			/* If forcing evaluation then do it */
	       { ipt = v4dpi_IsctEval(&ptbuf,ipt,ctx,V4DPI_EM_EvalQuote,NULL,NULL) ;
	         if (ipt == NULL) { v_Msg(ctx,NULL,"TallyForceEval",intmodx,&isctbuf) ; goto tally_fail ; } ;
	       } ;

	      tpt = v4im_tallyAllocAndCopy(vtm,ipt,ipt->Bytes) ;

	      switch (argx)
	       { case 1: vtm->Action[seqx].p1 = tpt ; break ;
	         case 2: vtm->Action[seqx].p2 = tpt ; break ;
	         case 3: vtm->Action[seqx].p3 = tpt ; break ;
	         case 4: vtm->Action[seqx].p4 = tpt ; break ;
	         case 5: vtm->Action[seqx].p5 = tpt ; break ;
	         case 6: vtm->Action[seqx].p6 = tpt ; break ;
	         case 7: vtm->Action[seqx].ByIf = tpt ; break ;
	         case 8: vtm->Action[seqx].With = tpt ; break ;
	         case 9: vtm->Action[seqx].WBind = tpt ; break ;
	         case 10: vtm->Action[seqx].Do = tpt ; break ;
		 case 11: vtm->Action[seqx].Project = tpt ; break ;
		 case 12: vtm->Action[seqx].BindIf = tpt ;
chkbindif:		switch (tpt->PntType)
			 { case V4DPI_PntType_Int:
				switch (tpt->Grouping)
				 { default:				v_Msg(ctx,NULL,"TallyBindIf",intmodx,V4IM_Tag_BindIf,tpt) ; goto tally_fail ;
				   case V4DPI_Grouping_Single:		vtm->Action[seqx].biMin = tpt->Value.IntVal ; vtm->Action[seqx].biMax = tpt->Value.IntVal ; break ;
				   case V4DPI_Grouping_LT:		vtm->Action[seqx].biMin = 1 ; vtm->Action[seqx].biMax = tpt->Value.IntVal - 1 ; break ;
				   case V4DPI_Grouping_LE:		vtm->Action[seqx].biMin = 1 ; vtm->Action[seqx].biMax = tpt->Value.IntVal ; break ;
				   case V4DPI_Grouping_GE:		vtm->Action[seqx].biMin = tpt->Value.IntVal ; vtm->Action[seqx].biMax = V4LIM_BiggestPositiveInt ; break ;
				   case V4DPI_Grouping_GT:		vtm->Action[seqx].biMin = tpt->Value.IntVal + 1 ; vtm->Action[seqx].biMax = V4LIM_BiggestPositiveInt ; break ;
				 } ;
				break ;
			   case V4DPI_PntType_Int2:			vtm->Action[seqx].biMin = tpt->Value.Int2Val[0] ; vtm->Action[seqx].biMax = tpt->Value.Int2Val[1] ; break ;
			   case V4DPI_PntType_Special:
				switch (tpt->Grouping)
				 { 
				   case V4DPI_Grouping_Current:		DIMVAL(ipt,ctx,tpt->Dim) ; if (ipt != NULL) { tpt = ipt ; goto chkbindif ; } ; v_Msg(ctx,NULL,"CtxNoCurVal",intmodx,tpt->Dim) ; goto tally_fail ;
				   case V4DPI_Grouping_PCurrent:	DIMPVAL(ipt,ctx,tpt->Dim) ; if (ipt != NULL) { tpt = ipt ; goto chkbindif ; } ; v_Msg(ctx,NULL,"CtxNoPriorVal",intmodx,tpt->Dim) ; goto tally_fail ;
				 } ;
				break ;
			 } ;
			if (vtm->Action[seqx].biMin != UNUSED) vtm->Action[seqx].BindIf = NULL ;	/* If we set biMin/biMax then clear out BindIf */
			break ;
		 case 13: vtm->Action[seqx].Array = tpt ; break ;
	       } ;
	    } ;
	   ipt = vtm->Action[seqx].p1 ;			/* First argument is/are values */
	   if (ipt != NULL)
	    { if (vtm->Action[seqx].p3 == NULL && vtm->Action[seqx].Project == NULL && vtm->Action[seqx].Array == NULL)
		{ v_Msg(ctx,NULL,"TallyNoBind",intmodx,V4IM_Tag_Bind,V4IM_Tag_Project,V4IM_Tag_Array,intmodx,seqx+1) ; goto tally_fail ; } ;
	      if (ipt->PntType != V4DPI_PntType_List)
	       { /* if (!ISQUOTED(ipt->Quoted))
	          v4_error(V4E_ARG2NOTISCT,0,"V4IM","Tally","ARG2NOTISCT","Second argument must be quoted Isct") ; */
	         vtm->Action[seqx].vallp = NULL ; vtm->Action[seqx].NumValues = 1 ;	/* Not a list */
	       } else
	       { vtm->Action[seqx].vallp = ALIGNLP(&ipt->Value) ; /* Got a list, set up list pointer */
	         vtm->Action[seqx].NumValues = SIZEofLIST(vtm->Action[seqx].vallp) ;
	       } ;
	    } else { 
		     intPNTv(&ptbuf,1) ; vtm->Action[seqx].p1 = v4im_tallyAllocAndCopy(vtm,&ptbuf,ptbuf.Bytes) ;
		     vtm->Action[seqx].NumValues = 1 ;
		   } ;
	   if (vtm->Action[seqx].With != NULL)
	    { if (vtm->Action[seqx].With->PntType == V4DPI_PntType_List)
	       { vtm->Action[seqx].Withlp = ALIGNLP(&vtm->Action[seqx].With->Value) ;
	         vtm->Action[seqx].NumWith = SIZEofLIST(vtm->Action[seqx].Withlp) ;
	       } else { vtm->Action[seqx].NumWith = 1 ; } ;
	      if (vtm->vtew == NULL)
	       vtm->vtew = (struct V4IM__TallyEntryWith *)v4mm_AllocChunk(sizeof *vtm->vtew,FALSE) ;
	    } ;
	   ipt = vtm->Action[seqx].p2 ;			/* Second argument is/are by's */
	   if (ipt == NULL)
	    { if (vtm->Action[seqx].p4 != NULL)
	       { v_Msg(ctx,NULL,"TallyTagWithTag",intmodx,V4IM_Tag_ByList,V4IM_Tag_By) ; goto tally_fail ; } ;
	      if (vtm->Action[seqx].p3 == NULL && vtm->Action[seqx].Project == NULL)
	       { v_Msg(ctx,NULL,"TallyMustHave",intmodx,V4IM_Tag_Bind,V4IM_Tag_Project,V4IM_Tag_By) ; goto tally_fail ; } ;
	      lsupi.ptrpart = (char *)vtm->Action[seqx].p3 ;
	      vtm->Action[seqx].DfltHash = lsupi.intpart ;	/* Pick random hash value when no "By" points */
	    } else
	    { 
//	      if (ipt->PntType == V4DPI_PntType_Isct || ipt->PntType == V4DPI_PntType_Special)
//	       { /* if (!ISQUOTED(ipt))
//	          v4_error(V4E_ARG2NOTISCT,0,"V4IM","Tally","ARG3NOTISCT","Third argument must be quoted Isct") ; */
//	         vtm->Action[seqx].comlp = NULL ; vtm->Action[seqx].NumComboPoints = 1 ;	/* Not a list */
//	       } else if (ipt->PntType == V4DPI_PntType_List)
//	          { vtm->Action[seqx].comlp = ALIGNLP(&ipt->Value) ; /* Got a list, set up list pointer */
//	            vtm->Action[seqx].NumComboPoints = SIZEofLIST(vtm->Action[seqx].comlp) ;
//		    if (vtm->Action[seqx].NumComboPoints > V4IM_TallyEntryValue_Max)
//		     { v_Msg(ctx,NULL,"TallyMaxAction",intmodx,V4IM_TallyEntryValue_Max) ; goto tally_fail ; } ;
//	          } ;
	      if (ipt->PntType == V4DPI_PntType_List)
	       { vtm->Action[seqx].comlp = ALIGNLP(&ipt->Value) ; /* Got a list, set up list pointer */
		 vtm->Action[seqx].NumComboPoints = SIZEofLIST(vtm->Action[seqx].comlp) ;
		 if (vtm->Action[seqx].NumComboPoints > V4IM_TallyEntryValue_Max)
		  { v_Msg(ctx,NULL,"TallyMaxAction",intmodx,V4IM_TallyEntryValue_Max) ; goto tally_fail ; } ;
	       } else 
	       { vtm->Action[seqx].comlp = NULL ; vtm->Action[seqx].NumComboPoints = 1 ;
	       } ;

	    } ;
	   if (vtm->Action[seqx].p3 != NULL && vtm->Action[seqx].Project != NULL)
	    { v_Msg(ctx,NULL,"ModOnlyOne",intmodx,V4IM_Tag_Bind,V4IM_Tag_Project) ; goto tally_fail ; } ;
	   if (vtm->Action[seqx].p3 != NULL || vtm->Action[seqx].Project != NULL)
	    { ipt = (vtm->Action[seqx].p3 != NULL ? vtm->Action[seqx].p3 : vtm->Action[seqx].Project) ;
	      if (ipt->PntType != V4DPI_PntType_List) { i = 1 ; }
	       else { lp = ALIGNLP(&ipt->Value) ; i = SIZEofLIST(lp) ; } ;
	      if (i > vtm->Action[seqx].NumValues &&
		   !( vtm->Action[seqx].ActionType == V4IM_ActType_Count || vtm->Action[seqx].ActionType == V4IM_ActType_List
			|| vtm->Action[seqx].ActionType == V4IM_ActType_UList || vtm->Action[seqx].ActionType == V4IM_ActType_UCount))
	       { v_Msg(ctx,NULL,"TallyActionNum",intmodx,(vtm->Action[seqx].p3 != NULL ? V4IM_Tag_Bind : V4IM_Tag_Project),seqx+1) ; goto tally_fail ; } ;
	    } ;
	   if (vtm->Action[seqx].Array != NULL)
	    { if (vtm->Action[seqx].NumComboPoints > V4IM_TallyArray_DimMax)
	       { v_Msg(ctx,NULL,"TallyByMax",intmodx,V4IM_TallyArray_DimMax,V4IM_Tag_By,V4IM_Tag_Array) ; goto tally_fail ; } ;
	    } ;
	   continue ;
misplaced_global_tag:
	v_Msg(ctx,NULL,"TallyGlblAct",intmodx,bx) ; goto tally_fail ;

	 } ;
	if (!ok) { v_Msg(ctx,NULL,"ModInvArg",intmodx,bx-1) ; goto tally_fail ; } ;
/*		Allocate for hash values */
	vtm->teb = (struct V4IM__TallyEntryBuf *)v4mm_AllocChunk(vtm->TallyEntryMax*(sizeof vtm->teb->Entry[0]),TRUE) ;
	vtm->ActionCount = seqx+1 ;
	ipt = argpnts[1] ;
	vtee.lp = v4im_VerifyList(NULL,ctx,ipt,intmodx) ;
	if (vtee.lp == NULL) { v_Msg(ctx,NULL,"ModInvArgList",intmodx,1) ; goto tally_fail ; } ;
	frameid = v4ctx_FramePush(ctx,NULL) ;		/* Start new context frame */
	if (trace & V4TRACE_Progress)
	 { vtee.totalEnumPts = SIZEofLIST(vtee.lp) ; showProgress = TRUE ;
	   if (vtee.totalEnumPts > 0)
	    { showProgress = (vtee.totalEnumPts >= gpi->traceProgressMin) ;
	      v_Msg(ctx,UCTBUF2,"*TraceEnum",intmodx,id,vtee.totalEnumPts) ;
	    } else { v_Msg(ctx,UCTBUF2,"TraceEnum2",intmodx,id) ; } ;
	   if (showProgress) vout_UCText(VOUT_Progress,0,UCTBUF2) ;
	 } else { showProgress = FALSE ; } ;
	vtee.totalEnumPts = SIZEofLIST(vtee.lp) ;		/* Get total number of points in list */
	if (vtm->Sample == 0) { i = 1 ; }			/* If sampling then pick starting point */
	 else {	i = (rand() % vtm->Sample) ; if (i <= 0) i = 1 ; } ;
	vtee.traceInc ;
	for(seqx=0;seqx<vtm->ActionCount;seqx++)		/* Maybe allocate list cache */
	 { 
	   if (vtm->Action[seqx].Cache < 1.0)			/* If we have Cache::0.x then allocate based on total Tally points */
	    { vtm->Action[seqx].Cache = (int)(vtm->Action[seqx].Cache * vtee.totalEnumPts) ; }
	   if (vtm->Action[seqx].ActionType != V4IM_ActType_UList && vtm->Action[seqx].ActionType != V4IM_ActType_UCount)
	    { if (vtm->Action[seqx].Cache > 0)			/* If not UCount or SetOf then maybe setup cache */
	       { if (vtm->Action[seqx].Cache < 1000 && vtm->Action[seqx].Cache != 1) { vtm->Action[seqx].Cache = V4IM_TallySortMax ; } else { vtm->Action[seqx].Cache = v_CvtToPrime(vtm->Action[seqx].Cache) ; } ;
	         vtm->Action[seqx].tsc =
	          (struct V4IM__TallySortCache *)v4mm_AllocChunk(TallySortCacheHeader+k*sizeof(struct V4IM__TallySort),TRUE) ;
	         vtm->Action[seqx].tsc->Count = vtm->Action[seqx].Cache ;
	       } ;
	      continue ;
	    } ;
/*	   Here to set up for SetOf / UCount */
	   if (vtm->Action[seqx].bitsInMap == 0) vtm->Action[seqx].bitsInMap = vtm->Action[seqx].Cache ;
	   if (vtm->Action[seqx].bitsInMap == 0 && vtm->Action[seqx].ActionType == V4IM_ActType_UCount) vtm->Action[seqx].bitsInMap = V4IM_TallyListBitMapMax ;
	   if (vtm->Action[seqx].bitsInMap == 0) continue ;
	   vtm->Action[seqx].tsc =
	    (struct V4IM__TallySortCache *)v4mm_AllocChunk(TallySortCacheHeader+sizeof(struct V4IM__TallySort),TRUE) ;
	   vtm->Action[seqx].tsc->Bits = vtm->Action[seqx].bitsInMap ;
	   if (vtm->Action[seqx].ActionType == V4IM_ActType_UList)
	    { if (vtm->Action[seqx].ResDim > 0)						/* Look to see if we save result as bitmap */
	       { DIMINFO(di,ctx,vtm->Action[seqx].ResDim) ;
		 if (di->ListDimId > 0)	vtm->Action[seqx].listDimId = di->ListDimId ;	/* Target list dimension has its own target dimension */
	       } ;
	    } ;
	 } ;
	
	vtee.isct = isct ; vtee.trace = trace ; vtee.vtm = vtm ; vtee.intmodx = intmodx ; vtee.showProgress = showProgress ;
#ifdef V4ENABLEMULTITHREADS
	if (vtm->Threads == 0) { vtm->Threads = v_AvailableProcessors() ; }
	 else if (vtm->Threads < 0) { vtm->Threads = -vtm->Threads ; }
	 else { if (vtm->Threads > v_AvailableProcessors()) vtm->Threads = v_AvailableProcessors() ; } ;
	INITMTLOCK(vtm->sfpLock) ; INITMTLOCK(vtm->tebLock) ; INITMTLOCK(vtm->traceLock) ;	/* Make locks available */
/*	If only want 1 thread OR we are looping thru fewer than 250_000 points then start up single thread Tally() */
	if (vtm->Threads == 1 || vtm->Threads < 0 /* || (vtee.totalEnumPts < 250000 && vtee.totalEnumPts != 0) */)
	 { vtee.startX = 1 ; vtee.endX = 999999999 ; vtee.ctx = ctx ; vtee.skip = skip ;
	   if (!v4im_TallyListEnum(&vtee)) goto tally_fail ;
	   vtm->SelectCount += vtee.SelectCount ; vtm->totalScan += vtee.totalScan ;
	 } else		/* Here to set up for multiple threads */
	 { struct V4L__Partitions lprtn ;
	   INDEX px ;
#ifdef WINNT
	   HANDLE hThreads[V4L_Partition_Max] ; DWORD dwThreadId ;
#endif
#if defined LINUX486 || defined RASPPI
	   pthread_t pThreads[V4L_Partition_Max] ;
#endif
	   if (skip != UNUSED) { v_Msg(ctx,NULL,"TallySkip",intmodx,V4IM_Tag_Skip,V4IM_OpCode_Tally) ; goto tally_fail ; } ;
/*	   Break up the Tally point list into partitions based on number of threads */
	   if (!v4l_ListPartition(ctx,vtee.lp,&lprtn,vtm->Threads,intmodx)) goto tally_fail ;
	   for(px=0;px<lprtn.Count;px++)
	    { struct V4MM__MemMgmtMaster *mmm=NULL ;
	      lprtn.Seg[px].vtee = vtee ; lprtn.Seg[px].vtee.startX = lprtn.Seg[px].Start ; lprtn.Seg[px].vtee.endX = lprtn.Seg[px].End ;
	      lprtn.Seg[px].vtee.totalEnumPts = lprtn.Seg[px].vtee.endX - lprtn.Seg[px].Start + 1 ;
#ifdef NEWMMM
	      mmm = v4mm_AllocChunk(sizeof *mmm,FALSE) ; v4mm_MemMgmtInit(mmm) ;
#endif
	      lprtn.Seg[px].vtee.ctx = (struct V4C__Context *)v4mm_AllocChunk(sizeof *ctx,FALSE) ; v4ctx_Initialize(lprtn.Seg[px].vtee.ctx,ctx,mmm) ;
	      lprtn.Seg[px].vtee.ctx->aggStream = px ;		/* Give each thread a separate Aggregate stream index */
	      lprtn.Seg[px].vtee.mmm = mmm ;
#ifdef NEWMMM
/*	      Create new mmm for this partition (thread) */
	      { INDEX ax ;
/*		Move all V4 areas (but make sure updatable work area still links back to main mmm) */
	        for(ax=gpi->LowHNum;ax<=gpi->HighHNum;ax++)
	         { if (gpi->RelH[ax].aid!=UNUSED) v4mm_copyToNewMMM(gpi->mmm,mmm,gpi->RelH[ax].aid,(ax == V4DPI_WorkRelHNum)) ; } ;
/*		Do we have external dictionary ? - if so then link back to main so we can update properly if we have to */
		if (gpi->xdr != NULL)
		 { v4mm_copyToNewMMM(gpi->mmm,mmm,gpi->xdr->pcb->AreaId,TRUE) ;
		 } ;
///*	        Move all aggregate (areas) for this thread into new mmm */
//	        for(ax=0;ax<lprtn.Seg[px].aggIndexCnt;ax++)
//	         { v4mm_copyToNewMMM(gpi->mmm,mmm,gpi->AreaAgg[lprtn.Seg[px].aggIndexes[ax]].pcb->AreaId,FALSE) ; } ;
/*	        Move all aggregate (areas) into new mmm */
	        for(ax=0;ax<gpi->AreaAggCount;ax++)
	         { if (gpi->AreaAgg[ax].pcb == NULL) continue ; 
	           v4mm_copyToNewMMM(gpi->mmm,mmm,gpi->AreaAgg[ax].pcb->AreaId,FALSE) ;
	         } ;
	        mmm->NumAreas = gpi->mmm->NumAreas ;
	      }
#endif
#ifdef WINNT
	      hThreads[px] = CreateThread(NULL,0,(LPTHREAD_START_ROUTINE)v4im_TallyListEnum,&lprtn.Seg[px].vtee,0,&dwThreadId) ;
#elif defined UNIX
	      if (pthread_create(&pThreads[px],NULL,v4im_TallyListEnum,&lprtn.Seg[px].vtee) != 0)
	       { v_Msg(ctx,NULL,"SpawnErr","pthread_create",errno) ; goto tally_fail ; } ;
#else
	      if (!v4im_TallyListEnum(&lprtn.Seg[px].vtee)) goto tally_fail ;
#endif


	    } ;
#ifdef WINNT
	   ok = WaitForMultipleObjects(lprtn.Count,hThreads,TRUE,INFINITE) ;
	   if (ok == WAIT_FAILED) { v_Msg(ctx,NULL,"SpawnWait",intmodx,GetLastError()) ; goto tally_fail ; } ;
#endif
#ifdef UNIX
	   for(i=0;i<lprtn.Count;i++)
	    { if (pthread_join(pThreads[i],NULL) != 0)		/* Wait for each/all threads to terminate */
	       { v_Msg(ctx,NULL,"SpawnWait",intmodx,errno) ; goto tally_fail ; } ;
	    } ;
#endif
	   for(px=0;px<lprtn.Count;px++)
	    { if (!lprtn.Seg[px].vtee.finishOK)
	       { UCstrcpy(ctx->ErrorMsg,lprtn.Seg[px].vtee.ctx->ErrorMsg) ; goto tally_fail ; } ;
	      vtm->SelectCount += lprtn.Seg[px].vtee.SelectCount ;
	      vtm->totalScan += lprtn.Seg[px].vtee.totalScan ;
	    } ;
	 } ;
#else							/* V4ENABLEMULTITHREADS */
	vtee.startX = 1 ; vtee.endX = 999999999 ; vtee.ctx = ctx ; vtee.skip = skip ;
	if (!v4im_TallyListEnum(&vtee)) goto tally_fail ;
	vtm->SelectCount += vtee.SelectCount ; vtm->totalScan += vtee.totalScan ;
#endif							/* V4ENABLEMULTITHREADS */
	
	if (showProgress)
	 { if (vtm->GlobalSelect != NULL || vtm->pifpt != NULL)
	    { v_Msg(ctx,UCTBUF2,"*TraceTallyScan",vtm->SelectCount,vtm->totalScan) ; }
 	    else { v_Msg(ctx,UCTBUF2,"*TraceTallyScan1",vtm->totalScan) ; } ;
	   vout_UCText(VOUT_Progress,0,UCTBUF2) ;
	 } ;
	if (vtm->UCFile.fp != NULL)				/* Writing out to area? */
	 { v4im_TallyAreaWrite(ctx,vtm->UCFile.fp,vtm,argpnts[1]->Dim,UNUSED) ; } ;
#ifdef WINNTx
	GetProcessTimes(GetCurrentProcess(),&ftCreate,&ftExit,&ftKernel1,&ftUser1) ;
	FileTimeToSystemTime(&ftUser1,&systime) ; cpu_start = systime.wMinute*6000 + systime.wSecond*100 + (systime.wMilliseconds+5)/10 ;
	time(&time_of_day) ; mmm = V4_GLOBAL_MMM_PTR ;
	for(ax=0;ax<mmm->NumAreas;ax++)
	 { if (mmm->Areas[ax].AreaId == UNUSED) continue ;
	   mmm->Areas[ax].BktReads = 0 ; mmm->Areas[ax].BktWrites = 0 ;
	 } ;
#define CHECK(WHERE,INDEX) \
	   wallseconds = time(NULL) -  time_of_day ; \
	   GetProcessTimes(GetCurrentProcess(),&ftCreate,&ftExit,&ftKernel2,&ftUser2) ; \
	   FileTimeToSystemTime(&ftUser2,&systime) ; cpuseconds = systime.wMinute*6000 + systime.wSecond*100 + (systime.wMilliseconds+5)/10 ; \
	   cpuseconds -= cpu_start ; cpuseconds /= 100.0 ; \
	   sprintf(ASCTBUF1,"*After %s #%d, Wall: %d  CPU: %g",WHERE,INDEX,wallseconds,cpuseconds) ; vout_Text(VOUT_Trace,0,ASCTBUF1) ; vout_NL(VOUT_Trace) ;\
	   for(ax=0;ax<mmm->NumAreas;ax++) \
	    { if (mmm->Areas[ax].AreaId == UNUSED) continue ; \
	      if (mmm->Areas[ax].BktReads + mmm->Areas[ax].BktWrites == 0) continue ; \
	      sprintf(ASCTBUF1,"*  %s - %d/%d",mmm->Areas[ax].FileName,mmm->Areas[ax].BktReads,mmm->Areas[ax].BktWrites) ; \
	      vout_Text(VOUT_Trace,0,ASCTBUF1) ; vout_NL(VOUT_Trace) ;\
	    } ;
#else
#define CHECK(WHERE,INDEX) {} ;
#endif

	for(i=0;i<vtm->ActionCount;i++)
	 { if (vtm->UCFile.fp != NULL)				/* Writing out to area? */
	    { v4im_TallyAreaWrite(ctx,vtm->UCFile.fp,vtm,argpnts[1]->Dim,i) ;
	      continue ;
	    } ;
	   if (vtm->Action[i].Array != NULL)
	    { if (!v4im_TallyMakeArray(ctx,vtm,i,V4IM_OpCode_Tally)) goto tally_fail ;
	      continue ;
	    } ;
	   switch (vtm->Action[i].ActionType)
	    { default:						/* Here unless a list */
		if (vtm->Action[i].p3 == NULL)			/* Null if returning a list */
		 { 
		   if (vtm->Action[i].Project != NULL)	/* Here to do projections */
		    { if (!v4im_TallyMakeProjections(ctx,vtm,i,vtm->Action[i].ByIf))	/* do it */
		       { v_Msg(ctx,NULL,"ModFailed2",intmodx) ; goto tally_fail ; } ;
		      CHECK("TallyMakeProjections",i) ;
		      if (vtm->Action[i].p4 != NULL)		/* Make a list of all points we tallied on? */
		       { if (!v4im_TallyMakeByList(ctx,vtm,i,vtm->Action[i].ByIf)) { v_Msg(ctx,NULL,"LPModFail",intmodx) ; goto tally_fail ; } ; CHECK("BYList",i) ; } ;
		      cpt = (P *)&Log_True ; break ;
		    } ;
		   if (vtm->Action[i].p4 != NULL)		/* Make a list of all points we tallied on? */
		    { if (!v4im_TallyMakeByList(ctx,vtm,i,vtm->Action[i].ByIf)) { v_Msg(ctx,NULL,"LPModFail",intmodx) ; goto tally_fail ; } ; } ;
		   cpt = (P *)&Log_True ;
		 } else
		 { if (!v4im_TallyMakeBinds(ctx,vtm,i,vtm->Action[i].ByIf))	/* do it */
		    { v_Msg(ctx,NULL,"ModFailed2",intmodx) ; goto tally_fail ; } ;
		   CHECK("TallyMakeBinds",i) ;
		   if (vtm->Action[i].p4 != NULL)		/* Make a list of all points we tallied on? */
		    { if (!v4im_TallyMakeByList(ctx,vtm,i,vtm->Action[i].ByIf)) { v_Msg(ctx,NULL,"LPModFail",intmodx) ; goto tally_fail ; } ; CHECK("BYList",i) ; } ;
		   cpt = (P *)&Log_True ;
		 } ;
		break ;
	      case V4IM_ActType_UList:
	      case V4IM_ActType_List:
		if (!v4im_TallyListMake(ctx,vtm,i,vtm->Action[i].ActionType,vtm->Action[i].BindIf))
		 { v_Msg(ctx,NULL,"ModFailed2",intmodx) ; goto tally_fail ; } ;
		CHECK("ListMake",i) ;
		if (vtm->Action[i].p4 != NULL)			/* Make a list of all points we tallied on? */
		 { if (!v4im_TallyMakeByList(ctx,vtm,i,vtm->Action[i].ByIf)) { v_Msg(ctx,NULL,"LPModFail",intmodx) ; goto tally_fail ; } ; CHECK("MakeByList",i) ; } ;
		cpt = (P *)&Log_True ;
		break ;
	      case V4IM_ActType_UCount:
		if (!v4im_TallyUCount(ctx,vtm,i,vtm->Action[i].ActionType))
		 { v_Msg(ctx,NULL,"ModFailed2",intmodx) ; goto tally_fail ; } ;
		CHECK("ListMake",i) ;
		if (vtm->Action[i].p4 != NULL)			/* Make a list of all points we tallied on? */
		 { if (!v4im_TallyMakeByList(ctx,vtm,i,vtm->Action[i].ByIf)) { v_Msg(ctx,NULL,"LPModFail",intmodx) ; goto tally_fail ; } ; CHECK("MakeByList",i) ; } ;
		cpt = (P *)&Log_True ;
		break ;
	    } ;
	 } ;
tally_end:
	if (vtm->UCFile.fp != NULL) { fprintf(vtm->UCFile.fp,"Z\n") ; v_UCFileClose(&vtm->UCFile) ; } ;
	for(;vtm->CurBuf!=NULL;)				/* Free up all buffers */
	 { obuf = vtm->CurBuf->PriorBuf ; v4mm_FreeChunk(vtm->CurBuf) ; vtm->CurBuf = obuf ; } ;
	if (ala != NULL) v4im_ALA_Cleanup(ala) ;
	if (vtm->teb != NULL) v4mm_FreeChunk(vtm->teb) ;
	if (vtm->vtew != NULL) v4mm_FreeChunk(vtm->vtew) ;
	v4mm_FreeChunk(vtm) ; v4mm_FreeChunk(vte) ;
	if (frameid != UNUSED)
	 { if (!v4ctx_FramePop(ctx,frameid,NULL))
	    { v_Msg(ctx,NULL,"ModCtxPopFrame",intmodx,frameid) ; REGISTER_ERROR(0) ; RETURNFAILURE ; } ;
	 } ;
	if (showProgress)
	 { v_Msg(ctx,UCTBUF2,"*TraceEnum7",intmodx,id) ; vout_UCText(VOUT_Progress,0,UCTBUF2) ; } ;
	if (cpt != NULL) { memcpy(respnt,cpt,cpt->Bytes) ; return(respnt) ; }
	 else { RETURNFAILURE ; } ;

tally_fail:
	REGISTER_ERROR(0) ; cpt = NULL ; goto tally_end ;
}

void *v4im_tallyAllocAndCopy(vtm,buf,bytes)
  struct V4IM__TallyMaster *vtm ;
  void *buf ;
  LENMAX bytes ;
{ void *b ;

	if (vtm->CurBuf == NULL) v4im_TallyEntryAlloc(vtm) ;
	if (vtm->CurBuf->NextFree + bytes >= V4IM_TallyBuf_Max) v4im_TallyEntryAlloc(vtm) ;
	b = (char *)&vtm->CurBuf->Buffer[vtm->CurBuf->NextFree] ; vtm->CurBuf->NextFree += bytes ;
	memcpy(b,buf,bytes) ;
	return(b) ;
}



LOGICAL v4im_TallyListEnum(vtee)
  struct V4IM_TallyEnumEnvironment *vtee ;
{ struct V4DPI__Point *ipt,*tpt,isctbuf,ptbuf,spnt,oldpar,oldpif,vbuf,lisctbuf ;
  struct V4L__ListPoint *lpctx,*lp1;
  struct V4C__Context *ctx ;
  struct V4IM__TallyMaster *vtm ;
  struct V4IM__TallyEntry *vte ; char vtebuf[sizeof *vte + V4IM_TallyEntryValue_Max] ;
  int trace,intmodx ;
  int lx,ic,j,inc,sx,ok,seqx,frameidv,slx,vx,loopok ; LOGICAL firstSum ; double dnum ;
  
/*	Pull data out of vtee */
	ctx = vtee->ctx ; vtm = vtee->vtm ; trace = vtee->trace ; intmodx = vtee->intmodx ;
#ifdef WINNT
	if (vtee->mmm != NULL) { TlsSetValue(gpi->mmmTLS,vtee->mmm) ; } ;
#endif
	ZPH(&oldpar) ;
	firstSum = TRUE ;
	vte = (struct V4IM__TallyEntry *)vtebuf ; memset(vtebuf,0,sizeof vtebuf) ;

	if (vtee->totalEnumPts <= 0) { vtee->traceInc = 50000 ; }
	 else { if (vtee->totalEnumPts < 5000) { vtee->traceInc = 5000 ; }
		 else if (vtee->totalEnumPts <= 100000) { vtee->traceInc = vtee->totalEnumPts / 5 ; }
		 else if (vtee->totalEnumPts <= 250000) { vtee->traceInc = vtee->totalEnumPts / 10 ; }
		 else if (vtee->totalEnumPts <= 1000000) { vtee->traceInc = vtee->totalEnumPts / 20 ; }
		 else { vtee->traceInc = vtee->totalEnumPts / 100 ; } ;
	      } ;
	inc = vtee->traceInc ; vtee->totalScan = 0 ;


	for(lx=vtee->startX;lx<=vtee->endX;)	/* Loop thru each point in list */
	 { 
	   FASTLISTPOINTVALUE(ic,vtee->lp,lx,&isctbuf) ; if (ic <= 0) break ;
	   vtee->totalScan ++ ;
	   if (vtee->skip > 0) { vtee->skip-- ; lx++ ; continue ; } ;
	   if (vtee->showProgress && (--inc <= 0))
	    { UCCHAR utb[20] ;
	      if (!GRABMTLOCK(vtm->traceLock)) goto tally_fail ;
	      if (vtee->totalEnumPts > 0) { UCsprintf(utb,UCsizeof(utb),UClit("(%d %%)"),intPC(lx-vtee->startX+1,vtee->totalEnumPts)) ; }
	       else { ZUS(utb) ; } ;
	      if (vtm->GlobalSelect != NULL || vtm->pifpt != NULL)
	       { v_Msg(ctx,UCTBUF2,"*TraceEnum4",intmodx,vtee->SelectCount,lx-vtee->startX+1,utb) ; }
	       else { v_Msg(ctx,UCTBUF2,"*TraceEnum5",intmodx,lx,utb) ; } ;
	      vout_UCText(VOUT_Progress,0,UCTBUF2) ; inc = vtee->traceInc ;
	      FREEMTLOCK(vtm->traceLock) ;
	    } ;
	   if (vtm->wantCount)
	    { vtm->cntpt.Value.IntVal = lx ; if (!v4ctx_FrameAddDim(ctx,0,(P *)&vtm->cntpt,0,0)) goto tallyctx_fail ;
	    } ;
	   if (vtm->Sample == 0) { lx++ ; }			/* If sampling then advance to next point */
	    else { j = (rand() % (vtm->Sample*2)) ; lx += (j == 0 ? 1 : j) ; }
	   if (gpi->PointMax > 0 && lx > gpi->PointMax || ((--vtm->maxNum) == 0))
	    { v_Msg(ctx,UCTBUF2,"*TraceTallyQuit",lx-1) ; vout_UCText(VOUT_Progress,0,UCTBUF2) ;
	      v4l_ListClose(ctx,vtee->lp) ;			/* Free up any list resources */
	      break ;
	    } ;
	   if (isctbuf.PntType == V4DPI_PntType_Isct)		/* If an ISCT then evaluate it */
	    { ic = 0 ; ipt = v4dpi_IsctEval(&ptbuf,&isctbuf,ctx,V4DPI_EM_EvalQuote,NULL,NULL) ; }
	    else { ipt = &isctbuf ; } ;
	   if (vtm->resDim > 0)
	    { if (!v4ctx_FrameAddDim(ctx,0,ipt,(vtm->resDim != ipt->Dim ? vtm->resDim : 0),0)) goto tallyctx_fail ;
	    } else
	    { if (ic != 2)
	       { FASTCTXADD(ipt,1) ; } ;
	    } ;
	   if (vtm->GlobalHold != NULL)
	    { ipt = vtm->GlobalHold ; ipt = v4dpi_IsctEval(&ptbuf,ipt,ctx,V4DPI_EM_EvalQuote,NULL,NULL) ;
	      if (ipt == NULL)
	       { v_Msg(ctx,NULL,"TagEvalFail",intmodx,V4IM_Tag_Hold,vtm->GlobalHold) ; goto tally_fail ; } ;
	      if (!v4ctx_FrameAddDim(ctx,V4C_FrameId_Hold,ipt,0,0)) goto tallyctx_fail ; CLEARCACHE
	    } ;
	   if (vtm->GlobalContext != NULL)
	    { ipt = vtm->GlobalContext ;
	      if (ipt->PntType == V4DPI_PntType_List)
	       { LOGICAL doSkip=FALSE ;
	         lpctx = v4im_VerifyList(NULL,ctx,ipt,intmodx) ;
		 for(sx=1;;sx++)
	          { if (v4l_ListPoint_Value(ctx,lpctx,sx,&spnt) <= 0) break ;
		    ipt = v4dpi_IsctEval(&ptbuf,&spnt,ctx,V4DPI_EM_EvalQuote,NULL,NULL) ;
		    if (ipt == NULL)
		     { v_Msg(ctx,NULL,"TagEvalFail",intmodx,V4IM_Tag_Context,vtm->GlobalContext) ; goto tally_fail ; } ;
		    if (memcmp(ipt,&protoSkip,protoSkip.Bytes) == 0) { doSkip = TRUE ; break ; } ;	/* If result is UV4:Skip then skip this point */
		    if (!v4ctx_FrameAddDim(ctx,0,ipt,0,0)) goto tallyctx_fail ; CLEARCACHE
		  } ; if (doSkip) continue ;
	       } else
	       { ipt = v4dpi_IsctEval(&ptbuf,ipt,ctx,V4DPI_EM_EvalQuote,NULL,NULL) ;
	         if (ipt == NULL) { v_Msg(ctx,NULL,"TagEvalFail",intmodx,V4IM_Tag_Context,vtm->GlobalContext) ; goto tally_fail ; } ;
	         if (memcmp(ipt,&protoSkip,protoSkip.Bytes) == 0) continue ;	/* If result is UV4:Skip then skip this point */
	         if (!v4ctx_FrameAddDim(ctx,0,ipt,0,0)) goto tallyctx_fail ;  CLEARCACHE
	       } ;
	    } ;
	   if (vtm->GlobalContextP != NULL)
	    { ipt = vtm->GlobalContextP ;
	      ipt = v4dpi_IsctEval(&ptbuf,ipt,ctx,V4DPI_EM_EvalQuote,NULL,NULL) ;
	      if (ipt == NULL) { v_Msg(ctx,NULL,"TagEvalFail",intmodx,V4IM_Tag_ContextP,vtm->GlobalContextP) ; goto tally_fail ; } ;
	      if (memcmp(ipt,&protoSkip,protoSkip.Bytes) == 0) continue ;	/* If result is UV4:Skip then skip this point */
	      if (ipt->PntType == V4DPI_PntType_List)
	       { lpctx = v4im_VerifyList(NULL,ctx,ipt,intmodx) ;
		 for(sx=1;;sx++)
	          { if (v4l_ListPoint_Value(ctx,lpctx,sx,&spnt) <= 0) break ;
		    ipt = v4dpi_IsctEval(&ptbuf,&spnt,ctx,V4DPI_EM_EvalQuote,NULL,NULL) ;
		    if (ipt == NULL)
		     { v_Msg(ctx,NULL,"TagEvalFail",intmodx,V4IM_Tag_Context,vtm->GlobalContext) ; goto tally_fail ; } ;
		    if (!v4ctx_FrameAddDim(ctx,0,ipt,0,0)) goto tallyctx_fail ; CLEARCACHE
		  } ;
	       } else
	       { if (!v4ctx_FrameAddDim(ctx,0,ipt,0,0)) goto tallyctx_fail ;  CLEARCACHE
	       } ;
	    } ;
	   if (vtm->indexDimId > 0)						/* If got a Index dimension then update */
	    { struct V4DPI__LittlePoint lPnt ;
	      intPNTv((P *)&lPnt,(vtm->indexStart + lx - 1)) ; lPnt.Dim = vtm->indexDimId ; lPnt.PntType = vtm->indexPntType ;
	      if (!v4ctx_FrameAddDim(ctx,0,(P *)&lPnt,0,0)) goto tally_fail ;
	    } ;
	   if (vtm->pifpt != NULL)					/* Have PIf:xxx point? */
	    { ipt = v4dpi_IsctEval(&ptbuf,vtm->parpt,ctx,V4DPI_EM_EvalQuote,NULL,NULL) ;
	      if (ipt == NULL) { v_Msg(ctx,NULL,"TagEvalFail",intmodx,V4IM_Tag_Parent,vtm->parpt) ; goto tally_fail ; } ;
	      if (memcmp(&oldpar,ipt,ipt->Bytes) != 0)		/* Parent different? */
	       { memcpy(&oldpar,ipt,ipt->Bytes) ;		/* Copy for next go-around */
		 FASTCTXADD(ipt,2) ;
		 CLEARCACHE
	         ipt = v4dpi_IsctEval(&oldpif,vtm->pifpt,ctx,V4DPI_EM_EvalQuote,NULL,NULL) ;
		 if (ipt == NULL) { v_Msg(ctx,NULL,"TagEvalFail",intmodx,V4IM_Tag_PIf,vtm->pifpt) ; goto tally_fail ; } ;
	       } else { ipt = &oldpif ; } ;
	      if (ipt->Value.IntVal <= 0) continue ;		/* If FALSE then try next point */
	      if (vtm->GlobalSelect == NULL) vtee->SelectCount ++ ; /* only update if no global select (otherwise will dbl count) */
	    } ;
	   if (vtm->GlobalWhile != NULL)			/* Have a global selection(while) criteria ? */
	    { 
	      FASTISCTEVAL(vtm->GlobalWhile,ipt,&ptbuf) ;
	      if (ipt == NULL)
	       { v_Msg(ctx,NULL,"TagEvalFail",intmodx,V4IM_Tag_While,vtm->GlobalWhile) ; goto tally_fail ; } ;
	      j = PNTlogVAL(&ok,ipt,ctx) ; if (!ok) { v_Msg(ctx,NULL,"ModInvArgNotOK",intmodx,V4IM_Tag_While,vtm->GlobalWhile,V4DPI_PntType_Logical,ipt) ; goto tally_fail ; } ;
	      if (!j)
	       { v4l_ListClose(ctx,vtee->lp) ;			/* Free up any list resources */
		 break ;
	       } ;
	      if (vtm->GlobalSelect == NULL && vtm->pifpt == NULL) vtee->SelectCount ++ ;
	    } ;
	   if (vtm->GlobalSelect != NULL)			/* Have a global selection criteria ? */
	    { ipt = vtm->GlobalSelect ;
	      FASTISCTEVAL(ipt,ipt,&ptbuf) ;
	      if (ipt == NULL)
	       { v_Msg(ctx,NULL,"TagEvalFail",intmodx,V4IM_Tag_If,vtm->GlobalSelect) ; goto tally_fail ; } ;
	      j = PNTlogVAL(&ok,ipt,ctx) ; if (!ok) { v_Msg(ctx,NULL,"ModInvArgNotOK",intmodx,V4IM_Tag_If,vtm->GlobalSelect,V4DPI_PntType_Logical,ipt) ; goto tally_fail ; } ;
	      if (!j) continue ;
	      vtee->SelectCount ++ ;
	    } ;
	   if (vtm->sumpt != NULL)
	    { for(sx=1;;sx++)
	       { if (vtm->lpsum != NULL)
	          { if (v4l_ListPoint_Value(ctx,vtm->lpsum,sx,&spnt) <= 0) break ; tpt = &spnt ; }
		  else { tpt = vtm->sumpt ; } ;
	         tpt = v4dpi_IsctEval(&ptbuf,tpt,ctx,V4DPI_EM_EvalQuote,NULL,NULL) ;
		 if (tpt == NULL)
		  { v_Msg(ctx,NULL,"TagEvalFail",intmodx,V4IM_Tag_Sum,vtm->sumpt) ; goto tally_fail ;
		  } ;
		 if (firstSum)					/* If first time then just add to context */
		  { if (!v4ctx_FrameAddDim(ctx,0,tpt,0,0)) goto tallyctx_fail ; CLEARCACHE
		  } else
		  { DIMVAL(ipt,ctx,tpt->Dim) ;		/* Get current dimension value */
		    ok = TRUE ; dnum = (ipt == NULL ? 0 : v4im_GetPointDbl(&ok,ipt,ctx)) ;
		    if (ok) dnum += v4im_GetPointDbl(&ok,tpt,ctx) ;	/* Add current value to context value */
		    if (!ok) { v_Msg(ctx,NULL,"TallyActionFail",intmodx,V4IM_Tag_Sum) ; goto tally_fail ; } ;
		    v4im_SetPointValue(ctx,tpt,dnum) ;
		    if (!v4ctx_FrameAddDim(ctx,0,tpt,0,0)) goto tallyctx_fail ;		/* Add updated point back into context */
		  } ;
	         if (vtm->lpsum == NULL) break ;			/* Don't have list */
	       } ;
	      firstSum = FALSE ;
	    } ;
	   loopok = TRUE ;
	   if (vtm->dopt != NULL)					/* If got Do::xxx then evaluate it */
	    { if (vtm->lpdo == NULL) { ipt = v4dpi_IsctEval(&ptbuf,vtm->dopt,ctx,V4DPI_EM_EvalQuote,NULL,NULL) ; }
	       else { for(j=1;v4l_ListPoint_Value(ctx,vtm->lpdo,j,&lisctbuf)>0;j++)
			{ if ((ipt = v4dpi_IsctEval(&ptbuf,&lisctbuf,ctx,V4DPI_EM_EvalQuote,NULL,NULL)) == NULL) break ; } ;
		    } ;
	      if (ipt == NULL) { v_Msg(ctx,NULL,"TagEvalFail",intmodx,V4IM_Tag_Do,vtm->dopt) ; goto tally_fail ; } ;
	    } ;
	   for(seqx=0;seqx<vtm->ActionCount && loopok;seqx++)
	    {
	     if (vtm->Action[seqx].IFabc < 0) { if (!vtee->IfResults[-vtm->Action[seqx].IFabc-1]) continue ; } ;
	     if (vtm->Action[seqx].p6 != NULL)			/* Start new context frame if Values::list */
	      frameidv = v4ctx_FramePush(ctx,NULL) ;
	     for(slx=1;;slx++)					/* Possibly do for each of the Values:: points */
	      { if (slx > 1 && vtm->Action[seqx].p6 == NULL) break ;	/* No sub Values list- break out of loop */
	        if (vtm->Action[seqx].p6 != NULL)
	         { if (slx == 1)
		    { ipt = v4dpi_IsctEval(&lisctbuf,vtm->Action[seqx].p6,ctx,V4DPI_EM_EvalQuote,NULL,NULL) ;
		      if (ipt == NULL) { v_Msg(ctx,NULL,"TagEvalFail",intmodx,V4IM_Tag_Values,vtm->Action[seqx].p6) ; goto tally_fail ; } ;
		      lp1 = v4im_VerifyList(&vbuf,ctx,ipt,intmodx) ;
		    } ;
		   if (v4l_ListPoint_Value(ctx,lp1,slx,&isctbuf) <= 0) break ;
		   if (isctbuf.PntType == V4DPI_PntType_Isct)		/* If an ISCT then evaluate it */
		    { ipt = v4dpi_IsctEval(&ptbuf,&isctbuf,ctx,V4DPI_EM_EvalQuote,NULL,NULL) ;
		      if (ipt == NULL) { v_Msg(ctx,NULL,"TagEvalFail",intmodx,V4IM_Tag_Values,&isctbuf) ; goto tally_fail ; } ;
		    } else { ipt = &isctbuf ; } ;
		   if (!v4ctx_FrameAddDim(ctx,0,ipt,0,0)) goto tallyctx_fail ;			/* Add point to current context */
		   CLEARCACHE
		 } ;
	        if (vtm->Action[seqx].p5 != NULL)			/* Do we have specific Select criteria? */
	         { ipt = vtm->Action[seqx].p5 ;
		   FASTISCTEVAL(ipt,ipt,&ptbuf) ;
		   if (vtm->Action[seqx].IFabc > 0)
		    vtee->IfResults[vtm->Action[seqx].IFabc-1] = (ipt == NULL ? FALSE : ipt->Value.IntVal > 0) ;
	           if (ipt == NULL)
	            { v_Msg(ctx,NULL,"TagEvalFail",intmodx,V4IM_Tag_If,vtm->Action[seqx].p5) ; goto tally_fail ; } ;
		   if (ipt->Value.IntVal < 1) continue ;		/*  else if defined then best be integer > 0 */
		   if (vtm->Action[seqx].SelectOnce) loopok = FALSE ;	/* If SelectOnce then don't do any addtional actions */
	         } ;
		if (vtm->Action[seqx].Do != NULL)			/* Have an action-specific Do::xxx ? */
	         { ipt = vtm->Action[seqx].Do ;
		   ipt = v4dpi_IsctEval(&ptbuf,ipt,ctx,V4DPI_EM_EvalQuote,NULL,NULL) ;
	           if (ipt == NULL)
	            { v_Msg(ctx,NULL,"TagEvalFail",intmodx,V4IM_Tag_Do,vtm->Action[seqx].Do) ; goto tally_fail ; } ;
		 } ;
/*		Init total bytes & set up offset to By-point buffer */
		vte->Offset = (char *)&vte->Entry[vtm->Action[seqx].NumValues] - (char *)vte ;
		vte->Bytes = vte->Offset ;
	        for(vx=0;vx<vtm->Action[seqx].NumComboPoints;vx++)
	         { P nlisctbuf ;
	           if (vtm->Action[seqx].comlp == NULL) { tpt = vtm->Action[seqx].p2 ; }
	            else { if (v4l_ListPoint_Value(ctx,vtm->Action[seqx].comlp,vx+1,&nlisctbuf) <= 0) break ;
		           tpt = &nlisctbuf ;
		         } ;
		    FASTISCTEVAL(tpt,ipt,&isctbuf) ;
	            if (ipt == NULL)
		     { v_Msg(ctx,NULL,"TagEvalFail",intmodx,V4IM_Tag_By,tpt) ; goto tally_fail ; } ;
/*		    Do quick 'sanity' check on result - don't want the By point to be huge (don't have enough room allocated) */
		    if (ipt->Bytes > 100)
		     { v_Msg(ctx,NULL,"TallyByTooBig",intmodx,V4IM_Tag_By,ipt,ipt->Bytes) ; goto tally_fail ; } ;
	            memcpy((char *)vte+vte->Bytes,ipt,ipt->Bytes) ; vte->Bytes += ALIGN(ipt->Bytes) ;
	         } ;
	         for(vx=0;vx<vtm->Action[seqx].NumValues;vx++)
	          { P nlisctbuf ;
	            if (vtm->Action[seqx].vallp == NULL) { tpt = vtm->Action[seqx].p1 ; }
	             else { if (v4l_ListPoint_Value(ctx,vtm->Action[seqx].vallp,vx+1,&nlisctbuf) <= 0) break ;
	       	            tpt = &nlisctbuf ;
	                  } ;
		    FASTISCTEVAL(tpt,ipt,&isctbuf) ;
	            if (ipt == NULL)
		     { v_Msg(ctx,NULL,"TallyValFail",intmodx,vx+1,tpt) ; goto tally_fail ; } ;
	            if (vtm->Action[seqx].ActionType == V4IM_ActType_List || vtm->Action[seqx].ActionType == V4IM_ActType_UList || vtm->Action[seqx].ActionType == V4IM_ActType_UCount)
	             { vte->ActionX = seqx ;
		       if (!v4im_TallyList(ctx,ipt,vtee,seqx,vte))
		        { v_Msg(ctx,NULL,"TallySubSysFail",intmodx,"TallyList") ; goto tally_fail ; } ;
		       continue ;
	             } ;

	vte->Entry[vx].Dim = ipt->Dim ; vte->Entry[vx].Count = 1 ;
	if (vtm->Action[seqx].ActionType == V4IM_ActType_StdDev)
	 { vte->Entry[vx].eType = V4IM_TEeType_sd ;
	   vte->Entry[vx].tec.sd.sdSum = v4im_GetPointDbl(&ok,ipt,ctx) ;
	   if (!ok) { v_Msg(ctx,NULL,"ModInvArg2",intmodx,ipt) ; goto tally_fail ; } ;
	   vte->Entry[vx].tec.sd.sdSumSq = vte->Entry[vx].tec.sd.sdSum * vte->Entry[vx].tec.sd.sdSum ;
	 } else { switch (ipt->PntType)
		   { default:
		 	vte->Entry[vx].eType = V4IM_TEeType_ns ;
		 	vte->Entry[vx].tec.ns.Sum = v4im_GetPointDbl(&ok,ipt,ctx) ;
			if (!ok) { v_Msg(ctx,NULL,"ModInvArg2",intmodx,ipt) ; goto tally_fail ; } ;
		 	break ;
		     case V4DPI_PntType_Fixed:
		 	vte->Entry[vx].eType = V4IM_TEeType_fs ;
			memcpy(&vte->Entry[vx].tec.fs.fSum,&ipt->Value.FixVal,sizeof(B64INT)) ;
			vte->Entry[vx].tec.fs.decimals = ipt->LHSCnt ;
			break ;
		     case V4DPI_PntType_UOM:
		 	vte->Entry[vx].eType = V4IM_TEeType_us ;
			vte->Entry[vx].tec.us.uRef = ipt->Value.UOMVal.Ref ; vte->Entry[vx].tec.us.uIndex = ipt->Value.UOMVal.Index ;
		 	vte->Entry[vx].tec.us.uSum = v4im_GetPointDbl(&ok,ipt,ctx) ;
			if (!ok) { v_Msg(ctx,NULL,"ModInvArg2",intmodx,ipt) ; goto tally_fail ; } ;
			break ;
		 } ;
	      } ;










	          } ;
	         for(vx=0;vx<vtm->Action[seqx].NumWith;vx++)
	          { P *wpt ;
	            if (vtm->Action[seqx].Withlp == NULL) { wpt = vtm->Action[seqx].With ; }
	             else { if (v4l_ListPoint_Value(ctx,vtm->Action[seqx].Withlp,vx+1,&isctbuf) <= 0) break ;
	       	            wpt = &isctbuf ;
	                  } ;
	            ipt = v4dpi_IsctEval(&isctbuf,wpt,ctx,V4DPI_EM_EvalQuote,NULL,NULL) ;
	            if (ipt == NULL) { v_Msg(ctx,NULL,"TallyTagFail",intmodx,V4IM_Tag_With,wpt) ; goto tally_fail ; } ;
		    memcpy(&vtm->vtew->wpt[vx],ipt,ipt->Bytes) ;	/* Save "With" point */
	          } ;
	        if (!(vtm->Action[seqx].ActionType == V4IM_ActType_List || vtm->Action[seqx].ActionType == V4IM_ActType_UList || vtm->Action[seqx].ActionType == V4IM_ActType_UCount))
		 { if (!v4im_TallyEntryInsert(ctx,vtee,vte,vtm->vtew,seqx)) { v_Msg(ctx,NULL,"ModFailed2",intmodx) ; goto tally_fail ; } ;
		 } ;
	      } ;
	     if (vtm->Action[seqx].p6 != NULL)			/* If got Values::xxx then pop off frame */
	      { if (!v4ctx_FramePop(ctx,frameidv,NULL)) { v_Msg(ctx,NULL,"ModCtxPopFrame",intmodx,frameidv) ; goto tally_fail ; } ; } ;
	    } ;
	   if (vtm->awpt != NULL)					/* Have AWhile:xxx point? */
	    { ipt = v4dpi_IsctEval(&ptbuf,vtm->awpt,ctx,V4DPI_EM_EvalQuote,NULL,NULL) ;
	      if (ipt == NULL)
	       { v_Msg(ctx,NULL,"TagEvalFail",intmodx,V4IM_Tag_AWhile,vtm->awpt) ; goto tally_fail ; } ;
	      if (ipt->Value.IntVal <= 0) break ;		/* FALSE = continue with next point */
	    } ;
	 } ;
	vtee->finishOK = TRUE ;

	return(TRUE) ;

tally_fail:
	vtee->finishOK = FALSE ;
	v4l_ListClose(ctx,vtee->lp) ;
	return(FALSE) ;

tallyctx_fail:
	v_Msg(ctx,NULL,"CtxAddFail",intmodx) ; goto tally_fail ;

}


struct V4DPI__Point *v4im_DoError(ctx,respnt,argpnts,argcnt,intmodx,trace)
  struct V4C__Context *ctx ;
  P *respnt ;						/* Ptr for result */
  INTMODX intmodx ;
  P *argpnts[] ;
  COUNTER argcnt ; VTRACE trace ;
{ P *cpt,*tpt,argbuf ;
  struct V4L__ListPoint *lp,*lp1 ;
  struct V4IM__Drawer *drw ;
  int ix,ok,tx,i ;

	if (argcnt == 0)				/* No arguments - return last saved error */
	 { uccharPNTv(respnt,gpi->SavedErrMsg) ; return(respnt) ; } ;
	memcpy(respnt,&Log_True,Log_True.Bytes) ;
	for (ix=1,ok=TRUE;ok&&ix<=argcnt;ix++)
	 { 
	   switch (tx=v4im_CheckPtArgNew(ctx,argpnts[ix],&cpt,&argbuf))
	    { default:			v_Msg(ctx,NULL,"TagBadUse",intmodx) ; goto fail ;
	      case V4IM_Tag_Unk:	v_Msg(ctx,NULL,"TagUnknown",intmodx) ; goto fail ;
	      case -V4IM_Tag_Count:	intPNTv(respnt,gpi->ErrCount) ; break ;
	      case V4IM_Tag_Count:	intPNTv(respnt,gpi->ErrCount) ; gpi->ErrCount = v4im_GetPointInt(&ok,cpt,ctx) ; if (gpi->ErrCount < 0) gpi->ErrCount = 0 ; break ;
	      case V4IM_Tag_Drawer:
		if (gpi->SavedErrMsg[0] == UCEOS) continue ;	/* If no saved error then skip */
		drw = v4im_GetDrawerPtr(cpt->Dim,cpt->Value.IntVal) ;
		if (drw == NULL) { v_Msg(ctx,NULL,"ModArgPntType2",intmodx,ix,cpt->PntType,V4DPI_PntType_Drawer) ; goto fail ; } ;
		uccharPNTv(respnt,gpi->SavedErrMsg) ;
		if (drw->Bytes + respnt->Bytes >= drw->maxBytes) { drw = v4im_ReallocDrawer(drw,UNUSED) ; } ;
		tpt = (P *)&drw->DrawerBuf ;
		for(i=0;i<drw->Points;i++)	/* Position to end of drawer */
		 { ADVPNT(tpt) ; } ;
		memcpy(tpt,respnt,respnt->Bytes) ; drw->Bytes += respnt->Bytes ; drw->Points ++ ;
		continue ;
	      case -V4IM_Tag_Error:
		uccharPNTv(respnt,gpi->SavedErrMsg) ; return(respnt) ;
	      case -V4IM_Tag_Intersection:
		uccharPNTv(respnt,gpi->SavedErrIsct) ; return(respnt) ;
	      case V4IM_Tag_ListOf:
		switch (v4im_GetDictToEnumVal(ctx,cpt))
		 { default:		v_Msg(ctx,NULL,"ErrorTag",intmodx,V4IM_Tag_ListOf,cpt) ; goto fail ;
		   case _Context:
			if (gpi->ved == NULL) { v_Msg(ctx,NULL,"ErrorNoData",intmodx) ; goto fail ; } ;
			INITLP(respnt,lp,Dim_List) ;
			for(i=0;gpi->ved->ctxpts[i]!=NULL;i++)
			 { v4l_ListPoint_Modify(ctx,lp,V4L_ListAction_Append,gpi->ved->ctxpts[i],0) ;
			 } ;
			ENDLP(respnt,lp)
			return(respnt) ;
		   case _Stack:
			if (gpi->ved == NULL) { v_Msg(ctx,NULL,"ErrorNoData",intmodx) ; goto fail ; } ;
			INITLP(respnt,lp,Dim_List) ;
			for(i=0;i<gpi->ved->lx;i++)
			 { P nlpnt ; double dnum ;
			   INITLP(&nlpnt,lp1,Dim_List) ;
			   uccharPNTv(&argbuf,(gpi->ved->level[i].errMsg == NULL ? UClit("") : gpi->ved->level[i].errMsg)) ;
			   v4l_ListPoint_Modify(ctx,lp1,V4L_ListAction_Append,&argbuf,0) ;
			   uccharPNTv(&argbuf,(gpi->ved->level[i].srcFile == NULL ? UClit("") : gpi->ved->level[i].srcFile)) ;
			   v4l_ListPoint_Modify(ctx,lp1,V4L_ListAction_Append,&argbuf,0) ;
			   dnum = (double)gpi->ved->level[i].lineNumber / 10.0 ; dblPNTv(&argbuf,dnum) ;
			   v4l_ListPoint_Modify(ctx,lp1,V4L_ListAction_Append,&argbuf,0) ;
			   ENDLP(&nlpnt,lp1) ;
			   v4l_ListPoint_Modify(ctx,lp,V4L_ListAction_Append,&nlpnt,0) ;
			 } ;
			ENDLP(respnt,lp)
			return(respnt) ;
		 }
		continue ;
	      case V4IM_Tag_Message:
		v4im_GetPointUC(&ok,UCTBUF1,V4TMBufMax,cpt,ctx) ; if (!ok) break ;
		UCstrcpy(gpi->SavedErrMsg,UCTBUF1) ; ZUS(gpi->SavedErrIsct) ; gpi->SavedIntModx = V4IM_OpCode_Error ;
		continue ;
	      case -V4IM_Tag_Module:
		ZPH(respnt) ; respnt->Dim = Dim_IntMod ; respnt->PntType = V4DPI_PntType_IntMod ; respnt->Bytes = V4PS_Int ;
		respnt->Value.IntVal = gpi->SavedIntModx ; return(respnt) ;
	      case -V4IM_Tag_Reset:
		ZUS(gpi->SavedErrMsg) ; ZUS(gpi->SavedErrIsct) ; gpi->SavedIntModx = 0 ;
		gpi->ErrCount = 0 ;
		continue ;
	      case -V4IM_Tag_Warning:
		INITLP(respnt,lp,Dim_List) ;
		intPNTv(&argbuf,gpi->WarnCount) ; v4l_ListPoint_Modify(ctx,lp,V4L_ListAction_Append,&argbuf,0) ;
		uccharPNTv(&argbuf,gpi->WarnMsg) ; v4l_ListPoint_Modify(ctx,lp,V4L_ListAction_Append,&argbuf,0) ;
		ENDLP(respnt,lp)
		return(respnt) ;
	      case V4IM_Tag_Warning:	intPNTv(respnt,gpi->WarnCount) ; gpi->WarnCount = v4im_GetPointInt(&ok,cpt,ctx) ; if (gpi->WarnCount < 0) gpi->ErrCount = 0 ; break ;
		
	    } ;
	   if (!ok) { v_Msg(ctx,NULL,"ModInvArg",intmodx,ix) ; goto fail ; } ;
	 } ;
	return(respnt) ;

fail:	REGISTER_ERROR(0) ; return(NULL) ;
}

struct V4DPI__Point *v4im_DoFail(ctx,respnt,argpnts,argcnt,intmodx,trace)
  struct V4C__Context *ctx ;
  P *respnt ;						/* Ptr for result */
  INTMODX intmodx ;
  P *argpnts[] ;
  COUNTER argcnt ; VTRACE trace ;
{ P *cpt,argbuf ;
  INDEX ix ; LOGICAL ok ;
  static UCCHAR failBuf[1024] ; UCCHAR fBuf[1024] ;

	ZUS(fBuf)
	for (ix=1,ok=TRUE;ok&&ix<=argcnt;ix++)
	 { 
	   if (argpnts[ix]->PntType != V4DPI_PntType_TagVal)
	    { v4im_GetPointUC(&ok,UCTBUF1,V4DPI_AlphaVal_Max,argpnts[ix],ctx) ;
	      if (!ok) v4dpi_PointToString(UCTBUF1,argpnts[ix],ctx,V4DPI_FormatOpt_Trace) ;	/* If can't format nicely then format as V4 point */
	      if (UCstrlen(fBuf) + UCstrlen(UCTBUF1) < UCsizeof(fBuf)) UCstrcat(fBuf,UCTBUF1) ;
	      continue ;
	    } ;
	   switch (v4im_CheckPtArgNew(ctx,argpnts[ix],&cpt,&argbuf))
	    { default:			v_Msg(ctx,NULL,"TagBadUse",intmodx) ; goto fail ;
	      case V4IM_Tag_Unk:	v_Msg(ctx,NULL,"TagUnknown",intmodx) ; goto fail ;
	      case -V4IM_Tag_Message:	if (UCempty(failBuf)) { v_Msg(ctx,NULL,"FailNoPrior",intmodx) ; goto fail ; } ;
					uccharPNTv(respnt,failBuf) ; return(respnt) ;
	      case -V4IM_Tag_Reset:	ZUS(failBuf) ; logPNTv(respnt,TRUE) ; return(respnt) ;
	    } ;
	   if (!ok) { v_Msg(ctx,NULL,"ModInvArg",intmodx,ix) ; goto fail ; } ;
	 } ;
/*	Do we have a new failure (i.e. fBuf not empty) ? */
	if (UCnotempty(fBuf))
	 { UCstrcpy(failBuf,fBuf) ;		/* Save fail message */
	   UCstrcpy(ctx->ErrorMsg,fBuf) ; UCstrcpy(gpi->SavedErrMsg,ctx->ErrorMsg) ;
	   goto fail ;
	 } ;
/*	Don't have new message, fail with generic message (prior to rev 625 Fail() would with no arguments would return previous error message) */
//	uccharPNTv(respnt,failBuf) ; return(respnt) ;
	UCstrcpy(ctx->ErrorMsg,UClit("failed for unspecified reason")) ; UCstrcpy(gpi->SavedErrMsg,UClit("failed for unspecified reason")) ;
	goto fail ;

fail:	REGISTER_ERROR(0) ; return(NULL) ;
}

struct V4DPI__Point *v4im_DoCounter(ctx,respnt,argpnts,argcnt,intmodx)
  struct V4C__Context *ctx ;
  P *respnt ;						/* Ptr for result */
  INTMODX intmodx ;
  P *argpnts[] ;
  COUNTER argcnt ;
{ P *cpt,argbuf ;
  int ix,tx,ok,i,hx,value ;
#define LCL_COUNTER_MAX 4001
  struct lcl__Counters {
    int Count ;					/* Number of entries below */
    struct {
      int Id ;					/* "Id" of counter (Value.IntVal of corresponding NId point */
      int Value ;				/* Counter's value */
     } Entry[LCL_COUNTER_MAX+5] ;
   } ;
  static struct lcl__Counters *Counters = NULL ;
#ifdef V4ENABLEMULTITHREADS
  static DCLSPINLOCK cntLock = UNUSEDSPINLOCKVAL ;
#endif

	GRABMTLOCK(cntLock) ;
	for (ix=1,ok=TRUE;ok&&ix<=argcnt;ix++)
	 { 
	   switch (tx=v4im_CheckPtArgNew(ctx,argpnts[ix],&cpt,&argbuf))
	    { default:			v_Msg(ctx,NULL,"TagBadUse",intmodx) ; goto fail ;
	      case V4IM_Tag_Unk:	v_Msg(ctx,NULL,"TagUnknown",intmodx) ; goto fail ;
	      case V4IM_Tag_Next:
	      case V4IM_Tag_Count:
	      case V4IM_Tag_Reset:
	      case V4IM_Tag_First:
		switch (cpt->PntType)
		 { default:		v_Msg(ctx,NULL,"ModArgPntType3",intmodx,ix,cpt->PntType,V4DPI_PntType_Int,V4DPI_PntType_Dict) ; goto fail ;
		   case V4DPI_PntType_Dict: case V4DPI_PntType_XDict:
		   CASEofINT		break ;
		 } ;
		if (Counters == NULL)
		 { Counters = (struct lcl__Counters *)v4mm_AllocChunk(sizeof *Counters,TRUE) ;
		   for(i=0;i<LCL_COUNTER_MAX;i++) Counters->Entry[i].Value = UNUSED ;
		 } ;
		if (Counters->Count >= LCL_COUNTER_MAX) { v_Msg(ctx,NULL,"NumMaxCounter",intmodx,LCL_COUNTER_MAX) ; goto fail ; } ;
		hx = (cpt->Value.IntVal & 0x7fffffff) % LCL_COUNTER_MAX ;
		for(;;hx=(++hx % LCL_COUNTER_MAX))
		 { if (Counters->Entry[hx].Value == UNUSED)
		    { Counters->Count++ ; Counters->Entry[hx].Id = cpt->Value.IntVal ; Counters->Entry[hx].Value = 0 ; break ; } ;
		   if (Counters->Entry[hx].Id == cpt->Value.IntVal) break ;
		 } ;
		switch(tx)
		 { case V4IM_Tag_Count:	intPNTv(respnt,Counters->Entry[hx].Value) ; goto retok ;
		   case V4IM_Tag_First:	logPNTv(respnt,(++Counters->Entry[hx].Value) == 1) ; goto retok ;
		   case V4IM_Tag_Next:	intPNTv(respnt,++Counters->Entry[hx].Value) ; goto retok ;
		   case V4IM_Tag_Reset:	if (ix == argcnt) { value = 0 ; }
					 else { value = v4im_GetPointInt(&ok,argpnts[++ix],ctx) ; if (!ok) break ; } ;
					intPNTv(respnt,(Counters->Entry[hx].Value = value)) ; goto retok ;
		 } ;
		break ;
	    } ;
	   if (!ok){ v_Msg(ctx,NULL,"ModInvArg",intmodx,ix) ; goto fail ; } ;
	 } ;
retok:	FREEMTLOCK(cntLock) ;
	return(respnt) ;

fail:	FREEMTLOCK(cntLock) ;
	REGISTER_ERROR(0) ; return(NULL) ;
}


struct V4DPI__Point *v4im_DoNum(ctx,respnt,argpnts,argcnt,intmodx)
  struct V4C__Context *ctx ;
  P *respnt ;						/* Ptr for result */
  INTMODX intmodx ;
  P *argpnts[] ;
  COUNTER argcnt ;
{ P *cpt,argbuf ;
  struct V4DPI__DimInfo *di,*sdi ;
  struct V4L__ListPoint *lp ;
  struct V4L__ListCmpndRange *lcr ;
  struct V4L__ListCmpndRangeDBL *lcrd ;
  struct V4DPI__Point_IntMix *pim ;
  struct V4DPI__Point_RealMix *prm ;
  int ix,tx,ok,i,wantNum,haveReal ; int inum,inum1 ; double dnum,dnum1 ;
  struct {						/* Temp num structure (ns) */
    int Count ;
    struct {
      double Begin,End,Increment ;
      int Number,Setup ;
     } Entry[V4DPI_PointIntMix_Max] ;
   } ns ;

	di = NULL ; ns.Count = 0 ; ns.Entry[ns.Count].Setup = FALSE ; wantNum = FALSE ; haveReal = FALSE ; sdi = NULL ;
	for (ix=1,ok=TRUE;ok&&ix<=argcnt;ix++)
	 { if (argpnts[ix]->PntType != V4DPI_PntType_TagVal)
	    { if (argpnts[ix]->Dim == Dim_Dim) { DIMINFO(di,ctx,argpnts[ix]->Value.IntVal) ; sdi = di ; continue ; } ;
	      if (di == NULL) { DIMINFO(di,ctx,argpnts[ix]->Dim) ; } ;
	      if (ns.Entry[ns.Count].Setup) { ns.Entry[++ns.Count].Setup = FALSE ; } ;
	      if (argpnts[ix]->Grouping == V4DPI_Grouping_Single)
	       { ns.Entry[ns.Count].Begin = v4im_GetPointDbl(&ok,argpnts[ix],ctx) ;
	         ns.Entry[ns.Count].End = ns.Entry[ns.Count].Begin ;
	       } else
	       { switch (argpnts[ix]->PntType)
	          { default:	ok = FALSE ; v_Msg(ctx,ctx->ErrorMsgAux,"NumMultPts",argpnts[ix]) ; break ;
		     CASEofINT
			pim = (struct V4DPI__Point_IntMix *)&argpnts[ix]->Value ;
			ns.Entry[ns.Count].Begin = pim->Entry[0].BeginInt ; ns.Entry[ns.Count].End = pim->Entry[0].EndInt ;
			break ;
		    case V4DPI_PntType_Calendar:
		    case V4DPI_PntType_Real:
			prm = (struct V4DPI__Point_RealMix *)&argpnts[ix]->Value ;
			memcpy(&ns.Entry[ns.Count].Begin,&prm->Entry[0].BeginReal,sizeof (double)) ;
			memcpy(&ns.Entry[ns.Count].End,&prm->Entry[0].EndReal,sizeof (double)) ;
			break ;
		  } ;
	       } ;
	      if (argpnts[ix]->PntType == V4DPI_PntType_Real || argpnts[ix]->PntType == V4DPI_PntType_Calendar) haveReal = TRUE ;
	       ns.Entry[ns.Count].Increment = 0 ;ns.Entry[ns.Count].Number = 0 ;
	      if (!ok) { v_Msg(ctx,NULL,"ModInvArg",intmodx,ix) ; goto fail ; } ;
	      ns.Entry[ns.Count].Setup = TRUE ;
	      continue ;
	    } ;
	   switch (tx=v4im_CheckPtArgNew(ctx,argpnts[ix],&cpt,&argbuf))
	    { default:			v_Msg(ctx,NULL,"TagBadUse",intmodx) ; goto fail ;
	      case V4IM_Tag_Unk:	v_Msg(ctx,NULL,"TagUnknown",intmodx) ; goto fail ;
	      case V4IM_Tag_Every:
	      case V4IM_Tag_By:
	        ns.Entry[ns.Count].Increment = v4im_GetPointDbl(&ok,cpt,ctx) ;
		if (cpt->PntType == V4DPI_PntType_Real) haveReal = TRUE ;
		if (ns.Entry[ns.Count].Increment == 0)
		 { v_Msg(ctx,ctx->ErrorMsgAux,"NumByZero",V4IM_Tag_By) ; ok = FALSE ; } ;
		break ;
	      case V4IM_Tag_To:
		if (ns.Entry[ns.Count].Number != 0)
		 { v_Msg(ctx,ctx->ErrorMsgAux,"ModOnlyOne",V4IM_Tag_Number,V4IM_Tag_To) ; ok = FALSE ; break ; } ;
		if (cpt->PntType == V4DPI_PntType_Real || cpt->PntType == V4DPI_PntType_Calendar) haveReal = TRUE ;
	        switch (cpt->PntType)
	          { default:	ns.Entry[ns.Count].End = v4im_GetPointDbl(&ok,cpt,ctx) ; break ;
		     CASEofINT	ns.Entry[ns.Count].End = (double)cpt->Value.IntVal ; break ;
		  } ;
		break ;
	      case -V4IM_Tag_ListOf:
		INITLP(respnt,lp,Dim_List) ;
		v4im_GetPointUC(&ok,UCTBUF1,V4DPI_UCVAL_MaxSafe,argpnts[1],ctx) ; if (!ok) break ;
		for(i=0;UCTBUF1[i]!=UCEOS;i++)
		 { struct V4DPI__LittlePoint spnt ;   enum DictionaryEntries deval ;
		   switch (UCTBUF1[i])
		    { default:
			{ UCCHAR tbuf[2] ; tbuf[0] = UCTBUF1[i] ; tbuf[1] = UCEOS ; uccharPNTv((P *)&spnt,tbuf) ; }
			v4l_ListPoint_Modify(ctx,lp,V4L_ListAction_Append,(P *)&spnt,0) ;
			continue ;
		      case UClit('0'): case UClit('1'): case UClit('2'): case UClit('3'): case UClit('4'): case UClit('5'): case UClit('6'): case UClit('7'): case UClit('8'): case UClit('9'):
			intPNTv(&spnt,UCTBUF1[i]-UClit('0')) ;
			v4l_ListPoint_Modify(ctx,lp,V4L_ListAction_Append,(P *)&spnt,0) ;
			continue ;
		      case UClit('-'):	deval = _Minus ; break ;
		      case UClit('.'):	deval = _Dot ; break ;
		      case UClit('+'):	deval = _Plus ; break ;
		      case UClit('e'):
		      case UClit('E'):	deval = _Exponent ; break ;
		    } ;
		   dictPNTv(&spnt,Dim_UV4,v4im_GetEnumToDictVal(ctx,deval,Dim_UV4)) ;
		   v4l_ListPoint_Modify(ctx,lp,V4L_ListAction_Append,(P *)&spnt,0) ;
		 } ;
		ENDLP(respnt,lp) ; return(respnt) ;
	      case V4IM_Tag_Num:
	      case V4IM_Tag_Number:
		if (ns.Entry[ns.Count].End != ns.Entry[ns.Count].Begin)
		 { v_Msg(ctx,ctx->ErrorMsgAux,"ModOnlyOne",V4IM_Tag_Number,V4IM_Tag_To) ; ok = FALSE ; break ; } ;
		ns.Entry[ns.Count].Number = v4im_GetPointInt(&ok,cpt,ctx) ;
		if (ok && ns.Entry[ns.Count].Number <= 0)
		 { v_Msg(ctx,ctx->ErrorMsgAux,"NumNumLE0",V4IM_Tag_Number,cpt) ; ok = FALSE ; break ; } ;
		break ;
	      case V4IM_Tag_Round:
		if (cpt->PntType == V4DPI_PntType_Dict || cpt->PntType == V4DPI_PntType_XDict)
		 { switch (v4im_GetDictToEnumVal(ctx,cpt))
		    { default:		v_Msg(ctx,NULL,"ModTagValue",intmodx,ix,V4IM_Tag_Round,cpt) ; goto fail ;
		      case _Down:	dnum = floor(ns.Entry[ns.Count].Begin) ; goto return_res ;
		      case _Up:		dnum = ceil(ns.Entry[ns.Count].Begin) ; goto return_res ;
		    } ; break ;
		 } ;
		switch (argpnts[1]->PntType)
		 { default:		v_Msg(ctx,NULL,"ModArgPntType",intmodx,ix,argpnts[1],argpnts[1]->PntType) ; goto fail ;
		   CASEofINT
		     inum = argpnts[1]->Value.IntVal ;
		     inum1 = v4im_GetPointInt(&ok,cpt,ctx) ; if (!ok) break ; if (inum1 < 1) inum1 = 1 ;
		     if (inum < 0) inum1 = -inum1 ;
		     intPNTv(respnt,((inum + (inum1 / 2)) / inum1) * inum1) ; respnt->Dim = argpnts[1]->Dim ;
		     return(respnt) ;
		   CASEofDBL
		     GETREAL(dnum,argpnts[1]) ;
		     dnum1 = v4im_GetPointDbl(&ok,cpt,ctx) ; if (!ok) break ;
		     if (dnum1 <= 0) { memcpy(respnt,argpnts[1],argpnts[1]->Bytes) ; return(respnt) ; } ;
		     dnum /= dnum1 ;
		     { double idbl, fdbl ;
		       fdbl = modf(dnum, &idbl) ;
		       if (fdbl >= 0.5) { idbl += 1 ; } else if (fdbl <= -0.5) { idbl -= 1 ; } ;
		       dnum = idbl * dnum1 ;
		     }
		     dblPNTv(respnt,dnum) ; respnt->Dim = argpnts[1]->Dim ;
		     return(respnt) ;
		 } ;
		break ;
	      case -V4IM_Tag_Num:
	      case -V4IM_Tag_Number:
		wantNum = TRUE ; DIMINFO(di,ctx,Dim_Int) ; break ;
	      case -V4IM_Tag_Sign:
		intPNTv(respnt,(ns.Entry[ns.Count].Begin < 0 ? -1 : (ns.Entry[ns.Count].Begin > 0 ? 1 : 0))) ;
		return(respnt) ;
	      case V4IM_Tag_Prime:
		intPNTv(respnt,v_CvtToPrime(v4im_GetPointInt(&ok,cpt,ctx))) ;
		return(respnt) ;
	      case -V4IM_Tag_Prime:
		inum1 = v_CvtToPrime(inum = (int)ns.Entry[ns.Count].Begin) ;
		logPNTv(respnt,(inum1 == inum)) ; return(respnt) ;
	      case -V4IM_Tag_Abs:
		dnum = (ns.Entry[ns.Count].Begin < 0 ? -ns.Entry[ns.Count].Begin : ns.Entry[ns.Count].Begin) ;
		goto return_res ;
	      case -V4IM_Tag_Negate:
	        dnum = -ns.Entry[ns.Count].Begin ; goto return_res ;
	      case -V4IM_Tag_Fractional:
	        dnum = modf(ns.Entry[ns.Count].Begin, &dnum1) ; goto return_res ;
	      case -V4IM_Tag_Integral:
	        dnum = floor(ns.Entry[ns.Count].Begin) ; goto return_res ;
	    } ;
	   if (!ok)
	    { v_Msg(ctx,NULL,"ModInvArg",intmodx,ix) ; goto fail ; } ;
	 } ;

	if (ns.Entry[ns.Count].Setup) ns.Count++ ;
	if (sdi != NULL) di = sdi ;
	if (haveReal && di == NULL) { DIMINFO(di,ctx,Dim_Num) ; } ;
	switch(di->PointType)
	 { default:
	     v_Msg(ctx,NULL,"NumDimNotNum",intmodx,di->DimId) ; goto fail ;
	   CASEofINT
	     if (haveReal) { v_Msg(ctx,NULL,"NumDimNotReal",intmodx,V4DPI_PntType_Real,V4DPI_PntType_Calendar,di->DimId) ; goto fail ; } ;
/*	     If we have simple case of single range of integers with increment of 1 then return a compound point, not a list */
	     if (ns.Count == 1 && ns.Entry[0].Increment == 0 && (ns.Entry[0].Number > 0 || ns.Entry[0].Begin < ns.Entry[0].End))
	      { struct V4DPI__Point_IntMix *pim ; pim = (struct V4DPI__Point_IntMix *)&respnt->Value ;
	        intPNT(respnt) ; respnt->Dim = di->DimId ; respnt->PntType = di->PointType ; respnt->Grouping = 1 ;
		pim->Entry[0].BeginInt = ns.Entry[0].Begin ;
		if (ns.Entry[0].Number > 0)
		 { pim->Entry[0].EndInt = ns.Entry[0].Begin + ns.Entry[0].Number - 1 ; }
		 else { pim->Entry[0].EndInt = ns.Entry[0].End ; } ;
		respnt->Bytes = (char *)&pim->Entry[1] - (char *)respnt ;
		return(respnt) ;
	      } ;
	     INITLP(respnt,lp,Dim_List) lp->Dim = di->DimId ;
	     lp->ListType = V4L_ListType_CmpndRange ; lp->PntType = di->PointType ;
	     lcr = (struct V4L__ListCmpndRange *)&lp->Buffer[0] ; lcr->Entries = 0 ; lcr->Count = 0 ;
	     for(dnum=0,i=0;i<ns.Count;i++)
	      { 
		if (ns.Entry[i].Number > 0)
		 { if (ns.Entry[i].Increment == 0) ns.Entry[i].Increment = 1 ;
		   ns.Entry[i].End = ns.Entry[i].Begin + (ns.Entry[i].Increment * (ns.Entry[i].Number - 1)) ;
		 } ;
		if (ns.Entry[i].Increment == 0) { ns.Entry[i].Increment = (ns.Entry[i].Begin > ns.Entry[i].End ? -1 : 1) ; } ;
		if (ns.Entry[i].Begin > ns.Entry[i].End && ns.Entry[i].Increment > 0)
		 { v_Msg(ctx,NULL,"NumPosInc",intmodx,ns.Entry[i].Increment,ns.Entry[i].Begin,ns.Entry[i].End) ; goto fail ; } ;
		if (ns.Entry[i].Increment > 0)
		 { dnum += floor((ns.Entry[i].End - ns.Entry[i].Begin) / ns.Entry[i].Increment) + 1 ; }
		 else { dnum += floor((ns.Entry[i].End - ns.Entry[i].Begin) / ns.Entry[i].Increment) + 1 ; } ;
	        lcr->Cmpnd[lcr->Count].Begin = (int)ns.Entry[i].Begin ; lcr->Cmpnd[lcr->Count].End = (int)ns.Entry[i].End ;
	        lcr->Cmpnd[lcr->Count++].Increment = (int)ns.Entry[i].Increment ; lcr->Entries = (int)dnum ;
	      } ;
	     if (wantNum) goto return_res ;		/* dnum has count of entries */
	     lcr->Bytes = (char *)&lcr->Cmpnd[lcr->Count] - (char *)lcr ;
	     lp->Entries = lcr->Entries ; lp->Bytes = (char *)&lp->Buffer[ALIGN(lcr->Bytes)] - (char *)lp ;
	     ENDLP(respnt,lp) return(respnt) ;
	   case V4DPI_PntType_Calendar:
	   case V4DPI_PntType_Real:
	     INITLP(respnt,lp,Dim_List) lp->Dim = di->DimId ;
	     lp->ListType = V4L_ListType_CmpndRangeDBL ; lp->PntType = di->PointType ;
	     lcrd = (struct V4L__ListCmpndRangeDBL *)&lp->Buffer[0] ; lcrd->Entries = 0 ; lcrd->Count = 0 ;
	     for(dnum=0,i=0;i<ns.Count;i++)
	      { 
		if (ns.Entry[i].Number > 0)
		 { if (ns.Entry[i].Increment == 0) ns.Entry[i].Increment = 1 ;
		   ns.Entry[i].End = ns.Entry[i].Begin + (ns.Entry[i].Increment * (ns.Entry[i].Number - 1)) ;
		 } ;
		if (ns.Entry[i].Increment == 0) { ns.Entry[i].Increment = (ns.Entry[i].Begin > ns.Entry[i].End ? -1 : 1) ; } ;
		if (ns.Entry[i].Begin > ns.Entry[i].End && ns.Entry[i].Increment > 0)
		 { v_Msg(ctx,ctx->ErrorMsg,"NumPosInc",intmodx,ns.Entry[i].Increment,ns.Entry[i].Begin,ns.Entry[i].End) ; goto fail ; } ;
		dnum += floor((ns.Entry[i].End - ns.Entry[i].Begin) / ns.Entry[i].Increment) + 1 ;
	        lcrd->Cmpnd[lcrd->Count].Begin = ns.Entry[i].Begin ; lcrd->Cmpnd[lcrd->Count].End = ns.Entry[i].End ;
	        lcrd->Cmpnd[lcrd->Count++].Increment = ns.Entry[i].Increment ; lcrd->Entries = (int)dnum ;
	      } ;
	     if (wantNum) goto return_res ;		/* dnum has count of entries */
	     lcrd->Bytes = (char *)&lcrd->Cmpnd[lcrd->Count] - (char *)lcrd ;
	     lp->Entries = lcrd->Entries ; lp->Bytes = (char *)&lp->Buffer[ALIGN(lcrd->Bytes)] - (char *)lp ;
	     ENDLP(respnt,lp) return(respnt) ;
	     break ;
	 }

return_res:
	ZPH(respnt) ; respnt->Dim = di->DimId ; respnt->PntType = di->PointType ; gpi->PointBytes[respnt->PntType] ;
	switch (respnt->PntType)
	 { default:
	     v_Msg(ctx,NULL,"NumDimNotNum",intmodx,di->DimId) ; goto fail ;
	   CASEofINT
		respnt->Value.IntVal = DtoI(dnum) ; break ;
	   case V4DPI_PntType_Calendar:
	   case V4DPI_PntType_Real:
		PUTREAL(respnt,dnum) ; break ;
	 } ;
	return(respnt) ;

fail:	REGISTER_ERROR(0) ; return(NULL) ;
}

P *v4im_DoLocale(ctx,respnt,intmodx,argpnts,argcnt,trace)
  struct V4C__Context *ctx ;
  P *respnt ;						/* Ptr for result */
  INTMODX intmodx ;
  P *argpnts[] ;
  COUNTER argcnt ; VTRACE trace ;
{ P ptbuf,*cpt ;
  struct V4DPI__DimInfo *di ;
  struct V4CI__CountryInfo *ci ;
  enum DictionaryEntries deval ;
  int ix,ok,tz,i,j,calt ; UCCHAR ucbuf[128] ;

	ZPH(respnt) ;
	for (ok=TRUE,ix=1;ok&&ix<=argcnt;ix++)
	 { switch (v4im_CheckPtArgNew(ctx,argpnts[ix],&cpt,&ptbuf))
	    { default:			v_Msg(ctx,NULL,"TagBadUse",intmodx) ; goto locale_fail ;
	      case V4IM_Tag_Unk:	v_Msg(ctx,NULL,"TagUnknown",intmodx) ; goto locale_fail ;
	      case V4IM_Tag_Calendar:
		switch (v4im_GetDictToEnumVal(ctx,cpt))
		 { default:		ok = FALSE ; v_Msg(ctx,ctx->ErrorMsgAux,"CalNotValid",cpt) ; break ;
		   case _Gregorian:	calt = VCAL_CalType_Gregorian ; break ;
		   case _Julian:	calt = VCAL_CalType_Julian ; break ;
		   case _Islamic:	calt = VCAL_CalType_Islamic ; break ;
		   case _ISO:		calt = VCAL_CalType_ISO ; break ;
		   case _Hebrew:	calt = VCAL_CalType_Hebrew ; break ;
		   case _Chinese:	calt = VCAL_CalType_Chinese ; break ;
		   case _Hindu:		calt = VCAL_CalType_Hindu ; break ;
		 } ; if (ok == FALSE) break ;
		gpi->ci->Cntry[gpi->ci->CurX].Calendar = calt ;	/* Set it & fall thru to report back */
	      case -V4IM_Tag_Calendar:
		dictPNT(respnt,Dim_UV4) ;
		DIMINFO(di,ctx,respnt->Dim) ;
		switch(gpi->ci->Cntry[gpi->ci->CurX].Calendar)
		 { case VCAL_CalType_Gregorian:	respnt->Value.IntVal = v4im_GetEnumToDictVal(ctx,deval=_Gregorian,Dim_UV4) ; break ;
		   case VCAL_CalType_Julian:	respnt->Value.IntVal = v4im_GetEnumToDictVal(ctx,deval=_Julian,Dim_UV4) ; break ;
		   case VCAL_CalType_Islamic:	respnt->Value.IntVal = v4im_GetEnumToDictVal(ctx,deval=_Islamic,Dim_UV4) ; break ;
		   case VCAL_CalType_ISO:	respnt->Value.IntVal = v4im_GetEnumToDictVal(ctx,deval=_ISO,Dim_UV4) ; break ;
		   case VCAL_CalType_Hebrew:	respnt->Value.IntVal = v4im_GetEnumToDictVal(ctx,deval=_Hebrew,Dim_UV4) ; break ;
		   case VCAL_CalType_Chinese:	respnt->Value.IntVal = v4im_GetEnumToDictVal(ctx,deval=_Chinese,Dim_UV4) ; break ;
		   case VCAL_CalType_Hindu:	respnt->Value.IntVal = v4im_GetEnumToDictVal(ctx,deval=_Hindu,Dim_UV4) ; break ;
		 } ; return(respnt) ;
	      case V4IM_Tag_Country:
		ci = gpi->ci ;
		if (cpt->PntType == V4DPI_PntType_Int)
		 { for(i=0;i<ci->Count;i++) { if (ci->Cntry[i].UNCode == cpt->Value.IntVal) break ; } ;
		   if (i >= ci->Count) { ok = FALSE ; v_Msg(ctx,ctx->ErrorMsgAux,"CntryBadVal",cpt->Value.IntVal) ; break ; } ;
		   v_setCurrentCountry(ci,i) ;
		 } else
		 { v4im_GetPointUC(&ok,UCTBUF1,255,cpt,ctx) ; if (!ok) break ;
		   j = v_CountryNameToRef(UCTBUF1) ;
		   if (j == 0) { ok = FALSE ; v_Msg(ctx,ctx->ErrorMsgAux,"DPIAcpNoCntry2",V4IM_Tag_Country,UCTBUF1) ; break ; } ;
		   for(i=0;i<ci->Count;i++) { if (ci->Cntry[i].UNCode == j) break ; } ;
		   v_setCurrentCountry(ci,i) ;
		 } ;
		/* Fall thru to return (new) current country */
	      case -V4IM_Tag_Country:
		respnt->Dim = Dim_UCountry ; respnt->PntType = V4DPI_PntType_Country ; respnt->Bytes = V4PS_Int ;
		respnt->Value.IntVal = gpi->ci->Cntry[gpi->ci->CurX].UNCode ;
		return(respnt) ;
	      case V4IM_Tag_Language:
		ci = gpi->ci ;
		if (cpt->PntType == V4DPI_PntType_Int)
		 { for(i=0;i<ci->li->Count;i++) { if (ci->li->LI[i].Language == cpt->Value.IntVal) break ; } ;
		   if (i >= ci->li->Count) { ok = FALSE ; v_Msg(ctx,ctx->ErrorMsgAux,"DPIAcpNoLang",cpt->Value.IntVal) ; break ; } ;
		   ci->li->CurX = cpt->Value.IntVal ;
		 } else
		 { v4im_GetPointUC(&ok,ucbuf,UCsizeof(ucbuf),cpt,ctx) ; if (!ok) break ;
		   for(i=0;i<ci->li->Count;i++)
		    { if (UCstrcmpIC(ucbuf,ci->li->LI[i].LangId)==0) break ; 
		    } ;
		   if (i >= ci->li->Count) { ok = FALSE ; v_Msg(ctx,ctx->ErrorMsgAux,"DPIAcpNoLang2",ucbuf) ; break ; } ;
		   ci->li->CurX = ci->li->LI[i].Language ;
		 } ;
		/* Fall thru to return current language */
	      case -V4IM_Tag_Language:
		dictPNT(respnt,Dim_UV4) ; DIMINFO(di,ctx,respnt->Dim) ; ci = gpi->ci ;
		respnt->Value.IntVal = v4dpi_DictEntryGet(ctx,respnt->Dim,ci->li->LI[ci->li->CurX].LangId,di,NULL) ;
		return(respnt) ;
	      case V4IM_Tag_TimeZone:
		tz = v4im_GetPointInt(&ok,cpt,ctx) ; if (!ok) break ;
		if (tz < -12) tz += 24 ; if (tz > 12) tz -= 24 ;
		if (tz < -12 || tz > 12) { v_Msg(ctx,NULL,"ModArgRange",intmodx,ix,cpt,-12,12) ; goto locale_fail ; } ;
		gpi->MinutesWest = tz * -60 ;	/* Set and then fall thru */
	      case -V4IM_Tag_TimeZone:
		intPNTv(respnt,-(gpi->MinutesWest / 60)) ; return(respnt) ;
	    } ;
	 } ;
	if (!ok) { v_Msg(ctx,NULL,"ModInvArg",intmodx,ix-1) ; goto locale_fail ; } ;
locale_fail:
	REGISTER_ERROR(0) ; return(NULL) ;
}

struct V4DPI__Point *v4im_DoUOM(ctx,respnt,argpnts,argcnt,intmodx,trace)
  struct V4C__Context *ctx ;
  P *respnt ;						/* Ptr for result */
  INTMODX intmodx ;
  P *argpnts[] ;
  COUNTER argcnt ; VTRACE trace ;
{ P *cpt,argbuf ;
  struct V4L__ListPoint *lp ;
  struct V4DPI__UOMTable *uomt ;
  struct V4DPI_UOMDetails *uomd  ;
  struct V4DPI__Value_UOM *uom,zuom ;
  struct V4DPI__Value_UOMPer *uomp ;
  struct V4DPI__Value_UOMPUOM *uompu ;
  int index = UNUSED ;
  char buf[64] ; UCCHAR adbuf[UCsizeof(uomd->UEntry[index].PSStr)], ucbuf[64],*ucb ;
  int ix,i,num,ok,udim ; double dnum,dfactor,preOffset,postOffset ;

	ix = 0 ;
restart_on_reset:
	uomd = NULL ; uom = NULL ; uomp = NULL ; uompu = NULL ;
	if (gpi->uomt == NULL) { v4dpi_UOMInitialize(ctx,UNUSED) ; } ;
	uomt = gpi->uomt ;

	for (++ix,ok=TRUE;ok&&ix<=argcnt;ix++)
	 { if (argpnts[ix]->PntType != V4DPI_PntType_TagVal)
	    { if (argpnts[ix]->PntType == V4DPI_PntType_UOM) { udim = argpnts[ix]->Dim ; uom = (struct V4DPI__Value_UOM *)&argpnts[ix]->Value ; }
	       else if (argpnts[ix]->PntType == V4DPI_PntType_UOMPer) { udim = argpnts[ix]->Dim ; uomp = (struct V4DPI__Value_UOMPer *)&argpnts[ix]->Value ; }
	       else if (argpnts[ix]->PntType == V4DPI_PntType_UOMPUOM) { uompu = (struct V4DPI__Value_UOMPUOM *)&argpnts[ix]->Value ; }
	       else if ((argpnts[ix]->PntType == V4DPI_PntType_Int && argpnts[ix]->Value.IntVal == 0))
		      { memset(&zuom,0,sizeof zuom) ; uom = &zuom ; }
	       else { v_Msg(ctx,NULL,"ModArgPntType3",intmodx,ix,argpnts[ix]->PntType,V4DPI_PntType_UOM,V4DPI_PntType_UOMPer) ; goto uom_fail ; } ;
	      continue ;
	    } ;
	   switch (i=v4im_CheckPtArgNew(ctx,argpnts[ix],&cpt,&argbuf))
	    { default:			v_Msg(ctx,NULL,"TagBadUse",intmodx) ; goto uom_fail ;
	      case V4IM_Tag_Unk:	v_Msg(ctx,NULL,"TagUnknown",intmodx) ; goto uom_fail ;
	      case -V4IM_Tag_Reset:
		if (uomd == NULL)	/* If no Id::num specified then reset all */
		 { for(i=0;i<uomt->Count;i++) { v4mm_FreeChunk(uomt->Entry[uomt->Count].uomd) ; } ;
		   v4mm_FreeChunk(uomt) ; gpi->uomt = NULL ; if (ix < argcnt) goto restart_on_reset ;
		 } else
		 { for(i=1;i<uomt->Count;i++) { if (uomt->Entry[i].Ref == uomd->Ref) break ; } ;
		   v4mm_FreeChunk(uomd) ;
		   for(ix=i+1;ix<uomt->Count;ix++) { uomt->Entry[ix-1] = uomt->Entry[ix] ; } ;
		   uomt->Count-- ;
		   goto restart_on_reset ;
		 } ;
		break ;
	      case V4IM_Tag_Id:		/* Id::num */
		if (cpt->PntType != V4DPI_PntType_Int)
		 { v4im_GetPointUC(&ok,ucbuf,UCsizeof(ucbuf),cpt,ctx) ;
		   for(i=0;i<uomt->Count;i++) { if (UCstrcmp(uomt->Entry[i].uomd->Name,ucbuf) == 0) break ; } ;
		   if (i < uomt->Count) { uomd = uomt->Entry[i].uomd ; break ; } ;
		   v_Msg(ctx,NULL,"UOMNoEntry",intmodx,buf) ; goto uom_fail ;
		 } ;
		num = v4im_GetPointInt(&ok,cpt,ctx) ; if (!ok) break ;
		for(i=0;i<uomt->Count;i++) { if (uomt->Entry[i].Ref == num) break ; } ;
		if (i >= uomt->Count)			/* Have to add new entry? */
		 { if (uomt->Count >= V4DPI_UOMTable_Max) { v_Msg(ctx,NULL,"UOMMaxEntries",intmodx,V4DPI_UOMTable_Max) ; goto uom_fail ; } ;
		   uomd = (struct V4DPI_UOMDetails *)v4mm_AllocChunk(sizeof *uomd,TRUE) ;
		   uomt->Entry[uomt->Count].Ref = num ; uomt->Entry[uomt->Count].uomd = uomd ;
		   uomd->DfltAcceptX = UNUSED ; uomd->DfltDispX = UNUSED ; uomd->Ref = num ; uomd->Rounding = 9999 ;
		   uomd->Attributes = V4DPI_UOMAttr_CoMingle + V4DPI_UOMAttr_FractionOK + V4DPI_UOMAttr_DisplayPSfix;
		   i = (uomt->Count++) ; 
		 } ;
		uomd = uomt->Entry[i].uomd ;
		break ;
	      case V4IM_Tag_Description:
		if (uomd == NULL) { v_Msg(ctx,NULL,"IdNoneGiven",intmodx) ; goto uom_fail ; } ;
		v4im_GetPointUC(&ok,uomd->Desc,UCsizeof(uomd->Desc),cpt,ctx) ;
		break ;
	      case V4IM_Tag_Name:
		if (uomd == NULL) { v_Msg(ctx,NULL,"IdNoneGiven",intmodx) ; goto uom_fail ; } ;
		v4im_GetPointUC(&ok,uomd->Name,UCsizeof(uomd->Name),cpt,ctx) ;
		break ;
	      case V4IM_Tag_Type:
		if (uomd == NULL) { v_Msg(ctx,NULL,"IdNoneGiven",intmodx) ; goto uom_fail ; } ;
		if (cpt->Bytes > sizeof uomd->TypePt)
		 { v_Msg(ctx,NULL,"ModArgPntType3",intmodx,ix,cpt->PntType,V4DPI_PntType_Int,V4DPI_PntType_Dict) ; goto uom_fail ;
		 } ;
		memcpy(&uomd->TypePt,cpt,cpt->Bytes) ;
		break ;
	      case V4IM_Tag_Index:
		if (uomd == NULL) { v_Msg(ctx,NULL,"IdNoneGiven",intmodx) ; goto uom_fail ; } ;
		num = v4im_GetPointInt(&ok,cpt,ctx) ; if (!ok) break ;
		for(i=0;i<uomd->Count;i++) { if (uomd->UEntry[i].Index == num) break ; } ;
		if (i >= uomd->Count)
		 { if (uomd->Count >= V4DPI_UOMDetails_Max) { v_Msg(ctx,NULL,"UOMMaxEntries",intmodx,V4DPI_UOMDetails_Max) ; goto uom_fail ; } ;
		   uomd->UEntry[uomd->Count].Index = num ;
		   i = (uomd->Count++) ;
		 } ;
		index = i ;
		break ;
	      case V4IM_Tag_Round:
		if (uomd == NULL) { v_Msg(ctx,NULL,"IdNoneGiven",intmodx) ; goto uom_fail ; } ;
		num = v4im_GetPointInt(&ok,cpt,ctx) ;
		uomd->Rounding = num ;
		break ;
	      case V4IM_Tag_Factor:
		if (index == UNUSED) { v_Msg(ctx,NULL,"UOMNoIndex",intmodx,V4IM_Tag_Factor,V4IM_Tag_Index) ; goto uom_fail ; } ;
		if (cpt->PntType != V4DPI_PntType_List)
		 { uomd->UEntry[index].Factor = v4im_GetPointDbl(&ok,cpt,ctx) ; uomd->UEntry[index].preOffset = 0 ; uomd->UEntry[index].postOffset = 0 ;
		 } else
		 { lp = (struct V4L__ListPoint *)&cpt->Value ;
#define UOMF(NAME,INDEX) \
 { P ptbuf ; int res = v4l_ListPoint_Value(ctx,lp,INDEX,&ptbuf) ; if (res == 0 || res == LISTVALERR) { v_Msg(ctx,NULL,"ListGetErr1",intmodx,INDEX,cpt) ; goto uom_fail ; } ; \
   uomd->UEntry[index].NAME = v4im_GetPointDbl(&ok,&ptbuf,ctx) ; \
 }
		   UOMF(Factor,1) UOMF(preOffset,2) UOMF(postOffset,3)
		 } ;
		break ;
	      case V4IM_Tag_Format:
		if (uomd == NULL) { v_Msg(ctx,NULL,"IdNoneGiven",intmodx) ; goto uom_fail ; } ;
		num = v4im_GetPointInt(&ok,cpt,ctx) ; if (!ok) break ;
		if (num > 0) { uomd->Attributes |= V4DPI_UOMAttr_DisplayPSfix ; }
		 else { uomd->Attributes &= ~V4DPI_UOMAttr_DisplayPSfix ; } ;
		break ;
	      case V4IM_Tag_Count:
		if (uomd == NULL) { v_Msg(ctx,NULL,"IdNoneGiven",intmodx) ; goto uom_fail ; } ;
		num = v4im_GetPointInt(&ok,cpt,ctx) ;
		uomd->CaseCount = num ;
		break ;
	      case V4IM_Tag_Label:
		if (index == UNUSED) { v_Msg(ctx,NULL,"UOMNoIndex",intmodx,V4IM_Tag_Label,V4IM_Tag_Index) ; goto uom_fail ; } ;
		v4im_GetPointUC(&ok,ucbuf,UCsizeof(ucbuf),cpt,ctx) ;
		if (ucbuf[0] == UClit('+')) { ucb = &ucbuf[1] ; uomd->UEntry[index].Prefix = TRUE ; }
		 else if (ucbuf[0] == UClit('-')) { ucb = &ucbuf[1] ; }
		 else { ucb = ucbuf ; } ;
		UCstrncpy(uomd->UEntry[index].PSStr,ucb,UCsizeof(uomd->UEntry[index].PSStr)-1) ;
		break ;
	      case V4IM_Tag_CoMingle:
		if (uomd == NULL) { v_Msg(ctx,NULL,"IdNoneGiven",intmodx) ; goto uom_fail ; } ;
		num = v4im_GetPointInt(&ok,cpt,ctx) ;
		if (num > 0) { uomd->Attributes |= V4DPI_UOMAttr_CoMingle ; }
		 else { uomd->Attributes &= ~V4DPI_UOMAttr_CoMingle ; } ;
		break ;
	      case V4IM_Tag_Partial:
		if (uomd == NULL) { v_Msg(ctx,NULL,"IdNoneGiven",intmodx) ; goto uom_fail ; } ;
		num = v4im_GetPointInt(&ok,cpt,ctx) ;
		if (num > 0) { uomd->Attributes |= V4DPI_UOMAttr_FractionOK ; }
		 else { uomd->Attributes &= ~V4DPI_UOMAttr_FractionOK ; } ;
		break ;
	      case V4IM_Tag_Acceptor:
		if (uomd == NULL) { v_Msg(ctx,NULL,"IdNoneGiven",intmodx) ; goto uom_fail ; } ;
		v4im_GetPointUC(&ok,adbuf,sizeof adbuf,cpt,ctx) ;
		for(i=0;i<uomd->Count;i++) { if (UCstrcmp(adbuf,uomd->UEntry[i].PSStr) == 0) break ; } ;
		if (i >= uomd->Count) { v_Msg(ctx,NULL,"UOMUndefDflt",intmodx,V4IM_Tag_Acceptor,adbuf) ; goto uom_fail ; } ;
		uomd->DfltAcceptX = i ;
		break ;
	      case V4IM_Tag_Displayer:
		if (uomd == NULL) { v_Msg(ctx,NULL,"IdNoneGiven",intmodx) ; goto uom_fail ; } ;
		v4im_GetPointUC(&ok,adbuf,sizeof adbuf,cpt,ctx) ;
		if (UCstrcmp(adbuf,UClit("ASIS")) == 0) { uomd->DfltDispX = UNUSED ; break ; } ;
		for(i=0;i<uomd->Count;i++) { if (UCstrcmp(adbuf,uomd->UEntry[i].PSStr) == 0) break ; } ;
		if (i >= uomd->Count) { v_Msg(ctx,NULL,"UOMUndefDflt",intmodx,V4IM_Tag_Displayer,adbuf) ; goto uom_fail ; } ;
		uomd->DfltDispX = i ;
		break ;
	      case -V4IM_Tag_Id:
		if (uomd == NULL)
		 { if (uom == NULL)
		    { INITLP(respnt,lp,Dim_List) ZPH(&argbuf) ; intPNT(&argbuf) ;
		      for(i=0;i<uomt->Count;i++)
		       { argbuf.Value.IntVal = uomt->Entry[i].Ref ;
		         v4l_ListPoint_Modify(ctx,lp,V4L_ListAction_Append,&argbuf,0) ;
		       } ;
		      ENDLP(respnt,lp)
		      return(respnt) ;
		    } ;
		   for(i=0;i<uomt->Count;i++) { if (uomt->Entry[i].Ref == uom->Ref) break ; } ;
		   if (i >= uomt->Count) { v_Msg(ctx,NULL,"UOMNoIntEntry",intmodx,uom->Ref) ; goto uom_fail ; } ;
		   uomd = uomt->Entry[i].uomd ;
		 } ;
		intPNTv(respnt,uomd->Ref) ; return(respnt) ;
	      case -V4IM_Tag_Round:
		if (uomd == NULL) { v_Msg(ctx,NULL,"IdNoneGiven",intmodx) ; goto uom_fail ; } ;
		intPNTv(respnt,uomd->Rounding) ; return(respnt) ;
	      case -V4IM_Tag_Factor:
		if (index == UNUSED)
		 { if (uom == NULL && uomp != NULL) uom = (struct V4DPI__Value_UOM *)uomp ;
		   if (uom == NULL) { v_Msg(ctx,NULL,"UOMPriorUOMI",intmodx,-V4IM_Tag_Factor,V4IM_Tag_Num,V4DPI_PntType_UOM) ; goto uom_fail ; } ;
		   if (uom->Index < 0) { dnum = -uom->Index ; dblPNTv(respnt,dnum) ; return(respnt) ; } ;
		   for(i=0;i<uomt->Count;i++) { if (uomt->Entry[i].Ref == uom->Ref) break ; } ;
		   if (i >= uomt->Count) { v_Msg(ctx,NULL,"UOMNoIntEntry",intmodx,uom->Ref) ; goto uom_fail ; } ;
		   uomd = uomt->Entry[i].uomd ;
		   if (uomd->DfltDispX == UNUSED)
		    { for(i=0;i<uomd->Count;i++) { if (uomd->UEntry[i].Index == uom->Index) break ; } ;
		      if (i >= uomd->Count) { v_Msg(ctx,NULL,"UOMNoIdxEntry",intmodx,uom->Index) ; goto uom_fail ; } ;
		    } else { i = uomd->DfltDispX ; } ;
		 } else { i = index ; } ;
		if (uomd->UEntry[i].preOffset == 0 && uomd->UEntry[i].postOffset == 0)
		 { dblPNTv(respnt,uomd->UEntry[i].Factor) ;
		 } else
		 { P ptbuf ; INITLP(respnt,lp,Dim_List) ;
		   dblPNTv(&ptbuf,uomd->UEntry[i].Factor) ; v4l_ListPoint_Modify(ctx,lp,V4L_ListAction_Append,&ptbuf,0) ;
		   dblPNTv(&ptbuf,uomd->UEntry[i].preOffset) ; v4l_ListPoint_Modify(ctx,lp,V4L_ListAction_Append,&ptbuf,0) ;
		   dblPNTv(&ptbuf,uomd->UEntry[i].postOffset) ; v4l_ListPoint_Modify(ctx,lp,V4L_ListAction_Append,&ptbuf,0) ;
		   ENDLP(respnt,lp) ;
		 } ;
		return(respnt) ;
	      case -V4IM_Tag_Label:
		if (index == UNUSED)
		 { if (uom == NULL && uomp != NULL) uom = (struct V4DPI__Value_UOM *)uomp ;
		   if (uom == NULL) { v_Msg(ctx,NULL,"UOMPriorUOMI",intmodx,-V4IM_Tag_Label,V4IM_Tag_Num,V4DPI_PntType_UOM) ; goto uom_fail ; } ;
		   for(i=0;i<uomt->Count;i++) { if (uomt->Entry[i].Ref == uom->Ref) break ; } ;
		   if (i >= uomt->Count) { v_Msg(ctx,NULL,"UOMNoIntEntry",intmodx,uom->Ref) ; goto uom_fail ; } ;
		   uomd = uomt->Entry[i].uomd ;
		   if (uom->Index < 0)			/* If Index < 0 then have embedded factor - look for negative entry for label */
		    { for(i=0;i<uomd->Count;i++) { if (uomd->UEntry[i].Index < 0) break ; } ;
		      uccharPNTv(respnt,(i < uomd->Count ? uomd->UEntry[i].PSStr : UClit("mp"))) ; return(respnt) ;
		    } ;
		   if (uomd->DfltDispX == UNUSED)
		    { for(i=0;i<uomd->Count;i++) { if (uomd->UEntry[i].Index == uom->Index) break ; } ;
		      if (i >= uomd->Count) { v_Msg(ctx,NULL,"UOMNoIdxEntry",intmodx,uom->Index) ; goto uom_fail ; } ;
		    } else { i = uomd->DfltDispX ; } ;
		 } else { i = index ; } ;
		uccharPNTv(respnt,uomd->UEntry[i].PSStr) ; return(respnt) ;
	      case V4IM_Tag_Num:
		if (uom != NULL)
		 { ZPH(respnt) ; respnt->Dim = udim ; respnt->PntType = V4DPI_PntType_UOM ; respnt->Bytes = V4PS_UOM ;
		   memcpy(&respnt->Value.UOMVal,uom,sizeof *uom) ;
		   for(i=0;i<uomt->Count;i++) { if (uomt->Entry[i].Ref == uom->Ref) break ; } ;
		   if (i >= uomt->Count) { v_Msg(ctx,NULL,"UOMNoIntEntry",intmodx,uom->Ref) ; goto uom_fail ; } ;
		   uomd = uomt->Entry[i].uomd ;
		   if (uomd->DfltDispX == UNUSED)
		    { if (uom->Index < 0) { dfactor = -uom->Index ; }
		       else { for(i=0;i<uomd->Count;i++) { if (uomd->UEntry[i].Index == uom->Index) break ; } ;
			      if (i >= uomd->Count) { v_Msg(ctx,NULL,"UOMNoIdxEntry",intmodx,uom->Index) ; goto uom_fail ; } ;
			      dfactor = uomd->UEntry[i].Factor ; preOffset = uomd->UEntry[i].preOffset ; postOffset = uomd->UEntry[i].postOffset ;
			    } ;
		    } else { dfactor = uomd->UEntry[uomd->DfltDispX].Factor ; preOffset = uomd->UEntry[uomd->DfltDispX].preOffset ; postOffset = uomd->UEntry[uomd->DfltDispX].postOffset ; } ;
		   dnum = ((v4im_GetPointDbl(&ok,cpt,ctx) + preOffset) * dfactor) + postOffset ; if (!ok) break ;
		   memcpy(&respnt->Value.UOMVal.Num,&dnum,sizeof dnum) ; return(respnt) ;
		 } else if (uomp != NULL)
		 { ZPH(respnt) ; respnt->Dim = udim ; respnt->PntType = V4DPI_PntType_UOMPer ; respnt->Bytes = V4PS_UOMPer ;
		   memcpy(&respnt->Value.UOMPerVal,uomp,sizeof *uomp) ;
		   dnum = v4im_GetPointDbl(&ok,cpt,ctx) ; if (!ok) break ;
		   memcpy(&respnt->Value.UOMPerVal.Amount,&dnum,sizeof dnum) ; return(respnt) ;
		 } else { v_Msg(ctx,NULL,"UOMPriorUOM",intmodx,-V4IM_Tag_Num,V4DPI_PntType_UOM) ; goto uom_fail ; } ;
	      case -V4IM_Tag_Num:
		if (uom == NULL && uomp != NULL) uom = (struct V4DPI__Value_UOM *)uomp ;
		if (uom == NULL) { v_Msg(ctx,NULL,"UOMPriorUOM",intmodx,-V4IM_Tag_Num,V4DPI_PntType_UOM) ; goto uom_fail ; } ;
		for(i=0;i<uomt->Count;i++) { if (uomt->Entry[i].Ref == uom->Ref) break ; } ;
		if (i >= uomt->Count) { v_Msg(ctx,NULL,"UOMNoIntEntry",intmodx,uom->Ref) ; goto uom_fail ; } ;
		uomd = uomt->Entry[i].uomd ;
		if (uomd->DfltDispX == UNUSED)
		 { for(i=0;i<uomd->Count;i++) { if (uomd->UEntry[i].Index == uom->Index) break ; } ;
		   if (i >= uomd->Count) { v_Msg(ctx,NULL,"UOMNoIdxEntry",intmodx,uom->Index) ; goto uom_fail ; } ;
		 } else { i = uomd->DfltDispX ; } ;
		memcpy(&dnum,&uom->Num,sizeof dnum) ;
		dblPNTv(respnt,dnum) ; return(respnt) ;
	      case -V4IM_Tag_Index:
		if (uom == NULL && uomp != NULL) uom = (struct V4DPI__Value_UOM *)uomp ;
		if (uom == NULL) { v_Msg(ctx,NULL,"UOMPriorUOM",intmodx,-V4IM_Tag_Index,V4DPI_PntType_UOM) ; goto uom_fail ; } ;
		intPNTv(respnt,uom->Index) ; return(respnt) ;
	      case V4IM_Tag_Head:
		if (uomp != NULL)
		 { ZPH(respnt) ; respnt->Dim = udim ; respnt->PntType = V4DPI_PntType_UOMPer ; respnt->Bytes = V4PS_UOMPer ;
		   memcpy(&respnt->Value.UOMPerVal,uomp,sizeof *uomp) ;
		   dnum = v4im_GetPointDbl(&ok,cpt,ctx) ; if (!ok) break ;
		   memcpy(&respnt->Value.UOMPerVal.Amount,&dnum,sizeof dnum) ; return(respnt) ;
		 } else { v_Msg(ctx,NULL,"UOMPriorUOM",intmodx,-V4IM_Tag_Head,V4DPI_PntType_UOMPer) ; goto uom_fail ; } ;
	      case -V4IM_Tag_Head:
		if (uomp != NULL) { dblPNTv(respnt,uomp->Amount) ; return(respnt) ; }
		 else if (uompu != NULL)
		       { uom = (struct V4DPI__Value_UOM *)&uompu->UOM ;
		         if (ix < argcnt) {  uompu = NULL ; break ; } ;		/* If more arguments then keep going */
		         ZPH(respnt) ; respnt->Dim = uompu->uomDim ; respnt->PntType = V4DPI_PntType_UOM ;
			 respnt->Bytes = V4PS_UOM ; respnt->Value.UOMVal = uompu->UOM ; return(respnt) ;
		       }
		 else { v_Msg(ctx,NULL,"UOMPriorUOM",intmodx,-V4IM_Tag_Head,V4DPI_PntType_UOMPer) ; goto uom_fail ; } ;
	      case -V4IM_Tag_Tail:
		if (uomp != NULL)
		 { uom = (struct V4DPI__Value_UOM *)uomp ;
		   if (ix < argcnt) { uomp = NULL ; break ; } ;			/* If not last argument keep going */
		   ZPH(respnt) ; memcpy(&respnt->Value.UOMVal,uom,sizeof *uom) ;	/* If last argument then return UOM portion */
		   respnt->Dim = udim ; respnt->Bytes = V4PS_UOM ; respnt->PntType = V4DPI_PntType_UOM ; return(respnt) ;
		 }
		 else if (uompu != NULL)
		       { uom = (struct V4DPI__Value_UOM *)&uompu->PUOM ;
		         if (ix < argcnt) { uompu = NULL ;break ; } ;		/* If more arguments then keep going */
		         ZPH(respnt) ; respnt->Dim = uompu->puomDim ; respnt->PntType = V4DPI_PntType_UOM ;
			 respnt->Bytes = V4PS_UOM ; respnt->Value.UOMVal = uompu->PUOM ; return(respnt) ;
		       }
		 else { v_Msg(ctx,NULL,"UOMPriorUOM",intmodx,-V4IM_Tag_Tail,V4DPI_PntType_UOMPer) ; goto uom_fail ; } ;
	      case -V4IM_Tag_Description:
		if (uomd == NULL) { v_Msg(ctx,NULL,"IdNoneGiven",intmodx) ; goto uom_fail ; } ;
		uccharPNTv(respnt,uomd->Desc) ; return(respnt) ;
	      case -V4IM_Tag_Name:
		if (uomd == NULL) { v_Msg(ctx,NULL,"IdNoneGiven",intmodx) ; goto uom_fail ; } ;
		uccharPNTv(respnt,uomd->Name) ; return(respnt) ;
	      case -V4IM_Tag_Type:
		if (uomd == NULL) { v_Msg(ctx,NULL,"IdNoneGiven",intmodx) ; goto uom_fail ; } ;
		if (uomd->TypePt.Dim == 0) { v_Msg(ctx,NULL,"UOMNoType",intmodx,V4IM_Tag_Type) ; goto uom_fail ; } ;
		memcpy(respnt,&uomd->TypePt,uomd->TypePt.Bytes) ;
		return(respnt) ;
	      case -V4IM_Tag_Format:
		if (uomd == NULL) { v_Msg(ctx,NULL,"IdNoneGiven",intmodx) ; goto uom_fail ; } ;
		if (uomd->Attributes & V4DPI_UOMAttr_DisplayPSfix)
		 { return((P *)&Log_True) ; } else { return((P *)&Log_False) ; } ;
	    } ;
	 } ;
	if (!ok) { v_Msg(ctx,NULL,"ModInvArg",intmodx,ix-1) ; goto uom_fail ; } ;
	return((P *)&Log_True) ;
uom_fail:
	REGISTER_ERROR(0) ; return(NULL) ;
}

#define PARSE_PT_MAX 100		/* Max number of points to parse */

struct V4DPI__Point *v4im_DoParse(ctx,respnt,argpnts,argcnt,intmodx,trace)
  struct V4C__Context *ctx ;
  P *respnt ;						/* Ptr for result */
  INTMODX intmodx ;
  P *argpnts[] ;
  COUNTER argcnt ; VTRACE trace ;
{ P *ipt,*cpt, *pts[PARSE_PT_MAX],*mpt, *ept ;
  P ptbuf,evalpt,match ;
  struct V4L__ListPoint *lp ;
  struct V4L__ListToken *vllt ;
#define V4PARSE_exclListMax 500
  int exclList[V4PARSE_exclListMax], exclNum, excludePoint ;
  int ix,i,j,k,c1,c2,lahead,pcnt,frameid,evalok,start,parsemode,parseflags,tx,treeDim,xmlTrace,max,nodes ;
  LOGICAL includeSchema=FALSE,includeAttr=FALSE,ok ; UCCHAR *b ; COUNTER curRadix,digit ;
 
	lahead = 1 ; /* Default look-ahead to 1 */
	frameid = UNUSED ; treeDim = UNUSED ; exclNum = 0 ; parseflags = 0 ;
	parsemode = 1 ; xmlTrace = 0 ; excludePoint = 0 ; max = V4LIM_BiggestPositiveInt ; nodes = 0 ;
	ZPH(&evalpt) ;
	for (ix=1,ok=TRUE;ok&&ix<=argcnt;ix++)
	 { if (ix == 1 && argpnts[ix]->PntType != V4DPI_PntType_TagVal) continue ;
	   switch (tx=v4im_CheckPtArgNew(ctx,argpnts[ix],&cpt,&ptbuf))
	    { default:			v_Msg(ctx,NULL,"TagBadUse",intmodx) ; goto fail ;
	      case V4IM_Tag_Unk:	v_Msg(ctx,NULL,"TagUnknown",intmodx) ; goto fail ;
	      case V4IM_Tag_As:
//		v4im_GetPointUC(&ok,UCTBUF1,V4TMBufMax,argpnts[1],ctx) ; if (!ok) break ;
		switch (v4im_GetDictToEnumVal(ctx,cpt))
		 { default:		v_Msg(ctx,NULL,"ModTagValue",intmodx,ix,tx,cpt) ; goto fail ;
		   case _ASCII:
			{ struct V4LEX__BigText bt ;
			  v4im_GetPointUC(&ok,UCTBUF1,V4TMBufMax,argpnts[1],ctx) ; if (!ok) break ;
			  for(i=0,j=0;UCTBUF1[i]!=UCEOS;i++)
			   { switch(UCTBUF1[i])
			      { default:		bt.BigBuf[j++] = (UCTBUF1[i] > 255 ? UClit('.') : UCTBUF1[i]) ; break ;
				case 130: case 8218:	bt.BigBuf[j++] = UClit(',') ; break ;
				case 131: case 402:	bt.BigBuf[j++] = UClit('f') ; break ;
				case 132: case 8222:	bt.BigBuf[j++] = UClit('"') ; break ;
				case 133: case 8230:	bt.BigBuf[j++] = UClit('.') ; break ;
				case 134: case 8224:	bt.BigBuf[j++] = UClit('+') ; break ;
				case 135: case 8225:	bt.BigBuf[j++] = UClit('+') ; break ;
				case 136: case 710:	bt.BigBuf[j++] = UClit('^') ; break ;
				case 137: case 8240:	bt.BigBuf[j++] = UClit('0') ; break ;
				case 138: case 352:	bt.BigBuf[j++] = UClit('S') ; break ;
				case 139: case 8249:	bt.BigBuf[j++] = UClit('<') ; break ;
				case 140: case 338:	bt.BigBuf[j++] = UClit('O') ; bt.BigBuf[j++] = UClit('E') ; break ;
				case 142: case 381:	bt.BigBuf[j++] = UClit('Z') ; break ;
				case 145: case 8216:	bt.BigBuf[j++] = UClit('\'') ; break ;
				case 146: case 8217:	bt.BigBuf[j++] = UClit('\'') ; break ;
				case 147: case 8220:	bt.BigBuf[j++] = UClit('"') ; break ;
				case 148: case 8221:	bt.BigBuf[j++] = UClit('"') ; break ;
				case 149: case 8226:	bt.BigBuf[j++] = UClit('*') ; break ;
				case 150: case 8211:	bt.BigBuf[j++] = UClit('-') ; break ;
				case 151: case 8212:	bt.BigBuf[j++] = UClit('-') ; break ;
				case 152: case 732:	bt.BigBuf[j++] = UClit('~') ; break ;
				case 153: case 8482:	bt.BigBuf[j++] = UClit('(') ; bt.BigBuf[j++] = UClit('t') ; bt.BigBuf[j++] = UClit('m') ; bt.BigBuf[j++] = UClit(')') ; break ;
				case 154: case 353:	bt.BigBuf[j++] = UClit('S') ; break ;
				case 155: case 8250:	bt.BigBuf[j++] = UClit('>') ; break ;
				case 156: case 339:	bt.BigBuf[j++] = UClit('o') ; bt.BigBuf[j++] = UClit('e') ; break ;
				case 158: case 382:	bt.BigBuf[j++] = UClit('Z') ; break ;
				case 159: case 376:	bt.BigBuf[j++] = UClit('Y') ; break ;
				case 160:		bt.BigBuf[j++] = UClit(' ') ; break ;
				case 161:		bt.BigBuf[j++] = UClit('!') ; break ;
				case 162:		bt.BigBuf[j++] = UClit('c') ; break ;
				case 163:		bt.BigBuf[j++] = UClit('l') ; bt.BigBuf[j++] = UClit('b') ; break ;
				case 164:		bt.BigBuf[j++] = UClit('*') ; break ;
				case 165:		bt.BigBuf[j++] = UClit('Y') ; break ;
				case 166:		bt.BigBuf[j++] = UClit('|') ; break ;
				case 167:		bt.BigBuf[j++] = UClit('p') ; break ;
				case 168:		bt.BigBuf[j++] = UClit('.') ; break ;
				case 169:		bt.BigBuf[j++] = UClit('(') ; bt.BigBuf[j++] = UClit('c') ; bt.BigBuf[j++] = UClit(')') ; break ;
				case 170:		bt.BigBuf[j++] = UClit('a') ; break ;
				case 171:		bt.BigBuf[j++] = UClit('<') ; bt.BigBuf[j++] = UClit('<') ; break ;
				case 174:		bt.BigBuf[j++] = UClit('(') ; bt.BigBuf[j++] = UClit('R') ; bt.BigBuf[j++] = UClit(')') ; break ;
				case 175:		bt.BigBuf[j++] = UClit('-') ; break ;
				case 176:		bt.BigBuf[j++] = UClit('o') ; break ;
				case 177:		bt.BigBuf[j++] = UClit('+') ; bt.BigBuf[j++] = UClit('/') ; bt.BigBuf[j++] = UClit('-') ; break ;
				case 178:		bt.BigBuf[j++] = UClit('2') ; break ;
				case 179:		bt.BigBuf[j++] = UClit('s') ; break ;
				case 180:		bt.BigBuf[j++] = UClit('\'') ; break ;
				case 181:		bt.BigBuf[j++] = UClit('u') ; break ;
				case 182:		bt.BigBuf[j++] = UClit('p') ; break ;
				case 183:		bt.BigBuf[j++] = UClit('.') ; break ;
				case 184:		bt.BigBuf[j++] = UClit(',') ; break ;
				case 185:		bt.BigBuf[j++] = UClit('1') ; break ;
				case 186:		bt.BigBuf[j++] = UClit('0') ; break ;
				case 187:		bt.BigBuf[j++] = UClit('>') ; bt.BigBuf[j++] = UClit('>') ; break ;
				case 188:		bt.BigBuf[j++] = UClit('1') ; bt.BigBuf[j++] = UClit('/') ; bt.BigBuf[j++] = UClit('4') ; break ;
				case 189:		bt.BigBuf[j++] = UClit('1') ; bt.BigBuf[j++] = UClit('/') ; bt.BigBuf[j++] = UClit('1') ; break ;
				case 190:		bt.BigBuf[j++] = UClit('3') ; bt.BigBuf[j++] = UClit('/') ; bt.BigBuf[j++] = UClit('4') ; break ;
				case 191:		bt.BigBuf[j++] = UClit('?') ; break ;
				case 192:		bt.BigBuf[j++] = UClit('A') ; break ;
				case 193:		bt.BigBuf[j++] = UClit('A') ; break ;
				case 194:		bt.BigBuf[j++] = UClit('A') ; break ;
				case 195:		bt.BigBuf[j++] = UClit('A') ; break ;
				case 196:		bt.BigBuf[j++] = UClit('A') ; break ;
				case 197:		bt.BigBuf[j++] = UClit('A') ; break ;
				case 198:		bt.BigBuf[j++] = UClit('A') ; bt.BigBuf[j++] = UClit('E') ; break ;
				case 199:		bt.BigBuf[j++] = UClit('C') ; break ;
				case 200:		bt.BigBuf[j++] = UClit('E') ; break ;
				case 201:		bt.BigBuf[j++] = UClit('E') ; break ;
				case 202:		bt.BigBuf[j++] = UClit('E') ; break ;
				case 203:		bt.BigBuf[j++] = UClit('E') ; break ;
				case 204:		bt.BigBuf[j++] = UClit('I') ; break ;
				case 205:		bt.BigBuf[j++] = UClit('I') ; break ;
				case 206:		bt.BigBuf[j++] = UClit('I') ; break ;
				case 207:		bt.BigBuf[j++] = UClit('I') ; break ;
				case 208:		bt.BigBuf[j++] = UClit('D') ; break ;
				case 209:		bt.BigBuf[j++] = UClit('N') ; break ;
				case 210:		bt.BigBuf[j++] = UClit('O') ; break ;
				case 211:		bt.BigBuf[j++] = UClit('O') ; break ;
				case 212:		bt.BigBuf[j++] = UClit('O') ; break ;
				case 213:		bt.BigBuf[j++] = UClit('O') ; break ;
				case 214:		bt.BigBuf[j++] = UClit('O') ; break ;
				case 215:		bt.BigBuf[j++] = UClit('x') ; break ;
				case 216:		bt.BigBuf[j++] = UClit('O') ; break ;
				case 217:		bt.BigBuf[j++] = UClit('U') ; break ;
				case 218:		bt.BigBuf[j++] = UClit('U') ; break ;
				case 219:		bt.BigBuf[j++] = UClit('U') ; break ;
				case 220:		bt.BigBuf[j++] = UClit('U') ; break ;
				case 221:		bt.BigBuf[j++] = UClit('Y') ; break ;
				case 222:		bt.BigBuf[j++] = UClit('P') ; break ;
				case 223:		bt.BigBuf[j++] = UClit('B') ; break ;
				case 224:		bt.BigBuf[j++] = UClit('a') ; break ;
				case 225:		bt.BigBuf[j++] = UClit('a') ; break ;
				case 226:		bt.BigBuf[j++] = UClit('a') ; break ;
				case 227:		bt.BigBuf[j++] = UClit('a') ; break ;
				case 228:		bt.BigBuf[j++] = UClit('a') ; break ;
				case 229:		bt.BigBuf[j++] = UClit('a') ; break ;
				case 230:		bt.BigBuf[j++] = UClit('a') ; bt.BigBuf[j++] = UClit('e') ; break ;
				case 231:		bt.BigBuf[j++] = UClit('c') ; break ;
				case 232:		bt.BigBuf[j++] = UClit('e') ; break ;
				case 233:		bt.BigBuf[j++] = UClit('e') ; break ;
				case 234:		bt.BigBuf[j++] = UClit('e') ; break ;
				case 235:		bt.BigBuf[j++] = UClit('e') ; break ;
				case 236:		bt.BigBuf[j++] = UClit('i') ; break ;
				case 237:		bt.BigBuf[j++] = UClit('i') ; break ;
				case 238:		bt.BigBuf[j++] = UClit('i') ; break ;
				case 239:		bt.BigBuf[j++] = UClit('i') ; break ;
				case 240:		bt.BigBuf[j++] = UClit('o') ; break ;
				case 241:		bt.BigBuf[j++] = UClit('n') ; break ;
				case 242:		bt.BigBuf[j++] = UClit('o') ; break ;
				case 243:		bt.BigBuf[j++] = UClit('o') ; break ;
				case 244:		bt.BigBuf[j++] = UClit('o') ; break ;
				case 245:		bt.BigBuf[j++] = UClit('o') ; break ;
				case 246:		bt.BigBuf[j++] = UClit('o') ; break ;
				case 247:		bt.BigBuf[j++] = UClit('/') ; break ;
				case 248:		bt.BigBuf[j++] = UClit('o') ; break ;
				case 249:		bt.BigBuf[j++] = UClit('u') ; break ;
				case 250:		bt.BigBuf[j++] = UClit('u') ; break ;
				case 251:		bt.BigBuf[j++] = UClit('u') ; break ;
				case 252:		bt.BigBuf[j++] = UClit('u') ; break ;
				case 253:		bt.BigBuf[j++] = UClit('y') ; break ;
				case 254:		bt.BigBuf[j++] = UClit('p') ; break ;
				case 255:		bt.BigBuf[j++] = UClit('y') ; break ;
			      } ;
			     if (j >= V4LEX_BigText_Max) { v_Msg(ctx,NULL,"@%1E - Result string (len=%2d) exceeds max length allowed(%3d)",intmodx,j,V4LEX_BigText_Max) ; goto fail ; } ;
			   } ;
			  if (!v4dpi_SaveBigTextPoint(ctx,&bt,j,respnt,Dim_Alpha,TRUE)) { v_Msg(ctx,NULL,"StrSaveBigText",intmodx,V4DPI_PntType_BigText) ; goto fail ; } ;
			  return(respnt) ;
			}
		   case _Binary:
			curRadix = 2 ; goto num_entry ;
		   case _CNumLiteral:
			  v4im_GetPointUC(&ok,UCTBUF1,V4TMBufMax,argpnts[1],ctx) ; if (!ok) break ;
			  intPNTv(respnt,UCstrtol(UCTBUF1,&b,0)) ; if (*b != UCEOS) goto parse_as_err ;
			  return(respnt) ;
		   case _Currency:
			{ double amt=0,factor=1.0 ; LOGICAL bos = TRUE, eos = FALSE, neg = FALSE, lparen = FALSE ;
			  v4im_GetPointUC(&ok,UCTBUF1,V4TMBufMax,argpnts[1],ctx) ; if (!ok) break ;
			  for(b=UCTBUF1;*b!=UCEOS;b++)
			   { digit = UNUSED ;
#ifdef V4UNICODE
			     if (vuc_IsDigit(*b))
			      { if (uci->Entry[*b].OtherValue >= 10) goto parse_as_err ;
			        digit = uci->Entry[*b].OtherValue ;
			      } ;
#else
			     if (*b >= UClit('0') && *b <= UClit('9'))
			      { digit = *b - UClit('0') ; } ;
#endif
			     if(digit != UNUSED)
			      { if (eos) goto parse_as_err ;
			        bos = FALSE ;
				if (factor < 1) { amt += ((double)(*b - UClit('0'))) * factor ; factor /= 10.0 ; }
				 else { amt = amt * 10.0 + (double)(*b - UClit('0')) ; } ;
			        continue ;
			      } ;
			     if (*b == gpi->ci->Cntry[gpi->ci->CurX].DigiDelim || *b == UClit('_')) { if (!bos && !eos) continue ; } ;
			     if (vuc_IsWSpace(*b) || *b == UClit('"') || *b == UClit('\''))
			      { if (bos) continue ; if (!eos) eos = TRUE ; continue ; } ;
			     if (*b == UClit('-'))
			      { if (neg) goto parse_as_err ; neg = TRUE ; if (bos) continue ; eos = TRUE ; continue ; } ;
			     if (*b == gpi->ci->Cntry[gpi->ci->CurX].RadixPnt)
			      { if (factor != 1) goto parse_as_err ;
				factor = 0.1 ; continue ;
			      } ;
			     if (*b == gpi->ci->Cntry[gpi->ci->CurX].CurrencySign[0])
			      { if (gpi->ci->Cntry[gpi->ci->CurX].CurSgnPrefix)
			         { if (bos) continue ; } else { eos = TRUE ; continue ; } ;
			      } ;
			     if (*b == UClit('('))
			      { if (neg || !bos || lparen) goto parse_as_err ; lparen = TRUE ; continue ; } ;
			     if (*b == UClit(')'))
			      { if (neg || !lparen) goto parse_as_err ; eos = TRUE ;  neg = TRUE ; lparen = FALSE ; continue ; } ;
			     goto parse_as_err ;
			   } ;
			  if (lparen) goto parse_as_err ;
			  if (neg) amt = -amt ; dblPNTv(respnt,amt) ; return(respnt) ;
			}
			break ;
		   case _DayOfWeek:
		   case _Decimal:
			curRadix = 10 ;
num_entry:
			{ UB64INT dn = 0 ; LOGICAL bos = TRUE, eos = FALSE, neg = FALSE ;
			  v4im_GetPointUC(&ok,UCTBUF1,V4TMBufMax,argpnts[1],ctx) ; if (!ok) break ;
			  for(b=UCTBUF1;*b!=UCEOS;b++)
			   { digit = UNUSED ;
#ifdef V4UNICODE
			     if (vuc_IsDigit(*b))
			      { if (uci->Entry[*b].OtherValue >= curRadix) goto parse_as_err ;
			        digit = uci->Entry[*b].OtherValue ;
			      } ;
#else
			     if (*b >= UClit('0') && *b <= UClit('9'))
			      { digit = *b - UClit('0') ; } ;
#endif
			     if (curRadix == 16 && digit == UNUSED)
			      { digit = 10 + (*b >= UClit('a') ? (*b - UClit('a')) : (*b - UClit('A'))) ;
				if (digit < 10 || digit > 15) goto parse_as_err ;
			      } ;
			     if(digit != UNUSED)
			      { if (eos) goto parse_as_err ;
			        bos = FALSE ;
			        switch (curRadix)
			         { case 2:	dn = (dn << 1) + digit ; break ;
				   case 8:	dn = (dn << 3) + digit ; break ;
				   case 10:	dn = dn * 10 + digit ; break ;
				   case 16:	dn = (dn << 4) + digit ; break ;
			         } ;
				if (dn > V4LIM_BiggestUnsignedInt) goto parse_as_err ;
			        continue ;
			      } ;
			     if (*b == gpi->ci->Cntry[gpi->ci->CurX].DigiDelim || *b == UClit('_')) { if (!bos && !eos) continue ; } ;
			     if (vuc_IsWSpace(*b) || *b == UClit('"') || *b == UClit('\''))
			      { if (bos) continue ; if (!eos) eos = TRUE ; continue ; } ;
			     if (*b == UClit('-') && curRadix == 10)
			      { if (neg) goto parse_as_err ; neg = TRUE ; if (bos) continue ; eos = TRUE ; continue ; } ;
			     goto parse_as_err ;
			   } ;
			  intPNTv(respnt,(neg ? -((int)dn) : dn)) ; return(respnt) ;
			}
		   case _EMail:
			v4im_GetPointUC(&ok,UCTBUF1,V4TMBufMax,argpnts[1],ctx) ; if (!ok) break ;
			if (UCstrlen(UCTBUF1) > 254) { b = (UCTBUF1 + 254) ; goto parse_as_err ; } ;	/* Entire address can't be more than 254 */
			{ COUNTER len ; UCCHAR *start ;
			  for(start=UCTBUF1;*start!=UCEOS;start++)			/* Strip off an leading white space */
			   { if (!vuc_IsWSpace(*start)) break ; } ;
			  for(b = start;*b!=UCEOS && *b!=UClit('@');b++)		/* Check name/local part */
			   { if (*b >= UClit('A') && *b <= UClit('Z')) continue ; if (*b >= UClit('a') && *b <= UClit('z')) continue ;  if (*b >= UClit('0') && *b <= UClit('9')) continue ;
			     if (*b == UClit('-') || *b == UClit('_') || *b == UClit('\'')) continue ;
			     if (*b == UClit('.'))					/* Restrictions on '.' - can't have 2 in a row, can't end with '.' */
			      { if (b == UCTBUF1 || *(b+1) == UClit('.') || *(b+1) == UClit('@')) { b++ ; goto parse_as_err ; } ; continue ; } ;
			     goto parse_as_err ;
			   } ;
			  if (b - UCTBUF1 > 64) goto parse_as_err;			/* Local part cannot exceed 64 */
			  if (*b != UClit('@')) goto parse_as_err ;
			  for(b++,len=0;*b!=UCEOS&&!vuc_IsWSpace(*b);b++)		/* Check host name */
			   { if ((*b >= UClit('A') && *b <= UClit('Z')) || (*b >= UClit('a') && *b <= UClit('z')) || (*b >= UClit('0') && *b <= UClit('9'))) { len++ ; continue ; } ;
			     if (*b == UClit('-'))					/* Restrictions on '-' - can't end with it */
			      { if (len == 0 || *(b+1) == UClit('.') || *(b+1) == UCEOS) goto parse_as_err ;
			        continue ;
			      } ;
			     if (*b == UClit('.'))					/* No part can exceed 63 characters */
			      { if (len < 1 || len > 63) goto parse_as_err ;
			        len = 0 ; continue ;
			      } ;
			     goto parse_as_err ;
			   } ;
			  if (*b != UCEOS)						/* Strip off any trailing white space */
			   { UCCHAR *b1 = b ; for(b1++;*b1!=UCEOS;b1++) { if (!vuc_IsWSpace(*b1)) break ; } ;
			     if (*b1 != UCEOS) goto parse_as_err ;
			     *b = UCEOS ;
			   } ;
			  UCSTRTOLOWER(start) ; uccharPNTv(respnt,start) ;		/* Normalize to lower case & return it */
			  return(respnt) ;
			}
		   case _Hexadecimal:
			curRadix = 16 ; goto num_entry ;
		   case _JSON:

			{ struct V4LEX__TknCtrlBlk *tcb ; DICTID dictId ;
			  tcb = v4mm_AllocChunk(sizeof(struct V4LEX__TknCtrlBlk),FALSE) ; v4lex_InitTCB(tcb,V4LEX_TCBINIT_NoStdIn) ;
			  cpt = argpnts[1] ;
/*			  Push first argument onto tcb as its source */
			  switch (cpt->PntType)
			   { default:			v_Msg(ctx,NULL,"ModArgPntType3",intmodx,1,cpt->PntType,V4DPI_PntType_Char,V4DPI_PntType_List) ; goto fail ;

			     case V4DPI_PntType_Dict:		/* If dictionary entry then assume name of buffered stream */
				{ UCCHAR *fbuf ; FILEID fileId ;
				   fileId = vout_PntIdToFileId(ctx,(struct V4DPI__LittlePoint *)cpt) ;
				   if (fileId == UNUSED) { v_Msg(ctx,NULL,"StreamNoOutput",intmodx,V4IM_Tag_XML,cpt) ; return(NULL) ; } ;
				   fbuf = vout_GetOutputBuffer(fileId,UNUSED,ctx->ErrorMsgAux) ;
				   if (fbuf == NULL) { v_Msg(ctx,NULL,"ModInvArg2",intmodx,cpt) ; return(NULL) ; } ;
				   v4lex_NestInput(tcb,NULL,NULL,V4LEX_InpMode_RetEOF) ;
				   v4lex_NestInput(tcb,NULL,fbuf,V4LEX_InpMode_StringPtr) ;
				}
				break ;
			     CASEofChar
				v4im_GetPointUC(&ok,UCTBUF1,V4TMBufMax,cpt,ctx) ;
				if (!ok) { v_Msg(ctx,NULL,"ModInvArg",intmodx,1) ; goto fail ; } ;
				v4lex_NestInput(tcb,NULL,NULL,V4LEX_InpMode_RetEOF) ;
				v4lex_NestInput(tcb,NULL,UCTBUF1,V4LEX_InpMode_String) ;
				break ;
			    case V4DPI_PntType_List:	
				{ struct V4L__ListPoint *lp ; P *tpnt = v4mm_AllocChunk(sizeof *tpnt,FALSE) ;
				  lp = (struct V4L__ListPoint *)v4im_VerifyList(tpnt,ctx,cpt,0) ;
				  v4lex_NestInput(tcb,NULL,(UCCHAR *)lp,V4LEX_InpMode_List) ;
				  break ;
				}
			   } ;
			  dictId = vjson_ParseString(ctx,tcb,NULL,0) ;
			  v4mm_FreeChunk(tcb) ;
			  if (dictId == 0) { v_Msg(ctx,NULL,"ParseJSON",intmodx) ; goto fail ; } ;
			  intPNTv(respnt,dictId) ; return(respnt) ;
			}
		   case _Octal:
			curRadix = 8 ; goto num_entry ;
		   case _Real:
			{ double amt=0,factor=1.0, exponent=0.0 ; LOGICAL bos = TRUE, eos = FALSE, neg = FALSE, haveExp = FALSE, negExp = FALSE ;
			  v4im_GetPointUC(&ok,UCTBUF1,V4TMBufMax,argpnts[1],ctx) ; if (!ok) break ;
			  for(b=UCTBUF1;*b!=UCEOS;b++)
			   { digit = UNUSED ;
#ifdef V4UNICODE
			     if (vuc_IsDigit(*b))
			      { if (uci->Entry[*b].OtherValue >= 10) goto parse_as_err ;
			        digit = uci->Entry[*b].OtherValue ;
			      } ;
#else
			     if (*b >= UClit('0') && *b <= UClit('9'))
			      { digit = *b - UClit('0') ; } ;
#endif
			     if(digit != UNUSED)
			      { if (eos) goto parse_as_err ;
			        bos = FALSE ;
				if (haveExp) { exponent = exponent * 10 + digit ; }
				 else if (factor < 1) { amt += ((double)(*b - UClit('0'))) * factor ; factor /= 10.0 ; }
				 else { amt = amt * 10.0 + (double)(*b - UClit('0')) ; } ;
			        continue ;
			      } ;
			     if (*b == gpi->ci->Cntry[gpi->ci->CurX].DigiDelim || *b == UClit('_')) { if (!bos && !eos) continue ; } ;
			     if (*b == UClit('E') || *b == UClit('e'))
			      { if (haveExp) goto parse_as_err ;
			        if (*(b+1) == UClit('-')) { negExp = TRUE ; b++ ; }
			         else if (*(b+1) == UClit('+')) { b++ ; } ;
			        haveExp = TRUE ; continue ;
			      } ;
			     if (vuc_IsWSpace(*b) || *b == UClit('"') || *b == UClit('\''))
			      { if (bos) continue ; if (!eos) eos = TRUE ; continue ; } ;
			     if (*b == UClit('-'))
			      { if (neg) goto parse_as_err ; neg = TRUE ; if (bos) continue ; eos = TRUE ; continue ; } ;
			     if (*b == gpi->ci->Cntry[gpi->ci->CurX].RadixPnt)
			      { if (factor != 1 || haveExp) goto parse_as_err ;
				factor = 0.1 ; continue ;
			      } ;
			     goto parse_as_err ;
			   } ;
			  if (haveExp) { amt *= pow(10.0,(negExp ? -exponent : +exponent)) ; } ;
			  if (neg) amt = -amt ; dblPNTv(respnt,amt) ; return(respnt) ;
			}
			break ;
		   case _Month:
		   case _Telephone:
			{ struct V4DPI__DimInfo *di ; DIMINFO(di,ctx,Dim_UTele) ;
			  v4im_GetPointUC(&ok,UCTBUF1,V4TMBufMax,argpnts[1],ctx) ; if (!ok) break ;
			  if (!v_parseTeleNum(ctx,di,respnt,NULL,UCTBUF1,ctx->ErrorMsgAux))
			   { v_Msg(ctx,NULL,"ParseAsErr1",intmodx,ix,argpnts[ix]) ; goto fail ; } ;
			}
			return(respnt) ;
		   case _Time:
		   case _URL:
/*			scheme://username:password@domain:port/path?query_string#fragment_id */

		   case _Zipcode:
			{ int zip5, zip4=0 ; UCCHAR *start,*delim,*delim2 ; char zbuf[16] ;
			  v4im_GetPointUC(&ok,UCTBUF1,V4TMBufMax,argpnts[1],ctx) ; if (!ok) break ;
			  for(start=UCTBUF1;*start!=UCEOS;start++) { if (!vuc_IsWSpace(*start)) break ; } ;
			  zip5 = UCstrtol(start,&delim,10) ; b = delim ;
			  if (!((b - start) == 5 || (b - start) == 9)) goto parse_as_err ;
			  if (zip5 > 99999)
			   { if (zip5 < 1999999) { b = delim ; goto parse_as_err ; } ;
			     zip4 = zip5 % 10000 ; zip5 /= 10000 ;
			   } ;
			  if (zip4 == 0 && (*delim == UClit('-') || (*delim == UClit(' ') && vuc_IsDigit(*(delim + 1)))))
			   { zip4 = UCstrtol(delim+1,&delim2,10) ;
			     if (zip4 < 0 || zip4 > 9999 || delim2 - (delim+1) != 4) { b = delim ; goto parse_as_err ; } ;
			     delim = delim2 ;
			   } ;
			  for(;*delim!=UCEOS;delim++) { if (!vuc_IsWSpace(*delim)) { b = delim ; goto parse_as_err ; } ; } ;
			  if (zip4 == 0) { sprintf(zbuf,"%05d",zip5) ; } else { sprintf(zbuf,"%05d-%04d",zip5,zip4) ; } ;
			  alphaPNTv(respnt,zbuf) ; return(respnt) ;
			}
			break ;
		 } ;
parse_as_err:	v_Msg(ctx,NULL,"ParseAsErr",intmodx,ix,argpnts[ix],(b - UCTBUF1),UCTBUF1); goto fail ;
	      case V4IM_Tag_Num:	lahead = v4im_GetPointInt(&ok,cpt,ctx) ; break ;
	      case V4IM_Tag_Evaluate:	memcpy(&evalpt,cpt,cpt->Bytes) ; break ;
	      case V4IM_Tag_ListOf:
		switch (v4im_GetDictToEnumVal(ctx,cpt))
		 { default:		v_Msg(ctx,NULL,"ModTagValue",intmodx,ix,tx,cpt) ; goto fail ;
		   case _Punctuation:	INITLP(respnt,lp,Dim_List) ;
					for(i=V_Opcode_Starting;i<=V_Opcode_Ending;i++)
					 { dictPNTv(&ptbuf,Dim_UV4,v4im_GetEnumToDictVal(ctx,opcodeDE[i-1],Dim_UV4)) ;
					   v4l_ListPoint_Modify(ctx,lp,V4L_ListAction_Append,&ptbuf,0) ;
					 } ;
					ENDLP(respnt,lp) ; break ;
		 } ;
		return(respnt) ;
	      case V4IM_Tag_Exclude:
		if (cpt->PntType != V4DPI_PntType_List) { v_Msg(ctx,NULL,"ModArgPntType2",intmodx,ix,cpt->PntType,V4DPI_PntType_List) ; goto fail ; } ;
		lp = (struct V4L__ListPoint *)&cpt->Value ;
		for(i=1;i<=V4PARSE_exclListMax;i++)
		 { j = v4l_ListPoint_Value(ctx,lp,i,&ptbuf) ; if (j == 0) break ;
		   if (j == LISTVALERR)
		    { v_Msg(ctx,NULL,"ListGetErr1",intmodx,i,cpt) ; goto fail ; } ;
		   if (ptbuf.PntType != V4DPI_PntType_Dict) { v_Msg(ctx,NULL,"ParseExclEl",intmodx,V4IM_Tag_Exclude,i,&ptbuf,V4DPI_PntType_Dict) ; goto fail ; } ;
		   exclList[exclNum++] = ptbuf.Value.IntVal ;
		 } ; break ;
	      case -V4IM_Tag_HTML:
		parsemode = V4L_ListType_HTMLTokens ; parseflags = 0 ; break ;
	      case V4IM_Tag_HTML:
		parsemode = V4L_ListType_HTMLTokens ; parseflags = v4im_ParseFlagsParse(&ok,ctx,cpt,intmodx,tx,ix) ; if (!ok) goto fail ; break ;
	      case V4IM_Tag_Include:
		lp = (cpt->PntType == V4DPI_PntType_List ? (struct V4L__ListPoint *)&cpt->Value : NULL) ;
		for(i=1;;i++)
		 { if (lp == NULL) { ipt = cpt ; }
		    else { j = v4l_ListPoint_Value(ctx,lp,i,&ptbuf) ; if (j == 0) break ;
			   if (j == LISTVALERR) { v_Msg(ctx,NULL,"ListGetErr1",intmodx,i,cpt) ; goto fail ; } ;
			   ipt = &ptbuf ;
			 } ;
		   switch (v4im_GetDictToEnumVal(ctx,ipt))
		    { default:			v_Msg(ctx,NULL,"ModTagValue",intmodx,i,V4IM_Tag_Include,cpt) ; ipt = NULL ; goto fail ; 
		      case _Schema:		includeSchema = TRUE ; break ;
		      case _Attributes:		includeAttr = TRUE ; break ;
		    } ;
		  if (lp == NULL) break ;
		 } ; break ;
	      case -V4IM_Tag_Java:
		parsemode = V4L_ListType_JavaTokens ; parseflags = 0 ; break ;
	      case V4IM_Tag_Maximum:
		max = v4im_GetPointInt(&ok,cpt,ctx) ; break ;
	      case V4IM_Tag_Nodes:
		nodes = v4im_GetPointInt(&ok,cpt,ctx) ; break ;
	      case V4IM_Tag_Token:
		parsemode = V4L_ListType_Token ; parseflags = v4im_ParseFlagsParse(&ok,ctx,cpt,intmodx,tx,ix) ; if (!ok) goto fail ; break ;
	      case -V4IM_Tag_Token:	parsemode = V4L_ListType_Token ; break ;
	      case V4IM_Tag_Trace:
		if (cpt->PntType == V4DPI_PntType_Int && cpt->Value.IntVal > 0)
		 { if (cpt->Grouping == V4DPI_Grouping_Single) { xmlTrace = cpt->Value.IntVal ; }
		    else if (cpt->Grouping == V4DPI_Grouping_GE) { xmlTrace = -cpt->Value.IntVal ; }
		    else if (cpt->Grouping == V4DPI_Grouping_GT) { xmlTrace = -(cpt->Value.IntVal+1) ; }
		    else { v_Msg(ctx,NULL,"ParseTrace",intmodx,V4IM_Tag_Trace,cpt) ; goto fail ; } ;
		 } else  { v_Msg(ctx,NULL,"ParseTrace",intmodx,V4IM_Tag_Trace,cpt) ; goto fail ; } ;
		break ;
	      case V4IM_Tag_Tree:
		{ struct V4DPI__DimInfo *di ;
		  treeDim = v4dpi_DimIndexDimId(&ok,ctx,cpt,NULL) ; DIMINFO(di,ctx,treeDim) ;
		  if (di->PointType != V4DPI_PntType_Tree)
		   { v_Msg(ctx,NULL,"ModArgPntType2",intmodx,ix,di->PointType,V4DPI_PntType_Tree) ; goto fail ; } ;
		}
		break ;
	      case -V4IM_Tag_XML:
		parsemode = V4L_ListType_XMLTokens ; parseflags = 0 ; break ;
	      case V4IM_Tag_XML:
		parsemode = V4L_ListType_XMLTokens ; parseflags = v4im_ParseFlagsParse(&ok,ctx,cpt,intmodx,tx,ix) ; if (!ok) goto fail ; break ;
	    } ;
	 } ;
	if (!ok) { v_Msg(ctx,NULL,"ModInvArg",intmodx,ix-1) ; goto fail ; } ;
	if (treeDim != UNUSED && !(parsemode == V4L_ListType_XMLTokens || parsemode == V4L_ListType_HTMLTokens))
	 { v_Msg(ctx,NULL,"ParseOpt",intmodx,V4IM_Tag_Tree,V4IM_Tag_XML) ; goto fail ; } ;
	switch (parsemode)
	 { case 1:		goto old_parse_logic ;
	   case V4L_ListType_Token:
	   case V4L_ListType_HTMLTokens:
	   case V4L_ListType_JavaTokens:
	   case V4L_ListType_XMLTokens:
	     ZPH(respnt) ; respnt->Dim = Dim_List ; respnt->PntType = V4DPI_PntType_List ;
	     INITLP(respnt,lp,Dim_List) ; lp->ListType = parsemode ;
	     vllt = (struct V4L__ListToken *)&lp->Buffer ; memset(vllt,0,sizeof *vllt) ;
	     vllt->tcb = v4mm_AllocChunk(sizeof(struct V4LEX__TknCtrlBlk),FALSE) ; v4lex_InitTCB(vllt->tcb,V4LEX_TCBINIT_NoStdIn) ;
	     if (lp->ListType == V4L_ListType_XMLTokens || lp->ListType == V4L_ListType_HTMLTokens)
	      { vllt->lxc = (struct V4LEX_ListXMLCtrl *)v4mm_AllocChunk(sizeof *vllt->lxc,FALSE) ;
	        vllt->lxc->nestLvl = 0 ; vllt->lxc->xmlState = XML_State_BOM ; vllt->lxc->includeSchema = includeSchema ; vllt->lxc->includeAttr = includeAttr ;
/*		Make sure XMLBegin & XMLEnd dimensions exist - if not then make them */
		if (v4dpi_DimGet(ctx,UClit("XMLBegin"),DIMREF_IRT) == 0)
	         { struct V4DPI__DimInfo diminfo ; memset(&diminfo,0,sizeof diminfo) ;
	           UCstrcpy(diminfo.DimName,UClit("XMLBegin")) ; UCstrcpy(diminfo.Desc,UClit("Auto-created XML 'begin' dimension")) ;
	           diminfo.PointType = V4DPI_PntType_Dict ; diminfo.DictType = V4DPI_DictType_Ext ; v4dpi_DimMake(ctx,&diminfo) ;
	         } ;
		if (v4dpi_DimGet(ctx,UClit("XMLEnd"),DIMREF_IRT) == 0)
	         { struct V4DPI__DimInfo diminfo ; memset(&diminfo,0,sizeof diminfo) ;
	           UCstrcpy(diminfo.DimName,UClit("XMLEnd")) ; UCstrcpy(diminfo.Desc,UClit("Auto-created XML 'end' dimension")) ;
	           diminfo.PointType = V4DPI_PntType_Dict ; diminfo.DictType = V4DPI_DictType_Ext ; v4dpi_DimMake(ctx,&diminfo) ;
	         } ;
	      } ;
	     vllt->parseFlags = parseflags ;
/*	     Push first argument onto tcb as its source */
	     switch (argpnts[1]->PntType)
	      { default:			v_Msg(ctx,NULL,"ModArgPntType3",intmodx,1,argpnts[1]->PntType,V4DPI_PntType_Char,V4DPI_PntType_List) ; goto fail ;
//	        case V4DPI_PntType_BigText:
	        CASEofChar			v4im_GetPointUC(&ok,UCTBUF1,V4TMBufMax,argpnts[1],ctx) ;
						if (!ok) { v_Msg(ctx,NULL,"ModInvArg",intmodx,1) ; goto fail ; } ;
						v4lex_NestInput(vllt->tcb,NULL,NULL,V4LEX_InpMode_RetEOF) ;
						v4lex_NestInput(vllt->tcb,NULL,UCTBUF1,V4LEX_InpMode_String) ; break ;
		case V4DPI_PntType_List:	vllt->listPt = (struct V4DPI__Point *)v4mm_AllocChunk(argpnts[1]->Bytes,FALSE) ;
						memcpy(vllt->listPt,argpnts[1],argpnts[1]->Bytes) ;
						v4lex_NestInput(vllt->tcb,NULL,NULL,V4LEX_InpMode_RetEOF) ;	/* Push this on to trigger pull of next line in list */
						break ;
	      } ;
	     respnt->Bytes = V4DPI_PointHdr_Bytes + sizeof *vllt ;
	     if (treeDim == UNUSED) return(respnt) ;	/* Return list point as result unless we are going to create tree below */
	 } ;

/*	Here to construct XML tree - enumerate through XML list and build tree on treeDim dimension */
	if (treeDim != UNUSED)
	 { struct V4DPI__LittlePoint treePt,dictPt ;
	   struct V4Tree__Node rootNode,*tnode ;
	   struct V4Tree__Master *tmas ;
	   struct V4DPI__Binding bindpt ;
	   #define XMLTreeDepthMax 100
	   struct V4Tree__Node *xmlTrees[XMLTreeDepthMax] ;
	   int xmlNest ;
	   int dimXMLBegin=v4dpi_DimGet(ctx,UClit("XMLBegin"),DIMREF_IRT), dimXMLEnd=v4dpi_DimGet(ctx,UClit("XMLEnd"),DIMREF_IRT) ;
	   tnode = v4tree_MakeTree(ctx,treeDim,nodes) ;			/* Construct root node of the tree */
	   if (tnode == NULL) { v_Msg(ctx,NULL,"ParseTreeErr",intmodx) ; goto fail ; } ;
	   rootNode = *tnode ;
	   tmas = v4tree_TreeMaster(ctx,TREEID(tnode->Id)) ;	/* Get tree master structure */
	   intPNT(&treePt) ; treePt.Dim = treeDim ;			/* treePt will be used in construction of bindings */
	   xmlNest = 0 ;
	   for(tx=1;tmas->nextNodeId<=max;tx++)
	    { 
	      ok = v4l_ListPoint_Value(ctx,lp,tx,&ptbuf) ;
	      if (xmlTrace > 0)
	       { if ((tx % xmlTrace) == 0) { v_Msg(ctx,NULL,"@%1d. token=%2P\n",tx,&ptbuf) ; vout_UCText(VOUT_Trace,0,ctx->ErrorMsg) ; } ;
	       } else if (xmlTrace < 0) { if (tx >= -(xmlTrace)) { v_Msg(ctx,NULL,"@%1d. token=%2P\n",tx,&ptbuf) ; vout_UCText(VOUT_Trace,0,ctx->ErrorMsg) ; } ; } ;
	      if (ok == LISTVALERR)
	       { v_Msg(ctx,NULL,"ParseXMLErr",intmodx,&ptbuf) ; goto fail ; } ;
	      if (ok <= 0)
	       break ;
	      if (ok & V4L_AutoEndLvl)				/* Did we auto-end an HTML level ? */
	       { if (excludePoint == ptbuf.Value.IntVal) { excludePoint = 0 ; continue ; }
	          else if (excludePoint != 0) continue ;
	         xmlNest-- ;
	         if (tnode->Id != rootNode.Id)
	          { if (xmlNest > 0 && xmlNest < XMLTreeDepthMax) { tnode = xmlTrees[xmlNest-1] ; }
		     else { tnode = v4tree_ParentNode(tmas,tnode) ; } ;
		    if (tnode == NULL) { v_Msg(ctx,NULL,"ParseTreeErr") ; goto fail ; } ;
	          } ;
	       } ;
	      if (ptbuf.Dim == dimXMLBegin)
	       { if (excludePoint != 0) continue ;
	         if (exclNum > 0)
	          { for (i=0;i<exclNum;i++) { if (exclList[i] == ptbuf.Value.IntVal) break ; } ;
	            if (i < exclNum) { excludePoint = ptbuf.Value.IntVal ; continue ; } ;
	          } ;
		 if (tnode == NULL) { tnode = v4tree_MakeTree(ctx,treeDim,nodes) ; rootNode = *tnode ; }
	          else { tnode = v4tree_SproutNode(ctx,tmas,tnode->Id,V4TREE_RelPos_Child,NULL) ; } ;
	         if (tnode == NULL) { v_Msg(ctx,NULL,"ParseTreeErr",intmodx) ; goto fail ; } ;
	         if (xmlNest < XMLTreeDepthMax) xmlTrees[xmlNest] = tnode ;	/* Keep track of XML nesting */
	         xmlNest++ ;
	         if (tnode == NULL) { v_Msg(ctx,NULL,"ParseTreeErr") ; goto fail ; } ;
	         if (FALSE)
	          { P *ip ;
	            treePt.Value.IntVal = tnode->Id ; dictPNTv(&dictPt,Dim_NId,v4im_GetEnumToDictVal(ctx,DE(Label),Dim_NId)) ;
		    INITISCT(&evalpt) ; evalpt.Grouping = 2 ; evalpt.Bytes += (treePt.Bytes + dictPt.Bytes) ;
		    ip = ISCT1STPNT(&evalpt) ; NOISCTVCD(&evalpt) ; memcpy(ip,&treePt,treePt.Bytes) ; ADVPNT(ip) ; memcpy(ip,&dictPt,dictPt.Bytes) ;
		    if (!v4dpi_BindListMake(&bindpt,&ptbuf,&evalpt,ctx,NULL,NOWGTADJUST,0,DFLTRELH)) goto fail ;
		  } else
		  { setNodePtr(tnode->Value,(P *)v4tree_AllocChunk(ctx,tmas,ptbuf.Bytes)) ; memcpy(getNodeValPt(tnode->Value),&ptbuf,ptbuf.Bytes) ;
		  } ;
	       } else if (ptbuf.Dim == dimXMLEnd)
	       { if (excludePoint == ptbuf.Value.IntVal) { excludePoint = 0 ; continue ; }
	          else if (excludePoint != 0) continue ;
	         xmlNest-- ;
	         if (tnode->Id != rootNode.Id)
	          { if (xmlNest > 0 && xmlNest < XMLTreeDepthMax) { tnode = xmlTrees[xmlNest-1] ; }
		     else { tnode = v4tree_ParentNode(tmas,tnode) ; } ;
		    if (tnode == NULL) { v_Msg(ctx,NULL,"ParseTreeErr") ; goto fail ; } ;
	          } ;
	       } else if (ptbuf.Dim == Dim_Alpha)
	       { if (excludePoint != 0) continue ;
	         tnode = v4tree_SproutNode(ctx,tmas,tnode->Id,V4TREE_RelPos_Child,NULL) ; if (tnode == NULL) { v_Msg(ctx,NULL,"ParseTreeErr") ; goto fail ; } ;
	         if (FALSE)
	          { P *ip ;
	            treePt.Value.IntVal = tnode->Id ; dictPNTv(&dictPt,Dim_NId,v4im_GetEnumToDictVal(ctx,DE(Value),Dim_NId)) ;
		    INITISCT(&evalpt) ; NOISCTVCD(&evalpt) ; evalpt.Grouping = 2 ; evalpt.Bytes += (treePt.Bytes + dictPt.Bytes) ;
		    ip = ISCT1STPNT(&evalpt) ; memcpy(ip,&treePt,treePt.Bytes) ; ADVPNT(ip) ; memcpy(ip,&dictPt,dictPt.Bytes) ;
		    if (!v4dpi_BindListMake(&bindpt,&ptbuf,&evalpt,ctx,NULL,NOWGTADJUST,0,DFLTRELH)) goto fail ;
		  } else
		  { if (ptbuf.Bytes > 60)
		     { struct V4LEX__BigText bt ; int len ;
		       len = UCCHARSTRLEN(&ptbuf) ; UCstrncpy(bt.BigBuf,&ptbuf.Value.UCVal[1],len) ;
		       v4dpi_SaveBigTextPoint(ctx,&bt,len,&ptbuf,ptbuf.Dim,FALSE) ;
		     } ;
		    setNodePtr(tnode->Value,(P *)v4tree_AllocChunk(ctx,tmas,ptbuf.Bytes)) ; memcpy(getNodeValPt(tnode->Value),&ptbuf,ptbuf.Bytes) ;
		  } ;
		 tnode = v4tree_ParentNode(tmas,tnode) ; if (tnode == NULL) { v_Msg(ctx,NULL,"ParseTreeErr") ; goto fail ; } ;
	       } else if (ptbuf.Dim == Dim_List)
	       { struct V4L__ListPoint *lp2 ;
	         struct V4DPI__Point aptbuf ;
	         if (excludePoint != 0) continue ;
	         lp2 = (struct V4L__ListPoint *)&ptbuf.Value ;
/*		 Grab attribute name */
		 ok = v4l_ListPoint_Value(ctx,lp2,1,&aptbuf) ;
		 if (ok == LISTVALERR)
		  { v_Msg(ctx,NULL,"ParseXMLErr",intmodx,&ptbuf) ; goto fail ; } ;
		 aptbuf.Dim = dimXMLBegin ;	/* Force this to XMLBegin dimension */
	         tnode = v4tree_SproutNode(ctx,tmas,tnode->Id,V4TREE_RelPos_Child,NULL) ; if (tnode == NULL) { v_Msg(ctx,NULL,"ParseTreeErr") ; goto fail ; } ;
	         if (FALSE)
	          { P *ip ;
	            treePt.Value.IntVal = tnode->Id ; dictPNTv(&dictPt,Dim_NId,v4im_GetEnumToDictVal(ctx,DE(Label),Dim_NId)) ;
		    INITISCT(&evalpt) ; NOISCTVCD(&evalpt) ; evalpt.Grouping = 2 ; evalpt.Bytes += (treePt.Bytes + dictPt.Bytes) ;
		    ip = ISCT1STPNT(&evalpt) ; memcpy(ip,&treePt,treePt.Bytes) ; ADVPNT(ip) ; memcpy(ip,&dictPt,dictPt.Bytes) ;
		    if (!v4dpi_BindListMake(&bindpt,&aptbuf,&evalpt,ctx,NULL,NOWGTADJUST,0,DFLTRELH)) goto fail ;
		  } else
		  { setNodePtr(tnode->Value,(P *)v4tree_AllocChunk(ctx,tmas,aptbuf.Bytes)) ; memcpy(getNodeValPt(tnode->Value),&aptbuf,aptbuf.Bytes) ;
		  } ;
/*		 Grab attribute value */
		 ok = v4l_ListPoint_Value(ctx,lp2,2,&aptbuf) ;
		 if (ok == LISTVALERR)
		  { v_Msg(ctx,NULL,"ParseXMLErr",intmodx,&ptbuf) ; goto fail ; } ;
	         tnode = v4tree_SproutNode(ctx,tmas,tnode->Id,V4TREE_RelPos_Child,NULL) ; if (tnode == NULL) { v_Msg(ctx,NULL,"ParseTreeErr") ; goto fail ; } ;
	         if (FALSE)
	          { P *ip ;
	            treePt.Value.IntVal = tnode->Id ; dictPNTv(&dictPt,Dim_NId,v4im_GetEnumToDictVal(ctx,DE(Value),Dim_NId)) ;
		    INITISCT(&evalpt) ; NOISCTVCD(&evalpt) ; evalpt.Grouping = 2 ; evalpt.Bytes += (treePt.Bytes + dictPt.Bytes) ;
		    ip = ISCT1STPNT(&evalpt) ; memcpy(ip,&treePt,treePt.Bytes) ; ADVPNT(ip) ; memcpy(ip,&dictPt,dictPt.Bytes) ;
		    if (!v4dpi_BindListMake(&bindpt,&aptbuf,&evalpt,ctx,NULL,NOWGTADJUST,0,DFLTRELH)) goto fail ;
		  } else
		  { if (aptbuf.Bytes > 60)
		     { struct V4LEX__BigText bt ; int len ;
		       len = UCCHARSTRLEN(&aptbuf) ; UCstrncpy(bt.BigBuf,&aptbuf.Value.UCVal[1],len) ;
		       v4dpi_SaveBigTextPoint(ctx,&bt,len,&aptbuf,aptbuf.Dim,FALSE) ;
		     } ;
		    setNodePtr(tnode->Value,(P *)v4tree_AllocChunk(ctx,tmas,aptbuf.Bytes)) ; memcpy(getNodeValPt(tnode->Value),&aptbuf,aptbuf.Bytes) ;
		  } ;
		 tnode = v4tree_ParentNode(tmas,tnode) ; if (tnode == NULL) { v_Msg(ctx,NULL,"ParseTreeErr") ; goto fail ; } ;
		 tnode = v4tree_ParentNode(tmas,tnode) ; if (tnode == NULL) { v_Msg(ctx,NULL,"ParseTreeErr") ; goto fail ; } ;
	       } else { v_Msg(ctx,NULL,"ParseValErr",intmodx,&ptbuf) ; goto fail ; } ;
	    } ;

/*	   All done, return root node as value */
	   treePNTv(respnt,rootNode.Id) ; respnt->Dim = treeDim ; return(respnt) ;
	 } ;	 
	 
old_parse_logic:
	if (evalpt.Dim == 0)			/* Did not initialize? */
	 { evalpt.PntType = V4DPI_PntType_Isct ; evalpt.Bytes = V4PS_Int ;	/* Create [] */
	 } ;
	if (evalpt.PntType != V4DPI_PntType_Isct)
	 { v_Msg(ctx,NULL,"ParseModEval",intmodx,V4IM_Tag_Evaluate) ; goto fail ; } ;

	lp = v4im_VerifyList(NULL,ctx,argpnts[1],intmodx) ;
	if (lp == NULL)
	 { v_Msg(ctx,NULL,"ModInvArgList",intmodx,1) ; goto fail ; } ;
	for(i=1;i <= PARSE_PT_MAX && v4l_ListPoint_Value(ctx,lp,i,&ptbuf) > 0;i++)
	 { cpt = &ptbuf ; pts[i-1] = (P *)v4mm_AllocChunk(cpt->Bytes,FALSE) ; memcpy(pts[i-1],cpt,cpt->Bytes) ;
	 } ; pcnt = i - 1 ;

	start = 0 ;
parse_retry:
	for(;pcnt > 1;)				/* Loop until only one point left (presumably the result) */
	 { 
	   frameid = v4ctx_FramePush(ctx,NULL) ;
	   for(i=start,evalok=UNUSED;i<pcnt;i++)	/* Start adding points to context until we get evaluation */
	    { 
	      if (!v4ctx_FrameAddDim(ctx,0,pts[i],0,0)) { v_Msg(ctx,NULL,"CtxAddFail",intmodx) ; goto fail ; } ;
	      CLEARCACHE
	      ctx->bpm = &match ;
	      ept = v4dpi_IsctEval(respnt,&evalpt,ctx,V4DPI_EM_EvalQuote,NULL,NULL) ;
	      ctx->bpm = NULL ;
	      if (ept == NULL) continue ;
	      if (evalok == UNUSED) evalok = i ;
	      if (i >= evalok + lahead) break ;	/* Got something valid and worthwhile */
	    } ;
	   if (evalok == UNUSED) { respnt = NULL ; goto end_parse ; } ;
/*	   Search for corresponding points in match isct & pts[] - make sure contiguous within pts */
	   c1 = UNUSED ;
	   for(j=0,mpt=ISCT1STPNT(&match);j<match.Grouping;j++,ADVPNT(mpt))
	    { for(k=0;k<=i;k++)
	       { if (mpt->PntType == V4DPI_PntType_Special ? mpt->Grouping == V4DPI_Grouping_All : FALSE)
	          { if (mpt->Dim != pts[k]->Dim) continue ;
		  } else
		  { if (memcmp(mpt,pts[k],pts[k]->Bytes) != 0) continue ;
		  } ;
	         if (c1 == UNUSED) { c1 = k ; c2 = k ; } ;
		 if (k < c1 - 1 || k > c2 + 1)			/* Not contiguous */
			  { if (start < pcnt - 1) { start++ ; if (!v4ctx_FramePop(ctx,frameid,NULL)) { v_Msg(ctx,NULL,"ModCtxPopFrame",intmodx,frameid) ; goto fail ; } ; frameid = UNUSED ; goto parse_retry ; } ;
		    respnt = NULL ; goto end_parse ;
		  } ;
		 if (k < c1) { c1 = k ; }
		  else if (k > c2) { c2 = k ; } ;
		 break ;
	       } ;
	    } ;
/*	   Clear context and re-insert matched points to get new value from just matched points */
	   if (c1 == UNUSED) { respnt = NULL ; goto end_parse ; } ;
	   if (!v4ctx_FramePop(ctx,frameid,NULL)) { v_Msg(ctx,NULL,"ModCtxPopFrame",intmodx,frameid) ; goto fail ; } ; frameid = v4ctx_FramePush(ctx,NULL) ;
	   for(i=c1;i<=c2;i++)
	    { 
	      if (!v4ctx_FrameAddDim(ctx,0,pts[i],0,0)) { v_Msg(ctx,NULL,"CtxAddFail",intmodx) ; goto fail ; } ;
	      CLEARCACHE ;
	    } ;
	   ept = v4dpi_IsctEval(respnt,&evalpt,ctx,V4DPI_EM_EvalQuote,NULL,NULL) ;
	   memcpy(pts[c1],ept,ept->Bytes) ;			/* Copy new point at begin of range */
	   for(i=c1+1;i<=c2;i++) { v4mm_FreeChunk(pts[i]) ; } ;
	   for(i=c1+1,j=c2+1;j<pcnt;i++,j++)			/* Compress remaining points */
	    { pts[i] = pts[j] ; } ;
	   pcnt -= (c2 - c1) ;
	   if (!v4ctx_FramePop(ctx,frameid,NULL)) { v_Msg(ctx,NULL,"ModCtxPopFrame",intmodx,frameid) ; goto fail ; } ; frameid = UNUSED ; start = 0 ;
	 } ;
	if (pcnt < 1) { respnt = NULL ; }
	 else { memcpy(respnt,pts[0],pts[0]->Bytes) ; } ;
end_parse:
	if (frameid != UNUSED) { if (!v4ctx_FramePop(ctx,frameid,NULL)) { v_Msg(ctx,NULL,"ModCtxPopFrame",intmodx,frameid) ; goto fail ; } ; } ;
	for(i=0;i<pcnt;i++) { v4mm_FreeChunk(pts[i]) ; } ;
	return(respnt) ;

fail:	REGISTER_ERROR(0) ; return(NULL) ;
}

int v4im_ParseFlagsParse(ok,ctx,flagPt,intmodx,tx,ix)
  LOGICAL *ok ;
  struct V4C__Context *ctx ;
  P *flagPt ;
  INTMODX intmodx ;
  int tx,ix ;
{ struct V4L__ListPoint *lp ;
  P ptbuf,*tpt ;
  int parseflags,i ;

	lp = (flagPt->PntType == V4DPI_PntType_List ? v4im_VerifyList(NULL,ctx,flagPt,intmodx) : NULL) ;
	parseflags = 0 ;
	for(i=1;;i++)
	 { if (lp == NULL) { tpt = flagPt ; }
	    else { if (v4l_ListPoint_Value(ctx,lp,i,&ptbuf) <= 0) break ; tpt = &ptbuf ; } ;
	   switch (v4im_GetDictToEnumVal(ctx,tpt))
	    { default:		v_Msg(ctx,NULL,"ModTagValue",intmodx,ix,tx,tpt) ; *ok = FALSE ; return(0) ;
	      case _EndOfLine:	parseflags |= V4L_ListToken_EndOfLine ; break ;
	      case _Lowercase:	parseflags |= V4L_ListToken_LowerCase ; break ;
	      case _Negative:	parseflags |= V4L_ListToken_Negative ; break ;
	      case _Space:	parseflags |= V4L_ListToken_Space ; break ;
	      case _Uppercase:	parseflags |= V4L_ListToken_UpperCase ; break ;
	    } ; if (lp == NULL) break ;
	 } ;
	*ok = TRUE ; return(parseflags) ;
}

#include "v4tc_tomcrypt.h"

struct V4DPI__Point *v4im_DoStr(ctx,respnt,argpnts,argcnt,intmodx)
  struct V4C__Context *ctx ;
  P *respnt ;						/* Ptr for result */
  INTMODX intmodx ;
  P *argpnts[] ;
  COUNTER argcnt ;
{ P *ipt,*cpt,valpt ; P argbuf,listbuf,list2buf ;
  struct V4DPI__DimInfo *di ;
  struct V4LEX__TknCtrlBlk *tcb = NULL ;
  struct V4L__ListPoint *lp,*lp2 ;
  struct V4LEX__BigText *bt ;
  struct vstr__StringBreak vsb ;
  struct V4IM__XMLNest xml ;
  int i,j,ix,begin,end,uc,len,tlen,rwnum,rstart,bigtextdim,resdim,escchar,gotBT,anchorLHS ; UCCHAR *bp,*bp1,*bp2 ; UB64INT ub64 ;
  UCCHAR *tbuf,tbuf0[V4LEX_BigText_Max+V4LEX_BigText_Max],tbuf1[V4LEX_BigText_Max+V4LEX_BigText_Max],repbuf[V4LEX_BigText_Max+V4LEX_BigText_Max] ;
  TAGVAL tagX ; LOGICAL ok,igCase ;
  unsigned char abuf[V4LEX_BigText_Max+20],rbuf[V4LEX_BigText_Max+20] ; int rindex ;
  BYTE edKey[256] ;
  UCCHAR evalbgn[20],evalend[20],startchar[2] ; UCCHAR ucbuf[V4LEX_BigText_Max+20],xmlSuffix[128] ;
  regex_t comp;
#define REGMATCHMAX 30
  regmatch_t matches[REGMATCHMAX+1];
  int isRegExp, isLocalRegExp ;

//static int vv=0 ; vv++;

	ipt = argpnts[1] ; ix=1 ; ZUS(tbuf0) ; tbuf = tbuf0 ; len = UNUSED ; ZS(edKey) ; ZUS(xmlSuffix) ; xml.Count = 0 ;
	if (argcnt == 2)		/* Str() has alot of overhead. If we have a simple request then try to expedite here */
	 { DIMINFO(di,ctx,ipt->Dim) ; if (di->Flags & V4DPI_DimInfo_Displayer) goto no_expedite ;
	   switch(ipt->PntType)
	    { default:				goto no_expedite ;
	      case V4DPI_PntType_UCChar:
		len = ipt->Value.UCVal[0] ; tbuf = &ipt->Value.UCVal[1] ;
		if (tbuf[len+1] != UCEOS)	/* VEH101105 If we don't end this string then make sure we do now (this may burn me at some future point but for now it is fast) */
		 { tbuf[len+1] = UCEOS ; } ;
		break ;
	      CASEofCharmU
		if (ipt->Value.AlphaVal[0] == V4PT_CharBigStrPrefix)
		 { for(len=0;;len++) { tbuf[len] = ipt->Value.AlphaVal[len+1] ; if (tbuf[len] == UCEOS) break ; } ;
		 } else
		 { len = ipt->Value.AlphaVal[0] ;
		   for(i=0;i<len;i++) { tbuf[i] = ipt->Value.AlphaVal[i+1] ; } ; tbuf[i] = UCEOS ; 
		 } ;
		break ;
	    } ;
	   if (argpnts[2]->PntType != V4DPI_PntType_TagVal)	/* If second argument not a tag then start clean (so we don't concat into argpnts[0]) */
	    { ZUS(tbuf0) ; tbuf = tbuf0 ; goto no_expedite ; } ;
	   ix = 2 ;						/* If we drop thru to Str() then continue with second argument */
	   TAGVALUE(ctx,argpnts[2],&cpt,&argbuf) ;
	   switch (v4im_LastTagNum)
	    { default:
		if (tbuf != tbuf0) { UCstrcpy(tbuf0,tbuf) ; tbuf = tbuf0 ; } ;	/* Make tbuf not point's buffer (e.g. a point in context that might get trashed for future references VEH060809) */
		goto no_expedite ;
	      case -V4IM_Tag_Length:
		intPNTv(respnt,len) ; break ;
	      case -V4IM_Tag_Hash32:
		VHASH32_FWD(i,tbuf,len) ;
		intPNTv(respnt,i) ; break ;
	    } ;
	   return(respnt) ;
	 } ;

/*	Here to handle normal Str() */
no_expedite:
	uc = FALSE ; isRegExp = FALSE ; isLocalRegExp = FALSE ; rindex = UNUSED ; anchorLHS = TRUE ;
	begin = UNUSED ; ZS(rbuf) ; rwnum = 1 ; bigtextdim = UNUSED ; resdim = UNUSED ; escchar = UCEOS ; gotBT = FALSE ; igCase = FALSE ;
	for (ok=TRUE;ix<=argcnt && ok;ix++)
	 { if (argpnts[ix]->PntType != V4DPI_PntType_TagVal)
	    { 
	      if (memcmp(argpnts[ix],&protoNone,V4PS_Int) == 0) continue ;	/* Don't format UV4:none point */
	      if (ix == 1 && argpnts[ix]->PntType == V4DPI_PntType_PntIdx)
	       { respnt = v4dpi_PntIdx_CvtIdxPtr(argpnts[ix]->Value.IntVal) ;	/* Force update to resident point */
	         switch(respnt->PntType)
		  { default:			if (!v4sxi_SpecialDisplayer(ctx,respnt,UCsizeof(ucbuf),ucbuf))
						 v4dpi_PointToStringML(ucbuf,respnt,ctx,V4DPI_FormatOpt_Echo,UCsizeof(ucbuf)) ;
						break ;
		    case V4DPI_PntType_BigText:	gotBT = TRUE ;		/* Remember that at least this arg is bigtext */
		    CASEofCharMBT		v4im_GetPointUC(&ok,ucbuf,UCsizeof(ucbuf),respnt,ctx) ; break ;
		  } ;
		 if (respnt->PntType == V4DPI_PntType_BigText) bigtextdim = respnt->Dim ;
		 if (resdim == UNUSED) { resdim = ((respnt->PntType == V4DPI_PntType_Char || respnt->PntType == V4DPI_PntType_UCChar) ? respnt->Dim : Dim_Alpha) ; }
		  else { if (resdim != respnt->Dim) resdim = Dim_Alpha ; } ;
	       } else
	       { switch(argpnts[ix]->PntType)
		  { default:			if (!v4sxi_SpecialDisplayer(ctx,argpnts[ix],UCsizeof(ucbuf),ucbuf))
						 v4dpi_PointToStringML(ucbuf,argpnts[ix],ctx,V4DPI_FormatOpt_Echo,UCsizeof(ucbuf)) ;
						break ;
		    case V4DPI_PntType_BigText:	gotBT = TRUE ;		/* Remember that at least this arg is bigtext */
		    CASEofCharMBT			v4im_GetPointUC(&ok,ucbuf,UCsizeof(ucbuf),argpnts[ix],ctx) ; break ;
		  } ;
	         if (argpnts[ix]->PntType == V4DPI_PntType_BigText) bigtextdim = argpnts[ix]->Dim ;
/*		 If no resulting dimension then take that of argument, if multiple args with multiple dims then use Dim_Alpha */
		 if (resdim == UNUSED) { resdim = ((argpnts[ix]->PntType == V4DPI_PntType_Char || argpnts[ix]->PntType == V4DPI_PntType_UCChar || argpnts[ix]->PntType == V4DPI_PntType_BigText) ? argpnts[ix]->Dim : Dim_Alpha) ; }
		  else { if (resdim != argpnts[ix]->Dim) resdim = Dim_Alpha ; } ;
	       } ;
	      len = UCstrlen(UCstrcat(tbuf,ucbuf)) ;
	      if (len >= V4LEX_BigText_Max) { v_Msg(ctx,NULL,"StrLitTooBig2",intmodx,ix,V4LEX_BigText_Max) ; goto failure ; } ;
	      continue ;
	    } ;
	   if (resdim == UNUSED) resdim = Dim_Alpha ;
	   switch (tagX=v4im_CheckPtArgNew(ctx,argpnts[ix],&cpt,&argbuf))
	    { default:			v_Msg(ctx,NULL,"TagBadUse",intmodx) ; goto failure ;
	      case V4IM_Tag_Unk:	v_Msg(ctx,NULL,"TagUnknown",intmodx) ; goto failure ;
	      case (V4DPI_TagFlag_Colon3|V4IM_Tag_After):
	      case V4IM_Tag_After:
		v4im_GetPointUC(&ok,ucbuf,512,cpt,ctx) ; if (!ok) break ;
		if (uc) { UCSTRTOUPPER(ucbuf) ; } ;
		if (anchorLHS)
		 { bp = (igCase ? vuc_StrStrIC(tbuf,ucbuf) : UCstrstr(tbuf,ucbuf)) ;
		 } else
		 { for(bp=NULL,bp1=tbuf;;bp1++)
		    { bp1 = (igCase ? vuc_StrStrIC(bp1,ucbuf) : UCstrstr(bp1,ucbuf)) ;
		      if (bp1 == NULL) break ; bp = bp1 ; 
		    } ;
		 } ;
		if (bp == NULL)
		 { if (tagX & V4DPI_TagFlag_Colon3) break ;		/* If After:::"xxx" then don't fail - just keep original string */
		   v_Msg(ctx,NULL,"StrNotInTarget",intmodx,V4IM_Tag_After,ucbuf,tbuf) ; goto failure ;
		 } ;
		bp += UCstrlen(ucbuf) ;		/* Advance over found string */
		UCstrcpy(tbuf,bp) ;		/* Copy after found string */
		len = UCstrlen(tbuf) ; break ;
	      case V4IM_Tag_All:
		if (cpt->PntType == V4DPI_PntType_List)
		 { LOGICAL allMatch = TRUE ;
		   lp = v4im_VerifyList(NULL,ctx,cpt,intmodx) ;
		   for(i=1;allMatch && v4l_ListPoint_Value(ctx,lp,i,&listbuf) > 0;i++)
		    { v4im_GetPointUC(&ok,ucbuf,512,&listbuf,ctx) ; if (!ok) break ;
		      if (uc) { UCSTRTOUPPER(ucbuf) ; } ;
		      bp = (igCase ? vuc_StrStrIC(tbuf,ucbuf) : UCstrstr(tbuf,ucbuf)) ; if (bp == NULL) allMatch = FALSE ;
		    } ;
		   if (!ok) break ;
		   logPNTv(respnt,allMatch) ; goto success ;		/* If here then no match */
		 } else if (cpt->PntType == V4DPI_PntType_RegExpPattern)
		 { memcpy(&comp,(char *)cpt + cpt->Bytes - sizeof comp,sizeof comp) ;
		 } else if (cpt->PntType == V4DPI_PntType_Dict)
		 { goto all_any_none ;
		 } else
		 { v4im_GetPointChar(&ok,rbuf,V4LEX_BigText_Max,cpt,ctx) ; if (!ok) break ;
		   j = REG_EXTENDED ; isLocalRegExp = TRUE ;
		   if (igCase) j |= REG_ICASE ;
		   if (i=vregexp_RegComp(&comp,rbuf,j))
		    { vregexp_Error(i,&comp,ctx->ErrorMsgAux,sizeof ctx->ErrorMsgAux) ;
		      v_Msg(ctx,NULL,"ModFailed2",intmodx) ; goto failure ;
		    } ;
		 } ;
		INITLP(respnt,lp,Dim_List) ;
		ipt = &valpt ; ZPH(ipt) ; ipt->PntType = V4DPI_PntType_Int2 ; ipt->Dim = Dim_Int2 ; ipt->Bytes = V4PS_Int2 ;
		UCstrcpyToASC(abuf,tbuf) ;	/* Have to convert to ASCII for regexp */
		for(ix=0,ok=FALSE;;)
		 { i = vregexp_RegExec(&comp,&abuf[ix],REGMATCHMAX,matches,0) ;
		   if (i) break ; ok = TRUE ;
		   for(j=1;j<REGMATCHMAX;j++) { if (matches[j].rm_so != -1) break ; } ;
		   if (j >= REGMATCHMAX) break ;
		   ipt->Value.Int2Val[0] = matches[j].rm_so + 1 + ix ; ipt->Value.Int2Val[1] = matches[j].rm_eo + ix ;
		   ix += matches[j].rm_eo ;
		   v4l_ListPoint_Modify(ctx,lp,V4L_ListAction_Append,ipt,0) ;
		 } ;
		if (!ok) { v_Msg(ctx,NULL,"StrRegExpNoMtch",intmodx,V4IM_Tag_All,cpt) ; goto failure ; } ;
		ENDLP(respnt,lp) ; ipt = respnt ;
		goto success ;
	      case V4IM_Tag_Anchor:
		switch (v4im_GetDictToEnumVal(ctx,cpt))
		 { default:	v_Msg(ctx,NULL,"ModTagValue",intmodx,ix,V4IM_Tag_Anchor,cpt) ; goto failure ;
		   case _LHS:	anchorLHS = TRUE ; break ;
		   case _RHS:	anchorLHS = FALSE ; break ;
		 } ; break ;
	      case V4IM_Tag_Any:
	      case V4IM_Tag_Count:
	      case V4IM_Tag_None:
all_any_none:
		{ COUNTER cnt=0 ;
		  len = UCstrlen(tbuf) ;
		  switch (v4im_GetDictToEnumVal(ctx,cpt))
		   { default:		v_Msg(ctx,NULL,"ModTagValue",intmodx,ix,tagX,cpt) ; goto failure ;
		     case _Alpha:	for(i=0;i<len;i++) { if (vuc_IsAlpha(tbuf[i])) cnt++ ; } ; break ;
		     case _Digit:	for(i=0;i<len;i++) { if (vuc_IsDigit(tbuf[i])) cnt++ ; } ; break ;
		     case _Hex:		for(i=0;i<len;i++) { if ((tbuf[i] >= UClit('0') && tbuf[i] <= UClit('9')) || (tbuf[i] >= UClit('A') && tbuf[i] <= UClit('F')) || (tbuf[i] >= UClit('a') && tbuf[i] <= UClit('f'))) cnt++ ; } ; break ;
		     case _Id:		if (vuc_IsBgnId(tbuf[0])) cnt++ ; for(i=1;i<len;i++) { if (vuc_IsContId(tbuf[i])) cnt++ ; } ; break ;
		     case _Lowercase:	for(i=0;i<len;i++) { if (vuc_IsLower(tbuf[i])) cnt++ ; } ; break ;
		     case _Octal:	for(i=0;i<len;i++) { if (tbuf[i] >= UClit('0') && tbuf[i] <= UClit('7')) cnt++ ; } ; break ;
		     case _Print:	for(i=0;i<len;i++) { if (vuc_IsPrint(tbuf[i])) cnt++ ; } ; break ;
		     case _Punctuation:	for(i=0;i<len;i++) { if (vuc_IsPunc(tbuf[i])) cnt++ ; } ; break ;
		     case _Uppercase:	for(i=0;i<len;i++) { if (vuc_IsUpper(tbuf[i])) cnt++ ; } ; break ;
		     case _WhiteSpace:	for(i=0;i<len;i++) { if (vuc_IsWSpace(tbuf[i])) cnt++ ; } ; break ;
		   } ;
		  switch (tagX)
		   { case V4IM_Tag_All:		logPNTv(respnt,(len > 0 ? cnt==len : FALSE)) ; break ;
		     case V4IM_Tag_Any:		logPNTv(respnt,cnt>0) ; break ;
		     case V4IM_Tag_Count:	intPNTv(respnt,cnt) ; break ;
		     case V4IM_Tag_None:	logPNTv(respnt,cnt==0) ; break ;
		   } ;
		}
		goto success ;
	      case (V4DPI_TagFlag_Colon3|V4IM_Tag_Before):
	      case V4IM_Tag_Before:
		v4im_GetPointUC(&ok,ucbuf,512,cpt,ctx) ; if (!ok) break ;
		if (uc) { UCSTRTOUPPER(ucbuf) ; } ;
		if (anchorLHS)
		 { bp = (igCase ? vuc_StrStrIC(tbuf,ucbuf) : UCstrstr(tbuf,ucbuf)) ;
		 } else
		 { for(bp=NULL,bp1=tbuf;;bp1++)
		    { bp1 = (igCase ? vuc_StrStrIC(bp1,ucbuf) : UCstrstr(bp1,ucbuf)) ;
		      if (bp1 == NULL) break ; bp = bp1 ; 
		    } ;
		 } ;
		if (bp == NULL)
		 { if (tagX & V4DPI_TagFlag_Colon3) break ;		/* If Before:::"xxx" then don't fail - just keep original string */
		   v_Msg(ctx,NULL,"StrNotInTarget",intmodx,V4IM_Tag_Before,ucbuf,tbuf) ; goto failure ;
		 } ;
		*bp = UCEOS ; len = UCstrlen(tbuf) ; break ;
	      case V4IM_Tag_Begin:
	      case V4IM_Tag_Start:
		begin = v4im_GetPointInt(&ok,cpt,ctx) ; if (!ok) break ;
		if (begin == 0) { begin = 1 ; }
		 else if (begin < 0) { begin += UCstrlen(tbuf) + 1 ; if (begin < 1) begin = 1 ; } ;
		break ;
	      case V4IM_Tag_Break:
		switch (cpt->PntType)
		 {
		   case V4DPI_PntType_Int2:
			vsb.Count = 3 ;
			vsb.Piece[0].StartByte = 0 ; vsb.Piece[0].EndByte = cpt->Value.Int2Val[0] - 2 ;
			vsb.Piece[1].StartByte = cpt->Value.Int2Val[0] - 1 ; vsb.Piece[1].EndByte = cpt->Value.Int2Val[1] - 1 ;
			vsb.Piece[2].StartByte = cpt->Value.Int2Val[1] ; vsb.Piece[2].EndByte = UCstrlen(tbuf) - 1 ;
			return(v4im_StrBreak(ctx,respnt,resdim,tbuf,&vsb,intmodx)) ;
		   case V4DPI_PntType_Int:
		   case V4DPI_PntType_List:
		      {	INDEX bx ;
		        lp = v4im_VerifyList(&list2buf,ctx,cpt,intmodx) ;
			vsb.Count = 0 ; ipt = &listbuf ; bx = 0 ;
			for(i=1;v4l_ListPoint_Value(ctx,lp,i,ipt) > 0;i++)
			 { switch(ipt->PntType)
			    { default:
				v_Msg(ctx,NULL,"ModArgPntType3",intmodx,ix,ipt->PntType,V4DPI_PntType_Int,V4DPI_PntType_Int2) ; goto failure ;
			      case V4DPI_PntType_Int2:
				vsb.Piece[vsb.Count].StartByte = bx ; vsb.Piece[vsb.Count++].EndByte = ipt->Value.Int2Val[0] - 2 ;
				vsb.Piece[vsb.Count].StartByte = ipt->Value.Int2Val[0] - 1 ; vsb.Piece[vsb.Count++].EndByte = ipt->Value.Int2Val[1] - 1 ;
				bx = ipt->Value.Int2Val[1] ; break ;
			      case V4DPI_PntType_Int:
				if (bx == ipt->Value.IntVal - 1) break ;
				vsb.Piece[vsb.Count].StartByte = bx ; vsb.Piece[vsb.Count++].EndByte = ipt->Value.IntVal - 2 ;
				bx = ipt->Value.IntVal - 1 ; break ;
			    } ;
			 } ;
			vsb.Piece[vsb.Count].StartByte = bx ; vsb.Piece[vsb.Count++].EndByte = UCstrlen(tbuf) - 1 ;
			return(v4im_StrBreak(ctx,respnt,resdim,tbuf,&vsb,intmodx)) ;
		      }
		   case V4DPI_PntType_Dict:
			switch (v4im_GetDictToEnumVal(ctx,cpt))
			 { default:		v_Msg(ctx,NULL,"StrBreakArg",intmodx,V4IM_Tag_Break) ; goto failure ;
//			   case _KAPairs:
//			     INITLP(respnt,lp,Dim_List) ;
//			     for(bp=tbuf;*bp!=UCEOS;bp++)
//			      { UCCHAR save ;
//			        INITLP((&listbuf),lp2,Dim_List) ;
///*				Skip leading white space */
//			        for(;*bp!=UCEOS;bp++) { if (!vuc_IsWSpace(*bp)) break ; } ;
///*				Parse the keyword */
//			        if (*bp == UCEOS) break ;		/* End of string - then quit */
//			        if (!vuc_IsBgnId(*bp)) goto invbrksyn ;
//			        for(bp2=bp;*bp2!=UCEOS;*bp2++) { if (!vuc_IsContId(*bp2)) break ; } ;
//			        if (*bp2 == UCEOS) goto invbrksyn ;
//			        save = *bp2 ; *bp2 = UCEOS ;
///*				Append keyword to inner list */
//			        uccharPNTv(&valpt,bp) ; v4l_ListPoint_Modify(ctx,lp2,V4L_ListAction_Append,&valpt,0) ;
//			        *bp2 = save ; bp = bp2 + 1 ;
///*				If not up to "=" then get to it and position bp to next character */
//			        if (save != UClit('='))
//			         { for(;*bp!=UCEOS;bp++) { if (*bp == UClit('=')) { bp++ ; break ; } ; if (!vuc_IsWSpace(*bp)) goto invbrksyn ; } ;
//			         } ;
///*				Again, skip any white space */
//			        for(;*bp!=UCEOS;bp++) { if (!vuc_IsWSpace(*bp)) break ; } ;
//			        if (*bp == UCEOS) goto invbrksyn ;
///*				Is value enclosed in quotes ? */
//			        if (*bp == UClit('"') || *bp == UClit('\''))
//			         { save = *bp ; bp2 = ++bp ;
//			           for(;*bp!=UCEOS;bp++) { if (*bp == save) break ; } ;
//			           if (*bp == UCEOS) goto invbrksyn ; save = *bp ; *bp = UCEOS ;
//			         } else
//			         { if (!(vuc_IsBgnId(*bp) || vuc_IsDigit(*bp))) goto invbrksyn ;	/* Not enclosed in quotes - best be some sort of identifier */
//			           bp2 = bp ;
//			           for(bp++;*bp!=UCEOS;bp++) { if (!vuc_IsContId(*bp)) break ; } ;
//			           if (!(*bp == UCEOS || vuc_IsWSpace(*bp))) goto invbrksyn ;
//			           save = *bp ; *bp = UCEOS ;
//			         } ;
///*				Append value to inner list, then append inner list to outer list */
//			        uccharPNTv(&valpt,bp2) ; v4l_ListPoint_Modify(ctx,lp2,V4L_ListAction_Append,&valpt,0) ;
//			        *bp = save ;
//			        ENDLP((&listbuf),lp2) ; v4l_ListPoint_Modify(ctx,lp,V4L_ListAction_Append,&listbuf,0) ;
//				if (save == UCEOS) break ;	/* If all done, don't go back (bp++ will skip over '\0' and we parse garbage */
//			      } ;
//			     ENDLP(respnt,lp) ; goto success ;
//invbrksyn:		     v_Msg(ctx,NULL,"StrBreakSyn",intmodx,V4IM_Tag_Break,(enum DictionaryEntries)_KAPairs,1+bp-tbuf,tbuf) ; goto failure ;
			 } ;
			break ;
		   default:
			INITLP(respnt,lp,Dim_List) uccharPNT(&valpt) ;
			if (ix >= argcnt ? FALSE : v4im_TagId(argpnts[ix+1]) == -V4IM_Tag_Trim)
			 { ix ++ ; j = TRUE ; }
			 else { j = FALSE ; } ;									/* Next is Trim? - don't include break character */
			v4im_GetPointUC(&ok,ucbuf,512,cpt,ctx) ; if (!ok) break ;
			if (UCempty(ucbuf)) UCstrcpy(ucbuf,UClit(" \t,.")) ;			/* Default to space, tab, comma, period */
			i = UCstrcspn(tbuf,ucbuf) ;
			UCstrncpy(&valpt.Value.UCVal[1],tbuf,i) ;
			UCCHARPNTBYTES2(&valpt,i) ;
			v4l_ListPoint_Modify(ctx,lp,V4L_ListAction_Append,&valpt,0) ;
			if (j) i ++ ;										/* Don't include break character */
			len = UCstrlen(tbuf) - i ; if (len < 0) len = 0 ;
			UCstrncpy(&valpt.Value.UCVal[1],&tbuf[i],len) ; 			
			UCCHARPNTBYTES2(&valpt,len) ;
			v4l_ListPoint_Modify(ctx,lp,V4L_ListAction_Append,&valpt,0) ;
			ENDLP(respnt,lp)
			goto success ;
		 } ;
	      case -V4IM_Tag_Capitalize:
	      case -V4IM_Tag_Title:
		{ LOGICAL startWord ;
		  for(startWord=TRUE,i=0;tbuf[i]!=UCEOS;i++)
		   { if (vuc_IsAlphaNum(tbuf[i]))
		      { if (startWord) { tbuf[i] = UCTOUPPER(tbuf[i]) ; startWord = FALSE ; continue ; } ;
		        tbuf[i] = UCTOLOWER(tbuf[i]) ; continue ;
		      } ;
/*		     Most likely start of new word. Check for exceptions (e.g. apostrophe) */
		     if (tbuf[i] == UClit('\'') && i > 0)
		      { if (vuc_IsAlphaNum(tbuf[i-1]) && vuc_IsAlphaNum(tbuf[i+1])) continue ; } ;
#ifdef V4UNICODE     /* Check for various other possible UNICODE apostrophe characters */
		     if (i > 0 && tbuf[i] == 0x2B9 || tbuf[i] == 0x2BC || tbuf[i] == 0x2C78 || tbuf[i] == 0x301 || tbuf[i] == 0x5F3 || tbuf[i] == 0x2032 || tbuf[i] == 0xA78C)
		      { if (vuc_IsAlphaNum(tbuf[i-1]) && vuc_IsAlphaNum(tbuf[i+1])) continue ; } ;
#endif
		     startWord = TRUE ;
		   } ;
		}
		break ;
	      case V4IM_Tag_Decode:
/*		Scan for special escape character - convert next character appropriately */
		for(i=0,j=0;i<len;i++,j++)
		 { if (tbuf[i] == UClit('\1'))  { tbuf[j] = tbuf[++i] - UClit('A') ; continue ; } ;
		   if (i == j) continue ;
		   tbuf[j] = tbuf[i] ;
		 } ; tbuf[j] = UCEOS ;
		switch (v4im_GetDictToEnumVal(ctx,cpt))
		 { default:		v_Msg(ctx,NULL,"StrEncDec",intmodx,V4IM_Tag_Decode,cpt) ; goto failure ;
		   case _Base64:
			if ((len = V_Decode64(tbuf,UCstrlen(tbuf),tbuf1,V4LEX_BigText_Max,ctx->ErrorMsgAux)) == -1)
			 { v_Msg(ctx,NULL,"StrEncDecFail",intmodx) ; goto failure ; } ;
			UCstrcpy(tbuf,tbuf1) ;
			break ;
		   case _DES:
			if (strlen(edKey) == 0) { v_Msg(ctx,NULL,"StrEncDecNoKey",intmodx,V4IM_Tag_DES,V4IM_Tag_Key) ; goto failure ; } ;
			len =  v_EncodeDecode((BYTE *)tbuf,j*sizeof(UCCHAR),V4LEX_BigText_Max*sizeof(UCCHAR),V4_EDMETHOD_DES,FALSE,edKey,strlen(edKey),ctx->ErrorMsgAux) ;
			if (len == UNUSED) { v_Msg(ctx,NULL,"StrEncDecFail",intmodx) ; goto failure ; } ;
			break ;
		   case _Hex:
#define dHex(X) (X <= UClit('9') ? (X - UClit('0')) : (UCTOUPPER(X) - UClit('A') + 10))
			for(i=0,j=0;tbuf[j]!=UCEOS;i++,j+=4)
			 { tbuf[i] = dHex(tbuf[j])
					+ (dHex(tbuf[j+1]) << 4)
					+ (dHex(tbuf[j+2]) << 8)
					+ (dHex(tbuf[j+3]) << 12) ;
			 } ; tbuf[len=i] = UCEOS ;
			break ;
		   case _Hex8:
			for(i=0,j=0;tbuf[j]!=UCEOS;i++,j+=2)
			 { tbuf[i] = dHex(tbuf[j]) + (dHex(tbuf[j+1]) << 4) ;
			 } ; tbuf[len=i] = UCEOS ;
			break ;
		   case _XML:
		      { int base = 10, num, digit ; UCCHAR *dbp, *digits = UClit("0123456789") ;
			for(i=0,j=0;tbuf[i]!=UCEOS;i++)
			 { 
			   if (tbuf[i] != UClit('&')) { tbuf1[j++] = tbuf[i] ; continue ; } ;
			   i++ ;
			   if (tbuf[i] == UClit('#'))		/* Have numeric form- &#nnn */
			    { i++ ;
			      if (tbuf[i] == UClit('x') || tbuf[i] == UClit('X')) { i++ ; base = 16 ; digits = UClit("0123456789ABCDEF") ; }
			       else if (tbuf[i] == UClit('0')) { i++ ; base = 8 ; digits = UClit("01234567") ; } ;
			      for(num=0;tbuf[i]!=UClit(';');i++)
			       { for(digit=0,dbp=digits;*dbp!=UCEOS;digit++,dbp++) { if (*dbp == UCTOUPPER(tbuf[i])) break ; } ;
			         if (digit >= base)
				  { v_Msg(ctx,NULL,"@%1E Invalid XML entity code",intmodx) ; goto failure ; } ;
			         num = num * base + digit ;
			       } ;
			      tbuf1[j++] = num ;
			    } else			/* Have named form - &name; */
			    { UCCHAR *bp2 = UCTBUF2 ; *(bp2++) = UClit('&') ;
			      for(;tbuf[i]!=UClit(';')&& tbuf[i]!=UCEOS;) { *(bp2 ++) = tbuf[i++] ; } ;
			      *(bp2++) = UClit(';') ; *bp2 = UCEOS ;
			      tbuf1[j++] = (UCCHAR)v4xml_LookupISONamedEntity(UCTBUF2) ;
			      if (tbuf1[j-1] == UCEOS)
			       { v_Msg(ctx,NULL,"@%1E Invalid/unknown ISO named entity (%2U)",intmodx,UCTBUF2) ; goto failure ; } ;
			    } ;
			 } ;
			tbuf1[j] = UCEOS ; UCstrcpy(tbuf,tbuf1) ; len = j ; break ;
		      }
		   case _XOR:
			if (strlen(edKey) == 0) { v_Msg(ctx,NULL,"StrEncDecNoKey",intmodx,V4IM_Tag_DES,V4IM_Tag_Key) ; goto failure ; } ;
			len =  v_EncodeDecode((BYTE *)tbuf,j*sizeof(UCCHAR),V4LEX_BigText_Max*sizeof(UCCHAR),V4_EDMETHOD_XOR,FALSE,edKey,strlen(edKey),ctx->ErrorMsgAux) ;
			if (len == UNUSED) { v_Msg(ctx,NULL,"StrEncDecFail",intmodx) ; goto failure ; } ;
			break ;
		   case _XOR8:
			if (strlen(edKey) == 0) { v_Msg(ctx,NULL,"StrEncDecNoKey",intmodx,V4IM_Tag_DES,V4IM_Tag_Key) ; goto failure ; } ;
			for(i=0;i<j;i++)
			 { if (tbuf[i] > 0xff) { v_Msg(ctx,NULL,"StrEncDecNoUNI",intmodx,V4IM_Tag_Decode,DE(XOR8)) ; goto failure ; } ;
			   abuf[i] = (char)tbuf[i] ;
			 } ;
			len =  v_EncodeDecode(abuf,j,V4LEX_BigText_Max*sizeof(UCCHAR),V4_EDMETHOD_XOR,TRUE,edKey,strlen(edKey),ctx->ErrorMsgAux) ;
			if (len == UNUSED) { v_Msg(ctx,NULL,"StrEncDecFail",intmodx) ; goto failure ; } ;
			for(i=0;i<len;i++) { tbuf[i] = (UCCHAR)abuf[i] ; } ; tbuf[len] = UCEOS ;
			break ;
		 } ;
		break ;
	      case V4IM_Tag_Encode:
		switch (v4im_GetDictToEnumVal(ctx,cpt))
		 { default:		v_Msg(ctx,NULL,"StrEncDec",intmodx,V4IM_Tag_Encode,cpt) ; goto failure ;
		   case _Base64:
			if ((len = VUC_Encode64(tbuf,UCstrlen(tbuf),tbuf1,V4LEX_BigText_Max,ctx->ErrorMsgAux)) == -1)
			 { v_Msg(ctx,NULL,"StrEncDecFail") ; goto failure ; } ;
			break ;
		   case _DES:
			if (strlen(edKey) == 0) { v_Msg(ctx,NULL,"StrEncDecNoKey",intmodx,V4IM_Tag_DES,V4IM_Tag_Key) ; goto failure ; } ;
			UCstrcpy(tbuf1,tbuf) ;
			len =  v_EncodeDecode((BYTE *)tbuf1,UCstrlen(tbuf1)*sizeof(UCCHAR),V4LEX_BigText_Max*sizeof(UCCHAR),V4_EDMETHOD_DES,TRUE,edKey,strlen(edKey),ctx->ErrorMsgAux) ;
			if (len == UNUSED) { v_Msg(ctx,NULL,"StrEncDecFail",intmodx) ; goto failure ; } ;
			len /= sizeof(UCCHAR) ;
			break ;
		   case _Hex:
			for(i=0,j=0;tbuf[i]!=UCEOS;i++)
			 { tbuf1[j++] = UClit("0123456789ABCDEF")[tbuf[i] & 0xf] ;
			   tbuf1[j++] = UClit("0123456789ABCDEF")[(tbuf[i] >> 4) & 0xf] ;
			   tbuf1[j++] = UClit("0123456789ABCDEF")[(tbuf[i] >> 8) & 0xf] ;
			   tbuf1[j++] = UClit("0123456789ABCDEF")[(tbuf[i] >> 12) & 0xf] ;
			 } ; tbuf1[len=j] = UCEOS ;
			break ;
		   case _Hex8:
			for(i=0,j=0;tbuf[i]!=UCEOS;i++)
			 { if (tbuf[i] > 0xff) { v_Msg(ctx,NULL,"StrEncDecNoUNI",intmodx,V4IM_Tag_Encode,DE(XOR8)) ; goto failure ; } ;
			   tbuf1[j++] = UClit("0123456789ABCDEF")[tbuf[i] & 0xf] ;
			   tbuf1[j++] = UClit("0123456789ABCDEF")[(tbuf[i] >> 4) & 0xf] ;
			 } ; tbuf1[len=j] = UCEOS ;
			break ;
		   case _XML:
			for(i=0,j=0;tbuf[i]!=UCEOS;i++)
			 { int stack[30], sx, val ; UCCHAR b ;
			   b = tbuf[i] ;
			   if (b < 128 && b != UClit('"') && b != UClit('&') && b != UClit('<') && b != UClit('>')) { tbuf1[j++] = b ; continue ; } ;
			   tbuf1[j++] = UClit('&') ; tbuf1[j++] = UClit('#') ;
			   val = b ; for(sx=0;val > 0;val /= 10) { stack[sx++] = val % 10 ; } ;
			   for(sx--;sx>=0;sx--) { tbuf1[j++] = stack[sx] + UClit('0') ; } ;
			   tbuf1[j++] = UClit(';') ;
//			   *(ubp1++) = (*ubp / 100) + UClit('0') ; *(ubp1++) = ((*ubp % 100) / 10) + UClit('0') ; *(ubp1++) = (*ubp % 10) + UClit('0') ;
			 } ; tbuf1[len=j] = UCEOS ;
			 break ;
		   case _XOR:
			if (strlen(edKey) == 0) { v_Msg(ctx,NULL,"StrEncDecNoKey",intmodx,V4IM_Tag_DES,V4IM_Tag_Key) ; goto failure ; } ;
			UCstrcpy(tbuf1,tbuf) ;
			len =  v_EncodeDecode((BYTE *)tbuf1,UCstrlen(tbuf1)*sizeof(UCCHAR),V4LEX_BigText_Max*sizeof(UCCHAR),V4_EDMETHOD_XOR,TRUE,edKey,strlen(edKey),ctx->ErrorMsgAux) ;
			if (len == UNUSED) { v_Msg(ctx,NULL,"StrEncDecFail",intmodx) ; goto failure ; } ;
			len /= sizeof(UCCHAR) ;
			break ;
		   case _XOR8:
			if (strlen(edKey) == 0) { v_Msg(ctx,NULL,"StrEncDecNoKey",intmodx,V4IM_Tag_DES,V4IM_Tag_Key) ; goto failure ; } ;
			for(i=0;;i++)
			 { if (tbuf[i] > 0xff) { v_Msg(ctx,NULL,"StrEncDecNoUNI",intmodx,V4IM_Tag_Encode,DE(XOR8)) ; goto failure ; } ;
			   abuf[i] = (char)tbuf[i] ;
			   if (tbuf[i] == UCEOS) break ;
			 } ;
			len =  v_EncodeDecode(abuf,strlen(abuf),V4LEX_BigText_Max*sizeof(UCCHAR),V4_EDMETHOD_XOR,TRUE,edKey,strlen(edKey),ctx->ErrorMsgAux) ;
			if (len == UNUSED) { v_Msg(ctx,NULL,"StrEncDecFail",intmodx) ; goto failure ; } ;
			for(i=0;i<len;i++) { tbuf1[i] = (UCCHAR)abuf[i] ; } ; tbuf1[len] = UCEOS ;
			break ;
		 } ;
/*		Have to make pass through this new string to see if any control characters */
		for(i=0,j=0;i<len;i++,j++)
		 { switch(tbuf1[i])
		    { default:			tbuf[j] = tbuf1[i] ; break ;
		      case UClit('\0'):
		      case UClit('\1'):		tbuf[j++] = UClit('\1') ; tbuf[j] = tbuf1[i] + UClit('A') ; break ;
		    } ;
		 } ; tbuf[j] = UCEOS ; len = j ;
		break ;
	      case V4IM_Tag_Dim:
		DIMINFO(di,ctx,cpt->Value.IntVal) ;
		if (di == NULL)
		 { v_Msg(ctx,NULL,"ModArgNotDim",intmodx,ix,cpt) ; goto failure ; } ;
		INITTCB ; v4lex_NestInput(tcb,NULL,tbuf,V4LEX_InpMode_String) ;
		i = v4dpi_PointAccept(&valpt,di,tcb,ctx,V4DPI_PointParse_RetFalse) ;
		v4lex_FreeTCB(tcb) ; tcb = NULL ;
		logPNTv(respnt,i) ; goto success ;
	      case V4IM_Tag_Empty:
		{ LOGICAL isEmpty, wantEmpty = v4im_GetPointLog(&ok,cpt,ctx) ; if (!ok) break ;
		  for(i=0;;i++)
		    { if (tbuf[i] == UCEOS) { isEmpty = TRUE ; break ; } ;
		      if (tbuf[i] <= 26 || vuc_IsWSpace(tbuf[i])) continue ;
		      isEmpty = FALSE ; break ;
		    } ;
		  logPNTv(respnt,(isEmpty == wantEmpty)) ; goto success ;
		}
	      case -V4IM_Tag_Empty:			/* Return true if string empty or contains only white-space */
		for(i=0;;i++)
		 { if (tbuf[i] == UCEOS) { logPNTv(respnt,TRUE) ; goto success ; } ;
		   if (tbuf[i] <= 26 || vuc_IsWSpace(tbuf[i])) continue ;
		   break ;
		 } ;
		logPNTv(respnt,FALSE) ; goto success ;
	      case V4IM_Tag_End:
		len = UCstrlen(tbuf) ;
		end =  v4im_GetPointInt(&ok,cpt,ctx) ; if (!ok) break ;
		if (end < 0) { end += len + 1 ; if (end < 1) end = 1 ; } ;
		if (begin == UNUSED) begin = 1 ;
		if (begin > len) { v_Msg(ctx,NULL,"StrPastEOS",intmodx,begin,len) ; goto failure ; } ;
		if (end > len) end = len ;
		for(i=0,j=begin-1;j<end;i++,j++) { tbuf[i] = tbuf[j] ; } ; tbuf[i] = UCEOS ; len = i ;
		break ;
	      case V4IM_Tag_Escape:
		if (cpt->PntType == V4DPI_PntType_Dict)
		 { if (memcmp(cpt,&protoNone,protoNone.Bytes) == 0) { escchar = UNUSED ; }
		    else { switch (v4im_GetDictToEnumVal(ctx,cpt))
			    { default:		v_Msg(ctx,NULL,"ModTagValue",intmodx,ix,V4IM_Tag_Escape,cpt) ; goto failure ;
			      case _HTML:	escchar = -2 ; break ;
			    } ;
			 } ;
		 } else
		 { v4im_GetPointUC(&ok,ucbuf,2,cpt,ctx) ; if (!ok) break ; escchar = ucbuf[0] ; } ;
		break ;
	      case V4IM_Tag_Evaluate:
		v4im_GetPointUC(&ok,evalbgn,UCsizeof(evalbgn),cpt,ctx) ; if (!ok) break ;
		len = UCstrlen(evalbgn) ;
		for(i=0,j=len-1;j>=0;i++,j--)
		 { switch (evalbgn[j])
		    { default:		evalend[i] = evalbgn[j] ; break ;
		      case UClit('('):		evalend[i] = UClit(')') ; break ;
		      case UClit('['):		evalend[i] = UClit(']') ; break ;
		      case UClit('<'):		evalend[i] = UClit('>') ; break ;
		      case UClit('{'):		evalend[i] = UClit('}') ; break ;
		    } ;
		 } ; evalend[len] = UCEOS ;
		ZUS(repbuf) ;
		for(bp=tbuf;;bp=bp2+len)
		 { bp1 = UCstrstr(bp,evalbgn) ; if (bp1 == NULL) { UCstrcat(repbuf,bp) ; break ; } ;
		   *bp1 = UCEOS ; UCstrcat(repbuf,bp) ;
		   bp2 = UCstrstr(bp1+len,evalend) ;
		   if (bp2 == NULL) { v_Msg(ctx,NULL,"StrEvalNoEnd",intmodx,evalend,bp1+UCstrlen(evalbgn)) ; goto failure ; } ;
		   *bp2 = UCEOS ; UCstrcpy(tbuf1,bp1+len) ;
		   if (UCempty(tbuf1)) continue ;		/* Nothing to evaluate - then nothing to do */
		   INITTCB ; v4lex_NestInput(tcb,NULL,tbuf1,V4LEX_InpMode_String) ;
		   if (!v4dpi_PointParse(ctx,&valpt,tcb,V4DPI_PointParse_RetFalse)) { v_Msg(ctx,NULL,"ModFailed2",intmodx) ; goto failure ; } ;
		   v4lex_FreeTCB(tcb) ; tcb = NULL ;
/*		   If point not isct then convert to intersection (as favor to programmer) */
		   if (valpt.PntType != V4DPI_PntType_Isct && valpt.PntType != V4DPI_PntType_Special)
		    { memcpy(respnt,&valpt,valpt.Bytes) ;
		      INITISCT(&valpt) ; NOISCTVCD(&valpt) ; valpt.Grouping = 1 ;
		      memcpy(ISCT1STPNT(&valpt),respnt,respnt->Bytes) ; valpt.Bytes += respnt->Bytes ;
		    } ;
		   ipt = v4dpi_IsctEval(respnt,&valpt,ctx,0,NULL,NULL) ;
		   if (ipt == NULL)
		    { v_Msg(ctx,NULL,"StrEvalIsctFail",intmodx,&valpt) ; goto failure ; } ;
		   v4dpi_PointToStringML(ucbuf,ipt,ctx,V4DPI_FormatOpt_Echo,UCsizeof(ucbuf)) ;	/* Convert to printable format */
		   if (UCstrlen(repbuf) + UCstrlen(ucbuf) >= V4LEX_BigText_Max)
		    { v_Msg(ctx,NULL,"StrEvalTooBig",intmodx,&valpt,ucbuf,UCstrlen(ucbuf),V4LEX_BigText_Max) ; goto failure ; } ;
		   UCstrcat(repbuf,ucbuf) ;
		 } ;
		UCstrcpy(tbuf,repbuf) ; len = UCstrlen(tbuf) ;
		break ;
	      case V4IM_Tag_Exact:
		if (cpt->PntType == V4DPI_PntType_List)
		 { lp = v4im_VerifyList(NULL,ctx,cpt,intmodx) ;
		   for(i=1;v4l_ListPoint_Value(ctx,lp,i,&listbuf) > 0;i++)
		    { cpt = &listbuf ;
		      v4im_GetPointUC(&ok,ucbuf,512,cpt,ctx) ; if (!ok) break ;
		      if (igCase)
		       { if (vuc_StrCmpIC(ucbuf,tbuf,0) == 0) { intPNTv(respnt,i) ; goto success ; }
		       } else 
		       { if (uc) { UCSTRTOUPPER(ucbuf) ; } ;
			 if (UCstrcmp(ucbuf,tbuf) == 0) { intPNTv(respnt,i) ; goto success ; }
		       } ;
		    } ; logPNTv(respnt,FALSE) ; goto success ;		/* If here then no match */
		 } ;
		v4im_GetPointUC(&ok,ucbuf,512,cpt,ctx) ; if (!ok) break ;
		if (igCase)
		 { if (vuc_StrCmpIC(ucbuf,tbuf,0) == 0) { intPNTv(respnt,ix-1) ; goto success ; }
		    else { if (ix >= argcnt) { logPNTv(respnt,FALSE) ; goto success ; } else continue ; } ;
		 } ;
		if (uc) { UCSTRTOUPPER(ucbuf) ; } ;
		if (UCstrcmp(ucbuf,tbuf) == 0)
		 { 
		   intPNTv(respnt,ix-1) ; goto success ;
		 } else { if (ix >= argcnt) { logPNTv(respnt,FALSE) ; goto success ; } else continue ; } ;
	      case -V4IM_Tag_Group:			/* If Group? then return list of all groups */
		if (!isRegExp)
		 { v_Msg(ctx,NULL,"@%1E Arg(#%2d) - must have prior RegExp::xxx match",intmodx,ix) ; goto failure ; } ;
		INITLP(respnt,lp,Dim_List) ;
		for(i=1;i<=REGMATCHMAX;i++)
		 { if (matches[i].rm_so == -1) break ;
		   ipt = &valpt ; uccharPNT(ipt) ; ipt->Dim = resdim ; len = matches[i].rm_eo - matches[i].rm_so ;
		   if (len >= V4LEX_BigText_Max-1) len = V4LEX_BigText_Max - 2 ;
		   UCstrncpy(&ipt->Value.UCVal[1],&tbuf[matches[i].rm_so],len) ;
		   UCCHARPNTBYTES2(ipt,len) ;
		   if (!v4l_ListPoint_Modify(ctx,lp,V4L_ListAction_Append,ipt,0)) { v_Msg(ctx,NULL,"LPModFail",intmodx) ; goto failure ; } ;
		 } ;
		ENDLP(respnt,lp) ; ipt = respnt ;
		goto success ;
	      case V4IM_Tag_Group:
		if (!isRegExp)
		 { v_Msg(ctx,NULL,"@%1E Group::n not allowed unless after RegExp tag",intmodx) ; goto failure ; } ;
		i = v4im_GetPointInt(&j,cpt,ctx) ; if (!j) i = -1 ;
		if (i < 0 || i > REGMATCHMAX ? TRUE : matches[i].rm_so == -1)
		 { v_Msg(ctx,NULL,"@%1E Group::n does not correspond to defined group",intmodx) ; goto failure ; } ;
		if (matches[i].rm_eo-matches[i].rm_so >= UCsizeof(tbuf0))
		 { ok = FALSE ; v_Msg(ctx,ctx->ErrorMsgAux,"@Group::%1d bytes(%2d) exceed max(%3d)",i,matches[i].rm_eo-matches[i].rm_so,(sizeof tbuf)-2) ; break ; } ;
		UCstrncpy(tbuf,&tbuf[matches[i].rm_so],matches[i].rm_eo-matches[i].rm_so) ;
		tbuf[matches[i].rm_eo-matches[i].rm_so] = UCEOS ; len = UCstrlen(tbuf) ; break ;
	      case V4IM_Tag_Has:
		if (cpt->PntType == V4DPI_PntType_List)
		 { LOGICAL didCompare=FALSE ;
		   lp = v4im_VerifyList(NULL,ctx,cpt,intmodx) ;
		   for(i=1;v4l_ListPoint_Value(ctx,lp,i,&listbuf) > 0;i++)
		    { cpt = &listbuf ;
		      v4im_GetPointUC(&ok,ucbuf,512,cpt,ctx) ; if (!ok) break ;
/*		      If Has string is empty then skip. If list only has empty strings then throw error */
		      if (UCempty(ucbuf)) continue ;
		      didCompare = TRUE ;
		      if (uc) { UCSTRTOUPPER(ucbuf) ; } ;
		      bp = (igCase ? vuc_StrStrIC(tbuf,ucbuf) : UCstrstr(tbuf,ucbuf)) ; if (bp == NULL) continue ;
		      if (intmodx == V4IM_OpCode_Str) { intPNTv(respnt,i) ; goto success ; }
		       else { logPNTv(respnt,TRUE) ; goto success ; } ;
		    } ;
		   if (!didCompare) { v_Msg(ctx, NULL, "StrIsEmpty", intmodx, argpnts[ix]) ; goto failure ; } ;
		   if (!ok) break ;
		   logPNTv(respnt,FALSE) ; goto success ;		/* If here then no match */
		 } ;
		v4im_GetPointUC(&ok,ucbuf,512,cpt,ctx) ; if (!ok) break ;
		if (uc) { UCSTRTOUPPER(ucbuf) ; } ;
		if (UCempty(ucbuf))
		 { v_Msg(ctx,NULL,"StrIsEmpty",intmodx,argpnts[ix]) ; goto failure ; } ;
		if (anchorLHS)
		 { bp = (igCase ? vuc_StrStrIC(tbuf,ucbuf) : UCstrstr(tbuf,ucbuf)) ;
		 } else
		 { for(bp=NULL,bp1=tbuf;;bp1++)
		    { bp1 = (igCase ? vuc_StrStrIC(bp1,ucbuf) : UCstrstr(bp1,ucbuf)) ;
		      if (bp1 == NULL) break ; bp = bp1 ; 
		    } ;
		 } ;
		if (bp == NULL) { logPNTv(respnt,FALSE) ; goto success ; } ;
		if (intmodx == V4IM_OpCode_Str) { intPNTv(respnt,bp-tbuf+1) ; goto success ; }
		 else { logPNTv(respnt,TRUE) ; goto success ; } ;
	      case V4IM_Tag_Hash:
		switch (v4im_GetDictToEnumVal(ctx,cpt))
		 { default:		v_Msg(ctx,NULL,"ModTagValue",intmodx,ix,V4IM_Tag_Hash,cpt) ; goto failure ;
		   case _32:
			for(i=0;;i++) { if (tbuf[i] > 0x7f) break ; ASCTBUF1[i] = tbuf[i] ; if (tbuf[i] == UCEOS) break ; } ;
			if (tbuf[i] == UCEOS)			/* Did we get to the end with just ASCII ? */
			 { VHASH32_FWDb(i,ASCTBUF1,i) ; intPNTv(respnt,i) ;
			 } else { VHASH32_FWD(i,tbuf,UCstrlen(tbuf)) ; intPNTv(respnt,i) ; } ;
			goto success ;
		   case _64:
			ZPH(respnt) ; respnt->PntType = V4DPI_PntType_Int2 ; respnt->Dim = Dim_Int2 ; respnt->Bytes = V4PS_Int2 ;
			ub64 = (UB64INT)v_Hash64(tbuf) ; memcpy(&respnt->Value.FixVal,&ub64,sizeof (UB64INT)) ;
			goto success ;
		   case _CRC:
			for(i=0;;i++) { if (tbuf[i] > 0x7f) break ; ASCTBUF1[i] = tbuf[i] ; if (tbuf[i] == UCEOS) break ; } ;
			if (tbuf[i] == UCEOS)			/* Did we get to the end with just ASCII ? */
			 { intPNTv(respnt,vcrc_Calculate((char *)ASCTBUF1,i)) ;
			 } else { intPNTv(respnt,vcrc_Calculate((char *)tbuf,UCstrlen(tbuf)*sizeof(UCCHAR))) ; } ;
			goto success ;
		   case _MD5:
			if (UCnotempty(edKey))		/* If got a Key:xxx then do HMAC */
			 { unsigned char hkey[1024], ikey[65], okey[65], md5sum[16], output[33] ; COUNTER hkeyLen ; VMD5__Context md5ctx;
			   strcpy(hkey,edKey) ; hkeyLen = strlen(hkey) ;
			   if (hkeyLen > 64)
			    { v_MD5Start(&md5ctx) ; v_MD5Update(&md5ctx,hkey,hkeyLen) ; v_MD5Finish(&md5ctx, hkey ) ;
			      hkeyLen = 16 ;
			    } ;
			   memset(okey,0,sizeof(okey)) ; memset(ikey,0,sizeof(ikey)) ; memcpy(okey,hkey,hkeyLen) ; memcpy(ikey,hkey,hkeyLen) ;
			   for(i=0;i<64;i++) { okey[i] ^= 0x5c ; ikey[i] ^= 0x36 ; } ;
			   v_MD5Start(&md5ctx) ; v_MD5Update(&md5ctx,ikey,64) ; v_MD5Update(&md5ctx,UCretASC(tbuf),UCstrlen(tbuf)) ; v_MD5Finish(&md5ctx, md5sum ) ;
			   v_MD5Start(&md5ctx) ; v_MD5Update(&md5ctx,okey,64) ; v_MD5Update(&md5ctx,md5sum,16) ; v_MD5Finish(&md5ctx, md5sum ) ;
			   for( j = 0; j < 16; j++ ) { sprintf(&output[j*2], "%02x", md5sum[j] ); } ;
			   alphaPNTvl(respnt,output,32) ;
			   goto success ;
			 } ;
		      { int i ; char *bp ;
/*			This gets a little complicated - are we dealing with ASCII or UC string - the result will differ */
			for(i=0;;i++) { if (tbuf[i] > 0x7f) break ; ASCTBUF1[i] = tbuf[i] ; if (tbuf[i] == UCEOS) break ; } ;
			if (tbuf[i] == UCEOS)			/* Did we get to the end with just ASCII ? */
			 { bp = v_MD5ChecksumFile(ctx,NULL,ASCTBUF1,i) ;
			 } else { bp = v_MD5ChecksumFile(ctx,NULL,(char *)tbuf,UCstrlen(tbuf)*sizeof(UCCHAR)) ; } ;
			if (bp == NULL) { v_Msg(ctx,NULL,"ModFailed2",intmodx) ; goto failure ; } ;
			alphaPNTv(respnt,bp) ; goto success ;
		      }
		   case _SHA1:
		      { INDEX i ; hash_state md; unsigned char hash[32], ikey[128], okey[128] ; char res[45] ;
			if (UCnotempty(edKey))
			 { unsigned char hkey[1024] ; COUNTER hkeyLen ;
			   strcpy(hkey,edKey) ;
			   hkeyLen = strlen(hkey) ;
			   if (hkeyLen > 64)
			    { sha1_init(&md) ; sha1_process(&md,hkey,hkeyLen) ; sha1_done(&md,hash);
			      for(i=0;i<20;i++)
			       { hkey[2*i] = "0123456789abcdef"[hash[i] / 16] ; edKey[2*i+1] = "0123456789abcdef"[hash[i] % 16] ; } ;
			      hkey[64] = '\0' ;
			    } else if (hkeyLen < 64)
			    { for(i=hkeyLen;i<64;i++) { hkey[i] = '\0' ; } ;
			    } ;
			   for(i=0;i<64;i++) { okey[i] = hkey[i] ^ 0x5c ; } ; okey[i] = '\0' ;
			   for(i=0;i<64;i++) { ikey[i] = hkey[i] ^ 0x36 ; } ; ikey[i] = '\0' ;
			   for(i=0;i<64;i++) { ASCTBUF1[i] = ikey[i] ; } ;
			   for(j=0;;j++) { ASCTBUF1[i++] = tbuf[j] ; if (tbuf[j] == UCEOS) break ; } ;
			   sha1_init(&md) ; sha1_process(&md, (unsigned char*)ASCTBUF1,i-1) ; sha1_done(&md,hash) ;
//			   for(i=0;i<20;i++)
//			    { res[2*i] = "0123456789abcdef"[hash[i] / 16] ; res[2*i+1] = "0123456789abcdef"[hash[i] % 16] ; } ; res[20] = '\0' ;
			   for(i=0;i<64;i++) { ASCTBUF1[i] = okey[i] ; } ;
			   for(j=0;j<20;j++) { ASCTBUF1[i++] = hash[j] ; } ; ASCTBUF1[i] = UCEOS ;
			   sha1_init(&md) ; sha1_process(&md, (unsigned char*)ASCTBUF1,i) ; sha1_done(&md,hash) ;
			   for(i=0;i<20;i++)
			    { res[2*i] = "0123456789abcdef"[hash[i] / 16] ; res[2*i+1] = "0123456789abcdef"[hash[i] % 16] ; } ;
			   alphaPNTvl(respnt,res,40) ;
			   goto success ;

			 } ;
/*
function hmac (key, message)
    if (length(key) > blocksize) then
        key = hash(key) // keys longer than blocksize are shortened
    end if
    if (length(key) < blocksize) then
        key = key | [0x00 * (blocksize - length(key))] // keys shorter than blocksize are zero-padded (where | is concatenation)
    end if
   
    o_key_pad = [0x5c * blocksize] ^ key // Where blocksize is that of the underlying hash function
    i_key_pad = [0x36 * blocksize] ^ key // Where ^ is exclusive or (XOR)
   
    return hash(o_key_pad | hash(i_key_pad | message)) // Where ? is concatenation
end function
*/


/*			This gets a little complicated - are we dealing with ASCII or UC string - the result will differ */
			for(i=0;;i++) { if (tbuf[i] > 0x7f) break ; ASCTBUF1[i] = tbuf[i] ; if (tbuf[i] == UCEOS) break ; } ;
			sha1_init(&md);
			if (tbuf[i] == UCEOS)			/* Did we get to the end with just ASCII ? */
			 { sha1_process(&md, (unsigned char*)ASCTBUF1,i) ;
			 } else { sha1_process(&md, (unsigned char*)tbuf,UCstrlen(tbuf)*sizeof(UCCHAR)) ; } ;
		        sha1_done(&md,hash);
			for(i=0;i<20;i++)
			 { res[2*i] = "0123456789abcdef"[hash[i] / 16] ; res[2*i+1] = "0123456789abcdef"[hash[i] % 16] ; } ;
			alphaPNTvl(respnt,res,40) ;
			goto success ;
		      }
		   case _SHA256:
		      { INDEX i ; hash_state md; unsigned char hash[32] ; char res[65] ;
/*			This gets a little complicated - are we dealing with ASCII or UC string - the result will differ */
			for(i=0;;i++) { if (tbuf[i] > 0x7f) break ; ASCTBUF1[i] = tbuf[i] ; if (tbuf[i] == UCEOS) break ; } ;
			sha256_init(&md);
//			sha256_process(&md, (unsigned char*)tests[i].msg, (unsigned long)strlen(tests[i].msg));
			if (tbuf[i] == UCEOS)			/* Did we get to the end with just ASCII ? */
			 { sha256_process(&md, (unsigned char*)ASCTBUF1,i) ;
			 } else { sha256_process(&md, (unsigned char*)tbuf,UCstrlen(tbuf)*sizeof(UCCHAR)) ; } ;
		        sha256_done(&md,hash);
			for(i=0;i<32;i++)
			 { res[2*i] = "0123456789abcdef"[hash[i] / 16] ; res[2*i+1] = "0123456789abcdef"[hash[i] % 16] ; } ;
			alphaPNTvl(respnt,res,64) ;
			goto success ;
		      }

		 } ;
	        return(respnt) ;
	      case -V4IM_Tag_Hash32:
		VHASH32_FWD(i,tbuf,UCstrlen(tbuf)) ; intPNTv(respnt,i) ; goto success ;
	      case -V4IM_Tag_Hash64:
		ZPH(respnt) ; respnt->PntType = V4DPI_PntType_Int2 ; respnt->Dim = Dim_Int2 ; respnt->Bytes = V4PS_Int2 ;
		ub64 = (UB64INT)v_Hash64(tbuf) ; memcpy(&respnt->Value.FixVal,&ub64,sizeof (UB64INT)) ;
		goto success ;
	      case -V4IM_Tag_HashMD5:
		{ int i ; char *bp ;
/*		  This gets a little complicated - are we dealing with ASCII or UC string - the result will differ */
		  for(i=0;;i++) { if (tbuf[i] > 0x7f) break ; ASCTBUF1[i] = tbuf[i] ; if (tbuf[i] == UCEOS) break ; } ;
		  if (tbuf[i] == UCEOS)			/* Did we get to the end with just ASCII ? */
		   { bp = v_MD5ChecksumFile(ctx,NULL,ASCTBUF1,i) ;
		   } else { bp = v_MD5ChecksumFile(ctx,NULL,(char *)tbuf,UCstrlen(tbuf)*sizeof(UCCHAR)) ; } ;
		  if (bp == NULL) { v_Msg(ctx,NULL,"ModFailed2",intmodx) ; goto failure ; } ;
		  alphaPNTv(respnt,bp) ; goto success ;
		}
	      case V4IM_Tag_Head:
		if (cpt->PntType == V4DPI_PntType_Int || cpt->PntType == V4DPI_PntType_Delta)
		 { if (cpt->Value.IntVal < 0)
		    { i = cpt->Value.IntVal + UCstrlen(tbuf) + 1 ; if (i < 0) i = 0 ;
		      tbuf[len=i] = UCEOS ; continue ;
		    } ;
		   if (cpt->Value.IntVal > UCstrlen(tbuf)) continue ; tbuf[len=cpt->Value.IntVal] = UCEOS ; continue ;
		 } ;
		if (cpt->PntType == V4DPI_PntType_List)
		 { lp = v4im_VerifyList(NULL,ctx,cpt,intmodx) ;
		   for(i=1;v4l_ListPoint_Value(ctx,lp,i,&listbuf) > 0;i++)
		    { cpt = &listbuf ;
		      v4im_GetPointUC(&ok,ucbuf,512,cpt,ctx) ; if (!ok) break ;
		      if (uc) { UCSTRTOUPPER(ucbuf) ; } ;
		      if (igCase)
		       { if (vuc_StrCmpIC(ucbuf,tbuf,UCstrlen(ucbuf)) != 0) continue ;
		       } else { if (UCstrncmp(ucbuf,tbuf,UCstrlen(ucbuf)) != 0) continue ; } ;
		      intPNTv(respnt,i) ; goto success ;
		    } ; logPNTv(respnt,FALSE) ; goto success ;		/* If here then no match */
		 } ;
		v4im_GetPointUC(&ok,ucbuf,512,cpt,ctx) ; if (!ok) break ;
		if (igCase)
		 { if (vuc_StrCmpIC(ucbuf,tbuf,UCstrlen(ucbuf)) == 0) { intPNTv(respnt,ix-1) ; goto success ; }
		    else { if (ix >= argcnt) { logPNTv(respnt,FALSE) ; goto success ; } else continue ; } ;
		 } ;
		if (uc) { UCSTRTOUPPER(ucbuf) ; } ;
		if (UCstrncmp(ucbuf,tbuf,UCstrlen(ucbuf)) == 0)
		 { 
		   intPNTv(respnt,ix-1) ; goto success ;
		 } else { if (ix >= argcnt) { logPNTv(respnt,FALSE) ; goto success ; } else continue ; } ;
	      case V4IM_Tag_HTML:
		ZUS(repbuf) ;
		switch (v4im_GetDictToEnumVal(ctx,cpt))
		 { default:		v_Msg(ctx,NULL,"ModTagValue",intmodx,ix,V4IM_Tag_HTML,cpt) ; goto failure ;
		   case _ASCII:
		     for(i=0,j=0;tbuf[i]!=UCEOS;i++)
		      { INDEX first,last,hx,sx ;
			if (!(tbuf[i] > 0x7f || tbuf[i] == UClit('<') || tbuf[i] == UClit('&')))
			 { repbuf[j++] = tbuf[i] ; continue ; } ;
			for(first=0,last=gpi->hent->count-1;;)
			 { hx = (last + first) / 2 ; 
			   if (tbuf[i] == gpi->hent->charVal[hx]) break ;
			   if (tbuf[i] <= gpi->hent->charVal[hx]){ last = hx - 1 ; } else { first = hx + 1 ; } ;
			   if (first > last) { hx = UNUSED ; break ; } ;
			 } ;
			if (hx == UNUSED)
			 { repbuf[j++] = UClit('&') ; repbuf[j++] = UClit('#') ;
			   UCsprintf(&repbuf[j],10,UClit("%d"),tbuf[i]) ; for(j++;repbuf[j]!=UCEOS;j++) { } ;
			   repbuf[j++] = UClit(';') ; continue ;
			 } ;
			hx = gpi->hent->entryX[hx] ;
			repbuf[j++] = UClit('&') ;
			for(sx=0;gpi->hent->entry[hx].alphaVal[sx]!=UCEOS;sx++) { repbuf[j++] = gpi->hent->entry[hx].alphaVal[sx] ; } ;
			repbuf[j++] = UClit(';') ;
		      } ; repbuf[j] = UCEOS ; UCstrcpy(tbuf,repbuf) ;
		     len = UNUSED ;
		     break ;
		 } ;
		
		break ;
	      case -V4IM_Tag_HTML:
		ZUS(repbuf) ;
		for(i=0,j=0;tbuf[i]!=UCEOS;i++)
		 { switch (tbuf[i])
		    { default:		repbuf[j++] = tbuf[i] ; break ;
		      case UClit('"'):	repbuf[j++] = UClit('&') ; repbuf[j++] = UClit('q') ; repbuf[j++] = UClit('u') ; repbuf[j++] = UClit('o') ; repbuf[j++] = UClit('t') ; repbuf[j++] = UClit(';') ; break ;
		      case UClit('\''):	repbuf[j++] = UClit('&') ; repbuf[j++] = UClit('a') ; repbuf[j++] = UClit('p') ; repbuf[j++] = UClit('o') ; repbuf[j++] = UClit('s') ; repbuf[j++] = UClit(';') ; break ;
		      case UClit('&'):	repbuf[j++] = UClit('&') ; repbuf[j++] = UClit('a') ; repbuf[j++] = UClit('m') ; repbuf[j++] = UClit('p') ; repbuf[j++] = UClit(';') ; break ;
		      case UClit('<'):	repbuf[j++] = UClit('&') ; repbuf[j++] = UClit('l') ; repbuf[j++] = UClit('t') ; repbuf[j++] = UClit(';') ; break ;
		    } ;
		 } ; repbuf[j] = UCEOS ; UCstrcpy(tbuf,repbuf) ;
		len = UNUSED ;
		break ;
	      case -V4IM_Tag_IC:
		igCase = TRUE ; break ;
	      case V4IM_Tag_Key:
		v4im_GetPointChar(&ok,edKey,sizeof edKey,cpt,ctx) ; break ;
	      case -V4IM_Tag_LC:
		UCSTRTOLOWER(tbuf) ; break ;
	      case V4IM_Tag_Length:
	      case V4IM_Tag_Width:
		if (begin == UNUSED) begin = 1 ;
		end = v4im_GetPointInt(&ok,cpt,ctx) ; if (!ok) break ;
		if (end < 0) { v_Msg(ctx,NULL,"ModArgRange",intmodx,ix,cpt,0,len-begin+1) ; goto failure ; } ;
		end = begin + end - 1 ;
		len = UCstrlen(tbuf) ;
		if (begin > len) { v_Msg(ctx,NULL,"StrPastEOS",intmodx,begin,len) ; goto failure ; } ;
		if (end > len) end = len ;
		for(i=0,j=begin-1;j<end;i++,j++) { tbuf[i] = tbuf[j] ; } ; tbuf[i] = UCEOS ; len = i ;
		break ;
	      case -V4IM_Tag_Length:
		intPNTv(respnt,UCstrlen(tbuf)) ; goto success ;
	      case -V4IM_Tag_ListOf:
		INITLP(respnt,lp,Dim_List) ;
		{ UCCHAR buf[2] ; buf[1] = UCEOS ;
		  for(i=0;tbuf[i]!=UCEOS;i++)
		   { buf[0] = tbuf[i] ; uccharPNTv(&valpt,buf) ; v4l_ListPoint_Modify(ctx,lp,V4L_ListAction_Append,&valpt,0) ;
		   } ;
		}
		ENDLP(respnt,lp) ; goto success ;
	      case V4IM_Tag_ListOf:
		INITLP(respnt,lp,Dim_List) ; uccharPNT(&valpt) ; valpt.Dim = resdim ; ZUS(valpt.Value.AlphaVal) ;
		if (cpt->PntType == V4DPI_PntType_Dict)
		 { switch (v4im_GetDictToEnumVal(ctx,cpt))
		    { default:		v_Msg(ctx,NULL,"StrListOfOpt",intmodx,ix,argpnts[ix]) ; goto failure ;
		      case _Characters:
			INITLP(respnt,lp,Dim_List) ;
			{ UCCHAR buf[2] ; buf[1] = UCEOS ;
			  for(i=0;tbuf[i]!=UCEOS;i++)
			   { buf[0] = tbuf[i] ; uccharPNTv(&valpt,buf) ; v4l_ListPoint_Modify(ctx,lp,V4L_ListAction_Append,&valpt,0) ;
			   } ;
			}
			ENDLP(respnt,lp) ; goto success ;
		      case _CSV:
			{ UCCHAR *src,*newSrc ;
			  for(src=tbuf;*src!=UCEOS;src=newSrc)
			   { ok = v4lex_NextCSVField(src,&valpt.Value.UCVal[1],V4DPI_UCVAL_MaxSafe,&newSrc,TRUE,NULL) ;
			     if (ok != V4LEX_CSVStatus_OK) { v_Msg(ctx,NULL,"StrListCSV",intmodx,DE(CSV),newSrc-tbuf,tbuf) ; goto failure ; } ;
			     UCCHARPNTBYTES1(&valpt) ;
			     if (!v4l_ListPoint_Modify(ctx,lp,V4L_ListAction_Append,&valpt,0)) { v_Msg(ctx,NULL,"LPModFail",intmodx) ; goto failure ; } ;
			   } ;
			}
			ENDLP(respnt,lp) ; goto success ;
		      case _Integer:
		        INITLP(respnt,lp,Dim_List) ; intPNTv(&valpt,0) ;
			for(i=0;tbuf[i]!=UCEOS;i++)
			 { valpt.Value.IntVal = tbuf[i] ; v4l_ListPoint_Modify(ctx,lp,V4L_ListAction_Append,&valpt,0) ; } ;
			ENDLP(respnt,lp) ; goto success ;
		      case _Tab:
		      	UCstrcpy(ucbuf,UClit("\t")) ; break ;
		    } ;
		   if (ix >= argcnt ? FALSE : v4im_TagId(argpnts[ix+1]) == -V4IM_Tag_Trim) { ix++ ; } ;
		   j = TRUE ;
		 } else
		 { v4im_GetPointUC(&ok,ucbuf,512,cpt,ctx) ; if (!ok) break ;
		   if (UCempty(ucbuf)) UCstrcpy(ucbuf,UClit(" \t,.")) ;		/* Default to space, tab, comma, period */
		   if (ix >= argcnt ? FALSE : v4im_TagId(argpnts[ix+1]) == -V4IM_Tag_Trim)
		    { ix ++ ; j = TRUE ; }
		    else { j = FALSE ; } ;						/* Next is Trim? - don't include break character */
		 } ;
		for(i=0,tlen=0;tbuf[i]!='\0';i++)
	         { valpt.Value.UCVal[++tlen] = tbuf[i] ;
		   for(bp=ucbuf;*bp!=UCEOS;bp++) { if (*bp == tbuf[i]) break ; } ;
	           if (*bp == UCEOS) continue ;
		   if (j) -- tlen ;				/* Cut of last character */
		   UCCHARPNTBYTES2(&valpt,tlen) ;
		   if (!v4l_ListPoint_Modify(ctx,lp,V4L_ListAction_Append,&valpt,0)) { v_Msg(ctx,NULL,"LPModFail",intmodx) ; goto failure ; } ;
		   tlen = 0 ;
		 } ;
		if (tlen > 0)				/* Don't forget last one */
		 { UCCHARPNTBYTES2(&valpt,tlen) ;
		   if (!v4l_ListPoint_Modify(ctx,lp,V4L_ListAction_Append,&valpt,0)) { v_Msg(ctx,NULL,"LPModFail",intmodx) ; goto failure ; } ;
		 }; 
		ENDLP(respnt,lp)
		goto success ;
	      case V4IM_Tag_Literal:
		if (cpt->PntType == V4DPI_PntType_Dict || cpt->PntType == V4DPI_PntType_XDict)
		 { LOGICAL needAB ;
		   switch (v4im_GetDictToEnumVal(ctx,cpt))
		    { default:		v_Msg(ctx,NULL,"ModTagValue",intmodx,ix,V4IM_Tag_Literal,cpt) ; goto failure ;
		      case _HTML:
			bp1 = ucbuf ; *(bp1++) = UClit('\'') ;
			for (bp=tbuf;*bp!=UCEOS;bp++)
			 { switch(*bp)
			    { default:		*(bp1++) = *bp ; break ;
			      case UClit('\\'):	*(bp1++) = *bp ; *(bp1++) = *bp ; break ;
			      case UClit('\''):	*(bp1++) = UClit('&') ; *(bp1++) = UClit('#') ; *(bp1++) = UClit('3') ; *(bp1++) = UClit('9') ; *(bp1++) = UClit(';') ; break ;
			    } ;
			 } ;
			*(bp1++) = UClit('\'') ; *bp1 = UCEOS ;
			UCstrcpy(tbuf,ucbuf) ; len = UNUSED ;
			break ;
		      case _Macro:
			if (tbuf[0] == UClit('"') || tbuf[0] == UClit('\''))
			 { needAB = FALSE ; }		/* Quoted string does NOT need angle brackets */
			 else { UCCHAR *b ; for(b=tbuf;*b!=UCEOS;b++) { if (!vuc_IsAlphaNum(*b)) break ; } ; needAB = (*b != UCEOS) ; } ;
			if (needAB)
			 { UCstrcpy(UCTBUF1,UClit("<")) ; UCstrcat(UCTBUF1,tbuf) ; UCstrcat(UCTBUF1,UClit(">")) ;
			   UCstrcpy(tbuf,UCTBUF1) ; len = UNUSED ;
			 } ;
			break ;
		    } ;
		   break ;
		 } ;
		v4im_GetPointUC(&ok,startchar,UCsizeof(startchar),cpt,ctx) ; if (!ok) break ;
		if ((len=v_StringLit(tbuf,ucbuf,V4LEX_BigText_Max,startchar[0],(escchar == UCEOS ? UClit('\\') : escchar))) == UNUSED)
		 { v_Msg(ctx,NULL,"StrLitTooBig",intmodx,-V4IM_Tag_Literal,V4LEX_BigText_Max) ; goto failure ; } ;
		UCstrcpy(tbuf,ucbuf) ; len = UNUSED ; break ;
	      case -V4IM_Tag_Literal:
		if ((len=v_StringLit(tbuf,ucbuf,V4LEX_BigText_Max,UClit('"'),(escchar == UCEOS ? UClit('\\') : escchar))) == UNUSED)
		 { v_Msg(ctx,NULL,"StrLitTooBig",intmodx,-V4IM_Tag_Literal,V4LEX_BigText_Max) ; goto failure ; } ;
		UCstrcpy(tbuf,ucbuf) ;len = UNUSED ; break ;
	      case V4IM_Tag_New:
		{ UCCHAR *sp,*dp = UCTBUF1 ; int eDigit ;
		  v4im_GetPointUC(&ok,UCTBUF2,V4TMBufMax,cpt,ctx) ; if (!ok) break ; sp = UCTBUF2 ;
		  for(;*sp!=UCEOS;sp++)
		   { *dp = UCEOS ;
		     if (*sp != (escchar == UCEOS ? UClit('~') : escchar)) { *(dp++) = *sp ; continue ; } ;
		     if (*(++sp) == (escchar == UCEOS ? UClit('~') : escchar)) { *(dp++) = (escchar == UCEOS ? UClit('~') : escchar) ; continue ; } ;
		     eDigit = *sp - UClit('0') ;
		     if (eDigit < 0 || eDigit > 9 ? TRUE : matches[eDigit].rm_so == -1)
		      { v_Msg(ctx,NULL,"@%1E With::n does not correspond to defined group",intmodx) ; goto failure ; } ;
		     for(i=matches[eDigit].rm_so;i<=matches[eDigit].rm_eo-1;i++)
		      { *(dp++) = tbuf[i] ; } ;
		   } ;
		  *dp = UCEOS ;
		}
		UCstrcpy(tbuf,UCTBUF1) ; len = UNUSED ; break ;
	      case V4IM_Tag_Num:
	      case V4IM_Tag_Number:	rwnum = v4im_GetPointInt(&ok,cpt,ctx) ; break ;
	      case -V4IM_Tag_Num:
	      case -V4IM_Tag_Number:	rwnum = 1234567 ; break ;
	      case V4IM_Tag_Partial:
		v4im_GetPointUC(&ok,ucbuf,V4LEX_BigText_Max,cpt,ctx) ; if (!ok) break ;
		if (uc) { UCSTRTOUPPER(ucbuf) ; } ;
		for(i=0;tbuf[i]!='\0';i++)
		 { if (tbuf[i] != ucbuf[i]) break ;
		 } ;
		intPNTv(respnt,i) ; goto success ;
	      case V4IM_Tag_Random:
		tlen = v4im_GetPointInt(&ok,cpt,ctx) ; if (!ok) break ;
		len = UCstrlen(tbuf) ; if (len <= 0) { v_Msg(ctx,NULL,"StrIsEmpty",intmodx,argpnts[ix]) ; goto failure ; } ;
		for(i=0;i<tlen;i++)
		 { j = (int)floor(vRan64_RandomDbl() * len) ; if (j == len) j-- ;
		   tbuf1[i] = tbuf[j] ;
		 } ; tbuf1[i] = UCEOS ;
		UCstrcpy(tbuf,tbuf1) ; len = tlen ;
		break ;
	      case V4IM_Tag_RegExp:

/*		If we have a list then better be ((pattern replace) (pattern replace) ...) */
		if (cpt->PntType == V4DPI_PntType_List)
		 { char *rebuf ; INDEX lx ;
		   rebuf = UCretASC(tbuf) ;			/* Regular expressions only ASCII for now */
		   lp = v4im_VerifyList(NULL,ctx,cpt,intmodx) ;
		   for(lx=1;v4l_ListPoint_Value(ctx,lp,lx,&listbuf) > 0;lx++)
		    { cpt = &listbuf ;
		      if (cpt->PntType != V4DPI_PntType_List)
		       { v_Msg(ctx,NULL,"@%1E RegExp::(list entry #%2d) is not itself a list",intmodx,lx) ; goto failure ; } ;
		      lp2 = v4im_VerifyList(NULL,ctx,cpt,intmodx) ;
		      if (v4l_ListPoint_Value(ctx,lp2,1,&list2buf) <= 0)
		       { v_Msg(ctx,NULL,"@%1E RegExp::(list entry #%2d) is not itself a two-entry list",intmodx,i) ; goto failure ; } ;
		      v4im_GetPointChar(&ok,rbuf,V4LEX_BigText_Max,&list2buf,ctx) ; if (!ok) break ;
		      j = REG_EXTENDED ; isLocalRegExp = TRUE ;
		      if (igCase) j |= REG_ICASE ;
		      if (i=vregexp_RegComp(&comp,rbuf,j))
		       { vregexp_Error(i,&comp,ctx->ErrorMsgAux,sizeof ctx->ErrorMsgAux) ;
		         v_Msg(ctx,NULL,"ModInvArg",intmodx,ix) ; goto failure ;
		       } ;
		      for(j=0;j<9999&&rebuf[0]!='\0';j++)	/* Make as many replacements as necessary, but don't do anything if source string is empty */
		       { ETYPE rer ; 
			 rer = vregexp_RegExec(&comp,rebuf,REGMATCHMAX,matches,0) ;
			 if (rer != 0) break ;			/* No match */
			 if (j == 0)				/* First time - evaluate replacement string */
			  { if (v4l_ListPoint_Value(ctx,lp2,2,&list2buf) <= 0)
			     { v_Msg(ctx,NULL,"@%1E RegExp::(list entry #%2d) is not itself a two-entry list",intmodx,i) ; goto failure ; } ;
			    v4im_GetPointUC(&ok,tbuf1,V4LEX_BigText_Max,&list2buf,ctx) ; if (!ok) break ;
			  } ;
		         rebuf[matches[0].rm_so] = '\0' ; strcpy(abuf,rebuf) ;
		         UCstrcatToASC(abuf,tbuf1) ;
		         strcat(abuf,&rebuf[matches[0].rm_eo]) ;
			 if (strlen(abuf) > V4LEX_BigText_Max)
			  { v_Msg(ctx,NULL,"@%1E RegExp::(list entry #%2d) result exceeds max V4 string length",intmodx,i) ; goto failure ; } ;
		         strcpy(rebuf,abuf) ;
		       } ;
		    } ;
		   UCstrcpyAtoU(tbuf,rebuf) ; len = UNUSED ;
		   break ;
		 } ;


		if (cpt->PntType == V4DPI_PntType_RegExpPattern)
		 { memcpy(&comp,(char *)cpt + cpt->Bytes - sizeof comp,sizeof comp) ;
		 } else
		 { v4im_GetPointChar(&ok,rbuf,V4LEX_BigText_Max,cpt,ctx) ; if (!ok) break ;
//v_Msg(ctx,NULL,"@*Str(%1U,Regexp::%2U)\n",tbuf,rbuf) ; vout_UCText(VOUT_Trace,0,ctx->ErrorMsg) ;
		   j = REG_EXTENDED ; isLocalRegExp = TRUE ;
		   if (igCase) j |= REG_ICASE ;
		   if (i=vregexp_RegComp(&comp,rbuf,j))
		    { vregexp_Error(i,&comp,ctx->ErrorMsgAux,sizeof ctx->ErrorMsgAux) ;
		      v_Msg(ctx,NULL,"ModInvArg",intmodx,ix) ; goto failure ;
		    } ;
		 } ;
		isRegExp = TRUE ;


//		if (ix < argcnt)			/* If not last tag then continue on */
//		 { 
//		   if (!i) break ;
//		   v_Msg(ctx,NULL,"StrRegExpNoMtch",intmodx,V4IM_Tag_RegExp,cpt) ; goto failure ;
//		   break ;
//		 } ;
//		i = vregexp_RegExec(&comp,UCretASC(tbuf),REGMATCHMAX,matches,0) ;
//		logPNTv(respnt,(!(i))) ; goto success ;

/*		Try and figure out intent of this Str() call - is it just a pattern match OR more to follow- a Group::nn or Num?/With::xxx */
		if (ix == argcnt)
		 { LOGICAL resFlag = vregexp_RegExec(&comp,UCretASC(tbuf),REGMATCHMAX,matches,0) ;
		   logPNTv(respnt,(!(resFlag))) ; goto success ;
		 } ;
		switch (v4im_CheckPtArgNew(ctx,argpnts[ix+1],&ipt,&argbuf))
		 { case V4IM_Tag_Group:
		   case -V4IM_Tag_Group:	if (vregexp_RegExec(&comp,UCretASC(tbuf),REGMATCHMAX,matches,0))
						 { v_Msg(ctx,NULL,"StrRegExpNoMtch",intmodx,V4IM_Tag_RegExp,cpt) ; goto failure ; } ;
						break ;
		   case V4IM_Tag_Num:
		   case -V4IM_Tag_Num:
		   case V4IM_Tag_With:		break ;			/* Just continue - will do pattern match later */
		 } ;
		break ;




	      case V4IM_Tag_Replace:
		if (cpt->PntType == V4DPI_PntType_Int)
		 { if (!isRegExp) { v_Msg(ctx,NULL,"StrNoRegExp",intmodx,ix,V4IM_Tag_Replace) ; goto failure ; } ;
		   rindex = v4im_GetPointInt(&ok,cpt,ctx) ; if (!ok) break ;
		   if (rindex < 0 || rindex > 9 ? TRUE : matches[rindex].rm_so == -1)
		    { v_Msg(ctx,NULL,"HTMLBadGroup",intmodx,ix,V4IM_Tag_Replace,rindex) ; goto failure ; } ;
		 } else if (cpt->PntType == V4DPI_PntType_List)
		 { lp = v4im_VerifyList(NULL,ctx,cpt,intmodx) ;
		   for(i=1;v4l_ListPoint_Value(ctx,lp,i,&listbuf) > 0;i++)
		    { UCCHAR *sptr ;
		      cpt = &listbuf ;
		      if (cpt->PntType != V4DPI_PntType_List)
		       { v_Msg(ctx,NULL,"@%1E Replace::(list entry #%2d) is not itself a list",intmodx,i) ; goto failure ; } ;
		      lp2 = v4im_VerifyList(NULL,ctx,cpt,intmodx) ;
		      if (v4l_ListPoint_Value(ctx,lp2,1,&list2buf) <= 0)
		       { v_Msg(ctx,NULL,"@%1E Replace::(list entry #%2d) is not itself a two-entry list",intmodx,i) ; goto failure ; } ;
		      v4im_GetPointUC(&ok,ucbuf,V4LEX_BigText_Max,&list2buf,ctx) ; if (!ok) break ;
		      if (uc) { UCSTRTOUPPER(ucbuf) ; } ;

#ifdef MOOOO
		      for(j=0;j<9999&&UCnotempty(ucbuf);j++)	/* Make as many replacements as necessary, but don't do anything if source string is empty */
		       { bp = (igCase ? vuc_StrStrIC(tbuf,ucbuf) : UCstrstr(tbuf,ucbuf)) ; if (bp == NULL) break ;
			 if (j == 0)				/* First time - evaluate replacement string */
			  { if (v4l_ListPoint_Value(ctx,lp2,2,&list2buf) <= 0)
			     { v_Msg(ctx,NULL,"@%1E Replace::(list entry #%2d) is not itself a two-entry list",intmodx,i) ; goto failure ; } ;
			    v4im_GetPointUC(&ok,tbuf1,V4LEX_BigText_Max,&list2buf,ctx) ; if (!ok) break ;
			  } ;
		         *bp = UCEOS ; UCstrcpy(UCTBUF1,tbuf) ; UCstrcat(UCTBUF1,tbuf1) ;
			 bp += UCstrlen(ucbuf) ; UCstrcat(UCTBUF1,bp) ;
			 if (UCstrlen(UCTBUF1) > V4LEX_BigText_Max)
			  { v_Msg(ctx,NULL,"@%1E Replace::(list entry #%2d) result exceeds max V4 string length",intmodx,i) ; goto failure ; } ;
			 UCstrcpy(tbuf,UCTBUF1) ;
		       } ;
#endif




/*		      tbuf = original string, ucbuf = search string, tbuf1 = replacement (see below), UCTBUF1 = updated string */
/*		      Want to spin through original string as long as we have matches and build up new string in UCTBUF1 */
		      ZUS(UCTBUF1) ; sptr = tbuf ;
		      for(j=0;j<9999&&UCnotempty(ucbuf);j++)	/* Make as many replacements as necessary, but don't do anything if source string is empty */
		       { bp = (igCase ? vuc_StrStrIC(sptr,ucbuf) : UCstrstr(sptr,ucbuf)) ; if (bp == NULL) break ;
			 if (j == 0)				/* First time - evaluate replacement string */
			  { if (v4l_ListPoint_Value(ctx,lp2,2,&list2buf) <= 0)
			     { v_Msg(ctx,NULL,"@%1E Replace::(list entry #%2d) is not itself a two-entry list",intmodx,i) ; goto failure ; } ;
			    v4im_GetPointUC(&ok,tbuf1,V4LEX_BigText_Max,&list2buf,ctx) ; if (!ok) break ;
			  } ;
		         *bp = UCEOS ; UCstrcat(UCTBUF1,sptr) ; UCstrcat(UCTBUF1,tbuf1) ;
			 sptr = (bp + UCstrlen(ucbuf)) ;
		       } ;
/*		      No more matches, reconstruct tbuf with UCTBUF1 and any remaining leftovers of source string */
		      if (sptr != tbuf)				/* If equal then no matches, don't have to do anything */
		       { UCstrcat(UCTBUF1,sptr) ;
		        UCstrcpy(tbuf,UCTBUF1) ;
		       } ;





		    } ;
		   ZUS(repbuf) ;		/* Set this to empty so With::xxx won't work */
		   len = UNUSED ;
		 } else
		 { if (cpt->PntType == V4DPI_PntType_RegExpPattern)
		    { memcpy(&comp,(char *)cpt + cpt->Bytes - sizeof comp,sizeof comp) ; isRegExp = TRUE ;
		    } else
		    { v4im_GetPointUC(&ok,repbuf,V4LEX_BigText_Max,cpt,ctx) ; if (!ok) break ;
		    } ;
		 } ;
		break ;
	      case V4IM_Tag_Soundex:
		switch (cpt->PntType == V4DPI_PntType_Dict ? v4im_GetDictToEnumVal(ctx,cpt) : -1)
		 { default:		v_Msg(ctx,NULL,"StrSoundex",intmodx,cpt,V4IM_Tag_Soundex,_Alpha,_MySQL,_Numeric) ; goto failure ;
		   case _Alpha:		v_Soundex(tbuf,tbuf) ; continue ;
		   case _MySQL:		v_Soundex2(tbuf,tbuf) ; continue ;
		   case _Numeric:	intPNTv(respnt,v_Soundex(tbuf,NULL)) ; goto success ;
		 } ;
		goto success ;
	      case -V4IM_Tag_Soundex:
		intPNTv(respnt,v_Soundex(tbuf,NULL)) ; goto success ;
	      case V4IM_Tag_Sub:
		{ UCCHAR subKey[40] ; INDEX skl ;
		  v4im_GetPointUC(&ok,subKey,UCsizeof(subKey),cpt,ctx) ; skl = UCstrlen(subKey) ;
		  for(i=0;tbuf[i]!=UCEOS;i++)
		   { UCCHAR c = tbuf[i] ;
		     if (c >= 'A' && c <= 'Z') { j = c - 'A' ; if (j < skl) { tbuf[i] = UCTOUPPER(subKey[j]) ; } ; }
		      else if (c >= 'a' && c <= 'z') { j = c - 'a' ; if (j < skl) { tbuf[i] = UCTOLOWER(subKey[j]) ; } ; }
		      else if (c >= '0' && c <= '9') { j = c - '0' + 26 ; if (j < skl) { tbuf[i] = subKey[j] ; } ; }
		   } ;
		}
		break ;
	      case V4IM_Tag_Tail:
		if (cpt->PntType == V4DPI_PntType_Int || cpt->PntType == V4DPI_PntType_Delta)
		 { if (cpt->Value.IntVal < 0)
		    { i = - (cpt->Value.IntVal + 1) ; if (i <= 0) continue ; if (i > UCstrlen(tbuf)) { tbuf[len=0] = UCEOS ; continue ; } ;
		    } else { i = UCstrlen(tbuf) - cpt->Value.IntVal ; if (i < 0) continue ;
		    } ;
		   UCstrcpy(tbuf,&tbuf[i]) ; len = UCstrlen(tbuf) ; continue ;
		 } ;
		if (cpt->PntType == V4DPI_PntType_List)
		 { lp = v4im_VerifyList(NULL,ctx,cpt,intmodx) ;
		   tlen = UCstrlen(tbuf) ;
		   for(i=1;v4l_ListPoint_Value(ctx,lp,i,&listbuf) > 0;i++)
		    { cpt = &listbuf ;
		      v4im_GetPointUC(&ok,ucbuf,512,cpt,ctx) ; if (!ok) break ;
		      if (uc) { UCSTRTOUPPER(ucbuf) ; } ;
		      len = UCstrlen(ucbuf) ;  if (len > tlen) continue ;
		      if (igCase)
		       { if (vuc_StrCmpIC(&tbuf[tlen-len],ucbuf,len) != 0) continue ;
		       } else { if (UCstrncmp(&tbuf[tlen-len],ucbuf,len) != 0) continue ; } ;
		      intPNTv(respnt,i) ; goto success ;
		    } ; logPNTv(respnt,FALSE) ; goto success ;		/* If here then no match */
		 } ;
		v4im_GetPointUC(&ok,ucbuf,512,cpt,ctx) ; if (!ok) break ;
		if (uc) { UCSTRTOUPPER(ucbuf) ; } ;
		i = UCstrlen(ucbuf) ; j = UCstrlen(tbuf) ;
		if (i > j) { logPNTv(respnt,FALSE) ; goto success ; } ;
		if (igCase)
		 { if (vuc_StrCmpIC(ucbuf,&tbuf[j-i],0) == 0) { intPNTv(respnt,ix-1) ; goto success ; }
		    else { if (ix >= argcnt) { logPNTv(respnt,FALSE) ; goto success ; } else continue ; } ;
		 } ;
		if(UCstrncmp(&tbuf[j-i],ucbuf,i) == 0)
		 { 
		   intPNTv(respnt,ix-1) ; goto success ;
		 } else { if (ix >= argcnt) { logPNTv(respnt,FALSE) ; goto success ; } else continue ; } ;
	      case V4IM_Tag_Split:
		INITLP(respnt,lp,Dim_List) ; uccharPNT(&valpt) ; valpt.Dim = resdim ; ZUS(valpt.Value.AlphaVal) ;
		v4im_GetPointUC(&ok,ucbuf,512,cpt,ctx) ; if (!ok) break ;
		if (UCempty(ucbuf)) { v_Msg(ctx,NULL,"StrIsEmpty",intmodx,argpnts[ix]) ; goto failure ; } ;
		{ UCCHAR *bp1, *bp2 ;

		for(bp1=tbuf;*bp1!=UCEOS;)
		 { bp2 = UCstrstr(bp1,ucbuf) ; 
		   if (bp2 == NULL)
		    { LENMAX len = UCstrlen(bp1) ; 


//		      if (len >= V4DPI_UCVal_Max) { v_Msg(ctx,NULL,"StrLitTooBig",intmodx,V4IM_Tag_Split,V4DPI_UCVal_Max) ; goto failure ; } ;
//		      uccharPNTvl(&valpt,bp1,len) ; bp1 = UClit("") ;

		     if (len >= V4DPI_UCVAL_MaxSafe)
		      { bt = (struct V4LEX__BigText *)v4mm_AllocChunk(sizeof *bt,FALSE) ; UCstrcpy(bt->BigBuf,bp1) ;
			if (!v4dpi_SaveBigTextPoint(ctx,bt,len,&valpt,Dim_Alpha,TRUE)) { v_Msg(ctx,NULL,"StrSaveBigText",intmodx,V4DPI_PntType_BigText) ; goto failure ; } ;
			v4mm_FreeChunk(bt) ;		
		      } else { uccharPNTvl(&valpt,bp1,len) ; } ;
		      bp1 = UClit("") ;





		    } else
		    { LENMAX len ; *bp2 = UCEOS ; len = UCstrlen(bp1) ;

//		      if (len >= V4DPI_UCVal_Max) { v_Msg(ctx,NULL,"StrLitTooBig",intmodx,V4IM_Tag_Split,V4DPI_UCVal_Max) ; goto failure ; } ;
//		      uccharPNTvl(&valpt,bp1,len) ;

		     if (len >= V4DPI_UCVAL_MaxSafe)
		      { bt = (struct V4LEX__BigText *)v4mm_AllocChunk(sizeof *bt,FALSE) ; UCstrcpy(bt->BigBuf,bp1) ;
			if (!v4dpi_SaveBigTextPoint(ctx,bt,len,&valpt,Dim_Alpha,TRUE)) { v_Msg(ctx,NULL,"StrSaveBigText",intmodx,V4DPI_PntType_BigText) ; goto failure ; } ;
			v4mm_FreeChunk(bt) ;		
		      } else { uccharPNTvl(&valpt,bp1,len) ; } ;

		      bp1 = bp2 + UCstrlen(ucbuf) ;



		    } ;
		   if (!v4l_ListPoint_Modify(ctx,lp,V4L_ListAction_Append,&valpt,0)) { v_Msg(ctx,NULL,"LPModFail",intmodx) ; goto failure ; } ;
		 } ;
		}
		ENDLP(respnt,lp)
		goto success ;
	      case V4IM_Tag_Trim:
		{ INDEX bx,ex ;
		  switch (v4im_GetDictToEnumVal(ctx,cpt))
		   { default:		v_Msg(ctx,NULL,"ModTagValue",intmodx,ix,V4IM_Tag_Trim,cpt) ; goto failure ;
		     case _All:
			goto trim_all ;
		     case _Left:
			for(bx=0;;bx++) { if (tbuf[bx] > UClit(' ')) break ; if (tbuf[bx] == UCEOS) break ; } ;
			if (tbuf[bx] == UCEOS) { ZUS(tbuf) ; len = 0 ; }
			 else { len = UCstrlen(&tbuf[bx]) ; memmove(tbuf,&tbuf[bx],(len+1)*sizeof(UCCHAR)) ; } ;
			break ;
		     case _Right:
			for(ex=UCstrlen(tbuf)-1;ex>=0;ex--) { if (tbuf[ex] > UClit(' ')) break ; } ;
			tbuf[ex+1] = UCEOS ; len = ex + 1 ; break ;
		   } ;
		}
		break ;
	      case -V4IM_Tag_Trim:
trim_all:	{ INDEX bx,ex ;
		  for(bx=0;;bx++) { if (tbuf[bx] > UClit(' ')) break ; if (tbuf[bx] == UCEOS) break ; } ;
		  if (tbuf[bx] == UCEOS) { ZUS(tbuf) ; break ; } ;
		  for(ex=UCstrlen(tbuf)-1;ex>=0;ex--) { if (tbuf[ex] > UClit(' ')) break ; } ;
		  if (bx > 0) { for(i=0,j=bx;j<=ex;i++,j++) { tbuf[i] = tbuf[j] ; } ; } ;
		  tbuf[ex+1-bx] = UCEOS ; len = ex + 1 - bx ;
		}
		break ;
	      case -V4IM_Tag_UC:
		UCSTRTOUPPER(tbuf) ; uc = TRUE ; break ;
	      case V4IM_Tag_URL:
		switch (v4im_GetDictToEnumVal(ctx,cpt))
		 { default:		v_Msg(ctx,NULL,"StrEncDec",intmodx,V4IM_Tag_URL,cpt) ; goto failure ;
		   case _UTF8:
		   case _Encode:
			UCUTF16toUTF8(abuf,V4TMBufMax,tbuf,UCstrlen(tbuf)) ;
			for(i=0,j=0;abuf[i]!='\0';i++)
			 { if (abuf[i] <= 127 && vuc_IsAlphaNum(abuf[i])) { tbuf[j++] = abuf[i] ; continue ; } ;
//			   if (abuf[i] == ' ') { tbuf[j++] = UClit('+') ; continue ; } ;
			   tbuf[j++] = UClit('%') ; tbuf[j++] = UClit("0123456789ABCDEF")[abuf[i] >> 4] ; tbuf[j++] = UClit("0123456789ABCDEF")[abuf[i] & 0xF] ;
			 } ;
			tbuf[j] = UCEOS ; len = j ;
			break ;
		   case _UCChar:
			UCstrcpy(tbuf1,tbuf) ;
			for(i=0,j=0;tbuf1[i]!=UCEOS;i++)
			 { if (tbuf1[i] <= 255)
			    { if (tbuf1[i] <= 127 && vuc_IsAlphaNum(tbuf1[i])) { tbuf[j++] = tbuf1[i] ; continue ; } ;
			      if (abuf[i] == ' ') { tbuf[j++] = '+' ; continue ; } ;
			      tbuf[j++] = '%' ; tbuf[j++] = UClit("0123456789ABCDEF")[tbuf1[i] >> 4] ; tbuf[j++] = UClit("0123456789ABCDEF")[tbuf1[i] & 0xF] ;
			      continue ;
			    } ;
			   tbuf[j++] = '%' ; tbuf[j++] = 'u' ;
			   tbuf[j++] = UClit("0123456789ABCDEF")[tbuf1[i] >> 12] ; tbuf[j++] = UClit("0123456789ABCDEF")[(tbuf1[i] & 0xF00) >> 8] ;
			   tbuf[j++] = UClit("0123456789ABCDEF")[(tbuf1[i] & 0xFF) >> 4] ; tbuf[j++] = UClit("0123456789ABCDEF")[tbuf1[i] & 0xF] ;
			 } ;
			tbuf[j] = UCEOS ; len = j ; break ;
		   case _Decode:
			for(i=0,j=0;;)
			 { char t1, t2 ;
			   if (tbuf[i] == UClit('+')) { abuf[j++] = ' ' ; i++ ; continue ; } ;
			   if (tbuf[i] != UClit('%')) { abuf[j++] = tbuf[i++] ; if (tbuf[i-1] == UCEOS) break ; continue ; } ;
			   t1 = UCTOUPPER(tbuf[i+1]) ; t2 = UCTOUPPER(tbuf[i+2]) ; if (t1 == UCEOS || t2 == UCEOS) break ;
			   abuf[j++] = ((t1 - (t1 >= UClit('A') ? (UClit('A') - 10) : UClit('0'))) << 4) +
						(t2 - (t2 >= UClit('A') ? (UClit('A') - 10) : UClit('0'))) ;
			   i += 3 ;
			 } ;
			UCUTF8toUTF16(tbuf,V4TMBufMax,abuf,i) ;
			len = UNUSED ; break ;
		 } ; break ;
	      case V4IM_Tag_UTF8:
		switch (v4im_GetDictToEnumVal(ctx,cpt))
		 { default:		v_Msg(ctx,NULL,"@%1E Expecting UTF8:Encode or UTF8:Decode",intmodx) ; goto failure ;
		   case _Encode:
			UCUTF16toUTF8(abuf,V4TMBufMax,tbuf,UCstrlen(tbuf)) ;
			for(i=0;;i++) { tbuf[i] = abuf[i] ; if (abuf[i] == '\0') break ; } ;
			len = i ; break ;
		   case _Decode:
			for(i=0;tbuf[i]<=0xff;i++) { abuf[i] = tbuf[i] ; if (abuf[i] == '\0') break ; } ;
			if (abuf[i] != '\0') { v_Msg(ctx,NULL,"StrNotUTF8",intmodx,i+1) ; goto failure ; } ;
			UCUTF8toUTF16(tbuf,V4TMBufMax,abuf,i) ;
			len = UNUSED ; break ;
		 } ; break ;
	      case V4IM_Tag_Word:
		if (cpt->PntType == V4DPI_PntType_List)
		 { lp = v4im_VerifyList(NULL,ctx,cpt,intmodx) ;
		   for(i=1;v4l_ListPoint_Value(ctx,lp,i,&listbuf) > 0;i++)
		    { UCCHAR *bpMatch ;
		      cpt = &listbuf ;
		      v4im_GetPointUC(&ok,ucbuf,512,cpt,ctx) ; if (!ok) break ;


		      { UCCHAR *word = ucbuf ; LOGICAL ms = TRUE, me = TRUE ; INDEX wl ;
			wl = UCstrlen(ucbuf) ;
			if (ucbuf[0] == UClit('*')) { word++ ; ms = FALSE ; wl-- ; }	/* "*xxx" - Does not need to be start of word */
			if (word[wl - 1] == UClit('*')) { me = FALSE ; ucbuf[UCstrlen(ucbuf) - 1] = UCEOS ; wl-- ; } ;	/* xxxx* - Does not not need to end word */
			if (uc) { UCSTRTOUPPER(ucbuf) ; } ;
			for (bp=NULL,bpMatch=NULL,bp1=tbuf;;bp1++)
			 { bp1 = (igCase ? vuc_StrStrIC(bp1,word) : UCstrstr(bp1,word)) ;
			   if (bp1 == NULL) break ;
/*			   Got a match - see if surrounding characters are OK */
			   if (ms) { if (!(bp1 == tbuf ? TRUE : vuc_IsPunc(bp1[-1]) || vuc_IsWSpace(bp1[-1]))) continue ; } ;
			   if (me) { if (!(bp1[wl] == UCEOS ? TRUE : vuc_IsPunc(bp1[wl]) || vuc_IsWSpace(bp1[wl]))) continue ; } ;
			   bpMatch = bp1 ; if (anchorLHS) break ;
			 } ;
			if (bpMatch == NULL) continue ;
			if (intmodx == V4IM_OpCode_Str) { intPNTv(respnt,bpMatch-tbuf+1) ; goto success ; }
			 else { logPNTv(respnt,TRUE) ; goto success ; } ;
		      }
		     if (bpMatch == NULL) { logPNTv(respnt,FALSE) ; goto success ; } ;




		    } ;
		   if (!ok) break ;
		   logPNTv(respnt,FALSE) ; goto success ;		/* If here then no match */
		 } ;
		v4im_GetPointUC(&ok,ucbuf,512,cpt,ctx) ; if (!ok) break ;
		{ UCCHAR *word = ucbuf, *bpMatch ; LOGICAL ms = TRUE, me = TRUE ; INDEX wl ;
		  wl = UCstrlen(ucbuf) ;
		  if (ucbuf[0] == UClit('*')) { word++ ; ms = FALSE ; wl-- ; }	/* "*xxx" - Does not need to be start of word */
		  if (word[wl - 1] == UClit('*')) { me = FALSE ; ucbuf[UCstrlen(ucbuf) - 1] = UCEOS ; wl-- ; } ;	/* xxxx* - Does not not need to end word */
		  if (uc) { UCSTRTOUPPER(ucbuf) ; } ;
		  for (bp=NULL,bpMatch=NULL,bp1=tbuf;;bp1++)
		   { bp1 = (igCase ? vuc_StrStrIC(bp1,word) : UCstrstr(bp1,word)) ;
		     if (bp1 == NULL) break ;
/*		     Got a match - see if surrounding characters are OK */
		     if (ms) { if (!(bp1 == tbuf ? TRUE : vuc_IsPunc(bp1[-1]) || vuc_IsWSpace(bp1[-1]))) continue ; } ;
		     if (me) { if (!(bp1[wl] == UCEOS ? TRUE : vuc_IsPunc(bp1[wl]) || vuc_IsWSpace(bp1[wl]))) continue ; } ;
		     bpMatch = bp1 ; if (anchorLHS) break ;
		   } ;
		  if (bpMatch == NULL) { logPNTv(respnt,FALSE) ; goto success ; } ;
		  if (intmodx == V4IM_OpCode_Str) { intPNTv(respnt,bpMatch-tbuf+1) ; goto success ; }
		   else { logPNTv(respnt,TRUE) ; goto success ; } ;
		}
		break ;
	      case V4IM_Tag_With:
		if ((UCempty(repbuf) && !isRegExp) && rindex == UNUSED)
		 { v_Msg(ctx,NULL,"@%1E Cannot have With::xxx without prior Replace::xxx",intmodx) ; goto failure ; } ;
		if (cpt->PntType == V4DPI_PntType_Int)
		 { if (!isRegExp)
		    { v_Msg(ctx,NULL,"@%1E Arg(#%2d) - must have prior RegExp::xxx match",intmodx,ix) ; goto failure ; } ;
		   i = v4im_GetPointInt(&ok,cpt,ctx) ; if (!ok) break ;
		   if (i < 0 || i > 9 ? TRUE : matches[i].rm_so == -1)
		    { v_Msg(ctx,NULL,"@%1E With::n does not correspond to defined group",intmodx) ; goto failure ; } ;
		   len = matches[i].rm_eo - matches[i].rm_so ;
		   UCstrncpy(ucbuf,&tbuf[matches[i].rm_so],len) ; ucbuf[len] = '\0' ;
		 } else
		 { v4im_GetPointUC(&ok,ucbuf,512,cpt,ctx) ; if (!ok) break ;
		 } ;
		for(rstart=0,i=1;i<=rwnum;i++)
		 { if (rindex == UNUSED)
		    { UCCHAR *s, *d ;
		      if (isRegExp)
		       { UCCHAR saveUC ;
		         if (vregexp_RegExec(&comp,UCretASC(&tbuf[rstart]),REGMATCHMAX,matches,0))
		          { if (rwnum == 1234567) break ;
		            v_Msg(ctx,NULL,"StrNotInTarget1",intmodx,V4IM_Tag_Replace,&tbuf[rstart]) ; goto failure ;
		          } ;
			 bp = &tbuf[rstart+matches[0].rm_so] ; saveUC = *bp ; *bp = UCEOS ; UCstrcpy(UCTBUF1,tbuf) ;
//			 UCstrcat(UCTBUF1,ucbuf) ;
			 d = &UCTBUF1[UCstrlen(UCTBUF1)] ; s = ucbuf ;
			 for(;*s!=UCEOS;s++)
			  { INDEX pNum ; UCCHAR *s1 ; LENMAX s1Len ;
			    if (*s != UClit('\\')) { *(d++) = *s ; continue ; } ;
			    s++ ; if (*s == UCEOS) break ;
			    if (!vuc_IsDigit(*s)) { *(d++) = *s ; continue ; } ;
			    pNum = UCstrtol(s,&s,10) ; s-- ;
			    if (pNum < 0 || pNum > REGMATCHMAX ? TRUE : matches[pNum].rm_so == -1)
			     { v_Msg(ctx,NULL,"@%1E Group::n does not correspond to defined group",intmodx) ; goto failure ; } ;
			    s1 = &tbuf[matches[pNum].rm_so] ; s1Len = matches[pNum].rm_eo-matches[pNum].rm_so ;
			    for(;s1Len>0;s1Len--) { *(d++) = *(s1++) ; } ;
			  } ; *d = UCEOS ;
			 *bp = saveUC ;
			 bp += matches[0].rm_eo - matches[0].rm_so ;
		       } else
		       { 
			 if (igCase)
			  { bp = vuc_StrStrIC(&tbuf[rstart],repbuf) ; }
			  else { bp = UCstrstr(&tbuf[rstart],repbuf) ; } ;

		         if (bp == NULL)
		          { if (rwnum == 1234567) break ;
		            v_Msg(ctx,NULL,"StrNotInTarget1",intmodx,V4IM_Tag_Replace,&tbuf[rstart]) ; goto failure ;
		          } ;
		         *bp = UCEOS ; UCstrcpy(UCTBUF1,tbuf) ; UCstrcat(UCTBUF1,ucbuf) ;
		         bp += UCstrlen(repbuf) ;
		       } ;
		    } else
		    { UCCHAR saveUC ;
		      if (i > 0)		/* If not first time then rescan */
		       { if (vregexp_RegExec(&comp,UCretASC(&tbuf[rstart]),REGMATCHMAX,matches,0))
		          { if (rwnum == 1234567) break ;
		            v_Msg(ctx,NULL,"StrNotInTarget1",intmodx,V4IM_Tag_Replace,&tbuf[rstart]) ; goto failure ;
		          } ;
			 if (rindex < 0 || rindex > 9 ? TRUE : matches[rindex].rm_so == -1)
			  { v_Msg(ctx,NULL,"@%1E Replace::n does not correspond to defined group",intmodx) ; goto failure ; } ;
		       } ;
		      bp = &tbuf[rstart+matches[rindex].rm_so] ; saveUC = *bp ; *bp = UCEOS ; UCstrcpy(UCTBUF1,tbuf) ; UCstrcat(UCTBUF1,ucbuf) ; *bp = saveUC ;
		      bp += matches[rindex].rm_eo - matches[rindex].rm_so ;
		    } ;
		   rstart = UCstrlen(UCTBUF1) ; UCstrcat(UCTBUF1,bp) ;
		   if (rstart + UCstrlen(bp) >= UCsizeof(tbuf0))
		    { v_Msg(ctx,NULL,"@%1E Replace/With exceed maximum internal string size (%2d + %3d > %4d)",intmodx,rstart,UCstrlen(bp),sizeof tbuf) ; goto failure ; } ;
		   UCstrcpy(tbuf,UCTBUF1) ; len = UCstrlen(tbuf) ;
		 } ;
		rwnum = 1 ; break ;
	      case V4IM_Tag_XML:
		ZUS(tbuf1) ;
		switch (v4imu_XMLSTART(ctx,&xml,UNUSED,cpt,FALSE,intmodx,tbuf1))
		 { default:			return(NULL) ;
		   case XMLSTART_None:		break ;
		   case XMLSTART_Normal:	break ;
		   case XMLSTART_Defer:		v_Msg(ctx,NULL,"XMLDeferInv",intmodx) ; return(NULL) ;
		 } ;
		for(bp=tbuf1;*bp==UClit(' ');bp++) { } ;	/* Trim off any leading indentation spacing */
		UCstrcat(tbuf,bp) ;
		len = UNUSED ;
		break ;
	    } ;
	 } ;
	if (!ok) { v_Msg(ctx,NULL,"ModInvArg",intmodx,ix-1) ; goto failure ; } ;
	if (xml.Count > 0)
	 { len = UNUSED ; if (!v4imu_XMLEND(ctx,&xml,UNUSED,intmodx,tbuf)) return(NULL) ; }
	if (len == UNUSED) len = UCstrlen(tbuf) ;			/* If here then returning a string */
	if (UCnotempty(xmlSuffix))
	 { if (len + UCstrlen(xmlSuffix) + 3 >= UCsizeof(tbuf0)) { v_Msg(ctx,NULL,"StrLitTooBig2",intmodx,ix,V4TMBufMax) ; goto failure ; } ;
	   UCstrcat(tbuf,UClit("</")) ; UCstrcat(tbuf,xmlSuffix) ; UCstrcat(tbuf,UClit(">")) ;
	   len = UCstrlen(tbuf) ;
	 } ;
	if (resdim == UNUSED) resdim = Dim_Alpha ;
	ZPH(respnt) ; respnt->PntType = V4DPI_PntType_UCChar ; respnt->Dim = resdim ;
/*	Here to actually store result - have to determine how (or maybe store as BigText) */
	if (len >= V4DPI_UCVAL_MaxSafe || gotBT)	/* If any arguments were BigText, then return bigtext point */
	 { 
	   if (len >= V4LEX_BigText_Max)
	    { v_Msg(ctx,NULL,"@%1E - Result string (len=%2d) exceeds max length allowed(%3d)",intmodx,len,V4LEX_BigText_Max) ; goto failure ; } ;
	   bt = (struct V4LEX__BigText *)v4mm_AllocChunk(sizeof *bt,FALSE) ;
	   UCstrcpy(bt->BigBuf,tbuf) ;
	   if (!v4dpi_SaveBigTextPoint(ctx,bt,UCstrlen(bt->BigBuf),respnt,(bigtextdim == UNUSED ? Dim_Alpha : bigtextdim),TRUE))
	    { v_Msg(ctx,NULL,"StrSaveBigText",intmodx,V4DPI_PntType_BigText) ; goto failure ; } ;
	   v4mm_FreeChunk(bt) ;		
	 } else		/* Store as Alpha point */	
	 { UCstrcpy(&respnt->Value.UCVal[1],tbuf) ; UCCHARPNTBYTES2(respnt,len) ;
	 } ;
success:
	if (isLocalRegExp) vregexp_Free(&comp) ;
	if (ix+1 <= argcnt)		/* Any other arguments to process ? */
	 { switch (respnt->PntType)
	    { default:		break ;
	      CASEofChar
		if (v4imu_NestToModule(ctx,respnt,argcnt,argpnts,ix+1,intmodx,v4im_DoStr,V4IM_OpCode_Str) == NULL) goto failure ;
		break ;
	      case V4DPI_PntType_List:
		if (v4imu_NestToModule(ctx,respnt,argcnt,argpnts,ix+1,intmodx,v4im_DoList,V4IM_OpCode_List) == NULL) goto failure ;
		break ;
	    } ;
	 } ;
	return(respnt) ;

failure:
	if (isLocalRegExp) vregexp_Free(&comp) ;
	REGISTER_ERROR(0) ; return(NULL) ;
}

/*	v4im_DoUnicode - Unicode() Handler */

P *v4im_DoUnicode(ctx,respnt,argcnt,argpnts,intmodx,trace)
  struct V4C__Context *ctx ;
  P *respnt,*argpnts[] ;
  int argcnt,intmodx,trace ;
{ P *cpt ;
/*	If only one argument then convert to/from character/integer */
	if (argcnt == 1)
	 { cpt = argpnts[1] ;
	   switch(cpt->PntType)
	    { 
	      case V4DPI_PntType_Int:	UCTBUF1[0] = cpt->Value.IntVal ; UCTBUF1[1] = UCEOS ; uccharPNTv(respnt,UCTBUF1) ; return(respnt) ;
	      case V4DPI_PntType_List:	{ P pnt ; struct V4L__ListPoint *lp ; INDEX j ;
					  lp = v4im_VerifyList(NULL,ctx,cpt,intmodx) ;
					  if (lp == NULL) { v_Msg(ctx,NULL,"ModInvArgList",intmodx,1) ; goto fail ; } ;
					  for(j=1;;j++)
					   { if (!v4l_ListPoint_Value(ctx,lp,j,&pnt)) break ;
					     if (pnt.PntType != V4DPI_PntType_Int)
					      { v_Msg(ctx,NULL,"ModArgPntType2",intmodx,j,pnt.PntType,V4DPI_PntType_Int) ; goto fail ; } ;
					     UCTBUF1[j-1] = pnt.Value.IntVal ;
					   } ;
					  UCTBUF1[j-1] = UCEOS ; uccharPNTv(respnt,UCTBUF1) ; return(respnt) ;
					}
	      CASEofChar		{ P pnt ; struct V4L__ListPoint *lp ; LOGICAL ok ; INDEX i ;
					  v4im_GetPointUC(&ok,UCTBUF1,V4TMBufMax,cpt,ctx) ; if (!ok) break ;
					  if (UCstrlen(UCTBUF1) == 1) { intPNTv(respnt,UCTBUF1[0]) ; return(respnt) ; } ;
					  INITLP(respnt,lp,Dim_List)
					  for(i=0;UCTBUF1[i]!=UCEOS;i++)
					   { intPNTv(&pnt,UCTBUF1[i]) ; v4l_ListPoint_Modify(ctx,lp,V4L_ListAction_Append,&pnt,0) ;
					   } ;
					  ENDLP(respnt,lp) ; return(respnt) ;
					}
	    } ;
	   v_Msg(ctx,NULL,"ModArgPntType",intmodx,1,cpt,cpt->PntType) ; goto fail ;
	 } ;
fail:
	REGISTER_ERROR(0) ; return(NULL) ;

}

struct V4DPI__Point *v4im_DoNGram(ctx,respnt,argpnts,argcnt,intmodx)
  struct V4C__Context *ctx ;
  P *respnt ;						/* Ptr for result */
  INTMODX intmodx ;
  P *argpnts[] ;
  COUNTER argcnt ;
{ P *cpt,vpnt ;
  struct V4L__ListPoint *lp ;
  struct V4DPI__DimInfo *di ;
  UCCHAR *dst, src[V4TMBufMax], nlChar ;
  INDEX ix,sx,dx,gx ; LOGICAL ok ; DIMID dimId ; PNTTYPE pntType ;
  B64INT *gArray ; COUNTER gCnt,numChars,nGram ;
#define NGRAM_MINSIZE 2
#define NGRAM_MAXSIZE 4

	ok = TRUE ; nGram = NGRAM_MINSIZE ; nlChar = UClit('_') ; dimId = Dim_Alpha ; pntType = V4DPI_PntType_Char ;
	v4im_GetPointUC(&ok,src,UCsizeof(src),argpnts[1],ctx) ; di = NULL ;
	for(ix=2;ok&&ix<=argcnt;ix++)
	 { 
	   switch (v4im_CheckPtArgNew(ctx,argpnts[ix],&cpt,&vpnt))
	    { default:			v_Msg(ctx,NULL,"TagBadUse",intmodx) ; goto fail ;
	      case V4IM_Tag_Unk:	v_Msg(ctx,NULL,"TagUnknown",intmodx) ; goto fail ;
	      case V4IM_Tag_Delimiter:	v4im_GetPointUC(&ok,UCTBUF1,10,cpt,ctx) ; nlChar = UCTBUF1[0] ; break ;
	      case V4IM_Tag_Dim:	dimId = cpt->Value.IntVal ; DIMINFO(di,ctx,dimId) ; pntType = di->PointType ;
					switch (di->PointType)
					 { default:			v_Msg(ctx,NULL,"ModArgPntType",intmodx,ix,cpt,di->PointType) ; goto fail ;
					   case V4DPI_PntType_Char:
					   case V4DPI_PntType_UCChar:
					   case V4DPI_PntType_Dict:	break ;
					 } ;
					break ;
	      case V4IM_Tag_Number:
	      case V4IM_Tag_Num:	nGram = v4im_GetPointInt(&ok,cpt,ctx) ;
					if (nGram < NGRAM_MINSIZE || nGram > NGRAM_MAXSIZE) { v_Msg(ctx,NULL,"ModArgRange",intmodx,ix,cpt,NGRAM_MINSIZE,NGRAM_MAXSIZE) ; goto fail ; } ;
					break ;
	    } ;
	 } ;
	if (!ok) { v_Msg(ctx,NULL,"ModInvArg",intmodx,ix-1) ; goto fail ; } ;
	if (di == NULL) { DIMINFO(di,ctx,dimId) ; } ;
	if (nGram < 2 || nGram > 4) return(NULL) ;
	if (sizeof(UCCHAR) > 2) return(NULL) ;
	dst = UCTBUF1 ; dx = 0 ; dst[dx++] = nlChar ; 
	for(sx=0;src[sx]!=UCEOS;sx++)
	 { if (vuc_IsLetter(src[sx])) { dst[dx++] = UCTOUPPER(src[sx]) ; continue ; } ;
	   if (dst[dx-1] != nlChar) dst[dx++] = nlChar ;
	 } ; if (dst[dx-1] != nlChar) dst[dx++] = nlChar ; dst[dx++] = UCEOS ;
	numChars = dx - 1 ;
	gArray = v4mm_AllocChunk(dx * sizeof(gArray[0]),FALSE) ; gCnt = 0 ;
	for(sx=0;sx<numChars-(nGram-1);sx++)
	 { B64INT curGram = 0 ;
	   switch (nGram)	/* Don't want to consider ngram with delimiter in middle (ex: x_y, xy_z, etc.) */
	    { default:		v_Msg(ctx,NULL,"ModArgRange",intmodx,ix,cpt,NGRAM_MINSIZE,NGRAM_MAXSIZE) ; goto fail ;
	      case 1:
	      case 2:		break ;
	      case 3:		if (UCTBUF1[sx+1] == nlChar) continue ; break ;
	      case 4:		if (UCTBUF1[sx+1] == nlChar || UCTBUF1[sx+2] == nlChar) continue ; break ;
	    } ;
	   memcpy(&curGram,&UCTBUF1[sx],nGram*sizeof(UCCHAR)) ;
	   for(gx=0;gx<gCnt;gx++)
	    { if (gArray[gx] == curGram) break ;
	    } ;
	   if (gx >= gCnt) { gArray[gCnt++] = curGram ; } ;
	 } ;
	INITLP(respnt,lp,Dim_List)
	for(gx=0;gx<gCnt;gx++)
	 { P tpnt ; UCCHAR current[4+1] ; memcpy(current,&gArray[gx],nGram*sizeof(UCCHAR)) ; current[nGram] = UCEOS ;
	   switch (pntType)
	    { default:
	      case V4DPI_PntType_Char:
	      case V4DPI_PntType_UCChar:
		uccharPNTvl(&tpnt,current,nGram) ; break ;
	      case V4DPI_PntType_Dict:
		dictPNTv(&tpnt,dimId,v4dpi_DictEntryGet(ctx,dimId,current,di,NULL)) ; break ;
	    } ;
	   v4l_ListPoint_Modify(ctx,lp,V4L_ListAction_Append,&tpnt,0) ;
	 } ;
	ENDLP(respnt,lp) ;
	v4mm_FreeChunk(gArray) ;
	return(respnt) ;

fail:
	REGISTER_ERROR(0) ; return(NULL) ;
}

P *v4im_StrBreak(ctx,respnt,resdim,strbuf,vsb,intmodx)
  struct V4C__Context *ctx ;
  P *respnt ; int resdim ;
  UCCHAR *strbuf ;
  struct vstr__StringBreak *vsb ;
  INTMODX intmodx ;
{ P valpt ;
  struct V4L__ListPoint *lp ;
  INDEX i ; LENMAX len,strbuflen ;

	INITLP(respnt,lp,Dim_List)
	ZPH(&valpt) ; valpt.PntType = V4DPI_PntType_UCChar ; valpt.Dim = resdim ;
	strbuflen = UCstrlen(strbuf) ;
	for(i=0;i<vsb->Count;i++)
	 { 
	   len = vsb->Piece[i].EndByte - vsb->Piece[i].StartByte + 1 ;
	   if (len < 0 || len >= V4DPI_UCVAL_MaxSafe || vsb->Piece[i].StartByte < 0 || vsb->Piece[i].StartByte + len > strbuflen)
	    { v_Msg(ctx,NULL,"StrBreakVals",intmodx,strbuf,strbuflen,vsb->Piece[i].StartByte,len) ; REGISTER_ERROR(0) ; return(NULL) ; } ;
	   UCstrncpy(&valpt.Value.UCVal[1],&strbuf[vsb->Piece[i].StartByte],len) ;
	   UCCHARPNTBYTES2(&valpt,len) ;
	   v4l_ListPoint_Modify(ctx,lp,V4L_ListAction_Append,&valpt,0) ;
	 } ;

	ENDLP(respnt,lp) ; return(respnt) ;
}

struct V4DPI__Point *v4im_DoV4(ctx,respnt,argpnts,argcnt,intmodx,trace)
  struct V4C__Context *ctx ;
  P *respnt ;						/* Ptr for result */
  INTMODX intmodx ;
  P *argpnts[] ;
  COUNTER argcnt ; VTRACE trace ;
{ P *cpt,*ipt,*apt,ptbuf,listbuf ;
  struct V4DPI__LittlePoint idpt ;
  struct V4DPI__DimInfo *di,*adi ;
  struct V4L__ListPoint *lp ;
  struct V4DPI__Point_IntMix *pim ;
  struct V4AGG__AggDims *vad ;
  struct V4L__ListAggRef *lar ;
  struct V4IS__ParControlBlk pcb ;
  struct V4C__AreaHInfo ahi ;
  struct V4DPI__CodedRange *vcr ;
  struct V4LEX__TknCtrlBlk *tcb ;
  struct V4__PTBitMap ptmap ;
  enum DictionaryEntries deval ;
#ifdef WINNT
#elif defined UNIX
  struct timeval endTime ;
#else
  time_t endTime ;
#endif
#define FNAMEMAX 100
  struct {
    int NoError ;
    int FCnt ;
    struct {
      UCCHAR FName[V_FileName_Max] ;
      int IsAgg ;		/* Set to TRUE if Agg, then with Unique ID on open */
     } File[FNAMEMAX] ;
    } area ;
  int update=FALSE,isagg ;
  int i,j,k ; INDEX ix, tx ; LOGICAL ok ; double dnum ; int number = 0x80000000 ; UCCHAR tbuf[V_FileName_Max+100] ;

	area.FCnt = 0 ; area.NoError = FALSE ; adi = NULL ; di = NULL ; apt = NULL ; ZPH(&idpt) ;
	for(ix=1,ok=TRUE;ok&&ix<=argcnt;ix++)			/* Step thru the remaining arguments */
	 { isagg = FALSE ;
	   if (argpnts[ix]->PntType != V4DPI_PntType_TagVal)
	    { apt = argpnts[ix] ;
	      if (apt->PntType == V4DPI_PntType_Dict ? apt->Dim == Dim_Dim : FALSE)
	       { ISVALIDDIM(apt->Value.IntVal,ix,"V4()") ; DIMINFO(di,ctx,apt->Value.IntVal) ;
		 if (di == NULL) { v_Msg(ctx,NULL,"ModArgNotDim",intmodx,ix,apt) ; goto fail ; } ;
		 adi = di ;
	       } else
	       { DIMINFO(di,ctx,apt->Dim) ;
		 if (di == NULL && apt->PntType == V4DPI_PntType_Isct) { DIMINFO(di,ctx,Dim_Isct) ; } ;
		 if (di == NULL) { v_Msg(ctx,NULL,"ModArgNotDim",intmodx,ix,apt) ; goto fail ; } ;
		 adi = di ;
	       }
	      continue ;
	    } ;
	   switch (tx=v4im_CheckPtArgNew(ctx,argpnts[ix],&cpt,&ptbuf))
	    { default:				v_Msg(ctx,NULL,"TagBadUse",intmodx) ; goto fail ;
	      case V4IM_Tag_Unk:		v_Msg(ctx,NULL,"TagUnknown",intmodx) ; goto fail ;
	      case -V4IM_Tag_Acceptor:
printf("\n\n************************* V4(Acceptor?) is deprecated, use Dim() module ******************\n\n") ;
		if (adi == NULL) 
		 { v_Msg(ctx,NULL,"DimNoneGiven",intmodx) ; goto fail ; } ;
		memcpy(respnt,&Log_True,Log_True.Bytes) ; respnt->Value.IntVal = (adi->Flags & V4DPI_DimInfo_Acceptor) != 0 ;
		return(respnt) ;
	      case V4IM_Tag_Acceptor:
printf("\n\n************************* V4(Acceptor::xxx) is deprecated, use Dim() module ******************\n\n") ;
		DIMINFO(di,ctx,cpt->Dim) ;
		memcpy(respnt,&Log_True,Log_True.Bytes) ; respnt->Value.IntVal = (di->Flags & V4DPI_DimInfo_Acceptor) != 0 ;
		return(respnt) ;
	      case -V4IM_Tag_ADPoint:
printf("\n\n************************* V4(ADPoint?) is deprecated, use Dim() module ******************\n\n") ;
		if (adi == NULL) 
		 { v_Msg(ctx,NULL,"DimNoneGiven",intmodx) ; goto fail ; } ;
		if (adi->ADPnt.Dim == 0) { v_Msg(ctx,NULL,"V4NoADPoint",intmodx,adi->DimId,DE(ADPoint)) ; goto fail ; } ;
		memcpy(respnt,&adi->ADPnt,adi->ADPnt.Bytes) ; return(respnt) ;
	      case V4IM_Tag_ADPoint:
printf("\n\n************************* V4(ADPoint::xxxx) is deprecated, use Dim() module ******************\n\n") ;
		DIMINFO(di,ctx,cpt->Dim) ;
		if (di->ADPnt.Dim == 0) { v_Msg(ctx,NULL,"V4NoADPoint",intmodx,di->DimId,DE(ADPoint)) ; goto fail ; } ;
		memcpy(respnt,&di->ADPnt,di->ADPnt.Bytes) ; return(respnt) ;
	      case V4IM_Tag_Count:
		switch (v4im_GetDictToEnumVal(ctx,cpt))
		 { default:		v_Msg(ctx,NULL,"ModTagValue",intmodx,ix,V4IM_Tag_Count,cpt) ; ipt = NULL ; goto fail ;
		   case _Context:	intPNTv(respnt,ctx->ContextAddCount) ; break ;
		   case _Errors:	intPNTv(respnt,gpi->ErrCount) ; break ;
		   case _Evaluations:	intPNTv(respnt,ctx->IsctEvalCount) ; break ;
		 } ;
		return(respnt) ;
	      case -V4IM_Tag_Fail:

		ipt = (P *)0 ; ipt->Bytes = 99 ;
	      case V4IM_Tag_Id:
printf("\n\n************************* V4(Id::xxxx) is deprecated, use Area() module ******************\n\n") ;
		if (cpt->Bytes > sizeof idpt) { v_Msg(ctx,NULL,"DimTooBig",intmodx,cpt) ; goto fail ; } ;
		memcpy(&idpt,cpt,cpt->Bytes) ;
		break ;
	      case -V4IM_Tag_Image:
#ifdef WINNT
		if (UCGetModuleFileName(NULL,UCTBUF1,V4TMBufMax))
		 { uccharPNTv(respnt,UCTBUF1) ; return(respnt) ; } ;
#endif	 
		v_Msg(ctx,NULL,"NYIonthisOS",intmodx) ; goto fail ;     
	      case -V4IM_Tag_Displayer:
printf("\n\n************************* V4(Displayer?) is deprecated, use Dim() module ******************\n\n") ;
		if (adi == NULL) 
		 { v_Msg(ctx,NULL,"DimNoneGiven",intmodx) ; goto fail ; } ;
		memcpy(respnt,&Log_True,Log_True.Bytes) ; respnt->Value.IntVal = (adi->Flags & V4DPI_DimInfo_Displayer) != 0 ;
		return(respnt) ;
	      case V4IM_Tag_Displayer:
printf("\n\n************************* V4(Displayer::xxx) is deprecated, use Dim() module ******************\n\n") ;
		DIMINFO(di,ctx,cpt->Dim) ;
		memcpy(respnt,&Log_True,Log_True.Bytes) ; respnt->Value.IntVal = (di->Flags & V4DPI_DimInfo_Displayer) != 0 ;
		return(respnt) ;
	      case -V4IM_Tag_DotDotToList:
printf("\n\n************************* V4(DotDotToList?) is deprecated, use Dim() module ******************\n\n") ;
		if (adi == NULL) 
		 { v_Msg(ctx,NULL,"DimNoneGiven",intmodx) ; goto fail ; } ;
		memcpy(respnt,&Log_True,Log_True.Bytes) ; respnt->Value.IntVal = (adi->Flags & V4DPI_DimInfo_DotDotToList) != 0 ;
		return(respnt) ;
	      case V4IM_Tag_DotDotToList:
printf("\n\n************************* V4(DotDotToList::xxx) is deprecated, use Dim() module ******************\n\n") ;
		DIMINFO(di,ctx,cpt->Dim) ;
		memcpy(respnt,&Log_True,Log_True.Bytes) ; respnt->Value.IntVal = (di->Flags & V4DPI_DimInfo_DotDotToList) != 0 ;
		return(respnt) ;
	      case -V4IM_Tag_All:
		if (apt == NULL) { v_Msg(ctx,NULL,"V4NoPriorPt",intmodx,-V4IM_Tag_All) ; goto fail ; } ;
		memcpy(respnt,&Log_True,Log_True.Bytes) ;
		respnt->Value.IntVal = (apt->PntType == V4DPI_PntType_Special && apt->Grouping == V4DPI_Grouping_All) ;
		return(respnt) ;
	      case V4IM_Tag_All:
		memcpy(respnt,&Log_True,Log_True.Bytes) ;
		respnt->Value.IntVal = (cpt->PntType == V4DPI_PntType_Special && cpt->Grouping == V4DPI_Grouping_All) ;
		return(respnt) ;
	      case -V4IM_Tag_Evaluations:
		intPNTv(respnt,ctx->IsctEvalCount) ; return(respnt) ;
	      case V4IM_Tag_Close:		/* Close::listUIds to close */
printf("\n\n************************* V4(Close::id) is deprecated, use Area() module ******************\n\n") ;
		lp = v4im_VerifyList(NULL,ctx,cpt,intmodx) ;
		if (lp == NULL) { v_Msg(ctx,NULL,"ModInvArgList",intmodx,ix) ; goto fail ; } ;
		for(j=1;;j++)
		 { if (!v4l_ListPoint_Value(ctx,lp,j,&listbuf)) break ;
		   i = (listbuf.PntType == V4DPI_PntType_Int ? listbuf.Value.IntVal : UNUSED) ;
		   for(k=0;k<gpi->AreaAggCount;k++)
	            { if (i != gpi->AreaAgg[k].AggUId || gpi->AreaAgg[k].pcb == NULL) continue ;
		      v4ctx_AreaClose(ctx,gpi->AreaAgg[k].pcb->AreaId) ; break ;
		    } ;
		   if (k >= gpi->AreaAggCount) { v_Msg(ctx,NULL,"V4NotAreaId",intmodx,ix,&listbuf) ; goto fail ; } ;
		 } ;
		return((P *)&Log_True) ;
	      case V4IM_Tag_Agg:		/* Agg::areaname */
		isagg = TRUE ;			/* fall thru and get list of names */
	      case V4IM_Tag_Area:		/* Area::areaname */
printf("\n\n************************* V4(Agg::file / Area::file) is deprecated, use Area() module ******************\n\n") ;
		if (cpt->PntType == V4DPI_PntType_List) { lp = v4im_VerifyList(NULL,ctx,cpt,intmodx) ; }
		 else { lp = NULL ; } ;
		for(j=1;j<=FNAMEMAX;j++)
		 { if (lp != NULL)
		    { if (!v4l_ListPoint_Value(ctx,lp,j,&listbuf)) break ;
		      cpt = &listbuf ;
		    } ;
		   v4im_GetPointUC(&ok,area.File[area.FCnt].FName,UCsizeof(area.File[area.FCnt].FName),cpt,ctx) ; if (!ok) break ;
		   area.File[area.FCnt].IsAgg = isagg ;
		   area.FCnt++ ;
		   if (lp == NULL) break ;
		 } ;
		if (j > FNAMEMAX) { v_Msg(ctx,NULL,"V4MaxAggs",intmodx,FNAMEMAX) ; goto fail ; } ;
		break ;
//	      case -V4IM_Tag_Area:		/* Area? - return list of areas */
//		INITLP(respnt,lp,Dim_List)
//		for(i=gpi->LowHNum;i<=gpi->HighHNum;i++)
//	         { if (gpi->RelH[i].aid == UNUSED) continue ;
//		   uccharPNTv(&ptbuf,gpi->RelH[i].pcb->UCFileName) ; v4l_ListPoint_Modify(ctx,lp,V4L_ListAction_Append,&ptbuf,0) ;
//		 } ;
//		ENDLP(respnt,lp)
//		return(respnt) ;
	      case -V4IM_Tag_Include:
		tcb = gpi->MainTcb ; ZUS(tbuf) ;
		if (tcb != NULL)
		 { for(j=tcb->ilx,ok=FALSE;!ok && j>0;j--)		/* Scan up through token source stack for file */
		    { switch (tcb->ilvl[j].mode)
		       { default:	break ;
			 case V4LEX_InpMode_CmpFile:
			 case V4LEX_InpMode_TempFile:
			 case V4LEX_InpMode_File:
				UCstrcat(tbuf,vlex_FullPathNameOfFile(tcb->ilvl[j].file_name,NULL,0)) ;
				UCsprintf(&tbuf[UCstrlen(tbuf)],UCsizeof(tbuf),UClit(" %d"),tcb->ilvl[j].current_line) ;
				ok = TRUE ; break ;
		       } ;
		    } ;
		 } ;
		uccharPNTv(respnt,tbuf) ; return(respnt) ;
	      case V4IM_Tag_Context:
	      { LOGICAL wantLocal = FALSE ;
		switch (v4im_GetDictToEnumVal(ctx,cpt))
		 { default:		v_Msg(ctx,NULL,"ModTagValue",intmodx,ix,V4IM_Tag_Context,cpt) ; ipt = NULL ; goto fail ;
		   case _Global:	break ;
		   case _Local:		wantLocal = TRUE ; break ;
		 } ;
		INITLP(respnt,lp,Dim_List)
		for(i=0;i<V4C_CtxDimHash_Max;i++)
		 { if (ctx->DimHash[i].Dim == 0) continue ;			/* Empty slot */
		   if ((j = ctx->DimHash[i].CtxValIndex) < 0) continue ;
		   if (wantLocal ? (ctx->Frame[ctx->CtxVal[j].FrameIndex].FrameId != 0) : (ctx->Frame[ctx->CtxVal[j].FrameIndex].FrameId == 0))
		    {
#ifdef V4_BUILD_SECURITY
		      DIMINFO(di,ctx,ctx->CtxVal[j].Point.Dim) ;
		      if (di == NULL ? TRUE : di->rtFlags & V4DPI_rtDimInfo_Hidden) continue ;
#endif
		      v4l_ListPoint_Modify(ctx,lp,V4L_ListAction_Append,&ctx->CtxVal[j].Point,0) ;
		    } ;
		 } ;
		ENDLP(respnt,lp)
		return(respnt) ;
	      }
	      case -V4IM_Tag_Context:
		INITLP(respnt,lp,Dim_List)
		for(i=0;i<V4C_CtxDimHash_Max;i++)
		 { if (ctx->DimHash[i].Dim == 0) continue ;			/* Empty slot */
		   if ((j = ctx->DimHash[i].CtxValIndex) < 0) continue ;
#ifdef V4_BUILD_SECURITY
		   DIMINFO(di,ctx,ctx->CtxVal[j].Point.Dim) ;
		   if (di == NULL ? TRUE : di->rtFlags & V4DPI_rtDimInfo_Hidden) continue ;
#endif
		   v4l_ListPoint_Modify(ctx,lp,V4L_ListAction_Append,&ctx->CtxVal[j].Point,0) ;
		 } ;
		ENDLP(respnt,lp)
		return(respnt) ;
	      case -V4IM_Tag_Stack:
		INITLP(respnt,lp,Dim_List) uccharPNT(&ptbuf) ;
		for(i=ctx->rtStackX;i>=0;i--)
		 { UCCHAR *srcFile ; int hnum = ctx->rtStack[i].vis.c.HNum ; struct V4LEX__CompileDir *vcd ;
		   if ((vcd = v4trace_LoadVCDforHNum(ctx,hnum,TRUE)) == NULL) continue ;
		   if (ctx->rtStack[i].vis.c.vcdIndex >= vcd->fileCount) continue ;
		   srcFile = vcd->File[ctx->rtStack[i].vis.c.vcdIndex].fileName ;
		   if (vcd->File[ctx->rtStack[i].vis.c.vcdIndex].spwHash64 != 0 && vcd->File[ctx->rtStack[i].vis.c.vcdIndex].spwHash64 != gpi->spwHash64)
		    { UCstrcpy(UCTBUF2,UClit("restricted-source")) ; }
		    else { v_Msg(ctx,UCTBUF2,"@%1U#%2U|%3P",srcFile,v4dbg_FormatLineNum(ctx->rtStack[i].vis.c.lineNumber),ctx->rtStack[i].isctPtr) ; } ;
		   if (UCstrlen(UCTBUF2) > 150) { UCTBUF2[150] = UCEOS ; UCstrcat(UCTBUF2,UClit("...")) ; } ;
		   UCstrcpy(&ptbuf.Value.UCVal[1],UCTBUF2) ; UCCHARPNTBYTES1(&ptbuf)
		   v4l_ListPoint_Modify(ctx,lp,V4L_ListAction_Append,&ptbuf,0) ;
		 } ;
		ENDLP(respnt,lp)
		return(respnt) ;
	      case -V4IM_Tag_Delete:
	      case -V4IM_Tag_Remove:
		if (di == NULL) { v_Msg(ctx,NULL,"DimNoneGiven",intmodx) ; goto fail ; } ;
		intPNTv(respnt,0) ;					/* Set result to Int:0 */
		switch (di->UniqueOK)
		 { default:		v_Msg(ctx,NULL,"V4RemovePts",intmodx,di->DimId) ; goto fail ;
		   case V4DPI_DimInfo_UOkNew:			/* Points on dimension to be created via {new} */
		   case V4DPI_DimInfo_UOkInt:
		   case V4DPI_DimInfo_UOkPoint:		/* Points to be created via V4EVAL "Point" command */
			respnt->Value.IntVal = v4dpi_DimUnqRmvFromCache(ctx,di) ;
			break ;
		   case V4DPI_DimInfo_UOkAgg:
			for(i=0;i<gpi->AreaAggCount;i++)			/* Loop thru all loaded aggs */
			 { if (gpi->AreaAgg[i].pcb == NULL) continue ;
			   vad = gpi->AreaAgg[i].vad ; if (vad == NULL) continue ;
			   for(j=0;j<vad->Count;j++)
			    { if (vad->Dims[j] != di->DimId) continue ;		/* Look for wanted dimension */
			      if (vad->Entry[j].BeginPt > vad->Entry[j].EndPt) continue ;
			      respnt->Value.IntVal += (vad->Entry[j].EndPt - vad->Entry[j].BeginPt + 1) ;
			      vad->Entry[j].BeginPt = vad->Entry[j].EndPt + 1 ;
			    } ;
			 } ;
			break ;
		 } ;
		return(respnt) ;
	      case V4IM_Tag_Mask:
		if (apt == NULL) { v_Msg(ctx,NULL,"V4NoPriorPt",intmodx,-V4IM_Tag_All) ; goto fail ; } ;
		uccharPNTv(respnt,gpi->formatMasks[di->PointType]) ;
		v4im_GetPointUC(&ok,gpi->formatMasks[di->PointType],UCsizeof(gpi->formatMasks[0]),cpt,ctx) ; if (!ok) break ;
		return(respnt) ;
//	      case V4IM_Tag_Trials:
//		{ INDEX i,max ;
//		  max = v4im_GetPointInt(&ok,cpt,ctx) ; if (!ok) break ;
//		  for(i=0;i<max;i++)
//		   { COUNTER ranHang =  (COUNTER)(vRan64_RandomU64() & 0x3f) ;
//		     printf("%d -> %d\n",i+1,ranHang) ;
//		   } ;
//		}
//		logPNTv(respnt,TRUE) ;
//		break ;
	      case V4IM_Tag_Test:
		if (gpi->RestrictionMap & V_Restrict_Test) { v_Msg(ctx,NULL,"RestrictMod",intmodx) ; goto fail ; } ;
		if (gpi->pntTest.Bytes == 0) { logPNTv(respnt,FALSE) ; } else { memcpy(respnt,&gpi->pntTest,gpi->pntTest.Bytes) ; } ;
		memcpy(&gpi->pntTest,cpt,cpt->Bytes) ;
		return(respnt) ;
	      case -V4IM_Tag_Test:
		if (gpi->RestrictionMap & V_Restrict_Test) { v_Msg(ctx,NULL,"RestrictMod",intmodx) ; goto fail ; } ;
		if (gpi->pntTest.Bytes == 0) { v_Msg(ctx,NULL,"EvalNoEval",intmodx,argpnts[ix]) ; goto fail ; } ;
		memcpy(respnt,&gpi->pntTest,gpi->pntTest.Bytes) ;
		return(respnt) ;
	      case V4IM_Tag_Type:
		dictPNT(respnt,Dim_UV4) ;
		respnt->Value.IntVal = v4dpi_DictEntryGet(ctx,0,v4im_PTName(cpt->PntType),di,NULL) ; ;
		return(respnt) ;
	      case -V4IM_Tag_Type:
		if (apt == NULL) { v_Msg(ctx,NULL,"V4NoPriorPt",intmodx,-V4IM_Tag_All) ; goto fail ; } ;
		dictPNT(respnt,Dim_UV4) ;
		respnt->Value.IntVal = v4dpi_DictEntryGet(ctx,0,v4im_PTName(apt->PntType),di,NULL) ; ;
		return(respnt) ;
	      case V4IM_Tag_Logical:
		ok = (cpt->PntType == V4DPI_PntType_List) ;
		lp = ALIGNLP(&cpt->Value) ;	/* Link up list structure */
		if (ok) { ok = (v4l_ListPoint_Value(ctx,lp,1,&ptbuf) > 0) ; v4im_GetPointUC(&ok,tbuf,UCsizeof(tbuf),&ptbuf,ctx) ; } ;
		if (ok) { ok = (v4l_ListPoint_Value(ctx,lp,2,&ptbuf) > 0) ; v4im_GetPointUC(&ok,UCTBUF1,UCsizeof(tbuf),&ptbuf,ctx) ; } ;
		if (!ok) { v_Msg(ctx,NULL,"V4Logical",intmodx,V4IM_Tag_Logical,cpt) ; goto fail ; } ;
		vlog_StoreSymValue(tbuf,UCTBUF1) ;
		logPNTv(respnt,TRUE) ; return(respnt) ;
	      case V4IM_Tag_Segment:
		apt = cpt ;			/* Just fall thru with proper apt */
	      case -V4IM_Tag_Segment:
		if (apt == NULL) { v_Msg(ctx,NULL,"V4NoPriorPt",intmodx,-V4IM_Tag_All) ; goto fail ; } ;
		switch (apt->Grouping)
		 { default:				deval = _Multiple ; break ;
		   case 1:				deval = _Range ; break ;
		   case V4DPI_Grouping_Single:		deval = (apt->PntType == V4DPI_PntType_List ? _List : _Point) ; break ;
		   case V4DPI_Grouping_All:		deval = _All ; break ;
		   case V4DPI_Grouping_Current:		deval = _Current ; break ;
		   case V4DPI_Grouping_Now:		deval = _Now ; break ;
		   case V4DPI_Grouping_Undefined:	deval = _Undefined ; break ;
		   case V4DPI_Grouping_Sample:		deval = _Sample ; break ;
		   case V4DPI_Grouping_LT:		deval = _LT ; break ;
		   case V4DPI_Grouping_LE:		deval = _LE ; break ;
		   case V4DPI_Grouping_GE:		deval = _GE ; break ;
		   case V4DPI_Grouping_GT:		deval = _GT ; break ;
		   case V4DPI_Grouping_NE:		deval = _NE ; break ;
		   case V4DPI_Grouping_New:		deval = _New ; break ;
		   case V4DPI_Grouping_PCurrent:	deval = _PCurrent ; break ;
		   case V4DPI_Grouping_None:		deval = _None ; break ;
		   case V4DPI_Grouping_AllCnf:		deval = _Alll ; break ;
		 } ;
		DIMINFO(di,ctx,respnt->Dim) ; dictPNT(respnt,Dim_UV4) ;
		respnt->Value.IntVal = v4im_GetEnumToDictVal(ctx,deval,Dim_UV4) ;
		return(respnt) ;
	      case V4IM_Tag_Sort:
		i = v4im_GetPointInt(&ok,cpt,ctx) ; if (!ok) break ;
		intPNTv(respnt,SPAWNMAXWAITDEC(gpi->sortWaitFlag)) ;
		if (i == 0) { gpi->sortWaitFlag = V_SPAWNWAIT_Infinite ; }
		 else { if (i < 1 || i > V_SPAWNWAIT_MaxSecs) { v_Msg(ctx,NULL,"ModArgRange",intmodx,ix,argpnts[ix],1,V_SPAWNWAIT_MaxSecs) ; goto fail ; } ;
			gpi->sortWaitFlag = SPAWNMAXWAITENC(i)|V_SPAWNPROC_Wait ;
		      }
		return(respnt) ;
	      case -V4IM_Tag_Sort:
		intPNTv(respnt,SPAWNMAXWAITDEC(gpi->sortWaitFlag)) ; return(respnt) ;
	      case V4IM_Tag_Begin:
		apt = cpt ;			/* Just fall thru with proper apt */
	      case -V4IM_Tag_Begin:
		if (apt == NULL) { v_Msg(ctx,NULL,"V4NoPriorPt",intmodx,-V4IM_Tag_All) ; goto fail ; } ;
		if (apt->Grouping > 0 && apt->Grouping < 100) { v_Msg(ctx,NULL,"V4SingleSeg",intmodx,apt) ; goto fail ; } ;
	        memcpy(respnt,apt,apt->Bytes) ; respnt->Grouping = V4DPI_Grouping_Single ;
		return(respnt) ;
	      case V4IM_Tag_UserOptions:
		uccharPNTv(respnt,gpi->userOptString) ; 
		v4im_GetPointUC(&ok,gpi->userOptString,UCsizeof(gpi->userOptString)-1,cpt,ctx) ; if (!ok) break ;
		return(respnt) ;
	      case -V4IM_Tag_UserOptions:
		uccharPNTv(respnt,gpi->userOptString) ; 
		return(respnt) ;
	      case -V4IM_Tag_Version:
		INITLP(respnt,lp,Dim_List)
		intPNTv(&ptbuf,V4IS_MajorVersion) ; v4l_ListPoint_Modify(ctx,lp,V4L_ListAction_Append,&ptbuf,0) ;
		intPNTv(&ptbuf,V4IS_MinorVersion) ; v4l_ListPoint_Modify(ctx,lp,V4L_ListAction_Append,&ptbuf,0) ;
		ZPH(&ptbuf) ; ptbuf.Dim = Dim_UDate ; ptbuf.PntType = V4DPI_PntType_UDate ; ptbuf.Bytes = V4PS_Int ;
#ifdef __DATE__
		UCstrcpy(tbuf,ASCretUC(__DATE__)) ;
		ptbuf.Value.IntVal = v_ParseUDate(ctx,tbuf,V4LEX_TablePT_Default,V4LEX_YMDOrder_MDY,FALSE) ;
/*		If we can't parse the date string to UDate then just return the string */
		if (ptbuf.Value.IntVal == VCAL_BadVal) { alphaPNTv(&ptbuf,__DATE__) ; } ;
		v4l_ListPoint_Modify(ctx,lp,V4L_ListAction_Append,&ptbuf,0) ;
#endif
		ENDLP(respnt,lp)
		return(respnt) ;
//	      case -V4IM_Tag_Agg:		/* Agg? - return list of aggregates */
//		INITLP(respnt,lp,Dim_List)
//		for(i=0;i<gpi->AreaAggCount;i++)
//	         { if (gpi->AreaAgg[i].pcb == NULL) continue ;
//		   uccharPNT(&ptbuf) ; v_Msg(ctx,&ptbuf.Value.UCVal[1],"@%1U(%2d)",gpi->AreaAgg[i].pcb->UCFileName,gpi->AreaAgg[i].AggUId) ;
//		   UCCHARPNTBYTES1(&ptbuf)
//		   v4l_ListPoint_Modify(ctx,lp,V4L_ListAction_Append,&ptbuf,0) ;
//		 } ;
//		ENDLP(respnt,lp)
//		return(respnt) ;
	      case V4IM_Tag_Binding:
		i = v4im_GetPointInt(&ok,cpt,ctx) ; if (!ok) break ;
		if (adi == NULL) 
		 { v_Msg(ctx,NULL,"DimNoneGiven",intmodx) ; goto fail ; } ;
		adi->BindList = i ;
		return((P *)&Log_True) ;
	      case -V4IM_Tag_Binding:
		if (adi == NULL) 
		 { v_Msg(ctx,NULL,"DimNoneGiven",intmodx) ; goto fail ; } ;
		intPNTv(respnt,adi->BindList) ; return(respnt) ;
	      case -V4IM_Tag_Description:
		if (adi == NULL) 
		 { v_Msg(ctx,NULL,"DimNoneGiven",intmodx) ; goto fail ; } ;
		if (UCempty(adi->Desc)) { v_Msg(ctx,NULL,"V4DimNoDesc",intmodx,Dim_Dim,adi->DimId,-V4IM_Tag_Description) ; goto fail ; } ;
		uccharPNTv(respnt,adi->Desc) ; return(respnt) ;
	      case V4IM_Tag_Error:
		j = v4im_GetPointInt(&ok,cpt,ctx) ; if (!ok) break ;
		if (j < 0 || j >= V4TRACE_MaxNestedrtStack ? TRUE : ctx->rtStack[j].failText == NULL)
		 { i = 0 ; }
		 else { i = UCstrlen(ctx->rtStack[j].failText) ; UCstrcpy(&respnt->Value.UCVal[1],ctx->rtStack[j].failText) ; } ;
		ZPH(respnt) ; respnt->Dim = Dim_Alpha ; respnt->PntType = V4DPI_PntType_Char ;
		uccharPNT(respnt) ; UCCHARPNTBYTES2(respnt,i) ;
		return(respnt) ;
	      case -V4IM_Tag_Error:
		uccharPNT(respnt) ; 
		if (ctx->rtStackFail < 0 || ctx->rtStack[ctx->rtStackFail].failText == NULL)
		 { UCstrcpy(&respnt->Value.UCVal[1],UClit("")) ; }
		 else { UCstrcpy(&respnt->Value.UCVal[1],ctx->rtStack[ctx->rtStackFail].failText) ; } ;
		UCCHARPNTBYTES1(respnt)
		return(respnt) ;
	      case V4IM_Tag_Dim:
		ISVALIDDIM(argpnts[ix]->Value.IntVal,ix,"V4()") ; DIMINFO(di,ctx,argpnts[ix]->Value.IntVal) ;
		if (di == NULL)	 { v_Msg(ctx,NULL,"ModArgNotDim",intmodx,ix,argpnts[ix]) ; goto fail ; } ;
		adi = di ; break ;
	      case V4IM_Tag_Epsilon:
	      case -V4IM_Tag_Epsilon:
/*		For both - set result to currrent value(s) */
		if (gpi->DblEpsilon == gpi->DblEpsilonZero) { dblPNTv(respnt,gpi->DblEpsilon) ; }
		 else { INITLP(respnt,lp,Dim_List)
			dblPNTv(&ptbuf,gpi->DblEpsilon) ; v4l_ListPoint_Modify(ctx,lp,V4L_ListAction_Append,&ptbuf,0) ;
			dblPNTv(&ptbuf,gpi->DblEpsilonZero) ; v4l_ListPoint_Modify(ctx,lp,V4L_ListAction_Append,&ptbuf,0) ;
			ENDLP(respnt,lp) ;
		      } ;
/*		If Epsilon? then just reutrn current settings */
		if (tx == -V4IM_Tag_Epsilon) return(respnt) ;
/*		Here to set the value(s) */
		if (cpt->PntType != V4DPI_PntType_List)
		 { dnum = v4im_GetPointDbl(&ok,cpt,ctx) ; if (dnum < 0.0 || !ok) { v_Msg(ctx,NULL,"ModArgPos",intmodx,ix,cpt) ; goto fail ; } ;
		   gpi->DblEpsilon = dnum ; gpi->DblEpsilonZero = dnum ;
		 } else
		 { lp = v4im_VerifyList(NULL,ctx,cpt,intmodx) ;
		   if (SIZEofLIST(lp) != 2) { v_Msg(ctx,NULL,"ModArgList",intmodx,ix,cpt) ; goto fail ; } ;
		   v4l_ListPoint_Value(ctx,lp,1,&listbuf) ; dnum = v4im_GetPointDbl(&ok,&listbuf,ctx) ; if (dnum < 0.0 || !ok) { v_Msg(ctx,NULL,"ModArgPos",intmodx,ix,cpt) ; goto fail ; } ; gpi->DblEpsilon = dnum ;
		   v4l_ListPoint_Value(ctx,lp,2,&listbuf) ; dnum = v4im_GetPointDbl(&ok,&listbuf,ctx) ; if (dnum < 0.0 || !ok) { v_Msg(ctx,NULL,"ModArgPos",intmodx,ix,cpt) ; goto fail ; } ; gpi->DblEpsilonZero = dnum ;
		 } ;
		return(respnt) ;
	      case V4IM_Tag_Num:
	      case V4IM_Tag_Number:
		if (adi == NULL) 
		 { v_Msg(ctx,NULL,"DimNoneGiven",intmodx) ; goto fail ; } ;
		if (adi->PointType != V4DPI_PntType_CodedRange)
		 { v_Msg(ctx,NULL,"ModArgPntType2",intmodx,1,adi->PointType,V4DPI_PntType_CodedRange) ; goto fail ; } ;
		number = v4im_GetPointInt(&ok,cpt,ctx) ;
		break ;
	      case V4IM_Tag_Range:
		if (adi == NULL || number == 0x80000000) { v_Msg(ctx,NULL,"V4NoPriorDimNum",intmodx,Dim_Dim,V4IM_Tag_Number) ; goto fail ; } ;
		if (adi->vcr == NULL)		/* Have to define first one? */
		 { adi->vcr = (struct V4DPI__CodedRange *)v4mm_AllocChunk(sizeof *vcr,TRUE) ;
		   vcr = adi->vcr ;
		 } else
		 { for(vcr=adi->vcr;vcr->vcr!=NULL;vcr=vcr->vcr) { } ;
		   vcr->vcr = (struct V4DPI__CodedRange *)v4mm_AllocChunk(sizeof *vcr,TRUE) ;
		   vcr = vcr->vcr ;
		 } ;
		vcr->crPoint = (P *)v4mm_AllocChunk(cpt->Bytes,FALSE) ; memcpy(vcr->crPoint,cpt,cpt->Bytes) ;
		vcr->InternalValue = number ; vcr->vcr = NULL ;
		number = 0x80000000 ;
		break ;
	      case -V4IM_Tag_NoError:		/* Noerror? - If single arg then reset NestMax */
		if (argcnt == 1) { gpi->NestMax = FALSE ; break ; }
		area.NoError = TRUE ; break ;
	      case V4IM_Tag_Delete:		/* Remove::list-of-agg-points */
	      case V4IM_Tag_Remove:		/* Remove::list-of-agg-points */
		lp = ALIGNLP(&cpt->Value) ;	/* Link up list structure */
		if (cpt->PntType != V4DPI_PntType_List || lp->ListType != V4L_ListType_AggRef)
		 { v_Msg(ctx,NULL,"V4AggList",intmodx,V4IM_Tag_Delete,cpt) ; goto fail ; } ;
		lar = (struct V4L__ListAggRef *)&lp->Buffer[0] ;
		for(i=0;i<gpi->AreaAggCount;i++)			/* Loop thru all loaded aggs */
		 { if (gpi->AreaAgg[i].pcb == NULL) continue ;
		   vad = gpi->AreaAgg[i].vad ; if (vad == NULL) continue ;
		   for(ix=0;ix<vad->Count;ix++)
		    { for(j=0;j<lar->Count;j++)
		       { if (lar->AreaAggIndex[j] == i && lar->Dim == vad->Dims[ix])
		          { update = TRUE ; vad->Dims[ix] = UNUSED ; } ;
		       } ;
		    } ;
		 } ;
		return((P *)(update ? &Log_True : &Log_False)) ;
	      case V4IM_Tag_Open:		/* Open::mode */
	      case V4IM_Tag_Share:		/* Share::mode */
		break ;
	      case V4IM_Tag_Sleep:
		dnum = 	v4im_GetPointDur(&ok,cpt,ctx) ; if (!ok) break ;
		HANGLOOSE((int)(dnum * 1000)) ;
		return((P *)&Log_True) ;
	      case V4IM_Tag_SourceFile:
		i = v4im_GetPointInt(&ok,cpt,ctx) ; if (!ok) break ;
		if (i < gpi->LowHNum || i > gpi->HighHNum)
		 { union V4DPI__IsctSrc vis ; struct V4LEX__CompileDir *vcd ; UCCHAR *srcFile ;
		   vis.iVal = i ;
		   INITLP(respnt,lp,Dim_List)
		   intPNTv(&ptbuf,vis.c.HNum) ; v4l_ListPoint_Modify(ctx,lp,V4L_ListAction_Append,&ptbuf,0) ;
		   intPNTv(&ptbuf,vis.c.vcdIndex) ; v4l_ListPoint_Modify(ctx,lp,V4L_ListAction_Append,&ptbuf,0) ;
		   if ((vcd = v4trace_LoadVCDforHNum(ctx,vis.c.HNum,TRUE)) != NULL)
		    { srcFile = (vis.c.vcdIndex < vcd->fileCount ? vcd->File[vis.c.vcdIndex].fileName : NULL) ;
		      if (srcFile != NULL)
		       { if (vcd->File[vis.c.vcdIndex].spwHash64 != 0 && vcd->File[vis.c.vcdIndex].spwHash64 != gpi->spwHash64) srcFile = UClit("restricted-file") ; } ;
		    } else { srcFile = NULL ; } ;
		   if (srcFile == NULL) { alphaPNTv(&ptbuf,"") ; } else { uccharPNTv(&ptbuf,srcFile) ; } ; v4l_ListPoint_Modify(ctx,lp,V4L_ListAction_Append,&ptbuf,0) ;
		   intPNTv(&ptbuf,vis.c.lineNumber/10) ; v4l_ListPoint_Modify(ctx,lp,V4L_ListAction_Append,&ptbuf,0) ;
		   ENDLP(respnt,lp) ;
		   return(respnt) ;
		 } ;
		if (gpi->RelH[i].aid == UNUSED) { v_Msg(ctx,NULL,"CtxNoHNum",intmodx,i) ; goto fail ; } ;
		{ struct V4LEX__CompileDir *vcd ; struct V4L__ListPoint *lp1 ;


		  if ((vcd =v4trace_LoadVCDforHNum(ctx,i,TRUE)) == NULL) { v_Msg(ctx,NULL,"CtxNoSrcInfo",intmodx,gpi->RelH[i].pcb->UCFileName) ; goto fail ; } ;

		  INITLP(respnt,lp,Dim_List)
		    if (vcd->compUpdCal != 0.0)
		     { INITLP(&listbuf,lp1,Dim_List) ;
			dictPNTv(&ptbuf,Dim_UV4,v4im_GetEnumToDictVal(ctx,deval=_Create,Dim_NId)) ; v4l_ListPoint_Modify(ctx,lp1,V4L_ListAction_Append,&ptbuf,0) ;
			ZPH(&ptbuf) ; ptbuf.Dim = Dim_UCal ; ptbuf.PntType = V4DPI_PntType_Calendar ; ptbuf.Bytes = V4PS_Calendar ;
			SETDBL(ptbuf.Value.RealVal,vcd->compUpdCal) ; v4l_ListPoint_Modify(ctx,lp1,V4L_ListAction_Append,&ptbuf,0) ;
		       ENDLP(&listbuf,lp1) ; v4l_ListPoint_Modify(ctx,lp,V4L_ListAction_Append,&listbuf,0) ;
		       INITLP(&listbuf,lp1,Dim_List) ;
			dictPNTv(&ptbuf,Dim_UV4,v4im_GetEnumToDictVal(ctx,deval=_Version,Dim_NId)) ; v4l_ListPoint_Modify(ctx,lp1,V4L_ListAction_Append,&ptbuf,0) ;
			intPNTv(&ptbuf,vcd->verMajor) ; v4l_ListPoint_Modify(ctx,lp1,V4L_ListAction_Append,&ptbuf,0) ;
			intPNTv(&ptbuf,vcd->verMinor) ; v4l_ListPoint_Modify(ctx,lp1,V4L_ListAction_Append,&ptbuf,0) ;
		       ENDLP(&listbuf,lp1) ; v4l_ListPoint_Modify(ctx,lp,V4L_ListAction_Append,&listbuf,0) ;
		     } ;
		    for(i=0;i<vcd->fileCount;i++)
		     { INITLP(&listbuf,lp1,Dim_List) ;
			dictPNTv(&ptbuf,Dim_UV4,v4im_GetEnumToDictVal(ctx,deval=_File,Dim_NId)) ; v4l_ListPoint_Modify(ctx,lp1,V4L_ListAction_Append,&ptbuf,0) ;
			intPNTv(&ptbuf,i) ; v4l_ListPoint_Modify(ctx,lp1,V4L_ListAction_Append,&ptbuf,0) ;
			uccharPNTv(&ptbuf,vcd->File[i].fileName) ; 
			   if (vcd->File[i].spwHash64 != 0 && vcd->File[i].spwHash64 != gpi->spwHash64) { uccharPNTv(&ptbuf,UClit("restricted-file")) ; } ;
			   v4l_ListPoint_Modify(ctx,lp1,V4L_ListAction_Append,&ptbuf,0) ;
			ZPH(&ptbuf) ; ptbuf.Dim = Dim_UCal ; ptbuf.PntType = V4DPI_PntType_Calendar ; ptbuf.Bytes = V4PS_Calendar ;
			SETDBL(ptbuf.Value.RealVal,vcd->File[i].fileUpdCal) ; v4l_ListPoint_Modify(ctx,lp1,V4L_ListAction_Append,&ptbuf,0) ;
		       ENDLP(&listbuf,lp1) ; v4l_ListPoint_Modify(ctx,lp,V4L_ListAction_Append,&listbuf,0) ;
		     } ;

		  ENDLP(respnt,lp) ;
		  return(respnt) ;
		}
	      case -V4IM_Tag_SourceFile:
		tcb = gpi->MainTcb ;
		if (tcb != NULL)
		 { for(i=tcb->ilx;i>0;i--)
		    { switch (tcb->ilvl[i].mode)
		       { case V4LEX_InpMode_File:
			 case V4LEX_InpMode_TempFile:
			 case V4LEX_InpMode_CmpFile:
			   uccharPNTv(respnt,tcb->ilvl[i].file_name) ; return(respnt) ;
		       } ;
		    } ;
		 } ;
		v_Msg(ctx,NULL,"V4NoSrcFile",intmodx) ; goto fail ;
	      case V4IM_Tag_Name:			/* V4(point Name::xxx [other points]) or V4(Name::num) */
		if (apt == NULL)
		 { i = v4im_GetPointInt(&ok,cpt,ctx) ;
		   if (!ok) { v_Msg(ctx,NULL,"V4NoPriorPt",intmodx,V4IM_Tag_Name) ; goto fail ; } ;
		   if(v4sxi_SpecialDelEntry(ctx,intmodx,i)) { return((P *)&Log_True) ; } else { return(NULL) ; } ;
		 } ;
		dnum = v4im_GetPointDbl(&ok,apt,ctx) ;
		if (!ok)				/* If TeleNum or GeoCoord then force to dnum */
		 { if (apt->PntType == V4DPI_PntType_TeleNum || apt->PntType == V4DPI_PntType_GeoCoord)
		    { GETREAL(dnum,apt) ; }
		    else { break ; } ;
		 } ;
		v4im_GetPointUC(&ok,tbuf,UCsizeof(tbuf),cpt,ctx) ; if (!ok) break ;
		memset(&ptmap,0,sizeof ptmap) ; ptmap.Map[apt->PntType / 32] = (1 << (apt->PntType % 32)) ;
		if (argcnt > 2)				/* Do we have Dim:x,y,z of additional points */
		 { ipt = argpnts[3] ;
		   if (ipt->Dim != Dim_Dim) { v_Msg(ctx,NULL,"V4NotDimDim",intmodx,3) ; goto fail ; } ;
		   pim = (struct V4DPI__Point_IntMix *)&ipt->Value ;
		   for(i=0;i<ipt->Grouping;i++)
		    { DIMINFO(di,ctx,pim->Entry[i].BeginInt) ; j = di->PointType  ; ptmap.Map[j / 32] |= (1 << (j % 32)) ; } ;
		 } ;
		intPNTv(respnt,v4sxi_SpecialAddKW(ctx,intmodx,&ptmap,dnum,tbuf)) ;
		if (respnt->Value.IntVal == UNUSED) goto fail ;
		return(respnt) ;			/* Return unique handle for this assignment */
	      case -V4IM_Tag_Name:
		if (adi == NULL) { v_Msg(ctx,NULL,"V4NoPriorPt",intmodx,-V4IM_Tag_Name) ; goto fail ; } ;
		if (!v4sxi_SpecialListOfKW(ctx,respnt,adi->PointType,intmodx)) goto fail ;
		return(respnt) ;
	      case V4IM_Tag_Throw:
		lp = (cpt->PntType == V4DPI_PntType_List ? v4im_VerifyList(NULL,ctx,cpt,intmodx) : NULL) ;
		for(k=1;(k>1 ? lp != NULL : TRUE);k++)
		 { char *bp,tbuf[33] ;
		   if (lp != NULL) { if (!v4l_ListPoint_Value(ctx,lp,k,&listbuf)) break ; cpt = &listbuf ; } ;
		   v4im_GetPointChar(&ok,tbuf,32,cpt,ctx) ; if (!ok) break ;
		   bp = tbuf ; if (*bp == '-') bp++ ;			/* Check for leading '-' (meaning disable) */
		   if (gpi->mi->InOrder)
		    { int first,last ;
		      for(first=0,last=gpi->mi->Count-1;;)
		       { i = (last + first) / 2 ; j = strcmp(bp,gpi->mi->Entry[i].Mnemonic) ;
		         if (j == 0) break ; if (j < 0) { last = i - 1 ; } else { first = i + 1 ; } ;
		         if (first > last) { i = gpi->mi->Count + 1 ; break ; } ;
		       } ;
		    } else					/* Have to do linear search (bummer) */
		    { for(i=0;i<gpi->mi->Count;i++) { if (strcmp(bp,gpi->mi->Entry[i].Mnemonic) == 0) break ; } ; } ;
		   if (i >= gpi->mi->Count)				/* Did we find it? */
		    { v_Msg(ctx,NULL,"V4NoErrMne",intmodx,bp) ; goto fail ; } ;
		   if (!gpi->mi->OKtoThrow[i]) { v_Msg(ctx,NULL,"V4ErrMneNotOK",intmodx,bp) ; goto fail ; } ;
		   gpi->mi->SetToThrow[i] = (bp == tbuf) ;	/* If bp != tbuf then started with '-' and want to turn off */
		 } ; if (!ok) break ;
		return((P *)&Log_True) ;
	      case -V4IM_Tag_Throw:
		INITLP(respnt,lp,Dim_List)
		for(i=0;i<gpi->mi->Count;i++)
	         { P *lpt ;
		   struct V4L__ListPoint *lp2 ;
		   if (!gpi->mi->OKtoThrow[i]) continue ;
		   lpt = &listbuf ; INITLP(lpt,lp2,Dim_List) ;
		   alphaPNTv(&ptbuf,gpi->mi->Entry[i].Mnemonic) ; v4l_ListPoint_Modify(ctx,lp2,V4L_ListAction_Append,&ptbuf,0) ;
		   logPNTv(&ptbuf,(gpi->mi->SetToThrow[i] != 0)) ; v4l_ListPoint_Modify(ctx,lp2,V4L_ListAction_Append,&ptbuf,0) ;
		   ENDLP(lpt,lp2) ; v4l_ListPoint_Modify(ctx,lp,V4L_ListAction_Append,lpt,0) ;
		 } ;
		ENDLP(respnt,lp)
		return(respnt) ;
	      case -V4IM_Tag_CPUTime:
		dnum = v_CPUTime() ;
		dblPNTv(respnt,dnum) ; return(respnt) ;
	      case -V4IM_Tag_ConnectTime:
		dnum = v_ConnectTime() ;
		ZPH(respnt) ; respnt->PntType = V4DPI_PntType_UTime ; respnt->Bytes = V4PS_UTime ; respnt->Dim = Dim_UTime ;
		PUTREAL(respnt,dnum) ;  return(respnt) ;
	      case V4IM_Tag_XML:
		switch (v4im_GetDictToEnumVal(ctx,cpt))
		 { default:		v_Msg(ctx,NULL,"ModTagValue",intmodx,ix,V4IM_Tag_XML,cpt) ; goto fail ;
		   case _AsIs:		gpi->xmlCase = 0 ; break ;
		   case _Lowercase:	gpi->xmlCase = 2 ; break ;
		   case _Uppercase:	gpi->xmlCase = 1 ; break ;
		 } 
	      case -V4IM_Tag_Unique:
	        v4_UniqueDictPoint(ctx,respnt) ;
		return(respnt) ;
	    } ;
	 } ;
	if (!ok) { v_Msg(ctx,NULL,"ModInvArg",intmodx,ix-1) ; goto fail ; } ;
	for(ix=0;ix<area.FCnt;ix++)
	 { memset(&pcb,0,sizeof pcb) ;
	   strcpy(pcb.V3name,"v4agg") ; pcb.DfltDataMode = V4IS_PCB_DataMode_Auto ; pcb.AccessMode = -1 ;
	   pcb.OpenMode = V4IS_PCB_OM_Read ; UCstrcpy(pcb.UCFileName,area.File[ix].FName) ;
	   pcb.AreaFlags = V4IS_PCB_OF_NoError ;
	   if (!v4is_Open(&pcb,NULL,ctx->ErrorMsgAux))
	    { if (area.NoError) continue ;
	      v_Msg(ctx,NULL,"ModFailed2",intmodx) ; goto fail ;
	    } ;
	   if (pcb.AreaId == V4IS_AreaId_SeqOnly)
	    { if (area.NoError) continue ;
	      v_Msg(ctx,NULL,"V4NotValidAgg",intmodx,pcb.UCFileName) ; goto fail ;
	    } ;
	   if (area.File[ix].IsAgg)
	    { for(i=0;i<gpi->AreaAggCount;i++)
	       { if (gpi->AreaAgg[i].pcb == NULL) continue ;
	         if (UCstrcmp(pcb.UCFileName,gpi->AreaAgg[i].pcb->UCFileName) == 0) break ;
	       } ;
	      if (i >= gpi->AreaAggCount)			/* Got a new area? */
	       { if ((area.File[ix].IsAgg = v4im_AggLoadArea(ctx,&pcb,&idpt)) == UNUSED)	/* Add to context */
		  { v_Msg(ctx,NULL,"V4AggLoadFail",intmodx,pcb.UCFileName) ; goto fail ; } ;
	       } else { v4is_Close(&pcb) ; } ;			/* Already got the aggregate - close file */
	    } else
	    { for(i=gpi->LowHNum;i<=gpi->HighHNum;i++)
	       { if (gpi->RelH[i].aid == UNUSED) continue ;
	         if (UCstrcmp(gpi->RelH[i].pcb->UCFileName,pcb.UCFileName) == 0) break ;
	       } ;
	      if (i > gpi->HighHNum)
	       { memset(&ahi,0,sizeof(ahi)) ;
	        if (v4ctx_AreaAdd(ctx,&pcb,&ahi,&idpt) == UNUSED)
		 { v4is_Close(&pcb) ; v_Msg(ctx,NULL,"V4AggLoadFail",intmodx,pcb.UCFileName) ; goto fail ; } ;
	       } else { v4is_Close(&pcb) ; v_Msg(ctx,NULL,"CtxDupHNum1",intmodx,gpi->RelH[i].pcb->UCFileName,i) ; goto fail ; } ;			/* Aready got area - close file */
	    } ;
	 } ;
/*	Maybe return list of UIds for aggregates */
	if (area.FCnt > 0)
	 { ZPH(respnt) ; pim = (struct V4DPI__Point_IntMix *)&respnt->Value ;
	   for(ix=0;ix<area.FCnt;ix++)
	    { if (area.File[ix].IsAgg > 1)
	       { pim->Entry[respnt->Grouping].BeginInt = (pim->Entry[respnt->Grouping].EndInt = area.File[ix].IsAgg) ;
	         respnt->Grouping++ ;
	       } ;
	    } ;
	   if (respnt->Grouping > 0)
	    { 
//	      intPNT(respnt) ; respnt->Bytes = (char *)&pim->Entry[respnt->Grouping] - (char *)respnt ;
	      intPNT(respnt) ; SETBYTESGRPINT(respnt) ;
	      return(respnt) ;
	    } ;
	 } ;
	return((P *)&Log_True) ;
fail:
	REGISTER_ERROR(0) ; return(NULL) ;
}

/*	v4_UniqueDictPoint - creates unique dictionary point	*/
/*	Call: v4_UniqueDictPoint( ctx , respnt)
	  where ctx is current context,
		respnt is updated to unique point		*/

void v4_UniqueDictPoint(ctx,respnt)
  struct V4C__Context *ctx ;
  P *respnt ;
{ 
  struct V4DPI__DimInfo *di ;
  static int ucounter = 0 ;
  UCCHAR ubuf[256] ; UB64INT ub64 ;

	UCsprintf(ubuf,UCsizeof(ubuf),UClit("%x%x%x%x"),(unsigned int)gpi->StartTime, (unsigned int)ucounter++, (unsigned int)clock(), (unsigned int)CURRENTPID) ;
	ub64 = v_Hash64(ubuf) ; UCsprintf(ubuf,100,UClit("UP%I64x"),ub64) ;
	dictPNT(respnt,Dim_NId) ; DIMINFO(di,ctx,respnt->Dim) ;
	respnt->Value.IntVal = v4dpi_DictEntryGet(ctx,0,ubuf,di,0) ;
}

void v4thread_WatchDog(arg)
  void *arg ;
{ UCCHAR msgBuf[256] ;
  static time_t lastTime ;
  static COUNTER isctCount, bindingCount ;
  
	for(;;)
	 { HANGLOOSE(10000) ;		/* Sleep 10 seconds */
	   if (gpi->ctx == NULL) continue ;
	   if (gpi->maxIdle > 0)
	    { if (isctCount != gpi->ctx->IsctEvalCount || bindingCount != gpi->BindingCount)
	       { lastTime = time(NULL) ; isctCount = gpi->ctx->IsctEvalCount ; bindingCount = gpi->BindingCount ;
	       } else
	       { if ((time(NULL) - lastTime) >= gpi->maxIdle)
		  { v_Msg(NULL,msgBuf,"WDIdleExit",(double)(gpi->maxIdle / 60.0)) ; break ; } ;
	       } ;
	    } ;
	   if (gpi->maxCPU > 0)
	    { if (v_CPUTime() >= gpi->maxCPU)
	       { v_Msg(NULL,msgBuf,"WDMaxCPU",v_CPUTime(),gpi->maxCPU) ; break ; } ;
	    } ;
	   if (gpi->maxKIscts > 0)
	    { if ((gpi->ctx->IsctEvalCount / 1000) >= gpi->maxKIscts)
	       { v_Msg(NULL,msgBuf,"WDMaxIsct",gpi->maxKIscts) ; break ; } ;
	    } ;
	 } ;
/*	If we get out of loop then want to terminate */
	vout_UCText(VOUT_Status,0,msgBuf) ;
	v4_ExitStats(gpi->ctx,gpi->MainTcb) ; v4mm_FreeResources(gpi) ; v4mm_MemoryExit() ;
//	if (gpi->doSummaryAtExit) v4im_DoSummaryOutput(gpi->ctx,NULL,FALSE,NULL) ;
#ifdef WINNT
	TerminateProcess((HANDLE)-1,EXITABORT) ;	/* Terminate current process */
#else
	exit(EXITABORT) ;
#endif
}

#ifdef CACHE_NO_LONGER_USED
#define CACHEX_MAX 1001
#define CACHE_MAX 50

struct lcl__Cache {
  int CacheXNum[CACHEX_MAX] ;
  int CacheDirX[CACHEX_MAX] ;
  int Count ;
  struct {
    int Calls,Hits ;
    P *isct ;		/* Pointer to intersection of interest */
    int CtxDimX ;	/* Index into DimHash[] for dependent dimension (UNUSED if none) */
    int LastDimUpd ;	/* Last update so we can determine if value is dirty */
    struct V4DPI__LittlePoint Val ;
    P *ValPtr ;		/* If value > little point then use this pointer */
  } Entry[CACHE_MAX] ;
 } ;

P *v4im_Cache(ctx,respnt,isct,num,trace)
  struct V4C__Context *ctx ;
  P *respnt,*isct ;
  int num ;
{ static struct lcl__Cache *lc = NULL ;
  P tpt,*ipt,*tisct = NULL ;
  int i,hx,dx,ex ;

	if (lc == NULL) lc = (struct lcl__Cache *)v4mm_AllocChunk(sizeof *lc,TRUE) ;

	for(hx = num % CACHEX_MAX;;)
	 { if (lc->CacheXNum[hx] == num) break ;
	   if (lc->CacheXNum[hx] != 0) { hx = (hx+1) % CACHEX_MAX ; } ;
	   if (lc->Count >= CACHE_MAX) goto nogo ;
	   ex = (lc->Count++) ; tisct = (P *)v4mm_AllocChunk(sizeof(P),FALSE) ; memcpy(tisct,isct,isct->Bytes) ;
	   for(ipt=(P *)&isct->Value,i=0,dx=UNUSED;i<isct->Grouping;i++,ipt=(P *)((char *)ipt + ipt->Bytes))
	    { if (ipt->PntType == V4DPI_PntType_Special && ipt->Grouping == V4DPI_Grouping_Current)
	       { if (dx != UNUSED) goto nogo ;
	         for(dx=0;dx<V4C_CtxDimHash_Max;dx++) { if (ctx->DimHash[dx].Dim == ipt->Dim) break ; } ;
	         if (dx >= V4C_CtxDimHash_Max) goto nogo ;
	       } ;
	    } ;
	   lc->CacheXNum[hx] = num ; lc->CacheDirX[hx] = ex ;
	   lc->Entry[ex].isct = tisct ; lc->Entry[ex].CtxDimX = dx ; lc->Entry[ex].LastDimUpd = UNUSED ;
	   break ;
	 } ;
	ex = lc->CacheDirX[hx] ;
lc->Entry[ex].Calls ++ ;
	if (lc->Entry[ex].LastDimUpd == ctx->DimHash[lc->Entry[ex].CtxDimX].LastDimUpd)
	 { 
lc->Entry[ex].Hits ++ ;
	   if (lc->Entry[ex].ValPtr == NULL) return((P *)&lc->Entry[ex].Val) ;
	   return(lc->Entry[ex].ValPtr) ;
	 } ;
	ipt = v4dpi_IsctEval(&tpt,lc->Entry[ex].isct,ctx,V4DPI_EM_EvalQuote,NULL,NULL) ;
	if (ipt == NULL) return(NULL) ;
	lc->Entry[ex].LastDimUpd = ctx->DimHash[lc->Entry[ex].CtxDimX].LastDimUpd ;
	if (lc->Entry[ex].ValPtr != NULL) { memcpy(lc->Entry[ex].ValPtr,ipt,ipt->Bytes) ; }
	 else { if (ipt->Bytes <= sizeof (struct V4DPI__LittlePoint))
		 { memcpy(&lc->Entry[ex].Val,ipt,ipt->Bytes) ; return((P *)&lc->Entry[ex].Val) ; }
		 else { lc->Entry[ex].ValPtr = (P *)v4mm_AllocChunk(sizeof(P),FALSE) ;
			memcpy(lc->Entry[ex].ValPtr,ipt,ipt->Bytes) ;
			return(lc->Entry[ex].ValPtr) ;
		      } ;
	      } ;
nogo:
	if (tisct != NULL) v4mm_FreeChunk(tisct) ;
	return((P *)v4dpi_IsctEval(respnt,isct,ctx,V4DPI_EM_EvalQuote,NULL,NULL)) ;
}
#endif		//CACHE_NO_LONGER_USED

/*	R P T   R O U T I N E S			*/


LOGICAL v4rpt_ParseURLSpec(ctx,vus,upt,intmodx)
  struct V4C__Context *ctx ;
  struct V4RPT__URLSpec *vus ;
  struct V4DPI__Point *upt ;
  INTMODX intmodx ;
{ struct V4L__ListPoint *lp ;
  P *cpt,lbuf,abuf ;
  LOGICAL ok ; INDEX lx ;

	memset(vus,0,sizeof *vus) ;
	if (upt->PntType != V4DPI_PntType_List)
	 { v4im_GetPointUC(&ok,vus->urlText,UCsizeof(vus->urlText),upt,ctx) ; if (!ok) return(FALSE) ;
	   return(TRUE) ;
	 } ;
	lp = VERIFYLIST(NULL,ctx,upt,0) ;
	for(lx=1;;lx++)
	 { if (v4l_ListPoint_Value(ctx,lp,lx,&lbuf) <= 0) break ;
	   if (lx == 1)				/* First element is always the URL */
	    { v4im_GetPointUC(&ok,vus->urlText,UCsizeof(vus->urlText),&lbuf,ctx) ; if (!ok) return(FALSE) ;
	      continue ;
	    } ;
	   switch (v4im_CheckPtArgNew(ctx,&lbuf,&cpt,&abuf))
	    { default:				v_Msg(ctx,ctx->ErrorMsgAux,"TagBadUse",intmodx) ; return(FALSE) ;
	      case V4IM_Tag_Unk:		v_Msg(ctx,ctx->ErrorMsgAux,"TagUnknown",intmodx) ; return(FALSE) ;
	      case V4IM_Tag_Target:		v4im_GetPointUC(&ok,vus->target,UCsizeof(vus->target),cpt,ctx) ; if (!ok) return(FALSE) ; break ;
	    } ;
	 } ;
	return(TRUE) ;
}

/*	v4rpt_AllocChunk - Allocates chunk of len bytes within current rri buffers */

void *v4rpt_AllocChunk(rri,len)
  struct V4RPT__RptInfo *rri ;
  LENMAX len ;
{ void *ptr ;

//VEH110201 - This routine causes (I think) strange problems every now & then
//It not all that necessary so I am replacing with the standard memory allocation
	return(v4mm_AllocChunk(len,FALSE)) ;
	
	if (rri->rriMC == NULL ? TRUE : rri->rriMC->bytesUsed + len >= V4RPT_RptMemChunkSize)
	 { struct V4RPT__RptMemChunk *tmc ;
	   tmc = (struct V4RPT__RptMemChunk *)v4mm_AllocChunk(sizeof *tmc,FALSE) ; tmc->bytesUsed = 0 ;
	   tmc->priorMC = rri->rriMC ; rri->rriMC = tmc ;
	 } ;
	ptr = (void *)&rri->rriMC->mcBuf[rri->rriMC->bytesUsed] ;
	rri->rriMC->bytesUsed += ALIGN(len) ;
	return(ptr) ;
}

/*	v4rpt_AllocUC - Allocated UC string within current rri buffers	*/

UCCHAR *v4rpt_AllocUC(rri,len,whereCode)
  struct V4RPT__RptInfo *rri ;
  LENMAX len ;
  int whereCode ;
{ UCCHAR *ucptr ;

if (len < 1 || len > 1000000)
 { UCCHAR ebuf[128] ; v_Msg(NULL,ebuf,"@* v4rpt_AllocUC(%1d) from %2d\n",len,whereCode) ; vout_UCText(VOUT_Warn,0,ebuf) ; len = 127 ;} ;
//VEH110412 - the above check may have found problem - try the original code again
////VEH110201 - This routine causes (I think) strange problems every now & then
////It's not all that necessary so I am replacing with the standard memory allocation
//	return(v4mm_AllocUC(len)) ;

	if (rri->rriMC == NULL ? TRUE : rri->rriMC->bytesUsed + (len + 1)*sizeof(UCCHAR) >= V4RPT_RptMemChunkSize)
	 { struct V4RPT__RptMemChunk *tmc ;
	   tmc = (struct V4RPT__RptMemChunk *)v4mm_AllocChunk(sizeof *tmc,FALSE) ; tmc->bytesUsed = 0 ;
	   tmc->priorMC = rri->rriMC ; rri->rriMC = tmc ;
	 } ;
	ucptr = (UCCHAR *)&rri->rriMC->mcBuf[rri->rriMC->bytesUsed] ;
	rri->rriMC->bytesUsed += ALIGN((len + 1)*sizeof(UCCHAR)) ;
	return(ucptr) ;
}

/*	v4im_RptUpdVFS - Updates vfs structure for with contents of fpnt (if list then recurses)	*/
/*	Call ok = v4im_RptUpdVFS(ctx,vfs,fpnt)
	  where ok is TRUE if OK, FALSE if error (ctx->ErrorMsgAux),
		ctx is context,
		vfs is V4SS__FormatSpec structure to be updated,
		fpnt is point or list of points (ex: TextColor::Red)					*/

LOGICAL v4im_RptUpdVFS(ctx,vfs,fpnt)
  struct V4C__Context *ctx ;
  struct V4SS__FormatSpec *vfs ;
  struct V4DPI__Point *fpnt ;
{ struct V4DPI__Point *cpt,isctbuf ;
  struct V4DPI__TagVal *tv ;
  struct V4L__ListPoint *lp ;
  int lx ; LOGICAL ok ; UCCHAR tb[512] ; double dnum ;
  
	ok = TRUE ;			/* Assume everything is going to be OK */
	switch (fpnt->PntType)
	 { default:
	   case V4DPI_PntType_Dict:
	     if (memcmp(fpnt,&protoNone,V4PS_Int) == 0) break ;		/* Ignore UV4:none point */
	   case V4DPI_PntType_List:	/* Just iterate through each point in list */
	     lp = VERIFYLIST(NULL,ctx,fpnt,0) ;
	     for(lx=1;;lx++)
	      { if (v4l_ListPoint_Value(ctx,lp,lx,&isctbuf) <= 0) break ;
	        if (!v4im_RptUpdVFS(ctx,vfs,&isctbuf)) return(FALSE) ;
	      } ;
	     return(TRUE) ;
	   case V4DPI_PntType_TagVal:
	     tv = (struct V4DPI__TagVal *)&fpnt->Value ; TAGVALUE(ctx,fpnt,&cpt,&isctbuf) ;
	     switch (tv->TagVal & V4DPI_TagFlag_MaskOut)
	      {	 default:		break ;
		 case V4IM_Tag_Font:	
		   v4im_GetPointUC(&ok,tb,UCsizeof(tb),cpt,ctx) ; if (!ok) break ;
		   ok = v_ParseFormatSpecs(ctx,vfs,V4SS_FormatType_Font,tb) ; break ;
		 case V4IM_Tag_StyleName:
		 case V4IM_Tag_Style:
		   v4im_GetPointUC(&ok,tb,UCsizeof(tb),cpt,ctx) ; if (!ok) break ;
		   ok = v_ParseFormatSpecs(ctx,vfs,V4SS_FormatType_Style,tb) ; break ;
		 case V4IM_Tag_Format:
		   v4im_GetPointUC(&ok,tb,UCsizeof(tb),cpt,ctx) ; if (!ok) break ;
		   ok = v_ParseFormatSpecs(ctx,vfs,V4SS_FormatType_Mask,tb) ; break ;
		 case V4IM_Tag_FontSize:
		   v4im_GetPointUC(&ok,tb,UCsizeof(tb),cpt,ctx) ; if (!ok) break ;
		   ok = v_ParseFormatSpecs(ctx,vfs,V4SS_FormatType_Size,tb) ; break ;
		 case V4IM_Tag_CellColor:
		   v4im_GetPointUC(&ok,tb,UCsizeof(tb),cpt,ctx) ; if (!ok) break ;
		   ok = v_ParseFormatSpecs(ctx,vfs,V4SS_FormatType_CellColor,tb) ; break ;
		 case V4IM_Tag_TextColor:
		   v4im_GetPointUC(&ok,tb,UCsizeof(tb),cpt,ctx) ; if (!ok) break ;
		   ok = v_ParseFormatSpecs(ctx,vfs,V4SS_FormatType_TextColor,tb) ; break ;
		 case V4IM_Tag_PageBreak:
		   break ;
		 case V4IM_Tag_URL:
		   v4im_GetPointUC(&ok,tb,UCsizeof(tb),cpt,ctx) ; if (!ok) break ;
		   ok = v_ParseFormatSpecs(ctx,vfs,V4SS_FormatType_URLLink,tb) ; break ;
		 case V4IM_Tag_Width:
		   dnum = v4im_GetPointDbl(&ok,cpt,ctx) ;
		   if (dnum < 0 || dnum > 150.0) return(FALSE) ;
		   vfs->Width = (int)(dnum < 1.0 ? dnum * 100 : dnum + 100) ;
		   break ;
		 case V4IM_Tag_CSS:
		   v4im_GetPointUC(&ok,tb,UCsizeof(tb),cpt,ctx) ; if (!ok) break ;
		   ok = v_ParseFormatSpecs(ctx,vfs,V4SS_FormatType_CSSStyle,tb) ; break ;
		 case V4IM_Tag_Id:
		   v4im_GetPointUC(&ok,tb,UCsizeof(tb),cpt,ctx) ; if (!ok) break ;
		   ok = v_ParseFormatSpecs(ctx,vfs,V4SS_FormatType_CSSId,tb) ; break ;
		 case V4IM_Tag_Class:
		   v4im_GetPointUC(&ok,tb,UCsizeof(tb),cpt,ctx) ; if (!ok) break ;
		   ok = v_ParseFormatSpecs(ctx,vfs,V4SS_FormatType_CSSClass,tb) ; break ;
	      } ;
	 } ;
	return(ok) ;
}

/*	v4im_RptContext - Updates rri cell with contextual format info		*/
/*	Call ok = v4im_RptContext(ctx,rri,colX,colLX,colPnt,baf)
	  where ok is TRUE if OK, FALSE if not (ctx->ErrorMsgAux),
		ctx is context,
		rri is current Rpt(),
		colX is column index (rri->col[]),
		colLX is sub-column (0 is first within list) (if single column specification references multiple real columns) or UNUSED,
		colPnt is current cell value,
		baf, if not NULL, is recapping info				*/

LOGICAL v4im_RptContext(ctx,rri,colX,colLX,colPnt,baf)
  struct V4C__Context *ctx ;
  struct V4RPT__RptInfo *rri ;
  INDEX colX,colLX ;
  struct V4DPI__Point *colPnt ;
  struct V4IM__BaA *baf ;
{ struct V4DPI__Point *ipnt,dpnt,isct ;
  struct V4DPI__DimInfo *di ;
  struct V4SS__FormatSpec vfs ;
  static DIMID Dim_URptL=0, Dim_URptT=0, Dim_URptS, Dim_URptR, Dim_URptV, Dim_URptSG ; static LOGICAL didSetup=FALSE ;
  enum DictionaryEntries deval ; LOGICAL gotVFS,ok,coldef ; int vx ;

	if (!didSetup)
	 { Dim_URptL = v4dpi_DimGet(ctx,UClit("URptL"),DIMREF_IRT) ; Dim_URptR = v4dpi_DimGet(ctx,UClit("URptR"),DIMREF_IRT) ; Dim_URptT = v4dpi_DimGet(ctx,UClit("URptT"),DIMREF_IRT) ;
	   Dim_URptS = v4dpi_DimGet(ctx,UClit("URptS"),DIMREF_IRT) ; Dim_URptV = v4dpi_DimGet(ctx,UClit("URptV"),DIMREF_IRT) ; Dim_URptSG = v4dpi_DimGet(ctx,UClit("URptSG"),DIMREF_IRT) ;
	   didSetup = TRUE ;
	 } ;
	coldef = (colPnt == NULL ? FALSE : (colPnt->Dim != 0)) ;	/* coldef TRUE if column defined */
/*	Add stuff to context, if dimension has been defined */
	if (Dim_URptR != 0)			/* Current report line type */
	 { switch (rri->rptType)
	    { default:
	      case V4RPT_Type_V4R:	deval=_V4R ; break ;
	      case V4RPT_Type_Tab:	deval=_Tab ; break ;
	      case V4RPT_Type_CSV:	deval=_CSV ; break ;
	      case V4RPT_Type_HTML:	deval=_HTML ; break ;
	      case V4RPT_Type_XML:	deval=_XML ; break ;
	    } ;
	   dictPNTv(&dpnt,Dim_URptR,v4im_GetEnumToDictVal(ctx,deval,UNUSED)) ; if (!v4ctx_FrameAddDim(ctx,0,&dpnt,0,0)) return(FALSE) ;
	 } ;
	if (Dim_URptT != 0)			/* Current report line type */
	 { switch (rri->lineType)
	    { case V4RPT_LineType_Default:	deval = _Default ; break ;
	      case V4RPT_LineType_Heading:	deval = _Heading ; break ;
	      case V4RPT_LineType_Detail:	deval = _Detail ; break ;
	      case V4RPT_LineType_Recap:	deval = _Recap ; break ;
	      case V4RPT_LineType_Footer:	deval = _Footer ; break ;
	    } ;
	   dictPNTv(&dpnt,Dim_URptT,v4im_GetEnumToDictVal(ctx,deval,UNUSED)) ; if (!v4ctx_FrameAddDim(ctx,0,&dpnt,0,0)) return(FALSE) ;
	 } ;
	if (Dim_URptL != 0 && rri->lineType == V4RPT_LineType_Detail)			/* Current report line */
	 { intPNTv(&dpnt,rri->dtlLines+1) ; dpnt.Dim = Dim_URptL ; if (!v4ctx_FrameAddDim(ctx,0,&dpnt,0,0)) return(FALSE) ; } ;
	if (Dim_URptS != 0 && UCstrlen(rri->sheetName) > 0)			/* Current sheet */
	 { DIMINFO(di,ctx,Dim_URptS) ; dictPNTv(&dpnt,Dim_URptS,v4dpi_DictEntryGet(ctx,0,rri->sheetName,di,NULL)) ; if (!v4ctx_FrameAddDim(ctx,0,&dpnt,0,0)) return(FALSE) ; } ;
	if (Dim_URptSG != 0 && colLX != UNUSED)			/* Current column sub-group index (add 1 so V4 sees index starting with 1, not zero) */
	 { intPNTv(&dpnt,colLX+1) ; dpnt.Dim = Dim_URptSG ; if (!v4ctx_FrameAddDim(ctx,0,&dpnt,0,0)) return(FALSE) ; } ;
	if (Dim_URptV && coldef)
	 { ZPH(&dpnt) ; dpnt.PntType = V4DPI_PntType_Shell ; dpnt.Dim = Dim_URptV ; dpnt.Bytes = V4DPI_PointHdr_Bytes + colPnt->Bytes ;
	   memcpy(&dpnt.Value,colPnt,colPnt->Bytes) ; if (!v4ctx_FrameAddDim(ctx,0,&dpnt,0,0)) return(FALSE) ;
	 } ;
	if (colX != UNUSED)
	 { if (rri->col[colX].idCol.Bytes != 0)
	    { if (!v4ctx_FrameAddDim(ctx,0,(P *)&rri->col[colX].idCol,0,0)) return(FALSE) ; } ;
	   rri->col[colX].valDim = (coldef ? colPnt->Dim : UNUSED) ;
	   if (baf != NULL && coldef)
	    { v4im_BaAIncrement(ctx,baf,colPnt,colX+1,UNUSED) ; } ;
	 } ;
/*	Now that context is set up, try to evaluate various formatting iscts */
//	[UV4:ColFormat] [UV4:RowFormat] [UV4:CellFormat] [UV4:Link]
/*	Initialize formatting, if we have default for column then take it otherwise zero out */

	vx = UNUSED ;
	if (vdfm != NULL && colX != UNUSED && coldef)	/* First see if value point's dimension in SSDim() list */
	 { for(vx=vdfm->Count-1;vx>=0;vx--) { if (vdfm->dimIdList[vx] == colPnt->Dim) break ; } ;
	 } ;

/* VM copies non-blank field from svfs -> vfs, VMM does same thing for text values */
#define VM(FLD) if (svfs->FLD != 0) vfs.FLD = svfs->FLD ;
#define VMM(FLD) \
  if (svfs->FLD != 0) \
   { int _i = vfs.Length - (vfs.VarString - (char *)&vfs) ; \
     char *_spec = &svfs->VarString[svfs->FLD - 1] ; int _len = strlen(_spec) ; \
     if (_i + _len + 1 < sizeof vfs.VarString) { strcpy(&vfs.VarString[_i],_spec) ; vfs.Length += (1+_len) ; vfs.FLD = _i+1 ; } ; \
   } ;

	if (colX != UNUSED ? rri->col[colX].vfsDflt != NULL : FALSE)
	 { vfs = *rri->col[colX].vfsDflt ;
	   if (vx != UNUSED)	/* This gets complicated - have SSDim() default & Rpt() default - merge them together giving SSDim() priority */
	    { struct V4SS__FormatSpec *svfs = vdfm->vfs[vx] ;
	      VM(FontAttr) VM(FontSize) VM(FgColor) VM(BgColor) VM(LBorderColor) VM(RBorderColor) VM(TBorderColor) VM(BBorderColor) VM(FontULStyle)
	      VM(FontColor) VM(FontBold) VM(FontFamily) VM(VAlign) VM(HAlign) VM(Orientation) VM(FillPattern) VM(Width) VM(PredefineFormat)
	      VMM(CSSStyle) VMM(CSSId) VMM(CSSClass) VMM(URLLink) VMM(FontNameX) VMM(MaskX)
	    } ;
	 } else			/* No default spec, then take SSDim() spec if we have it otherwise clear out vfs */
	 { if (vx != UNUSED ) { vfs = *vdfm->vfs[vx] ; } else { memset(&vfs,0,sizeof vfs) ; } ;
	 } ;
	gotVFS = FALSE ; ok = TRUE ;
#define EVALFORMATISCT(FORNAME) \
  if (ok) \
   { INITISCT(&isct) ; NOISCTVCD(&isct) ; isct.Grouping = 1 ; \
     ipnt = ISCT1STPNT(&isct) ; dictPNTv(ipnt,Dim_UV4,v4im_GetEnumToDictVal(ctx,deval=_##FORNAME,UNUSED)) ; \
     if (ipnt->Value.IntVal != 0) \
      { ADVPNT(ipnt) ; ISCTLEN(&isct,ipnt) ; ipnt = v4dpi_IsctEval(&dpnt,&isct,ctx,V4DPI_EM_NoIsctFail,NULL,NULL) ; \
	if (ipnt != NULL) { ok = v4im_RptUpdVFS(ctx,&vfs,ipnt) ; if (ok) gotVFS = TRUE ; } ; \
      } ; \
   } ;
	EVALFORMATISCT(ColFormat) EVALFORMATISCT(RowFormat) EVALFORMATISCT(CellFormat)
	 { if (rri->col[colX].vfs == NULL) rri->col[colX].vfs = (struct V4SS__FormatSpec *)v4rpt_AllocChunk(rri,sizeof vfs) ;
	   *rri->col[colX].vfs = vfs ;
	   if (rri->lineType == V4RPT_LineType_Default && gotVFS)	/* If setting up default then copy this into default specs */
	    { if (rri->col[colX].vfsDflt == NULL) rri->col[colX].vfsDflt = (struct V4SS__FormatSpec *)v4rpt_AllocChunk(rri,sizeof vfs) ;
	      *rri->col[colX].vfsDflt = *rri->col[colX].vfs ;
	    } ;
	 } ;
/*	Do we have a URL to link to ? (via [UV4:URL]) */
	if (colX != UNUSED)
	 { if (rri->col[colX].valURL != NULL) ZUS(rri->col[colX].valURL) ;
	   INITISCT(&isct) ; NOISCTVCD(&isct) ; isct.Grouping = 1 ;
	   ipnt = ISCT1STPNT(&isct) ; dictPNTv(ipnt,Dim_UV4,v4im_GetEnumToDictVal(ctx,deval=_URL,UNUSED)) ;
	   if (ipnt->Value.IntVal != 0)
	    { ADVPNT(ipnt) ; ISCTLEN(&isct,ipnt) ; ipnt = v4dpi_IsctEval(&dpnt,&isct,ctx,V4DPI_EM_NoIsctFail,NULL,NULL) ;
	      if (ipnt != NULL ? memcmp(ipnt,&protoNone,protoNone.Bytes) != 0 : FALSE)
	       { int len ; 
	         v4im_GetPointUC(&ok,UCTBUF1,V4TMBufMax,ipnt,ctx) ; len = UCstrlen(UCTBUF1) ; if (len < 255) len = 255 ;
	         if (len > rri->col[colX].maxURL) { rri->col[colX].valURL = v4rpt_AllocUC(rri,len,1) ; rri->col[colX].maxURL = len ; } ;
	         UCstrcpy(rri->col[colX].valURL,UCTBUF1) ;
	       } ;
	    } ;
	 } ;
	return(TRUE) ;	
}

/*	v4im_RptColList - Updates rri->col[] structure based on a list of lists describing the columns	*/
/*	Call: ok = v4im_RptColList(ctx,lp,rri,baf,intmodx,inHdr,updColX)
	  where ok is TRUE if ok, FALSE if not (ctx->ErrorMsgAux),
		lp is list with column info,
		rri is current Rpt(),
		baf, if not NULL, is recapping,
		intmodx is calling module index,
		inHdr is TRUE if called from Header:: tag,
		updColX is non-NULL if column list (lp) is going to be single argument (from tagged argument) or NULL if there may be several args (several calls to this routine) */
		
LOGICAL v4im_RptColList(ctx,lp,rri,baf,intmodx,inHdr,updColX)
  struct V4C__Context *ctx ;
  struct V4L__ListPoint *lp ;
  struct V4RPT__RptInfo *rri ;
  struct V4IM__BaA *baf ;
  INTMODX intmodx ;
  LOGICAL inHdr ;
  INDEX *updColX ;
{ P colpt,listbuf,valpt ;
  struct V4L__ListPoint *lp1 ;
  INDEX lx,curcol,scol ; LOGICAL ok,autoDef ; FRAMEID frameid ;

#define RPTCOLVAL(CVPT,COLX,COLLX) \
 { LENMAX bytes ; P evalpnt,*_ipt ; \
   ok = TRUE ; _ipt = v4dpi_IsctEval(&evalpnt,(CVPT),ctx,(V4DPI_EM_NoIsctFail|V4DPI_EM_EvalQuote),NULL,NULL) ; \
   if (_ipt == NULL) { ok = FALSE ; v_Msg(ctx,ctx->ErrorMsgAux,"RptValFail",COLX,(COLX == UNUSED ? NULL : &rri->col[COLX].idCol),(CVPT)) ; } \
    else { v4im_RptContext(ctx,rri,COLX,COLLX,_ipt,baf) ; \
	   if (rri->col[COLX].ptCol == NULL) rri->col[COLX].ptCol = v4rpt_AllocChunk(rri,sizeof (struct V4DPI__Point)) ; \
	   memcpy(rri->col[COLX].ptCol,_ipt,_ipt->Bytes) ; \
	   if (rri->nextURL != NULL ? UCnotempty(rri->nextURL) : FALSE) \
	    { bytes = UCstrlen(rri->nextURL) ; if (bytes < 255) bytes = 255 ; \
	      if (bytes >= rri->col[COLX].maxURL) { rri->col[COLX].valURL = v4rpt_AllocUC(rri,bytes,2) ; rri->col[COLX].maxURL = bytes ; } ; \
	      UCstrcpy(rri->col[COLX].valURL,rri->nextURL) ; ZUS(rri->nextURL) ; \
	    } ; \
	   if (rri->nextImage != NULL ? UCnotempty(rri->nextImage) : FALSE) \
	    { if (rri->col[COLX].valImage == NULL) rri->col[COLX].valImage = v4rpt_AllocUC(rri,V_FileName_Max,3) ; \
	      UCstrcpy(rri->col[COLX].valImage,rri->nextImage) ; ZUS(rri->nextImage) ; \
	    } ; \
	   if (rri->nextTarget != NULL ? UCnotempty(rri->nextTarget) : FALSE) \
	    { if (rri->col[COLX].valTarget == NULL) { rri->col[COLX].valTarget = v4rpt_AllocUC(rri,V4RPT_TargetMax,4) ; } ; \
	      UCstrcpy(rri->col[COLX].valTarget,rri->nextTarget) ; ZUS(rri->nextTarget) ; \
	    } ; \
	   if (rri->nextNote != NULL ? UCnotempty(rri->nextNote) : FALSE) \
	    { bytes = UCstrlen(rri->nextNote) ; if (bytes < 255) bytes = 255 ; \
	      if (bytes >= rri->col[COLX].maxNote) { rri->col[COLX].valNote = v4rpt_AllocUC(rri,bytes,5) ; rri->col[COLX].maxNote = bytes ; } ; \
	      UCstrcpy(rri->col[COLX].valNote,rri->nextNote) ; ZUS(rri->nextNote) ; \
	    } ; \
	 } ; \
 }

	frameid = v4ctx_FramePush(ctx,NULL) ;
	curcol = 0 ;					/* Current column */
	autoDef = inHdr && (rri->numCols == 0) ;	/* If TRUE then auto-define columns as we come across them */
/*	      Try to determine if we have list-of-lists or just 2-3 tuple of single entry */
/*	      (i.e. RPT( ((c1 a) (c2 b) ...) ) or RPT( (c1 a) (c2 b) ... ) */
	      
	for(lx=1;curcol < V4RPT_ColMax;lx++,curcol++)
	 { if (v4l_ListPoint_Value(ctx,lp,lx,&colpt) <= 0) break ;
	   if (updColX != NULL && lx == 1 && colpt.PntType != V4DPI_PntType_List)
	    { lp1 = lp ; lx = 999999 ;
	    } else
	    { if (colpt.PntType != V4DPI_PntType_List)
	       { curcol = rri->numCols ; RPTCOLVAL(&colpt,curcol,UNUSED) ; v4NutCracker = 99 ; rri->numCols++ ; continue ; } ;
	      lp1 = VERIFYLIST(&listbuf,ctx,&colpt,intmodx) ;
	    } ;
/*	   Column specification is list: (col value) or (firstcol secondcol value) */
	   v4l_ListPoint_Value(ctx,lp1,1,&valpt) ;	/* valpt = first element of list */
	   if (!autoDef)					/* If not auto-defining columns then look for it */
	    { COUNTER nthGrp, totalGrp ;
	      for (curcol=0;curcol<rri->numCols;curcol++) { if (memcmp(&valpt,&rri->col[curcol].idCol,rri->col[curcol].idCol.Bytes) == 0) break ; } ;
	      if (curcol >= rri->numCols) { v_Msg(ctx,ctx->ErrorMsgAux,"RptColNotFnd",&valpt,rri->numCols) ; goto fail ; } ;
/*	      If this is a 'redefinition' column then reset curcol to that column */
	      if (rri->col[curcol].colRedef == UNUSED)
	       { nthGrp = rri->col[curcol].nthGrp ; totalGrp = rri->col[curcol].totalGrp ;
	       } else 
	       { nthGrp = 1 ; totalGrp = rri->col[curcol].totalGrp ;
	         curcol = rri->col[curcol].colRedef ;
	       } ;
	      if (baf != NULL) baf->CurCol = curcol ;		/* Set this for RCV() */
	      if (nthGrp == 1)					/* Got a column group, rest of this list better fill it */
	       { INDEX cg,csg,colxo,llx ;
	         rri->col[curcol].spanCol = 0 ;			/* Assume no spanning (until we run out of values before columns, then set it below) */
	         for(cg=0,colxo=0;cg<totalGrp;cg++,colxo++)
	          { if (v4l_ListPoint_Value(ctx,lp1,2+cg,&valpt) <= 0) break ;
/*		    This is getting messy, but if &valpt is a list then try to expand it to fill the group */
		    if (valpt.PntType == V4DPI_PntType_List || valpt.PntType == V4DPI_PntType_Isct || valpt.PntType == V4DPI_PntType_Special || valpt.PntType == V4DPI_PntType_SymDef)
		     { P mpnt,mipnt,*tpt ; struct V4L__ListPoint *lp2 ;
		       if (valpt.PntType == V4DPI_PntType_List) { tpt = &valpt ; }
		        else { tpt = v4dpi_IsctEval(&mipnt,&valpt,ctx,(V4DPI_EM_NoIsctFail|V4DPI_EM_EvalQuote),NULL,NULL) ;
			       if (tpt == NULL) { v_Msg(ctx,NULL,"RptEvalFail",&valpt) ; goto fail ; } ;
			       if (tpt->PntType != V4DPI_PntType_List) { RPTCOLVAL(tpt,curcol+cg,UNUSED) ; continue ; } ;
			     } ;
		       lp2 = VERIFYLIST(NULL,ctx,tpt,intmodx) ;
		       for(csg=0,llx=cg+1;cg<totalGrp;cg++,csg++,colxo++,llx++)
		        { if (v4l_ListPoint_Value(ctx,lp2,llx,&mpnt) <= 0) break ;
		          if (mpnt.PntType == V4DPI_PntType_TagVal)	/* Got a tag ? then better be URL:: */
		           { P *cpt,ptbuf ;
		             switch (v4im_CheckPtArgNew(ctx,&mpnt,&cpt,&ptbuf))
			      { default:		v_Msg(ctx,NULL,"TagBadUse",intmodx) ; goto fail ;
				case V4IM_Tag_Unk:	v_Msg(ctx,NULL,"TagUnknown",intmodx) ; goto fail ;
				case V4IM_Tag_Image:	if (rri->nextImage == NULL) rri->nextImage = v4rpt_AllocUC(rri,V_FileName_Max,6) ;
							v4im_GetPointUC(&ok,rri->nextImage,V_FileName_Max,cpt,ctx) ;
							colxo-- ; cg-- ; continue ;
				case V4IM_Tag_URL:	{ struct V4RPT__URLSpec vus ;
							  if (!v4rpt_ParseURLSpec(ctx,&vus,cpt,intmodx)) goto fail ;
							  if (rri->nextURL == NULL) rri->nextURL = v4rpt_AllocUC(rri,V4RPT_URLSizeMax,7) ;
							  if (UCnotempty(vus.target))
							   { if (rri->nextTarget == NULL) rri->nextTarget = v4rpt_AllocUC(rri,V4RPT_TargetMax,8) ;
							     UCstrcpy(rri->nextTarget,vus.target) ;
							   } else { if (rri->nextTarget != NULL) { ZUS(rri->nextTarget) ; } ; } ;
							  UCstrcpy(rri->nextURL,vus.urlText) ;
							  colxo-- ; cg-- ; continue ;
							} ;
			      } ;
		           } ;
		          RPTCOLVAL(&mpnt,curcol+colxo,csg) ;
		          v4im_GetPointUC(&ok,UCTBUF1,V4TMBufMax,&mpnt,ctx) ;
		          if (UCTBUF1[0] == UClit('{') && (UCTBUF1[2] == UClit('}') || UCTBUF1[3] == UClit('}')))
		           { UCCHAR *bp ; COUNTER span ; span = UCstrtol(&UCTBUF1[1],&bp,10) ; if (*bp != UClit('}')) span = 1 ;
			     if (span > 1)
			      { rri->col[curcol+colxo].spanCol = span ;  colxo += (span-1) ; } ;
		           } ;
		        } ; continue ;
		     } ;
		    RPTCOLVAL(&valpt,curcol+cg,UNUSED) ; if (!ok) goto fail ;
		    v4im_GetPointUC(&ok,UCTBUF1,V4TMBufMax,&valpt,ctx) ;
		    if (UCTBUF1[0] == UClit('{') && (UCTBUF1[2] == UClit('}') || UCTBUF1[3] == UClit('}')))
		     { UCCHAR *bp ; COUNTER span ; span = UCstrtol(&UCTBUF1[1],&bp,10) ; if (*bp != UClit('}')) span = 1 ;
		       if (span > 1)
		        { rri->col[curcol+colxo].spanCol = span ;  colxo += (span-1) ; } ;
		     } ;
	          } ;
/*		 If we did not get number equal to number in group, then make last column span to the end of the group */
		 if (colxo < totalGrp) 
		  { rri->col[curcol+cg-1].spanCol = (totalGrp - rri->col[curcol+cg-1].nthGrp) + 1 ; } ;
	         continue ;
	       } ;
	    } ;
	   switch (SIZEofLIST(lp1))
	    { default:
		v_Msg(ctx,ctx->ErrorMsgAux,"RptInvColList",&colpt) ; goto fail ;
	      case 2:
		if (autoDef)
		 { curcol = rri->numCols ;
		   if (valpt.Bytes != V4PS_Int) { v_Msg(ctx,NULL,"ModArgPntType3",curcol+1,&valpt,valpt.PntType,V4DPI_PntType_Int,V4DPI_PntType_Dict) ; goto fail ; } ;
		   rri->col[rri->numCols].colRedef = UNUSED ;
		   memcpy(&rri->col[rri->numCols++].idCol,&valpt,valpt.Bytes) ;
		   if (baf != NULL) baf->CurCol = curcol-1 ;		/* Set this for RCV() */
		 } ;
		v4l_ListPoint_Value(ctx,lp1,2,&valpt) ;
		RPTCOLVAL(&valpt,curcol,UNUSED) ; if (!ok) goto fail ;
		rri->col[curcol].spanCol = 0 ; if (updColX != NULL) *updColX = curcol ;
		break ;
	      case 3:
		if (autoDef) { v_Msg(ctx,ctx->ErrorMsgAux,"RptSpanAuto",&colpt) ; goto fail ; } ;
		v4l_ListPoint_Value(ctx,lp1,3,&valpt) ;
		RPTCOLVAL(&valpt,curcol,UNUSED) ; if (!ok) goto fail ;
		v4l_ListPoint_Value(ctx,lp1,2,&valpt) ;
		for (scol=0;scol<rri->numCols;scol++) { if (memcmp(&valpt,&rri->col[scol].idCol,rri->col[scol].idCol.Bytes) == 0) break ; } ;
		if (scol >= rri->numCols) { v_Msg(ctx,ctx->ErrorMsgAux,"RptColNotFnd",&valpt,rri->numCols) ; goto fail ; } ;
		if (scol < curcol) { v_Msg(ctx,ctx->ErrorMsgAux,"RptColRange",&colpt) ; goto fail ; } ;
		if (updColX != NULL) *updColX = curcol ;
		rri->col[curcol].spanCol = scol - curcol + 1 ; curcol = scol ;
		break ;
	    } ;
	 } ;
	if (!v4ctx_FramePop(ctx,frameid,NULL)) { v_Msg(ctx,NULL,"ModCtxPopFrame",intmodx,frameid) ; return(FALSE) ; } ;
	return(TRUE) ;
fail:
	if (!v4ctx_FramePop(ctx,frameid,NULL)) { v_Msg(ctx,NULL,"ModCtxPopFrame",intmodx,frameid) ; return(FALSE) ; } ;
	return(FALSE) ;
}

/*	v4rpt_XMLHTMLInit - Inits Rpt output stream		*/
/*	Call: v4rpt_XMLHTMLInit(ctx,rri,ok,filex)
	  where ctx is context,
		rri is current Rpt()
		ok is updated to TRUE/FALSE if problems,
		filex is output stream index			*/

void v4rpt_XMLHTMLInit(ctx,rri,ok,filex)
  struct V4C__Context *ctx ;
  struct V4RPT__RptInfo *rri ;
  LOGICAL *ok ;
  INDEX filex ;
{ INDEX xx,i,cx,cnt ;
  struct UC__File UCFile ;

	if (rri->didInit) return ;			/* Init has already been done */
/*	Maybe do format initializations */
	for(cx=0;cx<rri->numCols;cx++)
	 { int saveLT = rri->lineType ;
	   rri->lineType = V4RPT_LineType_Default ;
	   v4im_RptContext(ctx,rri,cx,UNUSED,NULL,NULL) ;
	   rri->lineType = saveLT ;
	 } ;
	switch (rri->rptType)
	 { case V4RPT_Type_V4R:
	   case V4RPT_Type_Tab:
	   case V4RPT_Type_CSV:
		break ;
	   case V4RPT_Type_HTML:
	     for(cnt=0,i=0;ok&&i<V4RPT_CSSMax;i++)			/* Need 2 passes - one that links to CSS file, one that outputs immediate */
	      { if (rri->cssVal[i] == NULL) break ;
	        if (UCstrchr(rri->cssVal[i],'{') != NULL) continue ;	/* If has '{' then immediate style, handle below */
	        *ok = vout_UCTextFileX(filex,0,UClit("<link rel='StyleSheet' href='")) ;
	        *ok = vout_UCTextFileX(filex,0,rri->cssVal[i]) ;
	        *ok = vout_UCTextFileX(filex,0,UClit("' type='text/css' />\n")) ;
	      } ;
	     for(cnt=0,i=0;ok&&i<V4RPT_CSSMax;i++)
	      { if (rri->cssVal[i] == NULL) break ;
	        if (UCstrchr(rri->cssVal[i],'{') == NULL) continue ;	/* Must be URL, ignore here */
	        if (cnt == 0) { cnt++ ; *ok = vout_UCTextFileX(filex,0,UClit("<style type='text/css'>\n")) ; } ;
	        vout_UCTextFileX(filex,0,rri->cssVal[i]) ; vout_NLFileX(filex) ;
	      } ; if (cnt > 0) { *ok = vout_UCTextFileX(filex,0,UClit("</style>\n")) ; } ;
	     if (rri->beginCount > 0)	/* Special top-of-page */
	      { switch (rri->beginType)
	         { case 1:	/* Filename - open and append contents */
		     if (!(*ok = v_UCFileOpen(&UCFile,rri->valBegin[0],UCFile_Open_Read,TRUE,ctx->ErrorMsgAux,V4IM_OpCode_Rpt)))
			  { v_Msg(ctx,NULL,"EchoSInclude",V4IM_OpCode_Rpt,V4IM_OpCode_Rpt,rri->valBegin[0]) ; return ; } ;
		     for(;*ok;)
		      { if (v_UCReadLine(&UCFile,UCRead_UC,UCTBUF1,V4TMBufMax,ctx->ErrorMsgAux) < 0) break ;
			*ok = vout_UCTextFileX(filex,0,UCTBUF1) ;
		      } ;
		     v_UCFileClose(&UCFile) ;
		     break ;
	           case 2:	/* valBegin[] is text to output */
		     for(xx=0;*ok && xx<rri->beginCount;xx++)
		      { *ok = vout_UCTextFileX(filex,0,rri->valBegin[xx]) ; vout_NLFileX(filex) ; } ;
		     break ;
	         } ;
	      } ;
	     if (rri->titleCount > 0)	/* Dump out any <title>? - Take 1st title line */
	      { v_Msg(ctx,UCTBUF1,"@<title>%1U</title>\n",rri->valTitle[0]) ; *ok = vout_UCTextFileX(filex,0,UCTBUF1) ;
	      } ;
	     for(xx=0;*ok && xx<rri->htmlCount;xx++)
	      { ZUS(UCTBUF1) ; for(i=xx;i>0;i--) { UCstrcat(UCTBUF1,UClit(" ")) ; } ;
	        UCstrcat(UCTBUF1,UClit("<")) ; UCstrcat(UCTBUF1,rri->htmlTags[xx]) ; UCstrcat(UCTBUF1,UClit(">\n")) ;
	        *ok = vout_UCTextFileX(filex,0,UCTBUF1) ;
	      } ;
	     if (rri->titleCount > 0)	/* Dump out titles (and footer) as table <caption> entries */
	      {
		UCstrcpy(UCTBUF1,UClit("<caption class='rptTitle'>")) ;
		for(i=0;i<rri->titleCount;i++) { if (i > 0) UCstrcat(UCTBUF1,UClit("<br />")) ; UCstrcat(UCTBUF1,rri->valTitle[i]) ; } ;
		UCstrcat(UCTBUF1,UClit("</caption>\n")) ; *ok = vout_UCTextFileX(filex,0,UCTBUF1) ; if (!ok) break ;
		if (rri->valId != NULL)
		 { UCstrcpy(UCTBUF1,UClit("<caption class='rptId' align='bottom'>")) ; UCstrcat(UCTBUF1,rri->valId) ;
		   UCstrcat(UCTBUF1,UClit("</caption>\n")) ; *ok = vout_UCTextFileX(filex,0,UCTBUF1) ; if (!ok) break ;
		 } ;
	      } ;
	     break ;
	   case V4RPT_Type_XML:
	     *ok = vout_UCTextFileX(filex,0,UClit("<?xml version='1.0' encoding='ISO-8859-1'?>\n")) ;
	     for(xx=0;*ok && xx<rri->xmlCount;xx++)
	      { ZUS(UCTBUF1) ; for(i=xx;i>0;i--) { UCstrcat(UCTBUF1,UClit(" ")) ; } ;
	        UCstrcat(UCTBUF1,UClit("<")) ; UCstrcat(UCTBUF1,rri->xmlTags[xx]) ; UCstrcat(UCTBUF1,UClit(">\n")) ;
	        *ok = vout_UCTextFileX(filex,0,UCTBUF1) ;
	      } ; break ;
	 } ;
	rri->didInit = TRUE ;
}

/*	v4rpt_vfsToCSS - Converts vfs to string of valid CSS parameters		*/
/*	Call: v4rpt_vfsToCSS(ctx,vfs,cssBUF)
	  where ctx is context,
		vfs is internal format structure,
		cssBuf is updated with CSS parameters				*/

void v4rpt_vfsToCSS(ctx,vfs,cssBUF)
  struct V4C__Context *ctx ;
  struct V4SS__FormatSpec *vfs ;
  UCCHAR *cssBUF ;
{
  int ha ; UCCHAR *ts,tb[2048],*b ;

	ts = cssBUF ; ZUS(ts) ;
	if (vfs == NULL) return ;

	if (vfs->FontSize > 0) { v_Msg(NULL,tb,"@font-size: %1dpt; ",vfs->FontSize) ; UCstrcat(ts,tb) ; }
	 else if (vfs->FontSize < 0) { v_Msg(NULL,tb,"@font-size: %1d%%;",-vfs->FontSize) ; UCstrcat(ts,tb) ; } ;
	if (vfs->FontAttr & V4SS_Font_Italic) UCstrcat(ts,UClit("font-style: italic; ")) ;
	if (vfs->FontAttr & V4SS_Font_StrikeThru) UCstrcat(ts,UClit("text-decoration: line-through; ")) ;
	if (vfs->FontColor != 0) { v_Msg(NULL,tb,"@color: %1U; ",v_ColorRefToHTML(vfs->FontColor)) ; UCstrcat(ts,tb) ; } ;
	if (vfs->BgColor != 0)
	 { v_Msg(NULL,tb,"@background-color: %1U; ",v_ColorRefToHTML(vfs->BgColor)) ; UCstrcat(ts,tb) ; } ;
	if (vfs->FontULStyle != 0) UCstrcat(ts,UClit("text-decoration: underline; ")) ;
	if (vfs->FontBold > V4SS_FontBold_Normal) UCstrcat(ts,UClit("font-weight: bold; ")) ;
	ha = vfs->HAlign ;
	switch(vfs->HAlign)
	 { case V4SS_Align_MultiColCenter:	ha = V4SS_Align_Center ; break ;
	   case V4SS_Align_MultiColLeft:	ha = V4SS_Align_Left ; break ;
	   case V4SS_Align_MultiColRight:	ha = V4SS_Align_Right ; break ;
	 } ;
	if (vfs->FontNameX != 0)
	 { v_Msg(NULL,tb,"@font-family: %1U; ",&vfs->VarString[vfs->FontNameX-1]) ; UCstrcat(ts,tb) ; } ;
	switch (ha)
	 { default:			b = NULL ; break ;
	   case V4SS_Align_Left:	b = UClit("left") ; break ;
	   case V4SS_Align_Right:	b = UClit("right") ; break ;
	   case V4SS_Align_Center:	b = UClit("center") ; break ;
	 } ; if (b != NULL) { v_Msg(NULL,tb,"@text-align: %1U; ",b) ; UCstrcat(ts,tb) ; } ;
	switch (ha)
	 { default:			b = NULL ; break ;
	   case V4SS_Align_Indent1:	b = UClit("2em") ; break ;
	   case V4SS_Align_Indent2:	b = UClit("4em") ; break ;
	   case V4SS_Align_Indent3:	b = UClit("6em") ; break ;
	 } ; if (b != NULL) { v_Msg(NULL,tb,"@text-align:left; padding-left: %1U; ",b) ; UCstrcat(ts,tb) ; } ;
}

/*	v4im_DoRpt - Handles Rpt() module		*/

P *v4im_DoRpt(ctx,respnt,argpnts,argcnt,intmodx)
  struct V4C__Context *ctx ;
  P *respnt ;						/* Ptr for result */
  INTMODX intmodx ;
  P *argpnts[] ;
  COUNTER argcnt ;
{ P *ipt,*cpt,ptbuf,listbuf ;
  struct V4RPT__RptInfo *rri,rriBuf ;
  struct V4L__ListPoint *lp ;
  struct V4IM__BaA *baf ;
  INDEX ix,lx,curcol,cx,filex,hx,i,tx ; COUNTER sigArgs ; INDEX rowLevel ;
  LOGICAL haveNew,ok,okToOutput ; char tb[255] ; UCCHAR *uc,segName[256],ifCond[256] ;
  LENMAX *btMax ; UCCHAR **btStr ;	/* Points to either rri->bottomMax/topMax & rri->bottomStr/topStr so Bottom::xxx & Top::xxx can share same code */
  enum DictionaryEntries pageBreak = DE(Unused) ;

/*	GETRRI - does various initializations on rri.
	Also binds rri to current data stream so that all subsequent calls to Rpt() output to the same stream regardless of the current default output stream (VEH150203)
*/
#define GETRRI \
 if (rri == NULL) \
  { INDEX i ; \
    if (gpi->rri != NULL) { rri = gpi->rri ; } \
     else { rri = &rriBuf ; memset(rri,0,sizeof *rri) ; rri->filex = UNUSED ; haveNew = TRUE ; } ; \
    rri->embedCount = 0 ; rri->lineType = UNUSED ; gpi->rriCur = rri ; \
    filex = (rri->filex == UNUSED ? ctx->Frame[ctx->FrameCnt - 1].DataStreamFileX : rri->filex) ; \
    if (filex == UNUSED) filex = vout_StreamToFileX(VOUT_Data) ; \
    rri->filex = filex ; vout_rriSet(filex,rri) ; \
    rri->embedCount = 0 ; for(i=0;i<rri->numCols;i++) { rri->col[i].spanCol = 0 ; } ; \
  } ;
#define RPTIGNORE \
 if (memcmp(cpt,&protoNone,V4PS_Int) == 0 || memcmp(cpt,&CondEvalRet,CondEvalRet.Bytes) == 0) { sigArgs-- ; break ; } ;



	rri = NULL ; haveNew = FALSE ;			/* Have not picked a report spec yet */
	baf = v4ctx_FrameBaAInfo(ctx) ;			/* Doing totals? */
	curcol = 0 ;					/* Current column */
	segName[0] = 1 ;				/* Set first byte to denote uninitialized (want to be different from empty) */
	ZUS(ifCond) ; okToOutput = TRUE ;		/* Clear 'If::conditional' argument */
	sigArgs = 0 ;
	rowLevel = 0 ;					/* Default is that a row is at level 0 */
		
	for(ix=1,ok=TRUE;ok&&ix<=argcnt;ix++)
	 { 
//	   ipt = argpnts[ix] ;
/*	   Rpt does not preevaluate arguments (as of 9/9/09) */
	   ipt = v4dpi_IsctEval(respnt,argpnts[ix],ctx,V4DPI_EM_EvalQuote,NULL,NULL) ;
	   if (ipt == NULL) { v_Msg(ctx,NULL,"ModArgEval",intmodx,ix,argpnts[ix]) ; goto rpt_fail ; } ;
	   if (memcmp(ipt,&protoNone,V4PS_Int) == 0) continue ;	/* Don't format UV4:none point */
	   sigArgs++ ;					/* Increment the number of significant arguments (i.e. cause immediate rpt output) */
	   if (ipt->PntType == V4DPI_PntType_TagVal)
	    { switch (tx=v4im_CheckPtArgNew(ctx,ipt,&cpt,&ptbuf))
	       { default:			v_Msg(ctx,NULL,"TagBadUse",intmodx) ; goto rpt_fail ;
		 case V4IM_Tag_Unk:		v_Msg(ctx,NULL,"TagUnknown",intmodx) ; goto rpt_fail ;
		 case V4IM_Tag_Begin:
	           RPTIGNORE GETRRI sigArgs-- ;
		   if (rri->beginCount != 0) { v_Msg(ctx,NULL,"RptBeginMult",intmodx,V4IM_Tag_Begin,V4DPI_PntType_List,V4DPI_PntType_BigText) ; goto rpt_fail ; } ;
		   switch (cpt->PntType)
		    { default:
			v4im_GetPointUC(&ok,UCTBUF1,V4TMBufMax,cpt,ctx) ; if (!ok) break ;
			rri->beginType = (UCstrchr(UCTBUF1,'.') == NULL ? 2 : 1) ;
			rri->valBegin[0] = v4rpt_AllocUC(rri,UCstrlen(UCTBUF1),9) ; UCstrcpy(rri->valBegin[0],UCTBUF1) ;
			rri->beginCount++ ; break ;
		      case V4DPI_PntType_BigText:
		      case V4DPI_PntType_List:
			rri->beginType = 2 ;
			lp = VERIFYLIST(&listbuf,ctx,cpt,intmodx) ;
			for(lx=1;;lx++)
			 { if (v4l_ListPoint_Value(ctx,lp,lx,&listbuf) <= 0) break ;
			   v4im_GetPointUC(&ok,UCTBUF1,V4TMBufMax,&listbuf,ctx) ; if (!ok) break ;
			   if (rri->beginCount >= V4RPT_BeginMax) { v_Msg(ctx,NULL,"RptMaxArgs",intmodx,V4RPT_BeginMax,V4IM_Tag_Begin) ; goto rpt_fail ; } ;
			   rri->valBegin[rri->beginCount] = v4rpt_AllocUC(rri,UCstrlen(UCTBUF1),10) ; UCstrcpy(rri->valBegin[rri->beginCount],UCTBUF1) ;
			   rri->beginCount++ ; break ;
			 } ;
			break ;
		    } ;
		   break ;
		 case V4IM_Tag_Bottom:
	           RPTIGNORE GETRRI ; sigArgs-- ;
		   btMax = &rri->bottomMax ; btStr = &rri->bottomStr ;
		   goto bt_entry ;
		 case V4IM_Tag_Top:
	           RPTIGNORE GETRRI ; sigArgs-- ;
		   btMax = &rri->topMax ; btStr = &rri->topStr ;
bt_entry:
/*		   Pick up all the lines - may be a list of lines, may be BigText */
		   if (*btMax == 0) { *btMax = V4TMBufMax ; *btStr = v4mm_AllocUC(*btMax) ; ZUS(*btStr) ; } ;
		   switch (cpt->PntType)
		    { default:
			v4im_GetPointUC(&ok,UCTBUF1,V4TMBufMax,cpt,ctx) ; if (!ok) break ;
			{ UCCHAR *b, *b1 ; LENMAX cur ;
			  cur = UCstrlen(*btStr) ;
			  for(b=UCTBUF1;;b=b1+1)
			   { b1 = UCstrchr(b,'\r') ; if (b1 != NULL) *b1 = UCEOS ;
			     if (cur + UCstrlen(b) >= *btMax){ *btMax *= 1.5 ; *btStr = (UCCHAR *)realloc(*btStr,(*btMax*sizeof(UCCHAR))+1) ; } ;
			     UCstrcat(*btStr,b) ; UCstrcat(*btStr,UClit("\r")) ;
			     if (b1 == NULL) break ;
			   } ;
			} break ;
		      case V4DPI_PntType_List:
			lp = VERIFYLIST(&listbuf,ctx,cpt,intmodx) ;
			if (lp == NULL) { v_Msg(ctx,NULL,"ModInvArgList",intmodx,ix) ; goto rpt_fail ; } ;
			{ LENMAX cur ;
			  cur = UCstrlen(*btStr) ;
			  for(lx=1;;lx++)
		           { if (v4l_ListPoint_Value(ctx,lp,lx,&listbuf) <= 0) break ;
		             v4im_GetPointUC(&ok,UCTBUF1,V4TMBufMax,&listbuf,ctx) ; if (!ok) break ;
			     if (cur + UCstrlen(UCTBUF1) >= *btMax) { *btMax *= 1.5 ; *btStr = (UCCHAR *)realloc(*btStr,(*btMax*sizeof(UCCHAR))+1) ; } ;
			     UCstrcat(*btStr,UCTBUF1) ; UCstrcat(*btStr,UClit("\r")) ;
			   } ;
			}
			break ;
		      case V4DPI_PntType_BigText:
			{ UCCHAR *b, *b1 ; LENMAX cur ;
			  b = v4_BigTextCharValue(ctx,cpt) ;
			  cur = UCstrlen(*btStr) ;
			  for(;;b=b1+1)
			   { b1 = UCstrchr(b,'\r') ; if (b1 != NULL) *b1 = UCEOS ;
			     if (cur + UCstrlen(b) >= *btMax)
			      { *btMax *= 1.5 ; *btStr = (UCCHAR *)realloc(*btStr,(*btMax*sizeof(UCCHAR))+1) ; } ;
			     UCstrcat(*btStr,b) ; UCstrcat(*btStr,UClit("\r")) ;
			     if (b1 == NULL) break ;
			   } ;
			}
			break ;
		    } ;
		   break ;
		 case V4IM_Tag_Columns:		
	           RPTIGNORE GETRRI ; sigArgs-- ;
	           if (rri->numCols != 0)
	            { v_Msg(ctx,UCTBUF1,"RptCntNot0",intmodx,ix,argpnts[ix],rri->numCols) ; vout_UCText(VOUT_Warn,0,UCTBUF1) ; } ;
	           lp = VERIFYLIST(&listbuf,ctx,cpt,intmodx) ;
	           if (lp == NULL) { v_Msg(ctx,NULL,"ModInvArgList",intmodx,ix) ; goto rpt_fail ; } ;
		   for(lx=1;;lx++)
	            { struct V4L__ListPoint *lp1 ;
	              P grpnt ; COUNTER gnum ; INDEX rx ;
	              if (v4l_ListPoint_Value(ctx,lp,lx,&listbuf) <= 0) break ;
		      rri->col[rri->numCols].colRedef = UNUSED ;
		      if (listbuf.Bytes == V4PS_Int)			/* Element is Dictionary/Integer - take as column Id */
		       { if (rri->numCols >= V4RPT_ColMax) { v_Msg(ctx,NULL,"RptColMax",intmodx,V4RPT_ColMax) ; goto rpt_fail ; } ;
		         memcpy(&rri->col[rri->numCols++].idCol,&listbuf,listbuf.Bytes) ;
		         continue ;
		       } ;
/*		      Element is not column id, better be (columnId #columns) or (columnId redefcolstart redefcolend) */
		      if (listbuf.PntType != V4DPI_PntType_List)
		       { v_Msg(ctx,NULL,"ModArgPntType3",intmodx,ix,listbuf.PntType,V4DPI_PntType_Int,V4DPI_PntType_Dict) ; goto rpt_fail ; } ;
		      lp1 = VERIFYLIST(NULL,ctx,&listbuf,intmodx) ;
		      switch (SIZEofLIST(lp1))
		       { default:
			   v_Msg(ctx,NULL,"RptColGrpDef",intmodx,&listbuf) ; goto rpt_fail ;
		         case 2:	/* (columnId #columns) */
			   v4l_ListPoint_Value(ctx,lp1,1,&grpnt) ;
			   if (grpnt.Bytes != V4PS_Int) { v_Msg(ctx,NULL,"ModArgPntType3",intmodx,ix,grpnt.PntType,V4DPI_PntType_Int,V4DPI_PntType_Dict) ; goto rpt_fail ; } ;
			   memcpy(&rri->col[rri->numCols].idCol,&grpnt,grpnt.Bytes) ;
			   v4l_ListPoint_Value(ctx,lp1,2,&grpnt) ; gnum = v4im_GetPointInt(&ok,&grpnt,ctx) ; if (!ok) break ;
			   if (gnum <= 0) { v_Msg(ctx,NULL,"RptColGrpNum",intmodx,gnum,&listbuf) ; goto rpt_fail ; } ;
			   if (rri->numCols + gnum - 1 >= V4RPT_ColMax) { v_Msg(ctx,NULL,"RptColMax",intmodx,V4RPT_ColMax) ; goto rpt_fail ; } ;
			   for(i=0;i<gnum;i++)
			    { rri->col[rri->numCols+i].totalGrp = gnum ; rri->col[rri->numCols+i].nthGrp = i + 1 ;
			      if (i > 0) { intPNTv(&rri->col[rri->numCols+i].idCol,(gnum*1000)+(i+1)) ; } ;		/* Put dummy Id into idCol so everything works down the line */
			    } ;
			   rri->numCols += gnum ;
			   break ;
		         case 3:	/* (columnId redefcolstart redefcolend) */
			   v4l_ListPoint_Value(ctx,lp1,1,&grpnt) ;
			   if (grpnt.Bytes != V4PS_Int) { v_Msg(ctx,NULL,"ModArgPntType3",intmodx,ix,grpnt.PntType,V4DPI_PntType_Int,V4DPI_PntType_Dict) ; goto rpt_fail ; } ;
			   memcpy(&rri->col[rri->numCols].idCol,&grpnt,grpnt.Bytes) ;
			   v4l_ListPoint_Value(ctx,lp1,2,&grpnt) ;
			   for (rx=0;rx<rri->numCols;rx++) { if (memcmp(&rri->col[rx].idCol,&grpnt,grpnt.Bytes) == 0) break ; } ;
			   if (rx >= rri->numCols)
			    { v_Msg(ctx,NULL,"RptColNotFnd",intmodx,&grpnt,rri->numCols) ; goto rpt_fail ; } ;
			   rri->col[rri->numCols].colRedef = rx ;
			   v4l_ListPoint_Value(ctx,lp1,3,&grpnt) ;
			   for (rx=0;rx<rri->numCols;rx++) { if (memcmp(&rri->col[rx].idCol,&grpnt,grpnt.Bytes) == 0) break ; } ;
			   if (rx >= rri->numCols)
			    { v_Msg(ctx,NULL,"RptColNotFnd",intmodx,&grpnt,rri->numCols) ; goto rpt_fail ; } ;
			   if (rx <= rri->col[rri->numCols].colRedef)
			    { v_Msg(ctx,NULL,"RptRedef",intmodx,&listbuf) ; goto rpt_fail ; } ;
			   rri->col[rri->numCols].totalGrp = rx - rri->col[rri->numCols].colRedef + 1 ;
			   rri->col[rri->numCols].disable = TRUE ;
			   rri->numCols ++ ;
			   break ;
		       } ;
		    } ;
		   break ;
		 case V4IM_Tag_CellColor:		
		 case V4IM_Tag_ColumnId:
	           RPTIGNORE GETRRI ; sigArgs-- ;
	           lp = VERIFYLIST(&listbuf,ctx,cpt,intmodx) ;
	           if (lp == NULL) { v_Msg(ctx,NULL,"ModInvArgList",intmodx,ix) ; goto rpt_fail ; } ;
		   for(lx=1;;lx++)
		    { struct V4L__ListPoint *lp1 ; P cidpnt ;
		      if (v4l_ListPoint_Value(ctx,lp,lx,&listbuf) <= 0) break ;
		      if (listbuf.PntType != V4DPI_PntType_List) { v_Msg(ctx,NULL,"RptXMLColId",intmodx,&listbuf) ; goto rpt_fail ; } ;
		      lp1 = VERIFYLIST(NULL,ctx,&listbuf,intmodx) ;
		      if (SIZEofLIST(lp1) != 2) { v_Msg(ctx,NULL,"RptColGrpDef",intmodx,&listbuf) ; goto rpt_fail ; } ;
		      v4l_ListPoint_Value(ctx,lp1,1,&cidpnt) ;
		      for (cx=0;cx<rri->numCols;cx++) { if (memcmp(&cidpnt,&rri->col[cx].idCol,rri->col[cx].idCol.Bytes) == 0) break ; } ;
		      if (cx >= rri->numCols) { v_Msg(ctx,ctx->ErrorMsgAux,"RptColNotFnd",&cidpnt,rri->numCols) ; ok = FALSE ; break ; } ;
		      v4l_ListPoint_Value(ctx,lp1,2,&cidpnt) ; v4im_GetPointUC(&ok,UCTBUF1,V4TMBufMax,&cidpnt,ctx) ; if (!ok) break ;
		      rri->col[cx].xmlName = v4rpt_AllocUC(rri,UCstrlen(UCTBUF1),11) ; UCstrcpy(rri->col[cx].xmlName,UCTBUF1) ;
		    } ;
		   break ;
		 case V4IM_Tag_Close:
		   GETRRI ; sigArgs-- ;
		   switch (v4im_GetDictToEnumVal(ctx,cpt))
		    { default:		v_Msg(ctx,NULL,"ModTagValue",intmodx,ix,V4IM_Tag_Close,cpt) ; goto rpt_fail ; 
		      case _Sheet:
		        if (rri->sheetCount <= 0 || rri->sheetClosed) { v_Msg(ctx,NULL,"RptNoSheet",intmodx,V4IM_Tag_Close,DE(Sheet),V4IM_Tag_Sheet) ; goto rpt_fail ; } ;
		        /* Just fall thru and handle as if it were a table closing */
		      case _Table:
			switch (rri->rptType)
			 { default:			break ;
			   case V4RPT_Type_HTML:
				for(hx=rri->htmlCount-1;hx>=0;hx--)
				 { INDEX i ; UCCHAR *up ; up = UCstrchr(rri->htmlTags[hx],' ') ; if (up != NULL) *up = UCEOS ;
				   ZUS(UCTBUF1) ; for(i=hx;i>0;i--) { UCstrcat(UCTBUF1,UClit(" ")) ; } ;
				   UCstrcat(UCTBUF1,UClit("</")) ; UCstrcat(UCTBUF1,rri->htmlTags[hx]) ; UCstrcat(UCTBUF1,UClit(">\n")) ; if (up != NULL) *up = UClit(' ') ;
				   ok = vout_UCTextFileX(filex,0,UCTBUF1) ;
				   if (!ok) { v_Msg(ctx,NULL,"OutputErr",intmodx) ; goto rpt_fail ; } ;
				 } ;
				if (rri->sheetCount == 0) rri->htmlCount = 0 ;		/* If no sheet then set to 0 so we don't close off again (with Close?) */
				break ;
			   case V4RPT_Type_XML:
				ZUS(UCTBUF1) ; for(i=0;i<rri->xmlCount+1;i++) { UCstrcat(UCTBUF1,UClit(" ")) ; } ;
				UCstrcat(UCTBUF1,UClit("</")) ; UCstrcat(UCTBUF1,rri->sheetXMLName) ; UCstrcat(UCTBUF1,UClit(">\n")) ;
				ok = vout_UCTextFileX(filex,0,UCTBUF1) ;
				if (rri->sheetCount == 0) rri->xmlCount = 0 ;		/* If no sheet then set to 0 so we don't close off again (with Close?) */
				break ;
			   case V4RPT_Type_V4R:
#define TOPBOTTOM(LOC,PREFIX) \
if (rri->LOC##Str != NULL) \
 { UCCHAR *b, *b1 ; \
   for(b=rri->LOC##Str;;b=b1+1) \
    { b1 = UCstrchr(b,'\r') ; if (b1 != NULL) *b1 = UCEOS ; \
      ok = vout_UCTextFileX(filex,0,UClit(PREFIX)) ; ok = vout_UCTextFileX(filex,0,b) ; vout_NLFileX(filex) ; \
      if (b1 == NULL) break ; \
    } ; \
   v4mm_FreeChunk(rri->LOC##Str) ; rri->LOC##Str = NULL ; rri->LOC##Max = 0 ; \
 } ;
/*				Dump out any 'top' and/or 'bottom' HTML/Javascript */
				if (rri->topStr != NULL || rri->bottomStr != NULL) { ok = vout_UCTextFileX(filex,0,UClit("BSMeta\n")) ; } ;
				TOPBOTTOM(top,"IT") ; TOPBOTTOM(bottom,"IB") ;
		         } ;
		    } ;
		   break ;
		 case -V4IM_Tag_Close:
		   GETRRI ; sigArgs-- ; if (haveNew) break ;
		   vout_rriClose(rri) ;		/* Break any association with output stream */
		   switch(rri->rptType)
		    { case V4RPT_Type_V4R:
/*			Dump out any meta info we have gathered along the way */
#define RPTMETA(TAG,FIELD) \
 if (rri->FIELD != NULL) { vout_UCTextFileX(filex,0,UClit(TAG)) ; vout_UCTextFileX(filex,0,rri->FIELD) ; vout_NLFileX(filex) ; } ;
			vout_UCTextFileX(filex,0,UClit("BSMeta\n")) ;
/*			Dump out any 'top' HTML/Javascript */
			TOPBOTTOM(top,"IT") ; TOPBOTTOM(bottom,"IB") ;
			RPTMETA("UN",user) RPTMETA("VE",valId) RPTMETA("JN",jobId) RPTMETA("RN",name) RPTMETA("PE",privileges)
			RPTMETA("SR",server) RPTMETA("SU",setup) RPTMETA("ME",memo) RPTMETA("CK",cookieValues)
			if (rri->hyperLinks > 0)
			 { UCsprintf(UCTBUF1,100,UClit("HL%d"),rri->hyperLinks) ; vout_UCTextFileX(filex,0,UCTBUF1) ; vout_NLFileX(filex) ; } ;
			if (gpi->DblEpsilon != 0)
			 { UCsprintf(UCTBUF1,100,UClit("EP%g"),gpi->DblEpsilon) ; vout_UCTextFileX(filex,0,UCTBUF1) ; vout_NLFileX(filex) ; } ;
			UCsprintf(UCTBUF1,100,UClit("DF%d"),rri->dfltFormat) ; vout_UCTextFileX(filex,0,UCTBUF1) ; vout_NLFileX(filex) ;
			if (rri->idPnt.Bytes != 0)
			 { v4dpi_PointToString(UCTBUF1,(P *)&rri->idPnt,ctx,V4DPI_FormatOpt_Echo) ;
			   vout_UCTextFileX(filex,0,UClit("ID")) ; vout_UCTextFileX(filex,0,UCTBUF1) ; vout_NLFileX(filex) ; 
			 } ;
/*			Any linked libraries to include? */
			for(i=0;i<rri->linkLibCount;i++)
			 { vout_UCTextFileX(filex,0,UClit("LI")) ; vout_UCTextFileX(filex,0,rri->linkLib[i]) ; vout_NLFileX(filex) ; } ;
/*			And finally the EOF marker */
			vout_UCTextFileX(filex,0,UClit("BSEOF\n")) ;
			break ;
		      case V4RPT_Type_Tab:
		      case V4RPT_Type_CSV:	break ;
		      case V4RPT_Type_HTML:
			for(hx=rri->htmlCount-1;hx>=0;hx--)
			 { INDEX i ; UCCHAR *up ; up = UCstrchr(rri->htmlTags[hx],' ') ; if (up != NULL) *up = UCEOS ;
			   ZUS(UCTBUF1) ; for(i=hx;i>0;i--) { UCstrcat(UCTBUF1,UClit(" ")) ; } ;
			   UCstrcat(UCTBUF1,UClit("</")) ; UCstrcat(UCTBUF1,rri->htmlTags[hx]) ; UCstrcat(UCTBUF1,UClit(">\n")) ;
			   ok = vout_UCTextFileX(filex,0,UCTBUF1) ;
			   if (!ok) { v_Msg(ctx,NULL,"OutputErr",intmodx) ; goto rpt_fail ; } ;
			 } ; break ;
		      case V4RPT_Type_XML:
			if (rri->rptType == V4RPT_Type_XML && rri->sheetCount > 0)	/* Have to close off prior XML sheet level */
			 { ZUS(UCTBUF1) ; for(i=0;i<rri->xmlCount+1;i++) { UCstrcat(UCTBUF1,UClit(" ")) ; } ;
			   UCstrcat(UCTBUF1,UClit("</")) ; UCstrcat(UCTBUF1,rri->sheetXMLName) ; UCstrcat(UCTBUF1,UClit(">\n")) ;
			   ok = vout_UCTextFileX(filex,0,UCTBUF1) ;
			 } ;
			for(hx=rri->xmlCount-1;hx>=0;hx--)
			 { INDEX i ; UCCHAR *up ; up = UCstrchr(rri->xmlTags[hx],' ') ; if (up != NULL) *up = UCEOS ;
			   ZUS(UCTBUF1) ; for(i=hx;i>0;i--) { UCstrcat(UCTBUF1,UClit(" ")) ; } ;
			   UCstrcat(UCTBUF1,UClit("</")) ; UCstrcat(UCTBUF1,rri->xmlTags[hx]) ; UCstrcat(UCTBUF1,UClit(">\n")) ;
			   ok = vout_UCTextFileX(filex,0,UCTBUF1) ;
			   if (!ok) { v_Msg(ctx,NULL,"OutputErr",intmodx) ; goto rpt_fail ; } ;
			 } ; break ;
		    } ;
		   { struct V4RPT__RptMemChunk *tmc,*ptmc ;
		     struct V4RPT__RptInfo *trri,*prri ;
		     for(tmc=rri->rriMC;tmc!=NULL;) { ptmc = tmc->priorMC ; v4mm_FreeChunk(tmc) ; tmc = ptmc ; } ;
/*		     Before we free master structure, have to remove this from gpi->rri chain */
		     for(trri=gpi->rri,prri=NULL;trri!=NULL;trri=trri->rriNext)
		      { if (trri != rri) { prri = trri ; continue ; } ;
		        if (prri == NULL)
		         { gpi->rri = trri->rriNext ; }			/* rri matches gpi->rri */
		         else { prri->rriNext = trri->rriNext ; } ;	/* found in middle, link prior to next */
		        break ;
		      } ;
		   }
/*		   Free/Clear v4r-specific format entries */
		   if (vdfm != NULL)
		    { INDEX x1, x2 ;
		      for(x1=0,x2=0;x2<vdfm->Count;x2++)
		       { if (vdfm->dimIdList[x2] == UNUSED)
		          { if (vdfm->vfs[x2] != NULL) { v4mm_FreeChunk(vdfm->vfs[x2]) ; vdfm->vfs[x2] = NULL ; } ;
			    continue ;
			  } ;
			 if (x1 != x2)
			  { vdfm->vfs[x1] = vdfm->vfs[x2] ; vdfm->dimIdList[x1] = vdfm->dimIdList[x2] ; } ;
			 x1++ ;
		       } ; vdfm->Count = x1 ;
		    } ;
		   intPNTv(respnt,rri->dtlLines) ;
		   v4mm_FreeChunk(rri) ;
		   return(respnt) ;
		 case V4IM_Tag_Cookie:
		   RPTIGNORE GETRRI ; sigArgs-- ;
		   v4im_GetPointUC(&ok,UCTBUF1,V4TMBufMax,cpt,ctx) ; if (!ok) break ;
		   rri->cookieValues = v4rpt_AllocUC(rri,UCstrlen(UCTBUF1),12) ; UCstrcpy(rri->cookieValues,UCTBUF1) ;
		   break ;
		 case V4IM_Tag_CSS:		
	           RPTIGNORE GETRRI ; sigArgs-- ;
	           if (cpt->PntType != V4DPI_PntType_List)
	            { v4im_GetPointUC(&ok,UCTBUF1,V4TMBufMax,cpt,ctx) ; if (!ok) break ;
	              for(i=0;i<V4RPT_CSSMax;i++) { if (rri->cssVal[i] == NULL) break ; } ;
	              if (i >= V4RPT_CSSMax) { v_Msg(ctx,NULL,"RptMaxArgs",intmodx,V4RPT_CSSMax,V4IM_Tag_CSS) ; goto rpt_fail ; } ;
	              rri->cssVal[i] = v4rpt_AllocUC(rri,UCstrlen(UCTBUF1),13) ; UCstrcpy(rri->cssVal[i],UCTBUF1) ;
	              break ;
	            } ;
	           lp = VERIFYLIST(&listbuf,ctx,cpt,intmodx) ;
	           if (lp == NULL) { v_Msg(ctx,NULL,"ModInvArgList",intmodx,ix) ; goto rpt_fail ; } ;
		   for(lx=1;;lx++)
	            { if (v4l_ListPoint_Value(ctx,lp,lx,&listbuf) <= 0) break ;
	              v4im_GetPointUC(&ok,UCTBUF1,V4TMBufMax,&listbuf,ctx) ; if (!ok) break ;
	              for(i=0;i<V4RPT_CSSMax;i++) { if (rri->cssVal[i] == NULL) break ; } ;
	              if (i >= V4RPT_CSSMax) { v_Msg(ctx,NULL,"RptMaxArgs",intmodx,V4RPT_CSSMax,V4IM_Tag_CSS) ; goto rpt_fail ; } ;
	              rri->cssVal[i] = v4rpt_AllocUC(rri,UCstrlen(UCTBUF1),14) ; UCstrcpy(rri->cssVal[i],UCTBUF1) ;
		    } ;
		   break ;
		 case V4IM_Tag_Default:
		   RPTIGNORE GETRRI ; rri->dfltFormat = v4im_GetPointInt(&ok,cpt,ctx); if (!ok) break;
		   break ;
		 case V4IM_Tag_Disable:
		   RPTIGNORE GETRRI ; sigArgs-- ;
	           lp = VERIFYLIST(&listbuf,ctx,cpt,intmodx) ;
	           if (lp == NULL) { v_Msg(ctx,NULL,"ModInvArgList",intmodx,ix) ; goto rpt_fail ; } ;
		   for(lx=1;;lx++)
		    { if (v4l_ListPoint_Value(ctx,lp,lx,&listbuf) <= 0) break ;
		      for (cx=0;cx<rri->numCols;cx++) { if (memcmp(&listbuf,&rri->col[cx].idCol,rri->col[cx].idCol.Bytes) == 0) break ; } ;
		      if (cx >= rri->numCols) { v_Msg(ctx,ctx->ErrorMsgAux,"RptColNotFnd",&listbuf,rri->numCols) ; ok = FALSE ; break ; } ;
		      rri->col[cx].disable = TRUE ;
		      if (rri->col[cx].totalGrp > 0)		/* If this is column group then disable all in group */
		       { for(i=1;i<rri->col[cx].totalGrp;i++)  { rri->col[cx+i].disable = TRUE ; } ; } ;
		    } ;
		   break ;
		 case V4IM_Tag_Embed:
	           RPTIGNORE GETRRI ; sigArgs-- ;
	           lp = (cpt->PntType == V4DPI_PntType_List ? VERIFYLIST(&listbuf,ctx,cpt,intmodx) : NULL) ;
		   for(lx=1;;lx++)
	            { if (lp == NULL) { ipt = cpt ; }
	               else { if (v4l_ListPoint_Value(ctx,lp,lx,&listbuf) <= 0) break ; ipt = &listbuf ; } ;
	              v4im_GetPointUC(&ok,UCTBUF1,V4TMBufMax,ipt,ctx) ; if (!ok) break ;
	              if (UCstrlen(UCTBUF1) >= V4RPT_HTMLEntryMax) { v_Msg(ctx,NULL,"RptMaxChars",intmodx,ix,V4RPT_HTMLEntryMax,V4IM_Tag_Embed) ; goto rpt_fail ; } ;
	              if (rri->embedCount >= V4RPT_HTMLMax) { v_Msg(ctx,NULL,"RptMaxArgs",intmodx,V4RPT_CSSMax,V4IM_Tag_HTML) ; goto rpt_fail ; } ;
	              if (rri->embedVal[rri->embedCount] == NULL) rri->embedVal[rri->embedCount] = v4rpt_AllocUC(rri,V4RPT_HTMLEntryMax,15) ;
	              UCstrcpy(rri->embedVal[rri->embedCount],UCTBUF1) ; rri->embedCount++ ; if (lp == NULL) break ;
		    } ;
		   break ;
		 case V4IM_Tag_Font:		
		 case V4IM_Tag_FontSize:		
		 case V4IM_Tag_Format:		
		 case V4IM_Tag_Grid:
		   GETRRI ; sigArgs-- ;
		   rri->gridOption = v4im_GetPointLog(&ok,cpt,ctx) ; if (!ok) break ;
		   break ;
		 case V4IM_Tag_Footer:		
		 case V4IM_Tag_Heading:
		   RPTIGNORE GETRRI ;
/*		   If HTML & we have titles then init output and dump out titles as captions */
		   if (rri->rptType == V4RPT_Type_HTML && !rri->sheetInit)
		    { v4rpt_XMLHTMLInit(ctx,rri,&ok,filex) ; if (!ok) break ;
		     rri->sheetInit = TRUE ;
		    } ;
		   rri->lineType = (tx == V4IM_Tag_Heading ? V4RPT_LineType_Heading : V4RPT_LineType_Footer) ;
		   lp = VERIFYLIST(&listbuf,ctx,cpt,intmodx) ;
		   if (!v4im_RptColList(ctx,lp,rri,NULL,intmodx,TRUE,NULL))
		    { v_Msg(ctx,NULL,"RptInvColSpec",intmodx,ix) ; goto rpt_fail ; } ;
		   break ;
		 case V4IM_Tag_HTML:
		   RPTIGNORE GETRRI ; sigArgs-- ;
		   if (rri->htmlCount >= V4RPT_xmlTagMax) { v_Msg(ctx,NULL,"RptXMLMax",intmodx,V4RPT_xmlTagMax,V4IM_Tag_XML) ; goto rpt_fail ; } ;
		   v4im_GetPointUC(&ok,UCTBUF1,V4TMBufMax,cpt,ctx) ; if (!ok) break ;
		   rri->htmlTags[rri->htmlCount] = v4rpt_AllocUC(rri,UCstrlen(UCTBUF1),16) ; UCstrcpy(rri->htmlTags[rri->htmlCount],UCTBUF1) ;
		   rri->htmlCount++ ;
		   break ;
		 case V4IM_Tag_Id:
		   RPTIGNORE sigArgs-- ;
		   if (cpt->Bytes != V4PS_Int) { v_Msg(ctx,NULL,"RptIdNotValid",intmodx,cpt,V4DPI_PntType_Int,V4DPI_PntType_Dict) ; goto rpt_fail ; } ;
		   if (rri == NULL)
		    { if (gpi->rri == NULL)		/* Don't have any reports yet - then create a new one */
		       { GETRRI ; memcpy(&rri->idPnt,cpt,cpt->Bytes) ; }
		       else { for(rri=gpi->rri;rri!=NULL;rri=rri->rriNext)
			       { if (memcmp(cpt,&rri->idPnt,rri->idPnt.Bytes) == 0) break ;
			       } ; if (rri == NULL) { v_Msg(ctx,NULL,"RptIdNotFnd",intmodx,argpnts[ix]) ; goto rpt_fail ; } ;
			      rri->lineType = UNUSED ;
			      filex = (rri->filex == UNUSED ? ctx->Frame[ctx->FrameCnt - 1].DataStreamFileX : rri->filex) ;
			    } ;
		       gpi->rriCur = rri ;
		    } else
		    { if (rri->idPnt.Bytes == 0) { memcpy(&rri->idPnt,cpt,cpt->Bytes) ; }
		       else { if (memcmp(cpt,&rri->idPnt,rri->idPnt.Bytes) != 0) { v_Msg(ctx,NULL,"RptWrongId",intmodx,&rri->idPnt,cpt,ix) ; goto rpt_fail ; } ;
			    } ;
		    } ;
		   break ;
		 case V4IM_Tag_If:
		   RPTIGNORE GETRRI ; sigArgs-- ;
		   { P dpnt ;
		     ipt = v4dpi_IsctEval(&dpnt,cpt,ctx,V4DPI_EM_NoIsctFail,NULL,NULL) ;
		     if (ipt == NULL) { v_Msg(ctx,NULL,"ModArgEval",intmodx,ix,argpnts[ix]) ; goto rpt_fail ; } ;
		     if (ipt->PntType == V4DPI_PntType_Logical)
		      { okToOutput = ipt->Value.IntVal ;
		      } else { v4im_GetPointUC(&ok,ifCond,sizeof ifCond,ipt,ctx) ; } ;
		   }
		   break ;
		 case V4IM_Tag_Image:
		   RPTIGNORE GETRRI ;
		   if (rri->nextImage == NULL) rri->nextImage = v4rpt_AllocUC(rri,V_FileName_Max,17) ;
/*		   Do we have a single name or list of 2 entries? */
/*		   xv4rpp expects: url<tab>localfile<tab>rows<tab>columns */
		   if (cpt->PntType != V4DPI_PntType_List)
		    { v4im_GetPointUC(&ok,UCTBUF1,V4TMBufMax,cpt,ctx) ;
/*		      Did we get URL or local file ? */
		      if (UCstrncmp(UCTBUF1,UClit("http://"),7) != 0) { UCstrcpy(rri->nextImage,UClit("\t")) ; UCstrcat(rri->nextImage,UCTBUF1) ; }
		       else { UCstrcpy(rri->nextImage,UCTBUF1) ; UCstrcat(rri->nextImage,UClit("\t")) ; } ;
		    } else
		    { lp = VERIFYLIST(NULL,ctx,cpt,intmodx) ;
		      if (!(SIZEofLIST(lp) == 2 || SIZEofLIST(lp) == 4)) { v_Msg(ctx,NULL,"RptImage",intmodx,V4IM_Tag_Image,cpt) ; goto rpt_fail ; } ;
		      v4l_ListPoint_Value(ctx,lp,1,&listbuf) ;
		      v4im_GetPointUC(&ok,rri->nextImage,V_FileName_Max,&listbuf,ctx) ;
		      v4l_ListPoint_Value(ctx,lp,2,&listbuf) ;
		      v4im_GetPointUC(&ok,UCTBUF1,V_FileName_Max,&listbuf,ctx) ;
		      UCstrcat(rri->nextImage,UClit("\t")) ; UCstrcat(rri->nextImage,UCTBUF1) ;
		      if (SIZEofLIST(lp) == 4)
		       { UCCHAR buf[32] ; INDEX row,col ;
		         v4l_ListPoint_Value(ctx,lp,3,&listbuf) ; row = v4im_GetPointInt(&ok,&listbuf,ctx) ; if (!ok) break ;
		         v4l_ListPoint_Value(ctx,lp,4,&listbuf) ; col = v4im_GetPointInt(&ok,&listbuf,ctx) ; if (!ok) break ;
		         UCsprintf(buf,UCsizeof(buf),UClit("\t%d\t%d"),row,col) ; UCstrcat(rri->nextImage,buf) ;
		       } ;
		    } ;
		   break ;
		 case V4IM_Tag_InitialLevel:
		   RPTIGNORE GETRRI ; sigArgs-- ;
		   i = v4im_GetPointInt(&ok,cpt,ctx) ;
		   if (i < 0 || i >= V4IM_BaA_LevelMax) { v_Msg(ctx,NULL,"ModArgRange",ix,cpt,0,V4IM_BaA_LevelMax-1) ; goto rpt_fail ; } ;
		   rri->initialLevel = i ; break ;
		 case V4IM_Tag_Job:
		   RPTIGNORE GETRRI ; sigArgs-- ;
		   v4im_GetPointUC(&ok,UCTBUF1,V4TMBufMax,cpt,ctx) ;
		   rri->jobId = v4mm_AllocUC(UCstrlen(UCTBUF1)) ; UCstrcpy(rri->jobId,UCTBUF1) ;
		   break ;
//		 case V4IM_Tag_Key:
//		   RPTIGNORE GETRRI ;
//		   v4im_GetPointUC(&ok,UCTBUF1,V4RPT_KeySizeMax,cpt,ctx) ; if (!ok) break ;
//		   if (UCempty(UCTBUF1)) break ;
//		   if (rri->nextKey == NULL) rri->nextKey = v4rpt_AllocUC(rri,V4RPT_KeySizeMax,28) ;
//		   UCTBUF1[V4RPT_KeySizeMax-1] = UCEOS ; UCstrcpy(rri->nextKey,UCTBUF1) ;
//		   break ;
		 case V4IM_Tag_Level:
		   rowLevel = v4im_GetPointInt(&ok,cpt,ctx) ;
		   if (rowLevel < 0 || rowLevel >= V4IM_BaA_LevelMax) { v_Msg(ctx,NULL,"ModArgRange",ix,cpt,0,V4IM_BaA_LevelMax-1) ; goto rpt_fail ; } ;
		   break ;
		 case V4IM_Tag_Library:
		   RPTIGNORE GETRRI ; sigArgs-- ;
	           lp = (cpt->PntType == V4DPI_PntType_List ? VERIFYLIST(&listbuf,ctx,cpt,intmodx) : NULL) ;
		   for(lx=1;;lx++)
	            { if (lp == NULL) { ipt = cpt ; }
	               else { if (v4l_ListPoint_Value(ctx,lp,lx,&listbuf) <= 0) break ; ipt = &listbuf ; } ;
	              v4im_GetPointUC(&ok,UCTBUF1,V4TMBufMax,ipt,ctx) ; if (!ok) break ;
/*		      Verify that value is .js or .css - those are only two we handle at this point */
		      if (UCstrstr(UCTBUF1,UClit(".js")) != NULL)
		       { tb[0] = V4SS_Type_SourceJS ; }
		       else if (UCstrstr(UCTBUF1,UClit(".css")) != NULL)
		       { tb[0] = V4SS_Type_SourceCSS ; }
		       else { v_Msg(ctx,NULL,"RptSource",intmodx,V4IM_Tag_Source,UCTBUF1) ; goto rpt_fail ; } ;
		      if (rri->linkLibCount >= V4RPT_LinkLibMax) { v_Msg(ctx,NULL,"RptLinkMax",intmodx,V4RPT_LinkLibMax) ; goto rpt_fail ; }
		      rri->linkLib[rri->linkLibCount] = v4mm_AllocUC(UCstrlen(UCTBUF1)) ; UCstrcpy(rri->linkLib[rri->linkLibCount],UCTBUF1) ;
		      rri->linkLibCount++ ;
		      if (lp == NULL) break ;
		    } ;
		   break ;
		 case V4IM_Tag_Line:
		   v_Msg(ctx,NULL,"RptOptNYI",intmodx) ; goto rpt_fail ;
		 case V4IM_Tag_Link:
		   RPTIGNORE GETRRI ; sigArgs-- ;
		   switch (v4im_GetDictToEnumVal(ctx,cpt))
		    { default:		v_Msg(ctx,NULL,"ModTagValue",intmodx,ix,V4IM_Tag_Link,cpt) ; goto rpt_fail ; 
		      case _External:	rri->hyperLinks = V4RH_XLSXURL_exOnly ; break ;
		      case _None:	rri->hyperLinks = V4RH_XLSXURL_none ; break ;
		      case _Secure:	rri->hyperLinks = V4RH_XLSXURL_secure ; break ;
		      case _User:	rri->hyperLinks = V4RH_XLSXURL_userKey ; break ;
		    } ;
		   break ;
		 case V4IM_Tag_Mask:
		   v_Msg(ctx,NULL,"RptOptNYI",intmodx) ; goto rpt_fail ;
		 case V4IM_Tag_Memo:
		   RPTIGNORE GETRRI ;
		   v4im_GetPointUC(&ok,UCTBUF1,V4TMBufMax,cpt,ctx) ;
		   rri->memo = v4mm_AllocUC(UCstrlen(UCTBUF1)) ; UCstrcpy(rri->memo,UCTBUF1) ;
		   break ;
		 case V4IM_Tag_Name:
		   RPTIGNORE GETRRI ; sigArgs-- ;
		   v4im_GetPointUC(&ok,UCTBUF1,V4TMBufMax,cpt,ctx) ;
		   rri->name = v4mm_AllocUC(UCstrlen(UCTBUF1)) ; UCstrcpy(rri->name,UCTBUF1) ;
		   break ;
		 case V4IM_Tag_Note:
		   RPTIGNORE GETRRI ;
		   v4im_GetPointUC(&ok,UCTBUF1,V4RPT_NoteSizeMax,cpt,ctx) ; if (!ok) break ;
		   if (UCempty(UCTBUF1)) break ;
		   if (rri->nextNote == NULL) rri->nextNote = v4rpt_AllocUC(rri,V4RPT_NoteSizeMax,18) ;
		   UCTBUF1[V4RPT_NoteSizeMax-1] = UCEOS ; UCstrcpy(rri->nextNote,UCTBUF1) ;
		   break ;
		   
		 case V4IM_Tag_Out:		
		   RPTIGNORE GETRRI ; sigArgs-- ;
		   filex = vout_PntIdToFileX(ctx,(struct V4DPI__LittlePoint *)cpt) ;
		   if (filex == UNUSED) { v_Msg(ctx,NULL,"StreamNoOutput",intmodx,V4IM_Tag_Out,cpt) ; goto rpt_fail ; } ;
		   vout_rriSet(filex,rri) ; rri->filex = filex ;		/* Associate the stream with the report */
		   break ;
		 case V4IM_Tag_Page:
		   
		   switch (v4im_GetDictToEnumVal(ctx,cpt))
		    { default:		v_Msg(ctx,NULL,"ModTagValue",intmodx,ix,V4IM_Tag_Page,cpt) ; goto rpt_fail ; 
		      case _After:	pageBreak = DE(After) ; break ;
		      case _Before:	pageBreak = DE(Before) ; break ;
		    } ;
		   break ;
		 case V4IM_Tag_Privileges:
		   RPTIGNORE GETRRI ; sigArgs-- ;
		   v4im_GetPointUC(&ok,UCTBUF1,V4TMBufMax,cpt,ctx) ;
		   rri->privileges = v4mm_AllocUC(UCstrlen(UCTBUF1)) ; UCstrcpy(rri->privileges,UCTBUF1) ;
		   break ;
		 case V4IM_Tag_Recap:
		   break ;
		 case V4IM_Tag_Row:
		   RPTIGNORE GETRRI ; sigArgs-- ;
		   v4im_GetPointUC(&ok,rri->rowInfo,UCsizeof(rri->rowInfo),cpt,ctx) ;
		   break ;
		 case V4IM_Tag_Scale:
		   RPTIGNORE GETRRI ; sigArgs-- ;
		   { 
		     if (cpt->PntType != V4DPI_PntType_Dict ) { rri->scale = v4im_GetPointInt(&ok,cpt,ctx) ; }
		      else { switch (v4im_GetDictToEnumVal(ctx,cpt))
			      { default:		v_Msg(ctx,NULL,"RptScale",intmodx,V4IM_Tag_Scale,cpt,_Fit) ; goto rpt_fail ;
			        case _Fit:		rri->scale = -1 ; break ;
			      } ;
			  } ;
		   }
		   break ;
		 case V4IM_Tag_Segment:
		   break ;
		 case V4IM_Tag_Section:
		   RPTIGNORE GETRRI ; sigArgs-- ;
		   v4im_GetPointUC(&ok,UCTBUF1,V4TMBufMax,cpt,ctx) ;
		   vout_UCTextFileX(filex,0,UClit("BSMeta\nSN")) ; vout_UCTextFileX(filex,0,UCTBUF1) ; vout_NLFileX(filex) ;
		   break ;
		 case V4IM_Tag_Select:
		   RPTIGNORE GETRRI ; sigArgs-- ;
		   v4im_GetPointUC(&ok,rri->selectInfo,UCsizeof(rri->selectInfo),cpt,ctx) ;
		   break ;
		 case V4IM_Tag_Sheet:
		   RPTIGNORE GETRRI ; sigArgs-- ;
/*		   *** ANY CHANGES HERE SHOULD ALSO BE CHECKED AGAINST Close::Sheet OPTION ABOVE *** */
		   if (rri->rptType == V4RPT_Type_XML && rri->sheetCount > 0 && !rri->sheetClosed)	/* Have to close off prior XML sheet level */
		    { ZUS(UCTBUF1) ; for(i=0;i<rri->xmlCount+1;i++) { UCstrcat(UCTBUF1,UClit(" ")) ; } ;
		      UCstrcat(UCTBUF1,UClit("</")) ; UCstrcat(UCTBUF1,rri->sheetXMLName) ; UCstrcat(UCTBUF1,UClit(">\n")) ;
		      ok = vout_UCTextFileX(filex,0,UCTBUF1) ;
		    } ;
		   if (cpt->PntType != V4DPI_PntType_List)
		    { v4im_GetPointUC(&ok,rri->sheetName,UCsizeof(rri->sheetName),cpt,ctx) ; UCstrcpy(rri->sheetXMLName,rri->sheetName) ;
		    } else
		    { lp = VERIFYLIST(NULL,ctx,cpt,intmodx) ;
		      if (SIZEofLIST(lp) != 2) { v_Msg(ctx,NULL,"RptSheet",intmodx,V4IM_Tag_Sheet,cpt) ; goto rpt_fail ; } ;
		      v4l_ListPoint_Value(ctx,lp,1,&listbuf) ;
		      v4im_GetPointUC(&ok,rri->sheetName,UCsizeof(rri->sheetName),&listbuf,ctx) ;
		      v4l_ListPoint_Value(ctx,lp,2,&listbuf) ;
		      v4im_GetPointUC(&ok,rri->sheetXMLName,UCsizeof(rri->sheetXMLName),&listbuf,ctx) ;
		    } ;
		   switch (rri->rptType)
		    { 
		      case V4RPT_Type_V4R:
//VEH190322 - not clear why we need this code, try without
//			ZUS(UCTBUF1) ; for(i=0;i<rri->titleCount;i++) { if (i > 0) UCstrcat(UCTBUF1,UClit("\012")) ; UCstrcat(UCTBUF1,rri->valTitle[i]) ; } ; bytes = UCstrlen(UCTBUF1) ;
//			if (bytes > 250) { v_Msg(ctx,NULL,"EchoSMaxEnd",intmodx,V4IM_Tag_End,UCTBUF1,250); goto rpt_fail ; } ;
			break ;
		      case V4RPT_Type_HTML:
			for(hx=rri->htmlCount-1;!rri->sheetClosed && rri->sheetCount>0 && hx>=0;hx--)
			 { INDEX i ; UCCHAR *up ; up = UCstrchr(rri->htmlTags[hx],' ') ; if (up != NULL) *up = UCEOS ;
			   ZUS(UCTBUF1) ; for(i=hx;i>0;i--) { UCstrcat(UCTBUF1,UClit(" ")) ; } ;
			   UCstrcat(UCTBUF1,UClit("</")) ; UCstrcat(UCTBUF1,rri->htmlTags[hx]) ; UCstrcat(UCTBUF1,UClit(">\n")) ; if (up != NULL) *up = UClit(' ') ;
			   ok = vout_UCTextFileX(filex,0,UCTBUF1) ;
			   if (!ok) { v_Msg(ctx,NULL,"OutputErr",intmodx) ; goto rpt_fail ; } ;
			 } ;
			for(hx=0;ok && hx<rri->htmlCount;hx++)
			 { ZUS(UCTBUF1) ; for(i=hx;i>0;i--) { UCstrcat(UCTBUF1,UClit(" ")) ; } ;
			   UCstrcat(UCTBUF1,UClit("<")) ; UCstrcat(UCTBUF1,rri->htmlTags[hx]) ; UCstrcat(UCTBUF1,UClit(">\n")) ;
			   ok = vout_UCTextFileX(filex,0,UCTBUF1) ;
			 } ;
			break ;
		      case V4RPT_Type_XML:
			v4rpt_XMLHTMLInit(ctx,rri,&ok,filex) ;
			ZUS(UCTBUF1) ; for(i=0;i<rri->xmlCount+1;i++) { UCstrcat(UCTBUF1,UClit(" ")) ; } ;
			UCstrcat(UCTBUF1,UClit("<")) ; UCstrcat(UCTBUF1,rri->sheetXMLName) ; UCstrcat(UCTBUF1,UClit(">\n")) ;
			ok = vout_UCTextFileX(filex,0,UCTBUF1) ;
			break ;
		    } ;
/*		   Clear out existing columns */
		   for(cx=0;cx<rri->numCols;cx++) { memset(&rri->col[cx],0,sizeof (rri->col[cx])) ; } ;
		   rri->numCols = 0 ; rri->titleCount = 0 ; rri->hdrLines = 0 ;
		   rri->sheetInit = FALSE ; rri->sheetClosed = FALSE ; rri->sheetCount++ ; break ;
		 case V4IM_Tag_Server:
		   RPTIGNORE GETRRI ; sigArgs-- ;
		   v4im_GetPointUC(&ok,UCTBUF1,V4TMBufMax,cpt,ctx) ;
		   rri->server = v4mm_AllocUC(UCstrlen(UCTBUF1)) ; UCstrcpy(rri->server,UCTBUF1) ;
		   break ;
		 case V4IM_Tag_Setup:
		   RPTIGNORE GETRRI ; sigArgs-- ;
		   v4im_GetPointUC(&ok,UCTBUF1,V4TMBufMax,cpt,ctx) ;
		   rri->setup = v4mm_AllocUC(UCstrlen(UCTBUF1)) ; UCstrcpy(rri->setup,UCTBUF1) ;
		   break ;
		 case V4IM_Tag_Style:		
		 case V4IM_Tag_StyleName:		
		 case V4IM_Tag_Tag:
		   RPTIGNORE GETRRI ; sigArgs-- ;
		   v4im_GetPointUC(&ok,UCTBUF1,V4TMBufMax,cpt,ctx) ;
		   vout_UCTextFileX(filex,0,UClit("BSMeta\nTV")) ; vout_UCTextFileX(filex,0,UCTBUF1) ; vout_NLFileX(filex) ;
		   break ;
		 case V4IM_Tag_TextColor:		
		 case V4IM_Tag_Title:
		   RPTIGNORE GETRRI ; sigArgs-- ;
		   lp = (cpt->PntType == V4DPI_PntType_List ? VERIFYLIST(NULL,ctx,cpt,intmodx) : NULL) ;
		   for(lx=1;;lx++)
		    { if (lp == NULL) { ipt = cpt ; }
		       else { if (v4l_ListPoint_Value(ctx,lp,lx,&listbuf) <= 0) break ; ipt = &listbuf ; } ;
		      if (ipt->PntType == V4DPI_PntType_TagVal)
		       { P ptbuf1 ;
		         switch (v4im_CheckPtArgNew(ctx,ipt,&cpt,&ptbuf1))
			  { default:			v_Msg(ctx,NULL,"TagBadUse",intmodx) ; goto rpt_fail ;
			    case V4IM_Tag_Unk:		v_Msg(ctx,NULL,"TagUnknown",intmodx) ; goto rpt_fail ;
			    case V4IM_Tag_Embed:
				{ struct V4L__ListPoint *lp ; P listbuf1 ; INDEX lx ;
				  lp = (cpt->PntType == V4DPI_PntType_List ? VERIFYLIST(NULL,ctx,cpt,intmodx) : NULL) ;
				  for(lx=1;;lx++)
				   { if (lp == NULL) { ipt = cpt ; }
				      else { if (v4l_ListPoint_Value(ctx,lp,lx,&listbuf1) <= 0) break ; ipt = &listbuf1 ; } ;
				     v4im_GetPointUC(&ok,UCTBUF1,V4TMBufMax,ipt,ctx) ; if (!ok) break ;
				     if (UCstrlen(UCTBUF1) >= V4RPT_HTMLEntryMax) { v_Msg(ctx,NULL,"RptMaxChars",intmodx,ix,V4RPT_HTMLEntryMax,V4IM_Tag_HTML) ; goto rpt_fail ; } ;
				     if (rri->embedCount >= V4RPT_HTMLMax) { v_Msg(ctx,NULL,"RptMaxArgs",intmodx,V4RPT_CSSMax,V4IM_Tag_HTML) ; goto rpt_fail ; } ;
				     if (rri->embedVal[rri->embedCount] == NULL) rri->embedVal[rri->embedCount] = v4rpt_AllocUC(rri,V4RPT_HTMLEntryMax,19) ;
				     UCstrcpy(rri->embedVal[rri->embedCount],UCTBUF1) ; rri->embedCount++ ; if (lp == NULL) break ;
				  } ;
				}
				break ;
			  } ; continue ;
		       } ;
		      ZUS(UCTBUF1) ; v4im_GetPointUC(&ok,UCTBUF2,V4TMBufMax,ipt,ctx) ; if (!ok) break ;
		      for(i=0,uc=UCTBUF2;;i++)
		       { UCCHAR *b1 ;
		         if ((b1=UCstrchr(uc,'\033')) != NULL)
		          { *b1 = UCEOS ; UCstrcat(UCTBUF1,uc) ; if (i < rri->embedCount) UCstrcat(UCTBUF1,rri->embedVal[i]) ; uc = b1 + 1 ; continue ; } ;
		         UCstrcat(UCTBUF1,uc) ; break ;
		       } ;
		      if (rri->titleCount >= V4RPT_TitleMax) { v_Msg(ctx,NULL,"RptMaxArgs",intmodx,V4RPT_TitleMax,V4IM_Tag_Title) ; goto rpt_fail ; } ;
		      rri->valTitle[rri->titleCount] = v4rpt_AllocUC(rri,UCstrlen(UCTBUF1),20) ; UCstrcpy(rri->valTitle[rri->titleCount],UCTBUF1) ;
		      rri->titleCount++ ; if (lp == NULL) break ; rri->embedCount = 0 ;
		    } ;
		   break ;
		 case V4IM_Tag_Type:		
		   RPTIGNORE GETRRI ; sigArgs-- ;
		   switch (v4im_GetDictToEnumVal(ctx,cpt))
		    { default:		v_Msg(ctx,NULL,"ModTagValue",intmodx,ix,V4IM_Tag_Type,cpt) ; goto rpt_fail ; 
		      case _CSV:	rri->rptType = V4RPT_Type_CSV ; break ;
		      case _HTML:	rri->rptType = V4RPT_Type_HTML ; break ;
		      case _Tab:	rri->rptType = V4RPT_Type_Tab ; break ;
		      case _V4R:	rri->rptType = V4RPT_Type_V4R ; break ;
		      case _XML:	rri->rptType = V4RPT_Type_XML ; break ;
		    } ;
		   break ;
		 case -V4IM_Tag_Type:
		   GETRRI ;
		   switch (rri->rptType)
		    { default:
		      case V4RPT_Type_V4R:	respnt->Value.IntVal = v4im_GetEnumToDictVal(ctx,DE(V4R),Dim_UV4) ; break ;
		      case V4RPT_Type_CSV:	respnt->Value.IntVal = v4im_GetEnumToDictVal(ctx,DE(CSV),Dim_UV4) ; break ;
		      case V4RPT_Type_HTML:	respnt->Value.IntVal = v4im_GetEnumToDictVal(ctx,DE(HTML),Dim_UV4) ; break ;
		      case V4RPT_Type_Tab:	respnt->Value.IntVal = v4im_GetEnumToDictVal(ctx,DE(Tab),Dim_UV4) ; break ;
		      case V4RPT_Type_XML:	respnt->Value.IntVal = v4im_GetEnumToDictVal(ctx,DE(XML),Dim_UV4) ; break ;
		    } ;
		   dictPNT(respnt,Dim_UV4) ; return(respnt) ;
		 case V4IM_Tag_URL:
		   RPTIGNORE GETRRI ;
		   { struct V4RPT__URLSpec vus ;
		     if (!v4rpt_ParseURLSpec(ctx,&vus,cpt,intmodx)) goto rpt_fail ;
		     if (UCempty(vus.urlText)) break ;
		     if (rri->nextURL == NULL) rri->nextURL = v4rpt_AllocUC(rri,V4RPT_URLSizeMax,21) ;
		     UCstrcpy(rri->nextURL,vus.urlText) ;
		     if (UCnotempty(vus.target))
		      { if (rri->nextTarget == NULL) rri->nextTarget = v4rpt_AllocUC(rri,V4RPT_TargetMax,22) ; UCstrcpy(rri->nextTarget,vus.target) ; } ;
		   }
		   break ;
		 case V4IM_Tag_URLBase:
		   RPTIGNORE GETRRI ; sigArgs-- ;
	           if (cpt->PntType != V4DPI_PntType_List)
	            { v4im_GetPointUC(&ok,UCTBUF1,V4TMBufMax,cpt,ctx) ; if (!ok) break ;
		      if (UCempty(UCTBUF1)) break ;
	              for(i=0;i<V4RPT_URLBaseMax;i++) { if (rri->urlBase[i] == NULL) break ; } ;
	              if (i >= V4RPT_URLBaseMax) { v_Msg(ctx,NULL,"RptMaxArgs",intmodx,V4RPT_URLBaseMax,V4IM_Tag_URLBase) ; goto rpt_fail ; } ;
	              rri->urlBase[i] = v4rpt_AllocUC(rri,UCstrlen(UCTBUF1),23) ; UCstrcpy(rri->urlBase[i],UCTBUF1) ;
	              break ;
	            } ;
	           lp = VERIFYLIST(&listbuf,ctx,cpt,intmodx) ;
	           if (lp == NULL) { v_Msg(ctx,NULL,"ModInvArgList",intmodx,ix) ; goto rpt_fail ; } ;
		   for(lx=1;;lx++)
	            { if (v4l_ListPoint_Value(ctx,lp,lx,&listbuf) <= 0) break ;
	              v4im_GetPointUC(&ok,UCTBUF1,V4TMBufMax,&listbuf,ctx) ; if (!ok) break ;
		      if (UCempty(UCTBUF1)) continue ;
	              for(i=0;i<V4RPT_URLBaseMax;i++) { if (rri->urlBase[i] == NULL) break ; } ;
	              if (i >= V4RPT_URLBaseMax) { v_Msg(ctx,NULL,"RptMaxArgs",intmodx,V4RPT_URLBaseMax,V4IM_Tag_URLBase) ; goto rpt_fail ; } ;
	              rri->urlBase[i] = v4rpt_AllocUC(rri,UCstrlen(UCTBUF1),24) ; UCstrcpy(rri->urlBase[i],UCTBUF1) ;
		    } ;
		   break ;
		 case V4IM_Tag_User:
		   RPTIGNORE GETRRI ; sigArgs-- ;
		   v4im_GetPointUC(&ok,UCTBUF1,V4TMBufMax,cpt,ctx) ;
		   rri->user = v4mm_AllocUC(UCstrlen(UCTBUF1)) ; UCstrcpy(rri->user,UCTBUF1) ;
		   break ;
		 case V4IM_Tag_Version:
		   RPTIGNORE GETRRI ; sigArgs-- ;
		   v4im_GetPointUC(&ok,UCTBUF1,V4TMBufMax,cpt,ctx) ; if (!ok) break ;
		   rri->valId = v4rpt_AllocUC(rri,UCstrlen(UCTBUF1),25) ; UCstrcpy(rri->valId,UCTBUF1) ;
		   break ;
		 case V4IM_Tag_Width:		break ;
		 case V4IM_Tag_XML:
		   RPTIGNORE GETRRI ;
		   if (rri->xmlCount >= V4RPT_xmlTagMax) { v_Msg(ctx,NULL,"RptXMLMax",intmodx,V4RPT_xmlTagMax,V4IM_Tag_XML) ; goto rpt_fail ; } ;
		   v4im_GetPointUC(&ok,UCTBUF1,V4TMBufMax,cpt,ctx) ; if (!ok) break ;
		   rri->xmlTags[rri->xmlCount] = v4rpt_AllocUC(rri,UCstrlen(UCTBUF1),26) ; UCstrcpy(rri->xmlTags[rri->xmlCount],UCTBUF1) ;
		   rri->xmlCount++ ;
		   break ;
	       } ;
	     continue ;			/* Done tag - continue with next argument */
	    } ;
/*	   Here to handle non-tagged argument */
	   GETRRI ;
/*	   If don't yet know lineType then try to guess from baf context */
	   if (rri->lineType == UNUSED)
	    { switch (baf == NULL ? V4IM_BaA_Disable : baf->CurCond)
	       { default:
	         case V4IM_BaA_Disable:		rri->lineType = V4RPT_LineType_Detail ; break ;
	         case V4IM_BaA_CondBegin:
	         case V4IM_BaA_CondBefore:
	         case V4IM_BaA_CondAfter:	rri->lineType = V4RPT_LineType_Recap ; break ;
	         case V4IM_BaA_CondEnd1:	rri->lineType = V4RPT_LineType_Recap ; break ;
	         case V4IM_BaA_CondEnd2:	rri->lineType = V4RPT_LineType_Footer ; break ;
	       } ;
	    } ;
	   v4rpt_XMLHTMLInit(ctx,rri,&ok,filex) ;	/* Do any inits before first Rpt() output */
	   if (ipt->PntType == V4DPI_PntType_List)
	    { lp = VERIFYLIST(&listbuf,ctx,argpnts[ix],intmodx) ;
	      if (!v4im_RptColList(ctx,lp,rri,baf,intmodx,FALSE,&curcol))
	       { v_Msg(ctx,NULL,"RptInvColSpec",intmodx,ix) ; goto rpt_fail ; } ;
	      continue ;
	    } ;
/*	   Add next column */
	   if (rri->numCols >= V4RPT_ColMax) { v_Msg(ctx,NULL,"RptColMax",intmodx,V4RPT_ColMax) ; goto rpt_fail ; } ;
	   curcol++ ; if (curcol > rri->numCols) rri->numCols = curcol ;
	   RPTCOLVAL(ipt,curcol,UNUSED) ; if (!ok) break ;
	 } ;
	if (!ok) { v_Msg(ctx,NULL,"ModInvArg",intmodx,ix-1) ; goto rpt_fail ; } ;
//	if (sigArgs <= 0)			/* If nothing to do, then don't do anything */
//	 { logPNTv(respnt,FALSE) ; return(respnt) ; } ;

/*	If we have a new rri then append it to gpi->rri chain */
	if (haveNew)
	 { rri->rriNext = gpi->rri ; 
	   gpi->rri = (struct V4RPT__RptInfo *)v4mm_AllocChunk(sizeof *rri,FALSE) ; *gpi->rri = *rri ;
	 } ;

/*	Do we have anything to dump out ? */
	if (rri == NULL)		/* If no arguments, default to a blank line */
	 { GETRRI ;
	   rri->lineType = V4RPT_LineType_Detail ;
	 } ;
	if (rri->lineType == UNUSED) return((P *)&Log_True) ;

#define FIXCONTROLCHARS(UCS) \
 { UCCHAR *ub = (UCS) ; for(;*ub!=UCEOS;ub++) { if (!vuc_IsPrint(*ub)) *ub = UClit(' ') ; } ; }

	switch (okToOutput ? rri->rptType : UNUSED)	/* If we don't want to output anything, then don't ! */
	 { case V4RPT_Type_V4R:
	     switch (rri->lineType)
	      {
		case V4RPT_LineType_Heading:
		  rri->hdrLines++ ; break ;
		case V4RPT_LineType_Detail:
		  rri->dtlLines++ ; break ;
		case V4RPT_LineType_Recap:
		case V4RPT_LineType_Footer:	break ;
	      } ;



	     { struct V4DPI__DimInfo *di ;
	       LOGICAL inOther = FALSE ;
	     
	       char *outbuf ; double dnum ; B64INT b64 ; LENMAX bytes ;
/*	       Do we have to send (updated) list of SSDim entries? */
	       if (vdfm == NULL ? FALSE : vdfm->RevLevel > vdfm->xmitRevLevel)
		{ struct V4DPI__DimInfo *di ;
		  for(i=0;i<vdfm->Count;i++)				/* If SSDim updated then have to dump out to target spreadsheet */
		   { if (vdfm->dimIdList[i] == UNUSED) continue ;	/* If UNUSED then already called v4rh_FormatSpecToNewV4R for this entry */
		     DIMINFO(di,ctx,vdfm->dimIdList[i]) ; 
		     if (!v4rh_FormatSpecToNewV4R(ctx,i,di->PointType,vdfm->vfs[i],filex,!rri->didCountryLanguage))
		      { v_Msg(ctx,NULL,"@%1E Invalid point type for dimension (%2D), index %3d",intmodx,di->DimId,i) ; goto rpt_fail ; } ;
		     rri->didCountryLanguage = TRUE ;
		   } ;
		  vdfm->xmitRevLevel = vdfm->RevLevel ;
		} ;
/*	       Do we have any URL bases to dump out ? */
	       if (rri->urlBase[0] != NULL)
	        { 
	          for(i=0;i<V4RPT_URLBaseMax && !rri->urlBaseSent[i];i++)
	           { 
	             if (rri->urlBase[i] == NULL) break ;
		     if (!inOther) { vout_UCTextFileX(filex,0,UClit("BSOther\n")) ; inOther = TRUE ; } ;
		     v_Msg(ctx,UCTBUF1,"@UB%1d=%2U\n",i+1,rri->urlBase[i]) ;
		     vout_UCTextFileX(filex,0,UCTBUF1) ;
		    rri->urlBaseSent[i] = TRUE ;
	           } ;
	        } ;

/*	       Any CSS Entries to dump ? */
	       for(i=0;i<V4RPT_CSSMax;i++)
	        { LENMAX len ; 
	          if (rri->cssVal[i] == NULL || rri->cssValSent[i]) continue ;
		  len = UCstrlen(rri->cssVal[i]) ; if (len >= 253) { v_Msg(ctx,NULL,"RptMaxChars",intmodx,0,253,V4IM_Tag_CSS) ; goto rpt_fail ; } ;
		  tb[0] = V4SS_Type_CSS ; tb[1] = len + 2 ;
		  if (i == 0) vout_UCTextFileX(filex,0,UClit("BSOther\n")) ;
		  v_Msg(ctx,UCTBUF1,"@CS%1U\n",rri->cssVal[i]) ;
		  vout_UCTextFileX(filex,0,UCTBUF1) ;
		  rri->cssValSent[i] = TRUE ;
	        } ;
/*	       Any Begin-of-Report lines to dump ? */
	       for(i=0;i<rri->beginCount;i++)
	        { if (rri->valBegin[i] == NULL) continue ;
		  rri->valBegin[i] = NULL ;
	        } ;
/*	       Grid line option ? */
	       if (rri->gridOption != 0 && !rri->didInit)
	        { 
		  if (rri->gridOption) { vout_UCTextFileX(filex,0,UClit("SG2\n")) ; } ;
	        } ;

	       rri->didInit = TRUE ;		/* We have been here at least once */

/*	       Any HTML entries to send ? */
	       for(i=0;i<rri->embedCount;i++)
	        { 
		  v_Msg(ctx,UCTBUF1,"@HT%1U\n",rri->embedVal[i]) ; vout_UCTextFileX(filex,0,UCTBUF1) ;
	        } ;

		if (!rri->sheetInit)
		 { vout_UCTextFileX(filex,0,UClit("BSSheet\n")) ;
		   if (UCnotempty(rri->sheetName))
		    { v_Msg(ctx,UCTBUF1,"@NA%1U\n",rri->sheetName) ; vout_UCTextFileX(filex,0,UCTBUF1) ; } ;
		   if (UCnotempty(rri->selectInfo))
		    { v_Msg(ctx,UCTBUF1,"@SE%1U\n",rri->selectInfo) ; vout_UCTextFileX(filex,0,UCTBUF1) ; } ;
		   for(i=0;i<rri->titleCount;i++)
		    { UCCHAR *b,*d ;
		      for(b=rri->valTitle[i];;b=d+1)
		       { d = UCstrchr(b,'\012') ; if (d != NULL) *d = UCEOS ;
			 v_Msg(ctx,UCTBUF1,"@TI%1U\n",b) ; vout_UCTextFileX(filex,0,UCTBUF1) ;
			 if (d == UCEOS) break ;
		       } ;
		    } ;
		   if (rri->initialLevel > 0) 
		    { v_Msg(ctx,UCTBUF1,"@DL%1d\n",rri->initialLevel) ; vout_UCTextFileX(filex,0,UCTBUF1) ; } ;
/*		   Do we have column id/labels to output? */
		   { LOGICAL haveIds = FALSE ;
		     for(i=0;i<rri->numCols;i++) { if (rri->col[i].xmlName != NULL) { haveIds = TRUE ; break ; } ; } ;
		     if (haveIds)
		      { UCstrcpy(UCTBUF1,UClit("CN")) ;
		        for(i=0;i<rri->numCols;i++)
			 { if (rri->col[i].xmlName != NULL) { UCstrcat(UCTBUF1,rri->col[i].xmlName) ; } ;
			   UCstrcat(UCTBUF1,UClit("|")) ;
			 } ; UCstrcat(UCTBUF1,UClit("\n")) ;  vout_UCTextFileX(filex,0,UCTBUF1) ;
		      } ;
		   }
		   if (rri->scale != 0) { v_Msg(ctx,UCTBUF1,"@SC%1d\n",rri->scale) ; vout_UCTextFileX(filex,0,UCTBUF1) ; } ;
		   rri->sheetInit = TRUE ;
		 } ;


	       if (pageBreak == DE(Before))
	        { 
	        } ;

/*	       Start of a new row */
		switch (rri->lineType)
		 { 
//		   case V4RPT_LineType_Footer:				/* Comment this out until we can figure out how to handle nested Enum( .... @Enum(.... End::xxxx) End::xxx) - can't have premature footer!! */
//			vout_UCTextFileX(filex,0,UClit("BSFOOTER\n")) ; break ;
		   case V4RPT_LineType_Default:
		   case V4RPT_LineType_Footer:
		   case V4RPT_LineType_Detail:
			vout_UCTextFileX(filex,0,(rri->lineType == V4RPT_LineType_Footer ? UClit("BSFooter\n") : UClit("BSR\n"))) ;
			if (UCnotempty(ifCond))
			 { UCstrcpy(UCTBUF1,UClit("IF")) ; UCstrcat(UCTBUF1,ifCond) ; vout_UCTextFileX(filex,0,UCTBUF1) ; vout_NLFileX(filex) ; } ;
			if (UCnotempty(rri->rowInfo))
			 { UCstrcpy(UCTBUF1,UClit("KE")) ; UCstrcat(UCTBUF1,rri->rowInfo) ; vout_UCTextFileX(filex,0,UCTBUF1) ; vout_NLFileX(filex) ; } ;
			break ;
		   case V4RPT_LineType_Heading:
			vout_UCTextFileX(filex,0,UClit("BSHeader\n")) ;
			if (UCnotempty(ifCond))
			 { UCstrcpy(UCTBUF1,UClit("IF")) ; UCstrcat(UCTBUF1,ifCond) ; vout_UCTextFileX(filex,0,UCTBUF1) ; vout_NLFileX(filex) ; } ;
			break ;
		   case V4RPT_LineType_Recap:	vout_UCTextFileX(filex,0,UClit("BSRECAP\n")) ; break ;
		 } ;
		if (rowLevel > 0)
		 { UCCHAR lbuf[16] ;
		   v_Msg(ctx,lbuf,"@LE%1d:%2d\n",rowLevel,(baf == NULL ? UNUSED : baf->CurCond)) ; vout_UCTextFileX(filex,0,lbuf) ; } ;
		switch (pageBreak)
		 { case _Before:	vout_UCTextFileX(filex,0,UClit("PBB\n")) ; break ;
		   case _After:		vout_UCTextFileX(filex,0,UClit("PBA\n")) ; break ;
		 } ;
//	       if (rri->nextKey != NULL ? UCnotempty(rri->nextKey) : FALSE)
//	        { UCstrcpy(UCTBUF1,UClit("KE")) ; UCstrcat(UCTBUF1,rri->nextKey) ; UCstrcat(UCTBUF1,UClit("\n")) ;
//		  vout_UCTextFileX(filex,0,UCTBUF1) ; ZUS(rri->nextKey) ;
//		} ;
	       for(cx=0;ok && cx<rri->numCols;cx+=(rri->col[cx].spanCol > 0 ? rri->col[cx].spanCol : 1))
		{ INDEX dimFX ;						/* Dimension format index */
		  PNTTYPE pntType ;					/* If not UNUSED then point type to override point type implied by dimension (for shell dimensions) */
		  LOGICAL didCell ;					/* TRUE after output of "BSCell" */
		  UCCHAR *pType ;
		  if (rri->col[cx].disable) continue ;			/* Skip disabled columns */
		  ipt = rri->col[cx].ptCol ;

		  outbuf = ASCTBUF1 ;
		  if (ipt == NULL ? TRUE : ipt->Bytes == 0)		/* If empty column write out empty string */
		   { 
		     vout_UCTextFileX(filex,0,UClit("BSC\n")) ;
		     continue ;
		   } ;
		  DIMINFO(di,ctx,(ipt->PntType == V4DPI_PntType_Isct ? Dim_Isct : ipt->Dim)) ;
if (di == NULL)
 { v_Msg(ctx,UCTBUF1,"@* Rpt(column #%1d) - value(%2P) has no dimension\n",cx+1,ipt) ;  vout_UCText(VOUT_Warn,0,UCTBUF1) ; } ;
/*		  If point has displayer then convert it as per displayer binding */
		  if (di == NULL ? FALSE : ((di->Flags & V4DPI_DimInfo_Displayer) != 0))
		   { P tpnt,*ipnt,dpnt ;
		     INITISCT(&tpnt) ; NOISCTVCD(&tpnt) ; tpnt.Grouping = 2 ;			/* Construct [UV4:Displayer ipt] intersection */
		     ipnt = ISCT1STPNT(&tpnt) ; dictPNTv(ipnt,Dim_UV4,v4im_GetEnumToDictVal(ctx,DE(Displayer),UNUSED)) ;
		     if (ipnt->Dim == 0 || ipnt->Value.IntVal == 0) goto no_displayer ;
		     ADVPNT(ipnt) ;
		     if (di->ADPnt.Bytes != 0)
		      { memcpy(ipnt,&di->ADPnt,di->ADPnt.Bytes) ; tpnt.Grouping ++ ; ADVPNT(ipnt) ;
		        memcpy(ipnt,ipt,ipt->Bytes) ; if (ipnt->PntType == V4DPI_PntType_Int) ipnt->Dim = Dim_Int ;
		      } else
		      { memcpy(ipnt,ipt,ipt->Bytes) ;  if (UCstrlen(di->IsA) > 0) ipnt->Dim = v4dpi_DimGet(ctx,di->IsA,DIMREF_IRT) ;
		      } ;
		     ipnt->Grouping = V4DPI_Grouping_Single ;
		     ADVPNT(ipnt) ; ISCTLEN(&tpnt,ipnt) ;
		     ipnt = v4dpi_IsctEval(&dpnt,&tpnt,ctx,V4DPI_EM_NoIsctFail,NULL,NULL) ;
		     if (ipnt != NULL) ipt = ipnt ;			/* If eval'd then use this ipt for display */
		   } ;
no_displayer:

		  didCell = FALSE ;
/*		  Do we have a URL link for this column ? */
/*		  Look to see if we have already sent the vfs for this cell */
		  if (vdfm == NULL)
		    { vdfm = (struct V4SS__DimToFormatMap *)v4mm_AllocChunk(sizeof *vdfm,TRUE) ; } ;
		  if (rri->col[cx].vfs != NULL)
		   { 
		     if (rri->col[cx].vfs->Length == 0)
		      rri->col[cx].vfs->Length = sizeof (struct V4SS__FormatSpec) - sizeof (rri->col[cx].vfs->VarString) ;
/*		     If we have OutFormat with this dimension and have not overridden it then inject it into column's format spec */
	             if (di == NULL ? FALSE : (UCnotempty(di->OutFormat) && rri->col[cx].vfs->MaskX == 0))
	              { v_ParseFormatSpecs(ctx,rri->col[cx].vfs,V4SS_FormatType_Mask,di->OutFormat) ;
	              } ;
/*		      Maybe make some last minute adjustments to vfs */
		     rri->col[cx].vfs->pntType = ipt->PntType ;
		     switch (ipt->PntType)
		      { default:			v_Msg(ctx,NULL,"RptInvPntType",intmodx,ipt,ipt->PntType,cx+1) ; goto rpt_fail ;
//			case V4DPI_PntType_MIDASUDT:
			case V4DPI_PntType_UDate: case V4DPI_PntType_UDT: case V4DPI_PntType_Calendar: 	case V4DPI_PntType_UYear: case V4DPI_PntType_Int: case V4DPI_PntType_Delta:
			case V4DPI_PntType_Logical: case V4DPI_PntType_Real: case V4DPI_PntType_BinObj:  case V4DPI_PntType_UOM: case V4DPI_PntType_UOMPer:
			case V4DPI_PntType_UTime: case V4DPI_PntType_UMonth: case V4DPI_PntType_UQuarter: case V4DPI_PntType_UPeriod: case V4DPI_PntType_UWeek:
			case V4DPI_PntType_List: case V4DPI_PntType_Dict: case V4DPI_PntType_XDict: case V4DPI_PntType_Char: case V4DPI_PntType_BigText:
			case V4DPI_PntType_TeleNum: case V4DPI_PntType_Shell: case V4DPI_PntType_Isct: case V4DPI_PntType_Country: case V4DPI_PntType_GeoCoord:
			case V4DPI_PntType_UCChar:
				break ;
		      } ;
		     if (rri->col[cx].spanCol != 0)
		      { switch (rri->col[cx].vfs->HAlign)
		         { default:			rri->col[cx].vfs->HAlign = V4SS_Align_MultiColCenter ; break ;
		           case V4SS_Align_MultiColLeft:
		           case V4SS_Align_Left:	rri->col[cx].vfs->HAlign = V4SS_Align_MultiColLeft ; break ;
		           case V4SS_Align_MultiColRight:
		           case V4SS_Align_Right:	rri->col[cx].vfs->HAlign = V4SS_Align_MultiColRight ; break ;
		           case V4SS_Align_MultiColCenter:
		           case V4SS_Align_Center:	rri->col[cx].vfs->HAlign = V4SS_Align_MultiColCenter ; break ;
		         } ;
		      } else if (rri->col[cx].vfs->HAlign == 0)
		      {


	switch (rri->col[cx].vfs->pntType)
	 { default:
	   case V4DPI_PntType_Char:
	   case V4DPI_PntType_UCChar:
	   case V4DPI_PntType_FChar:	rri->col[cx].vfs->HAlign = V4SS_Align_Left ; break ;
	   case V4DPI_PntType_UTime:
	   case V4DPI_PntType_UMonth:
	   case V4DPI_PntType_UDT:
	   case V4DPI_PntType_UPeriod:
	   case V4DPI_PntType_UQuarter:
	   case V4DPI_PntType_UWeek:
	   case V4DPI_PntType_Calendar:
	   case V4DPI_PntType_UYear:
	   case V4DPI_PntType_Delta:
	   case V4DPI_PntType_Time:
	   case V4DPI_PntType_Int:
	   case V4DPI_PntType_Real:
	   case V4DPI_PntType_Fixed:	rri->col[cx].vfs->HAlign = V4SS_Align_Right ; break ;
	   case V4DPI_PntType_Logical:	rri->col[cx].vfs->HAlign = V4SS_Align_Center ; break ;
	 } ;


		      } ;

		     for(dimFX=0;dimFX<vdfm->Count;dimFX++)
		      { if (memcmp(vdfm->vfs[dimFX],rri->col[cx].vfs,rri->col[cx].vfs->Length) == 0) break ;
		      } ;
		     if (dimFX >= vdfm->Count)				/* A new one - have to send it */
		      { if(vdfm->Count >= V4SS__DimToFormat_Max) vdfm->Count = V4SS__DimToFormat_Max - 1 ;
		        vdfm->vfs[vdfm->Count] = (struct V4SS__FormatSpec *)v4mm_AllocChunk(sizeof *vdfm->vfs[0],FALSE) ;
		        *vdfm->vfs[vdfm->Count] = *rri->col[cx].vfs ; vdfm->dimIdList[vdfm->Count] = UNUSED ;
			if (!v4rh_FormatSpecToNewV4R(ctx,vdfm->Count,ipt->PntType,vdfm->vfs[vdfm->Count],filex,!rri->didCountryLanguage))
			 { v_Msg(ctx,NULL,"@%1E Invalid point (%2P) type (%3d) column (%4d) dimension (%5D)",intmodx,ipt,ipt->PntType,cx,ipt->Dim) ; goto rpt_fail ; } ;
		        rri->didCountryLanguage = TRUE ; dimFX = vdfm->Count ; vdfm->Count++ ;
		      } ;
/*		     Send format info before detail */
		   } else
		   { dimFX = UNUSED ;
		   } ;

		  
		  if (rri->col[cx].valURL != NULL ? (bytes = UCstrlen(rri->col[cx].valURL)) > 0 : FALSE)
		   { if (!didCell) { vout_UCTextFileX(filex,0,UClit("BSC\n")) ; didCell = TRUE ; } ;
		     if (rri->col[cx].valURL[0] == UClit('+'))
		      { if (rri->col[cx].valURL[1] >= UClit('0') && rri->col[cx].valURL[1] <= UClit('9') && (rri->col[cx].valURL[2] == UClit(',') || rri->col[cx].valURL[2] == UClit(':')))
		         { rri->col[cx].valURL[2] = UClit(':') ;
		           v_Msg(ctx,UCTBUF1,"@UR%1U\n",&rri->col[cx].valURL[1]) ;
		         } else
		         { v_Msg(ctx,UCTBUF1,"@UR1:%1U\n",&rri->col[cx].valURL[1]) ;
		         } ;
		      } else
		      { v_Msg(ctx,UCTBUF1,"@UR%1U\n",rri->col[cx].valURL) ;
		      } ;
		     vout_UCTextFileX(filex,0,UCTBUF1) ;
		     if (rri->col[cx].valTarget != NULL ? UCnotempty(rri->col[cx].valTarget) : FALSE)
		      { v_Msg(ctx,UCTBUF1,"@TA%1U\n",rri->col[cx].valTarget) ; vout_UCTextFileX(filex,0,UCTBUF1) ; } ;
		   } ;
		  if (rri->col[cx].valImage != NULL ? (bytes = UCstrlen(rri->col[cx].valImage)) > 0 : FALSE)
		   { if (!didCell) { vout_UCTextFileX(filex,0,UClit("BSC\n")) ; didCell = TRUE ; } ;
		     v_Msg(ctx,UCTBUF1,"@IM%1U\n",rri->col[cx].valImage) ;
		     vout_UCTextFileX(filex,0,UCTBUF1) ;
		   } ;
		  if (rri->col[cx].valNote != NULL ? (bytes = UCstrlen(rri->col[cx].valNote)) > 0 : FALSE)
		   { if (!didCell) { vout_UCTextFileX(filex,0,UClit("BSC\n")) ; didCell = TRUE ; } ;
		     v_Msg(ctx,UCTBUF1,"@NO%1U\n",rri->col[cx].valNote) ;
		     vout_UCTextFileX(filex,0,UCTBUF1) ;
		   } ;

	      if (ipt->PntType == V4DPI_PntType_Shell)
	       { ipt = (P *)&ipt->Value ; pntType = ipt->PntType ;
	       } else { pntType = UNUSED ; } ;
	      switch(ipt->PntType)
	       { case V4DPI_PntType_Dict:
		   if (memcmp(ipt,&protoNone,V4PS_Int) == 0) { ZUS(UCTBUF1) ; break ; } ;
		   if (memcmp(ipt,&protoQNone,V4PS_Int) == 0) { ipt = (P *)&protoNone ; } ;
	         default:
		 case V4DPI_PntType_Country:
		 case V4DPI_PntType_XDict:
		 case V4DPI_PntType_Time:
		 case V4DPI_PntType_UOM:
		 case V4DPI_PntType_UOMPer:
		 case V4DPI_PntType_UOMPUOM:
		   pType= UClit("A") ;
		   v4dpi_PointToString(UCTBUF1,ipt,ctx,V4DPI_FormatOpt_Echo) ;	/* Convert to printable format */
		   break ;
		 case V4DPI_PntType_UTime:
		 case V4DPI_PntType_Color:
		 case V4DPI_PntType_UWeek:
		 case V4DPI_PntType_UQuarter:
		 case V4DPI_PntType_UMonth:
		 case V4DPI_PntType_UPeriod:
/*		   If got special displayer then do it otherwise normal format to string */
		   if (!v4sxi_SpecialDisplayer(ctx,ipt,V4TMBufMax,UCTBUF1)) v4dpi_PointToString(UCTBUF1,ipt,ctx,V4DPI_FormatOpt_Echo) ;
		   pType = UClit("A") ;
		   break ;
		 case V4DPI_PntType_Logical:
		   if (v4sxi_SpecialDisplayer(ctx,ipt,V4TMBufMax,UCTBUF1)) break ;
		   UCsprintf(UCTBUF1,16,UClit("%d"),(ipt->Value.IntVal > 0)) ;
		   pType = UClit("L") ;
		   break ;
		 case V4DPI_PntType_UYear:			/* If special displayer then do it otherwise drop down */
		 case V4DPI_PntType_CodedRange:
		 case V4DPI_PntType_Int:
		 case V4DPI_PntType_IMArg:
		   if (v4sxi_SpecialDisplayer(ctx,ipt,V4TMBufMax,UCTBUF1)) break ;
		   UCsprintf(UCTBUF1,16,UClit("%d"),ipt->Value.IntVal) ;
		   pType = UClit("I") ;
		   break ;
		 case V4DPI_PntType_Calendar:
		   memcpy(&dnum,&ipt->Value.IntVal,sizeof dnum) ;
		   UCsprintf(UCTBUF1,32,UClit("%g"),dnum) ;
		   pType = UClit("D") ;
		   break ;
		 case V4DPI_PntType_UDate:
		   if (v4sxi_SpecialDisplayer(ctx,ipt,V4TMBufMax,UCTBUF1)) break ;
		   UCsprintf(UCTBUF1,32,UClit("%d"),UDtoCAL(ipt->Value.IntVal)) ;
		   pType = UClit("D") ;
		   break ;
		 case V4DPI_PntType_UDT:
		   if (v4sxi_SpecialDisplayer(ctx,ipt,V4TMBufMax,UCTBUF1)) break ;
		   UCsprintf(UCTBUF1,32,V4DPI_PntFormat_Real,UDTtoCAL(ipt->Value.IntVal)) ;
		   pType = UClit("D") ;
		   break ;
		 case V4DPI_PntType_Fixed:
		   memcpy(&b64,ipt->Value.FixVal,sizeof b64) ; UCsprintf(UCTBUF1,32,UClit("%dD%lld"),ipt->LHSCnt,b64) ;
		   pType = UClit("F") ;
		 case V4DPI_PntType_Real:
		   if (v4sxi_SpecialDisplayer(ctx,ipt,V4TMBufMax,UCTBUF1)) break ;
		   GETREAL(dnum,ipt) ;
		   UCsprintf(UCTBUF1,100,V4DPI_PntFormat_Real,dnum) ;
		   pType = UClit("R") ;
		   break ;
		 case V4DPI_PntType_BigText:
		 case V4DPI_PntType_UCChar:
		 case V4DPI_PntType_Char:		/* Alpha unless starts with "=" then make a formula */
		 case V4DPI_PntType_URL:
		   v4im_GetPointUC(&ok,UCTBUF1,V4TMBufMax,ipt,ctx) ;
		   if (!ok) { strcpy(outbuf,"*invBigText*") ; } ;
		   pType = UClit("A") ;
		   break ;
		   break ;
		 case V4DPI_PntType_FChar:
		   break ;
		 case V4DPI_PntType_SSVal:
		   if (ipt->Bytes == V4PS_Int)		/* Do we have value or format? */
		    { UCsprintf(UCTBUF1,16,UClit("%d"),ipt->Value.IntVal) ; pType = UClit("X") ; }
		    else { v_Msg(ctx,NULL,"RptOptNYI",intmodx) ; goto rpt_fail ; } ;
		   break ;
	       } ;
/*		UCTBUF1 has data to be sent, dimFX (if not UNUSED) set to SSDim index, pType is default point type */
	       { INDEX colSpan = UNUSED ; UCCHAR *tc,*lType,*cv,*fv ;
	         lType = UClit("CV") ; cv = UCTBUF1 ; fv = NULL ;
	         if (cv[0] == UClit('{')) { colSpan = UCstrtol(&cv[1],&tc,10) ; cv = tc + 1 ; }
	          else if (rri->col[cx].spanCol > 0) { colSpan = rri->col[cx].spanCol ; }
	          else { colSpan = UNUSED ; } ;
		 if (colSpan > 0)
		  { if (!didCell) { vout_UCTextFileX(filex,0,UClit("BSC\n")) ; didCell = TRUE ; } ;
		    v_Msg(ctx,UCTBUF2,"@SP%1d\n",colSpan) ; vout_UCTextFileX(filex,0,UCTBUF2) ;
		  } ;
		 if (cv[0] == UClit('='))	/* Have a formula ? */
		  { fv = &cv[1] ;		/* Make everything after '=' the formula */
		    cv = UCstrchr(fv,'\t') ;	/* If we have a tab then anything after tab is actual cell value (to show if we are not going to Excel */
		    if (cv != NULL) { *cv = UCEOS ; cv++  ; } ;
		  } ;
		 if (fv != NULL)
		  { if (!didCell) { vout_UCTextFileX(filex,0,UClit("BSC\n")) ; didCell = TRUE ; } ;
		    if (dimFX != UNUSED)
		     { v_Msg(ctx,UCTBUF2,"@EX%1d:%2U\n",dimFX+V4SS__DimOffsetForV4RPP,fv) ;  vout_UCTextFileX(filex,0,UCTBUF2) ;
		     } else
		     { v_Msg(ctx,UCTBUF2,"@EX%1U:%2U\n",pType,fv) ;  vout_UCTextFileX(filex,0,UCTBUF2) ;
		     } ;
		  } ;
		 if (cv != NULL)
		  { UCCHAR *prefix, *ub, *eb ; LENMAX ol ;
		    prefix = (didCell ? UClit("CV") : UClit("BSC ")) ;		/* If have not yet output BSCell then do value & BS on same line */
		    ol = UCstrlen(cv) ;
/*		    If last character is '\' then append a space so v4rpp does not think that the line is continued onto the next */
		    if (cv[ol-1] == UClit('\\'))
		     { cv[ol] = UClit(' ') ; cv[ol+1] = UCEOS ; } ; 
/*		     We may have to output multiple lines if output has embedded newline */
		     for(ub=cv;;ub=eb+1)
		      { 
//		       eb = UCstrchr(ub,'\012') ; if (eb != NULL) *eb = UCEOS ;
		       eb = UCstrpbrk(ub,UClit("\r\n")) ; if (eb != NULL) *eb = UCEOS ;
		        if (ub == cv)		/* Is this the first line? */
			 { 
			   if (pntType != UNUSED)
			    { if (dimFX != UNUSED)
			       { v_Msg(ctx,UCTBUF2,"@%1U%2d.%3d:%4U%5U\n",prefix,dimFX+V4SS__DimOffsetForV4RPP,pntType,ub,(eb == NULL ? UClit("") : UClit("\\"))) ;  vout_UCTextFileX(filex,0,UCTBUF2) ;
			       } else
			       { v_Msg(ctx,UCTBUF2,"@%1U%2U.%3d:%4U%5U\n",prefix,pType,pntType,ub,(eb == NULL ? UClit("") : UClit("\\"))) ;  vout_UCTextFileX(filex,0,UCTBUF2) ;
			       } ;
			    } else
			    {
			      if (dimFX != UNUSED)
			       { v_Msg(ctx,UCTBUF2,"@%1U%2d:%3U%4U\n",prefix,dimFX+V4SS__DimOffsetForV4RPP,ub,(eb == NULL ? UClit("") : UClit("\\"))) ;  vout_UCTextFileX(filex,0,UCTBUF2) ;
			       } else
			       { v_Msg(ctx,UCTBUF2,"@%1U%2U:%3U%4U\n",prefix,pType,ub,(eb == NULL ? UClit("") : UClit("\\"))) ;  vout_UCTextFileX(filex,0,UCTBUF2) ;
			       } ;
			    } ;
			 } else
			 { v_Msg(ctx,UCTBUF2,"@%1U%2U\n",ub,(eb == NULL ? UClit("") : UClit("\\"))) ;  vout_UCTextFileX(filex,0,UCTBUF2) ;
			 } ;
		        if (eb == NULL) break ;
		      } ;
		  } ;
	       }
		} ;

	     }











	     break ;
	   case V4RPT_Type_Tab:
	     switch (rri->lineType)
	      {
		case V4RPT_LineType_Heading:
		case V4RPT_LineType_Detail:
		case V4RPT_LineType_Recap:
		case V4RPT_LineType_Footer:
		   { LOGICAL didOut ;
		     for(cx=0,didOut=FALSE;ok && cx<rri->numCols;cx++)
		      { if (rri->col[cx].disable) continue ;			/* Skip disabled columns */
		        if (didOut) { ok = vout_UCTextFileX(filex,0,UClit("\t")) ; } ;
		        if (ok && (rri->col[cx].ptCol != NULL ? rri->col[cx].ptCol->Bytes > 0 : FALSE)) v4im_GetPointUC(&ok,UCTBUF1,V4TMBufMax,rri->col[cx].ptCol,ctx) ;
		        FIXCONTROLCHARS(UCTBUF1) ;
		        ok = vout_UCTextFileX(filex,0,UCTBUF1) ; didOut = TRUE ;
		      } ;
		     if (ok) { ok = vout_UCTextFileX(filex,0,UClit("\n")) ; } ;
		     if (!ok) { v_Msg(ctx,NULL,"OutputErr",intmodx) ; goto rpt_fail ; } ;
		   }
		   rri->dtlLines++ ; break ;
	      } ; break ;
	   case V4RPT_Type_CSV:
	     switch (rri->lineType)
	      {
		case V4RPT_LineType_Heading:
		case V4RPT_LineType_Detail:
		case V4RPT_LineType_Recap:
		case V4RPT_LineType_Footer:
		   { LOGICAL didOut ;
		     for(cx=0,didOut=FALSE;ok && cx<rri->numCols;cx++)
		      { if (rri->col[cx].disable) continue ;			/* Skip disabled columns */
		        if (didOut) { ok = vout_UCTextFileX(filex,0,UClit(",")) ; } ;
		        if (ok && (rri->col[cx].ptCol != NULL ? rri->col[cx].ptCol->Bytes > 0 : FALSE)) v4im_GetPointUC(&ok,UCTBUF1,V4TMBufMax,rri->col[cx].ptCol,ctx) ;
			FIXCONTROLCHARS(UCTBUF1) ;
/*			Check to see if any embedded commas or double quotes in this string */
			uc = UCstrpbrk(UCTBUF1,UClit(",\"' ")) ;
			if (uc == NULL) { ok = vout_UCTextFileX(filex,0,UCTBUF1) ; didOut = TRUE ; continue ; }
/*			Have to do a little work to fix up this string for legal CSV */
			v_StringLit(UCTBUF1,UCTBUF2,V4TMBufMax,UClit('"'),UClit('"')) ;
		        ok = vout_UCTextFileX(filex,0,UCTBUF2) ; didOut = TRUE ;
		      } ;
		     if (ok) { ok = vout_UCTextFileX(filex,0,UClit("\n")) ; } ;
		     if (!ok) { v_Msg(ctx,NULL,"OutputErr",intmodx) ; goto rpt_fail ; } ;
		   }
		   rri->dtlLines++ ; break ;
	      } ; break ;
	   case V4RPT_Type_HTML:
	     { UCCHAR rowTag[20], cellTag[20] ;
	       switch (rri->lineType)
	        {
		  case V4RPT_LineType_Heading:
			rri->hdrLines++ ;
			UCstrcpy(rowTag,UClit("thead")) ; UCstrcpy(cellTag,UClit("th")) ; break ;
		  case V4RPT_LineType_Detail:
			rri->dtlLines++ ;
		  case V4RPT_LineType_Recap:
			UCstrcpy(rowTag,UClit("tr")) ; UCstrcpy(cellTag,UClit("td")) ; break ;
		  case V4RPT_LineType_Footer:
			UCstrcpy(rowTag,UClit("tr")) ; UCstrcpy(cellTag,UClit("td")) ; break ;
		} ;
	       ZUS(UCTBUF1) ; for(i=rri->htmlCount;i>=0;i--) { UCstrcat(UCTBUF1,UClit(" ")) ; } ;
	       UCstrcat(UCTBUF1,UClit("<")) ; UCstrcat(UCTBUF1,rowTag) ;
	       switch (pageBreak)
	        { case DE(Before):	UCstrcat(UCTBUF1,UClit(" style='page-break-before: always'")) ; break ;
	          case DE(After):	UCstrcat(UCTBUF1,UClit(" style='page-break-after: always'")) ; break ;
	        }
	       UCstrcat(UCTBUF1,UClit(">\n")) ; if (ok) { ok = vout_UCTextFileX(filex,0,UCTBUF1) ; } ;
	       for(cx=0;ok && cx<rri->numCols;cx+=(rri->col[cx].spanCol > 0 ? rri->col[cx].spanCol : 1))
	        { LOGICAL coldef,nobr = FALSE ;
		  if (rri->col[cx].disable) continue ;			/* Skip disabled columns */
		  UCstrcpy(UCTBUF1,UClit(" ")) ; for(i=rri->htmlCount;i>=0;i--) { UCstrcat(UCTBUF1,UClit(" ")) ; } ;
		  UCstrcat(UCTBUF1,UClit("<")) ; UCstrcat(UCTBUF1,cellTag) ;
		  coldef = (rri->col[cx].ptCol == NULL ? FALSE : rri->col[cx].ptCol->Dim != 0) ;
		  if (!coldef) v4im_RptContext(ctx,rri,cx,UNUSED,NULL,NULL) ;		/* If column not defined then still have to get formatting info */
		  if (rri->col[cx].vfs != NULL)
		   { struct V4SS__FormatSpec *vfs = rri->col[cx].vfs ; nobr = vfs->FontAttr & V4SS_Font_NoBreak ;
/*		     If no alignment defined then take default from column heading */
		     if (rri->lineType == V4RPT_LineType_Heading)
		      { rri->col[cx].dfltAlign = vfs->HAlign ; 
		      } else
		      { if (vfs->HAlign == 0) vfs->HAlign = rri->col[cx].dfltAlign ; } ;
		     if (vfs->CSSId != 0) { UCstrcat(UCTBUF1,UClit(" id='")) ; UCstrcat(UCTBUF1,ASCretUC(&vfs->VarString[vfs->CSSId-1])) ; UCstrcat(UCTBUF1,UClit("'")) ; } ;
		     if (vfs->CSSClass != 0) { UCstrcat(UCTBUF1,UClit(" class='")) ; UCstrcat(UCTBUF1,ASCretUC(&vfs->VarString[vfs->CSSClass-1])) ; UCstrcat(UCTBUF1,UClit("'")) ; } ;
		     v4rpt_vfsToCSS(ctx,vfs,UCTBUF2) ;
		     if (UCstrlen(UCTBUF2) > 0) { UCstrcat(UCTBUF1,UClit(" style='")) ; UCstrcat(UCTBUF1,UCTBUF2) ; UCstrcat(UCTBUF1,UClit("'")) ; } ;
		   } ;
		  if (rri->col[cx].spanCol != 0)
		   { v_Msg(ctx,UCTBUF2,"@ colspan='%1d'",rri->col[cx].spanCol) ; UCstrcat(UCTBUF1,UCTBUF2) ;
		   } ;
		  UCstrcat(UCTBUF1,UClit(">")) ;
		  if (rri->col[cx].valURL == NULL ? FALSE : UCstrlen(rri->col[cx].valURL) > 0)
		   { UCstrcat(UCTBUF1,UClit("<a href='")) ;
/*		     If URL begins with '+' then look for '+d,' where d is digit 0-9 representing URLBase indexes '0'=9, '1'=0, '2'=1, ... '9'=8 */
		     if (rri->col[cx].valURL[0] != UClit('+'))
		      { UCstrcat(UCTBUF1,rri->col[cx].valURL) ;
		      } else
		      { INDEX bx = 0 ; UCCHAR *bu ;
		        if (rri->col[cx].valURL[2] == UClit(',') && rri->col[cx].valURL[1] >= UClit('0') && rri->col[cx].valURL[1] <= UClit('9'))
		         { bx = (rri->col[cx].valURL[1] == UClit('0') ? 9 : rri->col[cx].valURL[1] - UClit('1')) ;
		           bu = &rri->col[cx].valURL[3] ;
		         } else { bu = &rri->col[cx].valURL[1] ; } ;
		        if (rri->urlBase[bx] != NULL) { UCstrcat(UCTBUF1,rri->urlBase[bx]) ; } ;
		        UCstrcat(UCTBUF1,bu) ;
		      } ; UCstrcat(UCTBUF1,UClit("'>")) ;
		   } ;
		  if (nobr) UCstrcat(UCTBUF1,UClit("<nobr>")) ;
		  
		  if (!coldef) { UCstrcat(UCTBUF1,UClit("&nbsp;")) ; }
		   else { UCCHAR *format = (rri->col[cx].vfs == NULL ? NULL : (rri->col[cx].vfs->MaskX == 0 ? NULL : ASCretUC(&rri->col[cx].vfs->VarString[rri->col[cx].vfs->MaskX-1]))) ;
			  double dnum ; UCCHAR fldColor[64] ;
			  ZUS(fldColor) ;
			  switch (format == NULL ? UNUSED : rri->col[cx].ptCol->PntType)
			   { default:
				v4im_GetPointUC(&ok,UCTBUF2,V4TMBufMax,rri->col[cx].ptCol,ctx) ; break ;
			     case V4DPI_PntType_Int:
				v_FormatInt(rri->col[cx].ptCol->Value.IntVal,format,UCTBUF2,fldColor) ;
				break ;
			     case V4DPI_PntType_Real:
				GETREAL(dnum,rri->col[cx].ptCol) ; v_FormatDbl(dnum,format,UCTBUF2,fldColor) ;
				break ;
			     case V4DPI_PntType_UDate:
				i = v_FormatDate(&rri->col[cx].ptCol->Value.IntVal,rri->col[cx].ptCol->PntType,VCAL_CalType_UseDeflt,VCAL_TimeZone_Local,format,UCTBUF2) ;
				break ;
			   } ;
			  if (UCstrlen(fldColor) > 0)
			   { UCstrcat(UCTBUF1,UClit("<span style='color:")) ; UCstrcat(UCTBUF1,fldColor) ; UCstrcat(UCTBUF1,UClit(";'>")) ; } ;
/*			  UCTBUF2 has value to append into UCTBUF1, first check for any '\$' and substitute in HTML entries */
			  for(i=0,uc=UCTBUF2;;i++)
			   { UCCHAR *b1 ;
			     if ((b1=UCstrchr(uc,'\033')) != NULL)
			      { *b1 = UCEOS ; UCstrcat(UCTBUF1,uc) ; if (i < rri->embedCount) UCstrcat(UCTBUF1,rri->embedVal[i]) ; uc = b1 + 1 ; continue ; } ;
			     UCstrcat(UCTBUF1,uc) ; break ;
			   } ;
			  if (UCstrlen(fldColor) > 0) { UCstrcat(UCTBUF1,UClit("</span>")) ; } ;
			} ;
		  
		  
		  
		  
		  if (nobr) UCstrcat(UCTBUF1,UClit("</nobr>")) ;
		  if (rri->col[cx].valURL != NULL) { UCstrcat(UCTBUF1,UClit("</a>")) ; } ;
		  UCstrcat(UCTBUF1,UClit("</")) ; UCstrcat(UCTBUF1,cellTag) ; UCstrcat(UCTBUF1,UClit(">\n")) ;
		  ok = vout_UCTextFileX(filex,0,UCTBUF1) ;
		} ;
	       ZUS(UCTBUF1) ; for(i=rri->htmlCount;i>=0;i--) { UCstrcat(UCTBUF1,UClit(" ")) ; } ;
	       UCstrcat(UCTBUF1,UClit("</")) ; UCstrcat(UCTBUF1,rowTag) ; UCstrcat(UCTBUF1,UClit(">\n")) ; if (ok) { ok = vout_UCTextFileX(filex,0,UCTBUF1) ; } ;
	       if (!ok) { v_Msg(ctx,NULL,"OutputErr",intmodx) ; goto rpt_fail ; } ;
	     }
	     break ;
	   case V4RPT_Type_XML:
	     { UCCHAR *levelTag ;
	       if (UCempty(segName)) break ;	/* Don't do XML if segment has no name */
	       levelTag = (segName[0] != 1 ? segName : NULL) ;
	       if (levelTag == NULL)
	        { switch (rri->lineType)
	           { case V4RPT_LineType_Heading:	levelTag = UClit("Heading") ; break ;
		     case V4RPT_LineType_Detail:	levelTag = UClit("Detail") ; break ;
		     case V4RPT_LineType_Recap:		levelTag = UClit("Reacp") ; break ;
		     case V4RPT_LineType_Footer:	levelTag = UClit("Footer") ; break ;
		   } ;
	        } ;
	       ZUS(UCTBUF1) ; for(i=0;i<rri->xmlCount+1+(rri->sheetCount>0);i++) { UCstrcat(UCTBUF1,UClit(" ")) ; } ;
	         UCstrcat(UCTBUF1,UClit("<")) ; UCstrcat(UCTBUF1,levelTag) ; UCstrcat(UCTBUF1,UClit(">\n")) ;
	         ok = vout_UCTextFileX(filex,0,UCTBUF1) ;
	       for(cx=0;ok && cx<rri->numCols;cx++)
	        { if (rri->col[cx].disable) continue ;			/* Skip disabled columns */
	          ZUS(UCTBUF1) ; for(i=0;i<rri->xmlCount+2+(rri->sheetCount>0);i++) { UCstrcat(UCTBUF1,UClit(" ")) ; } ;
	          if (rri->col[cx].xmlName == NULL) { v4dpi_PointToString(UCTBUF2,(P *)&rri->col[cx].idCol,ctx,V4DPI_FormatOpt_Echo) ; rri->col[cx].xmlName = v4rpt_AllocUC(rri,UCstrlen(UCTBUF2),27) ; UCstrcpy(rri->col[cx].xmlName,UCTBUF2) ; } ;
	          UCstrcat(UCTBUF1,UClit("<")) ; UCstrcat(UCTBUF1,(rri->col[cx].xmlName)) ; UCstrcat(UCTBUF1,UClit(">")) ;
	          if (rri->col[cx].ptCol == NULL ? FALSE : rri->col[cx].ptCol->Dim != 0)
	           { v4im_GetPointUC(&ok,UCTBUF2,V4TMBufMax,rri->col[cx].ptCol,ctx) ; FIXCONTROLCHARS(UCTBUF2) ; UCstrcat(UCTBUF1,UCTBUF2) ; } ;
	          UCstrcat(UCTBUF1,UClit("</")) ; UCstrcat(UCTBUF1,rri->col[cx].xmlName) ; UCstrcat(UCTBUF1,UClit(">\n")) ;
	          ok = vout_UCTextFileX(filex,0,UCTBUF1) ;
	        } ;
	       ZUS(UCTBUF1) ; for(i=0;i<rri->xmlCount+1+(rri->sheetCount>0);i++) { UCstrcat(UCTBUF1,UClit(" ")) ; } ;
	         UCstrcat(UCTBUF1,UClit("</")) ; UCstrcat(UCTBUF1,levelTag) ; UCstrcat(UCTBUF1,UClit(">\n")) ;
	         if (ok) { ok = vout_UCTextFileX(filex,0,UCTBUF1) ; } ;
	       if (!ok) { v_Msg(ctx,NULL,"OutputErr",intmodx) ; goto rpt_fail ; } ;
	     }
	     break ;
	 } ;
/*	Clear out all points for next row */
	for(cx=0;cx<rri->numCols;cx++)
	 { if (rri->col[cx].ptCol != NULL) ZPH(rri->col[cx].ptCol) ;
	   if (rri->col[cx].valURL != NULL) { ZUS(rri->col[cx].valURL) ; } ;
	   if (rri->col[cx].valNote != NULL) { ZUS(rri->col[cx].valNote) ; } ;
	   if (rri->col[cx].valImage != NULL) { ZUS(rri->col[cx].valImage) ; } ;
	 } ;
	rri->embedCount = 0 ;

	return((P *)&Log_True) ;			/*  & return as value */
rpt_fail:
	REGISTER_ERROR(0) ; return(NULL) ;
}

LOGICAL v4rh_FormatSpecToNewV4R(ctx,dimNum,pntType,vfs,filex,first)
  struct V4C__Context *ctx ;
  INDEX dimNum ;
  PNTTYPE pntType ;
  struct V4SS__FormatSpec *vfs ;
  INDEX filex ;
  LOGICAL first ;				/* TRUE if first time for this v4r */
{
  UCCHAR out[1024] ;
  
#define V4ROUT vout_UCTextFileX(filex,0,out)
#define V4ROUTL(LITERAL) vout_UCTextFileX(filex,0,ASCretUC(LITERAL))

	V4ROUTL("BSFormat\n") ;
	if (first)
	 { UCsprintf(UCTBUF1,100,UClit("LA%d"),gpi->ci->Cntry[gpi->ci->CurX].UNCode) ; vout_UCTextFileX(filex,0,UCTBUF1) ; vout_NLFileX(filex) ; } ;
/*	Format should start with PT (alignment is defaulted based on this) We can override default later on if this is handled first */
	v_Msg(ctx,out,"@PT%1d\n",pntType) ; V4ROUT ;
	if (vfs->BgColor != 0) { char cbuf[16] ; sprintf(cbuf,"%06x",v_ColorRefToRGB(vfs->BgColor)) ; v_Msg(ctx,out,"@BK#%1s\n",cbuf) ; V4ROUT ; } ;
#define BORDER(TYPE) case V4SS_Border_##TYPE:	V4ROUTL("BO" #TYPE "\n") ; break ;
	switch (vfs->LBorderColor)
	 { BORDER(Dashed) BORDER(Dotted) BORDER(Double) BORDER(Hairline) BORDER(Medium) BORDER(Thick) BORDER(Thin)
	 } ;
#define CHARATTR(TYPE) if (vfs->FontAttr & V4SS_Font_##TYPE) { V4ROUTL("CA" #TYPE "\n") ; } ;
	CHARATTR(Bold) CHARATTR(Italic) CHARATTR(Outline) CHARATTR(Shadow) CHARATTR(SubScript) CHARATTR(SuperScript) CHARATTR(StrikeThru)
	if (vfs->CSSStyle != 0)
	 { v_Msg(ctx,out,"@CS%1s\n",&vfs->VarString[vfs->CSSStyle-1]) ; V4ROUT ; } ;
	v_Msg(ctx,out,"@DI%1d\n",dimNum+V4SS__DimOffsetForV4RPP) ; V4ROUT ;
	if (vfs->MaskX != 0)	
	 { v_Msg(ctx,out,"@FM%1s\n",&vfs->VarString[vfs->MaskX-1]) ; V4ROUT ; } ;
	if (vfs->FontFamily != 0)	
	 { v_Msg(ctx,out,"@FO%1s\n",&vfs->VarString[vfs->FontFamily-1]) ; V4ROUT ; } ;
	if (vfs->FontSize != 0)
	 { v_Msg(ctx,out,"@FS%1d\n",vfs->FontSize) ; V4ROUT ; } ;
#define HA(TYPE) case V4SS_Align_##TYPE: V4ROUTL("HA" #TYPE "\n") ; break ;
	switch (vfs->HAlign)
	 { HA(Center) HA(Fill) HA(Justify) HA(Left) HA(Right) ; HA(Indent1) ; HA(Indent2) ; HA(Indent3) ;
	   case V4SS_Align_MultiColLeft:	 V4ROUTL("HALeft\n") ; break ;
	   case V4SS_Align_MultiColRight:	 V4ROUTL("HARight\n") ; break ;
	   case V4SS_Align_MultiColCenter:	 V4ROUTL("HACenter\n") ; break ;
	 } ;
//	Id
//	CL html class
	if (vfs->FontColor != 0)
	 { char cbuf[16] ;
	   sprintf(cbuf,"%06x",v_ColorRefToRGB(vfs->FontColor)) ;
	   v_Msg(ctx,out,"@TC#%1s\n",cbuf) ; V4ROUT ; } ;
	switch (vfs->FontULStyle)
	 { case V4SS_ULStyle_Single: V4ROUTL("UL1\n") ; break ;
	   case V4SS_ULStyle_Double: V4ROUTL("UL2\n") ; break ;
	 } ;
#define VA(TYPE) case V4SS_Align_##TYPE: V4ROUTL("VA" #TYPE "\n") ; break ;
	switch (vfs->HAlign)
	 { VA(Bottom) VA(Top) VA(Center)
	 } ;
#define WRAPATTR(TYPE) if (vfs->FontAttr & V4SS_Font_##TYPE) { V4ROUTL("WA" #TYPE "\n") ; } ;
	WRAPATTR(NoBreak) WRAPATTR(SizeToFit) WRAPATTR(Wrap)
	if  (vfs->Width != 0)
	 { v_Msg(ctx,out,"@WI%1d\n",vfs->Width) ; V4ROUT ; } ;
	return(TRUE) ;
}

P *v4im_DoEchoS(ctx,respnt,argpnts,argcnt,intmodx)
  struct V4C__Context *ctx ;
  P *respnt ;						/* Ptr for result */
  INTMODX intmodx ;
  P *argpnts[] ;
  COUNTER argcnt ;
{
  struct V4IM__BaA *baf ;
  P *ipt,*cpt ;
  P isctbuf,ptbuf ;
  struct V4DPI__DimInfo *di ;
  struct UC__File UCFile ;
  struct V4L__ListPoint *lp ;
  enum DictionaryEntries deval ;
  int resdim, ok, num, ix, bx, i, j, k, argok, rcv, filex, type ; PNTTYPE pntType ;
  double dnum ; B64INT b64 ;
  char tb[255],*b ; char outbuf[V4TMBufMax] ;
  INDEX dimFX ; UCCHAR *pType ;
  LOGICAL didRow ;	/* Set to TRUE after "BSRow\n" is output */
  LOGICAL didCell ;	/* Set to TRUE after "BSCell\n" is output */

#define DOROW if (!didRow) { didRow = TRUE ;  vout_UCTextFileX(filex,0,UClit("BSR\n")) ; } ;
#define DOCELL if (!didCell) { didCell = TRUE ;  vout_UCTextFileX(filex,0,UClit("BSC\n")) ; } ;

	baf = v4ctx_FrameBaAInfo(ctx) ;				/* Doing totals? */
	resdim = 0 ; ok = TRUE ; rcv = UNUSED ;			/* Set to Dim if we get Count::xxx */
	filex = vout_StreamToFileX(VOUT_Data) ;
	didRow = FALSE ; didCell = FALSE ;
	if (vdfm == NULL ? FALSE : vdfm->RevLevel > vdfm->xmitRevLevel)
	{ struct V4DPI__DimInfo *di ;
	  for(i=0;i<vdfm->Count;i++)				/* If SSDim updated then have to dump out to target spreadsheet */
	   { if (vdfm->dimIdList[i] == UNUSED) continue ;	/* If UNUSED then already called v4rh_FormatSpecToNewV4R for this entry */
	     DIMINFO(di,ctx,vdfm->dimIdList[i]) ; v4rh_FormatSpecToNewV4R(ctx,i,di->PointType,vdfm->vfs[i],filex,TRUE) ;
	   } ;
	  vdfm->xmitRevLevel = vdfm->RevLevel ;
	} ;
	for(num=0,ix=1,argok=TRUE;argok&&ix<=argcnt;ix++)
	 {
//	   ipt = argpnts[ix] ;
/*	   EchoS does not preevaluate arguments (as of 9/9/09) */
	   ipt = v4dpi_IsctEval(respnt,argpnts[ix],ctx,V4DPI_EM_EvalQuote,NULL,NULL) ;
	   if (ipt == NULL) { v_Msg(ctx,NULL,"ModArgEval",intmodx,ix,argpnts[ix]) ; goto echos_fail ; } ;
	   if (memcmp(ipt,&protoNone,V4PS_Int) == 0) continue ;	/* Don't format UV4:none point */
	   if (ipt->PntType != V4DPI_PntType_List) { lp = NULL ; }
	    else { lp = ALIGNLP(&ipt->Value) ; } ;
	   for(j=1;;j++)
	    { if (lp != NULL)
	       { if (v4l_ListPoint_Value(ctx,lp,j,&isctbuf) < 1) break ;
		 ipt = &isctbuf ;
	       } ;
	      if (ipt->PntType == V4DPI_PntType_TagVal)
	       { switch (v4im_CheckPtArgNew(ctx,ipt,&cpt,&ptbuf))
		  { default:			v_Msg(ctx,NULL,"TagBadUse",intmodx) ; goto echos_fail ;
		    case V4IM_Tag_Unk:		v_Msg(ctx,NULL,"TagUnknown",intmodx) ; goto echos_fail ;
		    case V4IM_Tag_If:		ok = v4im_GetPointInt(&argok,cpt,ctx) ; break ;
		    case V4IM_Tag_Out:
			filex = vout_PntIdToFileX(ctx,(struct V4DPI__LittlePoint *)cpt) ;
			if (filex == UNUSED) { v_Msg(ctx,NULL,"StreamNoOutput",intmodx,V4IM_Tag_Out,cpt) ; goto echos_fail ; } ;
			break ;
		    case V4IM_Tag_RCV:
			rcv = v4im_GetPointLog(&argok,cpt,ctx) ; break ;
		    case V4IM_Tag_Echo:
			break ;
		    case V4IM_Tag_PageBreak:
			vout_UCTextFileX(filex,0,UClit("PBA\n")) ;
			break ;
		    case V4IM_Tag_Include:		/* Include::filename */
			if (gpi->RestrictionMap & V_Restrict_FileRead) { v_Msg(ctx,NULL,"RestrictMod",intmodx) ; goto echos_fail ; } ;
			v4im_GetPointFileName(&argok,UCTBUF1,V4TMBufMax,cpt,ctx,NULL) ; if (!argok) break ;
			if (!v_UCFileOpen(&UCFile,UCTBUF1,UCFile_Open_ReadBin,TRUE,ctx->ErrorMsgAux,intmodx))
			  { v_Msg(ctx,NULL,"EchoSInclude",intmodx,V4IM_Tag_Include,UCTBUF1) ; goto echos_fail ; } ;
			v_Msg(ctx,UCTBUF2,"@BSMeta\nIN%1U\n",UCTBUF1) ; vout_UCTextFileX(filex,0,UCTBUF2) ;
			break ;
		    case V4IM_Tag_End:
			v4im_GetPointUC(&argok,UCTBUF1,V4TMBufMax,cpt,ctx) ; if (!argok) break ;
			{ UCCHAR *ub, *eb ;
			  for(ub=UCTBUF1;;ub=eb+1)
			   { eb = UCstrchr(ub,'\012') ; if (eb != NULL) *eb = UCEOS ;
			     v_Msg(ctx,UCTBUF2,"@TI%1U\n",ub) ; vout_UCTextFileX(filex,0,UCTBUF2) ;
			     if (eb == NULL) break ;
			   } ;
			  vout_UCTextFileX(filex,0,UClit("BSEOF\n")) ;
			}
			break ;
		    case V4IM_Tag_Id:
			v4im_GetPointChar(&argok,outbuf,V4TMBufMax,cpt,ctx) ; if (!argok) break ;
			v_Msg(ctx,UCTBUF1,"@BSMeta\nId%1s\n",outbuf) ; vout_UCTextFileX(filex,0,UCTBUF1) ;
			break ;
		    case V4IM_Tag_Grid:
			v4im_GetPointChar(&argok,outbuf,V4TMBufMax,cpt,ctx) ; if (!argok) break ;
			v_Msg(ctx,UCTBUF1,"@SG%1s\n",outbuf) ; vout_UCTextFileX(filex,0,UCTBUF1) ;
			break ;
		    case V4IM_Tag_ColCap:
			bx = v4im_GetPointInt(&argok,cpt,ctx) ;
			v_Msg(ctx,UCTBUF1,"@CC%1d\n",bx) ; vout_UCTextFileX(filex,0,UCTBUF1) ;
			break ;
		    case V4IM_Tag_RowCap:
			DOROW
			bx = v4im_GetPointInt(&argok,cpt,ctx) ;
			v_Msg(ctx,UCTBUF1,"@RC%1d\n",bx) ; vout_UCTextFileX(filex,0,UCTBUF1) ;
			break ;
		    case V4IM_Tag_Error:
			v4im_GetPointUC(&argok,UCTBUF2,V4TMBufMax,cpt,ctx) ; if (!argok) break ;
			v_Msg(ctx,UCTBUF1,"@BSError\nMQ%1U\n",UCTBUF2) ; vout_UCTextFileX(filex,0,UCTBUF1) ;
			break ;
		    case V4IM_Tag_Evaluate:
			argok = FALSE ; break ;
			break ;
		    case V4IM_Tag_Sheet:
			v4im_GetPointChar(&argok,outbuf,V4TMBufMax,cpt,ctx) ; if (!argok) break ;
			v_Msg(ctx,UCTBUF1,"@BSSheet\nNA%1s\n",outbuf) ; vout_UCTextFileX(filex,0,UCTBUF1) ;
			break ;
		    case V4IM_Tag_Scale:
			if (cpt->PntType != V4DPI_PntType_Dict ) { dnum = v4im_GetPointDbl(&argok,cpt,ctx) ; }
			 else { switch (v4im_GetDictToEnumVal(ctx,cpt))
				 { default:		v_Msg(ctx,NULL,"RptScale",intmodx,V4IM_Tag_Scale,cpt,_Fit) ; goto echos_fail ;
				   case _Fit:		dnum = -1 ; break ;
				 } ;
			      } ;
			v_Msg(ctx,UCTBUF1,"@SC%1g\n",dnum) ; vout_UCTextFileX(filex,0,UCTBUF1) ;
			break ;
		    case V4IM_Tag_Portrait:
			i = v4im_GetPointLog(&argok,cpt,ctx) ;
			v_Msg(ctx,UCTBUF1,"@PL%1s\n",(i ? "P" : "L")) ; vout_UCTextFileX(filex,0,UCTBUF1) ;
			break ;
		    case V4IM_Tag_LogoImage:
			v4im_GetPointChar(&argok,outbuf,V4TMBufMax,cpt,ctx) ; if (!argok) break ;
			v_Msg(ctx,UCTBUF1,"@BSSheet\nNA%1s\n",outbuf) ; vout_UCTextFileX(filex,0,UCTBUF1) ;
			break ;
		    case V4IM_Tag_URL:		k = 0 ; type = V4SS_Type_URLLink ; goto urlentry ;
		    case V4IM_Tag_URL2:		k = 1 ; type = V4SS_Type_URLLink2 ; goto urlentry ;
		    case V4IM_Tag_URL3:		k = 2 ; type = V4SS_Type_URLLink3 ; goto urlentry ;
		    case V4IM_Tag_URL4:		k = 3 ; type = V4SS_Type_URLLink4 ; goto urlentry ;
		    case V4IM_Tag_URL5:		k = 4 ; type = V4SS_Type_URLLink5 ; goto urlentry ;
urlentry:		DOROW DOCELL
			{ struct V4RPT__URLSpec vus ;
			  if (!v4rpt_ParseURLSpec(ctx,&vus,cpt,intmodx)) goto echos_fail ;
/*			  Maybe convert to new style of URL indexing */
			  if (vus.urlText[0] == '+')
			   { v_Msg(ctx,UCTBUF1,"@UR%1d:%2U\n",k,&vus.urlText[1]) ; vout_UCTextFileX(filex,0,UCTBUF1) ;
			   } else { v_Msg(ctx,UCTBUF1,"@UR%1U\n",vus.urlText) ; vout_UCTextFileX(filex,0,UCTBUF1) ; } ;
			  if (UCnotempty(vus.target)) { v_Msg(ctx,UCTBUF1,"@TA%1U\n",vus.target) ; vout_UCTextFileX(filex,0,UCTBUF1) ; } ;
			}
			break ;
		    case V4IM_Tag_URLBase:	b = "0" ; goto urlbentry ;
		    case V4IM_Tag_URLBase2:	b = "1" ; goto urlbentry ;
		    case V4IM_Tag_URLBase3:	b = "2" ; goto urlbentry ;
		    case V4IM_Tag_URLBase4:	b = "3" ; goto urlbentry ;
		    case V4IM_Tag_URLBase5:	b = "4" ; goto urlbentry ;
urlbentry:		v4im_GetPointChar(&argok,outbuf,V4TMBufMax,cpt,ctx) ; if(!argok) break ;
			v_Msg(ctx,UCTBUF1,"@UB%1s=%2s\n",b,outbuf) ; vout_UCTextFileX(filex,0,UCTBUF1) ;
			break ;
			
		    case V4IM_Tag_HTML:
			v4im_GetPointChar(&argok,outbuf,V4TMBufMax,cpt,ctx) ; if (!argok) break ;
			v_Msg(ctx,UCTBUF1,"@HT%1s\n",outbuf) ; vout_UCTextFileX(filex,0,UCTBUF1) ;
			break ;
		    case V4IM_Tag_CSS:
			v4im_GetPointChar(&argok,outbuf,V4TMBufMax,cpt,ctx) ; if (!argok) break ;
			v_Msg(ctx,UCTBUF1,"@BSOther\nCS%1s\n",outbuf) ; vout_UCTextFileX(filex,0,UCTBUF1) ;
			break ;
		    case V4IM_Tag_Image:
			if (memcmp(cpt,&protoNone,V4PS_Int) == 0 || memcmp(cpt,&CondEvalRet,CondEvalRet.Bytes) == 0) break ;
			DOROW DOCELL
/*			Do we have a single name or list of 2 entries? */
/*			xv4rpp expects: url<tab>localfile<tab>rows<tab>columns */
			if (cpt->PntType != V4DPI_PntType_List)
			 { v4im_GetPointUC(&ok,UCTBUF1,V4TMBufMax,cpt,ctx) ;
			   if (UCempty(UCTBUF1)) break ;						/* Skip if empty string */
/*			   Did we get URL or local file ? */
			   if (UCstrncmp(UCTBUF1,UClit("http://"),7) != 0)
			    { UCstrcpy(UCTBUF2,UClit("IM\t")) ; UCstrcat(UCTBUF2,UCTBUF1) ; }
			    else { UCstrcpy(UCTBUF2,UClit("IM")) ; UCstrcat(UCTBUF2,UCTBUF1) ; UCstrcat(UCTBUF2,UClit("\t")) ; } ;
			 } else
			 { P listPnt ;
			   struct V4L__ListPoint *lp = VERIFYLIST(NULL,ctx,cpt,intmodx) ;
			   if (!(SIZEofLIST(lp) == 2 || SIZEofLIST(lp) == 4)) { v_Msg(ctx,NULL,"RptImage",intmodx,V4IM_Tag_Image,cpt) ; goto echos_fail ; } ;
			   UCstrcpy(UCTBUF2,UClit("IM")) ; 
			   v4l_ListPoint_Value(ctx,lp,1,&listPnt) ; v4im_GetPointUC(&ok,UCTBUF1,V_FileName_Max,&listPnt,ctx) ;
			   UCstrcat(UCTBUF2,UCTBUF1) ;
			   v4l_ListPoint_Value(ctx,lp,2,&listPnt) ; v4im_GetPointUC(&ok,UCTBUF1,V_FileName_Max,&listPnt,ctx) ;
			   UCstrcat(UCTBUF2,UClit("\t")) ; UCstrcat(UCTBUF2,UCTBUF1) ;
			   if (SIZEofLIST(lp) == 4)
			    { UCCHAR buf[32] ; INDEX row,col ;
			      v4l_ListPoint_Value(ctx,lp,3,&listPnt) ; row = v4im_GetPointInt(&ok,&listPnt,ctx) ; if (!ok) break ;
			      v4l_ListPoint_Value(ctx,lp,4,&listPnt) ; col = v4im_GetPointInt(&ok,&listPnt,ctx) ; if (!ok) break ;
			      UCsprintf(buf,UCsizeof(buf),UClit("\t%d\t%d"),row,col) ; UCstrcat(UCTBUF2,buf) ;
			    } ;
			 } ;
			UCstrcat(UCTBUF2,UCTXTEOL) ; vout_UCTextFileX(filex,0,UCTBUF2) ;
			break ;
		   break ;
		  } ; if (lp == NULL) { break ; } else { continue ; } ;		/* Don't print point, continue with next! */
	       } ;
	      if (baf != NULL)
	       { ++num ;			/* Update to current column */
		 v4im_BaAIncrement(ctx,baf,ipt,num,rcv) ;
	       } ;
	      if (!ok) { if (lp == NULL) { break ; } else { continue ; } ; } ;

	      if (vdfm != NULL)
	       { for (dimFX=vdfm->Count-1;dimFX>=0;dimFX--)
	          { if (vdfm->dimIdList[dimFX] == ipt->Dim) break ;
	          } ;
	       } else
	       { dimFX = UNUSED ;
	       } ;
	      if (ipt->PntType == V4DPI_PntType_Shell)
	       { ipt = (P *)&ipt->Value ; pntType = ipt->PntType ;
	       } else { pntType = UNUSED ; } ;
	      DIMINFO(di,ctx,ipt->Dim) ;
	      if (di == NULL ? FALSE : di->Flags & V4DPI_DimInfo_Displayer)		/* If a displayer function then tweak here & drop thru */
	       { P spnt ;
	         INITISCT(&spnt) ; NOISCTVCD(&spnt) ; spnt.Grouping = 2 ;
		 cpt = ISCT1STPNT(&spnt) ; dictPNTv(cpt,Dim_UV4,v4im_GetEnumToDictVal(ctx,deval=_Displayer,UNUSED)) ;
		 if (cpt->Dim == 0 || cpt->Value.IntVal == 0)
		  { v_Msg(ctx,UCTBUF1,"*DPIDspNoDisplr",di->DimId) ; vout_UCText(VOUT_Warn,0,UCTBUF1) ; goto no_displayer ; } ;
	         ADVPNT(cpt) ;
	         if (di->ADPnt.Bytes != 0)
	          { memcpy(cpt,&di->ADPnt,di->ADPnt.Bytes) ; ADVPNT(cpt) ; spnt.Grouping ++ ;
		    memcpy(cpt,ipt,ipt->Bytes) ; if (cpt->PntType == V4DPI_PntType_Int) cpt->Dim = Dim_Int ;
		  } else
		  { memcpy(cpt,ipt,ipt->Bytes) ;
		    if (UCstrlen(di->IsA) > 0) cpt->Dim = v4dpi_DimGet(ctx,di->IsA,DIMREF_IRT) ;
		  } ;
		 if (UCstrlen(di->IsA) > 0) cpt->Dim = v4dpi_DimGet(ctx,di->IsA,DIMREF_IRT) ;
		 ADVPNT(cpt) ; ISCTLEN(&spnt,cpt) ;
		 cpt = v4dpi_IsctEval(respnt,&spnt,ctx,V4DPI_EM_NoIsctFail,NULL,NULL) ;
		 if (cpt != NULL) { ipt = cpt ; }			/* If eval'd then use this point for display */
		  else { v_Msg(ctx,UCTBUF1,"*DPIDspNoDisplr",di->DimId) ; vout_UCText(VOUT_Warn,0,UCTBUF1) ; } ;
	       } ;
no_displayer:
/*	      If we have an output format for this dimension the make sure we have done an SSDim() with that format */
	      if (di == NULL ? FALSE : (UCnotempty(di->OutFormat) && (di->rtFlags & V4DPI_rtDimInfo_v4rpp) == 0))
	       { dimFX = v4im_SSDimSetMask(ctx,di,di->OutFormat,intmodx) ;
	         if (dimFX == UNUSED) return(NULL) ;
	       } ;
	      
	      switch(ipt->PntType)
	       { default:
		 case V4DPI_PntType_Country:
		 case V4DPI_PntType_XDict:
		 case V4DPI_PntType_Dict:
		 case V4DPI_PntType_Time:
		 case V4DPI_PntType_UOM:
		 case V4DPI_PntType_UOMPer:
		 case V4DPI_PntType_UOMPUOM:
		   v4dpi_PointToString(UCTBUF2,ipt,ctx,V4DPI_FormatOpt_Echo) ;	/* Convert to printable format */
		   pType = UClit("A") ;
		   break ;
		 case V4DPI_PntType_UTime:
		 case V4DPI_PntType_Color:
		 case V4DPI_PntType_UWeek:
		 case V4DPI_PntType_UQuarter:
		 case V4DPI_PntType_UDT:
		 case V4DPI_PntType_UMonth:
		 case V4DPI_PntType_UPeriod:
/*		   If got special displayer then do it otherwise normal format to string */
		   if (!v4sxi_SpecialDisplayer(ctx,ipt,V4TMBufMax,UCTBUF2)) v4dpi_PointToString(UCTBUF2,ipt,ctx,V4DPI_FormatOpt_Echo) ;
		   pType = UClit("A") ;
		   break ;
		 case V4DPI_PntType_Logical:
		   if (v4sxi_SpecialDisplayer(ctx,ipt,V4TMBufMax,UCTBUF2)) break ;
		   UCsprintf(UCTBUF2,16,UClit("%d"),(ipt->Value.IntVal > 0)) ;
		   pType = UClit("L") ;
		   break ;
		 case V4DPI_PntType_UYear:			/* If special displayer then do it otherwise drop down */
		   if (v4sxi_SpecialDisplayer(ctx,ipt,V4TMBufMax,UCTBUF2))
		    { pType = UClit("A") ; break ; } ;
		 case V4DPI_PntType_CodedRange:
		 case V4DPI_PntType_Int:
		 case V4DPI_PntType_IMArg:
		   if (v4sxi_SpecialDisplayer(ctx,ipt,V4TMBufMax,UCTBUF2))
		    { pType = UClit("A") ; break ; } ;
		   UCsprintf(UCTBUF2,64,UClit("%d"),ipt->Value.IntVal) ; pType = UClit("I") ; break ;
		 case V4DPI_PntType_Calendar:
		   memcpy(&dnum,&ipt->Value.IntVal,sizeof dnum) ;
		   UCsprintf(UCTBUF2,64,UClit("%d"),UDtoCAL(vcal_CalToUDate(dnum,VCAL_TimeZone_Local,&ok))) ; pType = UClit("D") ;
		   if (!ok) { strcpy(outbuf,"*invCalDate*") ; pType = UClit("A") ; } ;
		   break ;
		 case V4DPI_PntType_UDate:
		   if (v4sxi_SpecialDisplayer(ctx,ipt,V4TMBufMax,UCTBUF2))
		    { pType = UClit("A") ; break ; } ;
		   UCsprintf(UCTBUF2,64,UClit("%d"),UDtoCAL(ipt->Value.IntVal)) ; pType = UClit("D") ; break ;
		 case V4DPI_PntType_Fixed:
		   memcpy(&b64,ipt->Value.FixVal,sizeof b64) ; UCsprintf(UCTBUF2,64,UClit("%dD%lld"),ipt->LHSCnt,b64) ;
		   pType = UClit("F") ; break ;
		 case V4DPI_PntType_Real:
		   if (v4sxi_SpecialDisplayer(ctx,ipt,V4TMBufMax,UCTBUF2))
		    { pType = UClit("A") ; break ; } ;
		   GETREAL(dnum,ipt) ;
		   UCsprintf(UCTBUF2,100,V4DPI_PntFormat_Real,dnum) ;
		   pType = UClit("R") ; break ;
		 case V4DPI_PntType_BigText:
		   v4im_GetPointUC(&ok,UCTBUF2,V4TMBufMax,ipt,ctx) ;
		   if (!ok) { UCstrcpy(UCTBUF2,UClit("*invBigText*")) ; } ;
		   pType = UClit("A") ; break ;
		 case V4DPI_PntType_Char:		/* Alpha unless starts with "=" then make a formula */
		 case V4DPI_PntType_URL:
		   v4im_GetPointUC(&ok,UCTBUF2,V4TMBufMax,ipt,ctx) ;
		   pType = UClit("A") ; break ;
		 case V4DPI_PntType_FChar:
		   switch(ipt->LHSCnt)			/* LHSCnt has point type of cell value */
		    { default:				i = V4SS_Type_Alpha ; break ;
		      case V4DPI_PntType_Real:		i = V4SS_Type_Double ; break ;
		      case V4DPI_PntType_UDate:		i = V4SS_Type_UDate ; break ;
		    } ;
		   outbuf[0] = i ; v4im_GetPointChar(&argok,&outbuf[1],V4TMBufMax-2,ipt,ctx) ; i = V4SS_Type_FAlpha ; 
		   break ;
		 case V4DPI_PntType_SSVal:
		   if (ipt->Bytes == V4PS_Int)		/* Do we have value or format? */
		    { outbuf[0] = ipt->Value.IntVal ; outbuf[1] = '\0' ; i = V4SS_Type_SSVal ; }
		    else { struct V4SS__FormatSpec *vfs ; vfs = (struct V4SS__FormatSpec *)&ipt->Value ;
			   tb[0] = V4SS_Type_FormatSpecNP ; tb[1] = 2 + vfs->Length ; vout_TextFileX(filex,2,tb) ;
			   vout_TextFileX(filex,vfs->Length,(char *)vfs) ;
			   goto next_point ;
			 } ;
		   break ;
	       } ;
/*	      UCTBUF2 has data, dimFX is format index unless UNUSED in which case use pType */
	      DOROW
	       { INDEX colSpan = UNUSED ; UCCHAR *tc,*lType,*cv,*fv,*prefix ;
	         lType = UClit("CV") ; cv = UCTBUF2 ; fv = NULL ;
	         if (cv[0] == UClit('{')) { colSpan = UCstrtol(&cv[1],&tc,10) ; cv = tc + 1 ; }
	          else { colSpan = UNUSED ; } ;
		 if (colSpan > 0)
		  { DOCELL v_Msg(ctx,UCTBUF1,"@SP%1d\n",colSpan) ; vout_UCTextFileX(filex,0,UCTBUF1) ; } ;
		 if (cv[0] == UClit('='))	/* Have a formula ? */
		  { fv = &cv[1] ;		/* Make everything after '=' the formula */
		    cv = UCstrchr(fv,'\t') ;	/* If we have a tab then anything after tab is actual cell value (to show if we are not going to Excel */
		    if (cv != NULL) { *cv = UCEOS ; cv++  ; } ;
		  } ;
		 if (fv != NULL)
		  { DOCELL
		    if (dimFX != UNUSED)
		     { v_Msg(ctx,UCTBUF1,"@EX%1d:%2U\n",dimFX+V4SS__DimOffsetForV4RPP,fv) ;  vout_UCTextFileX(filex,0,UCTBUF1) ;
		     } else
		     { v_Msg(ctx,UCTBUF1,"@EX%1U:%2U\n",pType,fv) ;  vout_UCTextFileX(filex,0,UCTBUF1) ;
		     } ;
		  } ;
/*		 Do special check to see if we can put cell value on same line as 'BSCell' */
		 if (didCell) { prefix = UClit("CV") ; }
		  else { prefix = UClit("BSC ") ; didCell = TRUE ; } ;
/*		 Write out cell value, if multiple lines ('\012') then terminate each line to be continued with '\' */
		 if (cv != NULL)
		  { UCCHAR *ub, *eb ; LENMAX ol ;
		    ol = UCstrlen(cv) ;
/*		    If last character is '\' then append a space so v4rpp does not think that the line is continued onto the next */
		    if (cv[ol-1] == UClit('\\'))
		     { cv[ol] = UClit(' ') ; cv[ol+1] = UCEOS ; } ; 
		     for(ub=cv;;ub=eb+1)
		      { eb = UCstrchr(ub,'\012') ; if (eb != NULL) *eb = UCEOS ;
		        if (ub == cv)
			 { 
			   if (pntType != UNUSED)
			    { if (dimFX != UNUSED)
			       { v_Msg(ctx,UCTBUF1,"@%1U%2d.%3d:%4U%5U\n",prefix,dimFX+V4SS__DimOffsetForV4RPP,pntType,ub,(eb == NULL ? UClit("") : UClit("\\"))) ;  vout_UCTextFileX(filex,0,UCTBUF1) ;
			       } else
			       { v_Msg(ctx,UCTBUF1,"@%1U%2U.%3d:%4U%5U\n",prefix,pType,pntType,ub,(eb == NULL ? UClit("") : UClit("\\"))) ;  vout_UCTextFileX(filex,0,UCTBUF1) ;
			       } ;
			    } else
			    {
			      if (dimFX != UNUSED)
			       { v_Msg(ctx,UCTBUF1,"@%1U%2d:%3U%4U\n",prefix,dimFX+V4SS__DimOffsetForV4RPP,ub,(eb == NULL ? UClit("") : UClit("\\"))) ;  vout_UCTextFileX(filex,0,UCTBUF1) ;
			       } else
			       { v_Msg(ctx,UCTBUF1,"@%1U%2U:%3U%4U\n",prefix,pType,ub,(eb == NULL ? UClit("") : UClit("\\"))) ;  vout_UCTextFileX(filex,0,UCTBUF1) ;
			       } ;
			    } ;
			 } else
			 { v_Msg(ctx,UCTBUF1,"@%1U%2U\n",ub,(eb == NULL ? UClit("") : UClit("\\"))) ;  vout_UCTextFileX(filex,0,UCTBUF1) ;
			 } ;
		        if (eb == NULL) break ;
		      } ;
		  } ;
	       }
	      didCell = FALSE ;			/* Done with this cell, reset for possible next cell */	      
	      { static LOGICAL didEchoS = FALSE ;
	        if (!didEchoS)			/* Dump out we are doing EchoS() (so postprocessor can set appropriate settings) */
	         { didEchoS = TRUE ; v_Msg(ctx,UCTBUF1,"@BSMeta\nSPEchoS\n") ;  vout_UCTextFileX(filex,0,UCTBUF1) ;
		   if (gpi->DblEpsilon != 0)
		    { UCsprintf(UCTBUF1,100,UClit("EP%g"),gpi->DblEpsilon) ; vout_UCTextFileX(filex,0,UCTBUF1) ; vout_NLFileX(filex) ; } ;
	         } ;
	      }
next_point:
	      if (lp == NULL) break ;
	   } ;
	 } ;
	if (!argok) { v_Msg(ctx,NULL,"ModInvArg",intmodx,ix-1) ; goto echos_fail ; } ;
	return((P *)&Log_True) ;			/*  & return as value */
echos_fail:
	REGISTER_ERROR(0) ; return(NULL) ;
}

P *v4im_CoerceStringToPoint(ctx,respnt,intmodx,textBuf,di)
  struct V4C__Context *ctx ;
  P *respnt ;
  INTMODX intmodx ;
  UCCHAR *textBuf ;
  struct V4DPI__DimInfo *di ;
{ struct V4LEX__TknCtrlBlk *tcb ;
  P isctbuf, *ipt ;

	tcb = v4mm_AllocChunk(sizeof *tcb,FALSE) ; v4lex_InitTCB(tcb,V4LEX_TCBINIT_NoStdIn) ; v4lex_NestInput(tcb,NULL,textBuf,V4LEX_InpMode_String) ;
	if (!v4dpi_PointParse(ctx,&isctbuf,tcb,V4DPI_PointParse_RetFalse))
	 { v4lex_FreeTCB(tcb) ; v_Msg(ctx,NULL,"ModInvArg",intmodx,2) ; return(NULL) ; } ;
	v4lex_FreeTCB(tcb) ;
	ipt = v4dpi_IsctEval(respnt,&isctbuf,ctx,0,NULL,NULL) ;
	if (ipt != NULL) ipt->Dim = di->DimId ;
	return(ipt) ;
}

struct V4DPI__Point *v4im_DoProject(ctx,respnt,argpnts,argcnt,intmodx,fallthru)
  struct V4C__Context *ctx ;
  P *respnt ;						/* Ptr for result */
  INTMODX intmodx ;
  P *argpnts[] ;
  LOGICAL *fallthru ;
  COUNTER argcnt ;
{
  struct V4IS__AreaCB *acb ;
  struct V4IS__IndexBktHdr *ibh ;
  struct V4IS__Bkt *bkt ;
  struct V4IS__IndexBktKeyList *ibkl ;
  struct V4IS__IndexKeyDataEntry *ikde ;
  P *cpt,*ipt,argbuf,*spt,*tpt ;
  struct V4DPI__DimInfo *di ;
  struct V4DPI__WormHoleIntInt *whii ;
  struct V4DPI__WormHoleIntDbl *whid ;
  struct V4DPI__WormHoleIntAgg *whia ;
  struct V4DPI__WormHoleIntUOMPer *whiup ;
  struct V4DPI__WormHoleIntGeo *whigeo ;
  struct V4DPI__WormHoleLIntLInt *whll ;
  struct V4DPI__ProjectionInfo prj,*prjp,*prjp1 ;
  struct V4DPI__ProjectionData prd,*prdp ;
  struct V4L__ListPoint *lp ;
  struct V4DPI__Point *args[3] ;
  static int srctgtDims = 0 ; static struct V4DPI__ProjectionInfo *prjPrior = NULL;
  int ix,rx,i,j,srcdim,targetdim,exists,bytes,ok,val ; double dnum ; char *b ;

	*fallthru = FALSE ;
/*	Have to determine one of 3 forms-
	  1) Declaring new projection (more than 2 arguments)
	  2) Defining a new mapping: Project(dim1:value dim2:value)
	  3) Determining a projection: Project(Dim:dim1 dim2:value)
*/
	if (argcnt > 2) goto project_setup ;
	tpt = argpnts[1] ; spt = argpnts[2] ;		/* Set up target/source points */
	if (tpt->Dim == 0 || spt->Dim == 0)
	 { v_Msg(ctx,NULL,"ProjectUndef2",intmodx,tpt,spt) ; goto project_fail ; } ;
/*	Have 2 args - if first is Dim:xxx then we must be projecting, if not then defining a projection */
	if (tpt->Dim != Dim_Dim) goto project_define ;
/*	Here to get value of projection */
	if ((spt->Dim << 16 | tpt->Value.IntVal) == srctgtDims)
	 { prjp = prjPrior ; goto does_exist ; } ;
	exists = v4prj_GetProjectionInfo(ctx,spt->Dim,tpt->Value.IntVal,&prjp) ;
	if (exists)
	 { srctgtDims = spt->Dim << 16 | tpt->Value.IntVal ; prjPrior = prjp ;
	 } else				/* Don't yet know if we do know how to do this */
	 { memset(&prj,0,sizeof prj) ;
#ifdef V4ENABLEMULTITHREADS
	   INITMTLOCK(prj.prjLock) ;
#endif
	   prj.kp.fld.AuxVal = V4IS_SubType_ProjectionInfo ; prj.kp.fld.KeyType = V4IS_KeyType_V4 ;
	   prj.kp.fld.KeyMode = V4IS_KeyMode_Int ; prj.kp.fld.Bytes = sizeof prj.kp + sizeof prj.KeyVal ;
	   prj.KeyVal.SrcDim = spt->Dim ; prj.KeyVal.TargetDim = tpt->Value.IntVal ;
	   for(rx=gpi->HighHNum;rx>=gpi->LowHNum;rx--)
	    { if (gpi->RelH[rx].aid == UNUSED) continue ;
	      if (v4is_PositionKey(gpi->RelH[rx].aid,(struct V4IS__Key *)&prj,(struct V4IS__Key **)&ikde,0,V4IS_PosDCKLx) != V4RES_PosKey) continue ;
	      prjp = (struct V4DPI__ProjectionInfo *)v4dpi_GetBindBuf(ctx,gpi->RelH[rx].aid,ikde,FALSE,NULL) ;
	      break ;
	    } ;
	   if (rx >= gpi->LowHNum)		/* Did we find anything? */
	    { prjp1 = (struct V4DPI__ProjectionInfo *)v4mm_AllocChunk(prjp->Bytes,FALSE) ;
	      memcpy(prjp1,prjp,prjp->Bytes) ; prjp = prjp1 ;
	      prjp->aid = gpi->RelH[rx].aid ;
	      INITMTLOCK(prjp->prjLock) ;	/* Init this lock just-in-case (older prj->xxx in areas may not have proper length!) */
	    } else { prjp = NULL ; } ;		/* No */
	   v4prj_CacheProjectionInfo(ctx,spt->Dim,tpt->Value.IntVal,prjp) ;
	   srctgtDims = spt->Dim << 16 | tpt->Value.IntVal ; prjPrior = prjp ;
	 } ;
does_exist:
	if (prjp == NULL)			/* If NULL then don't know how to project - use predefined defaults */
	 { *fallthru = TRUE ; return(NULL) ; } ;
	if (prjp->Permanent)				/* If a permanent projection then save in area */
	 { 
	   prd.kp.fld.AuxVal = V4IS_SubType_ProjectionData ; prd.kp.fld.KeyType = V4IS_KeyType_V4 ;
	   prd.kp.fld.KeyMode = V4IS_KeyMode_Alpha ;  prd.TargetDim = tpt->Value.IntVal ;


	   if (spt->PntType == V4DPI_PntType_UCChar)	/* If UNICODE then convert to Alpha VEH100907 */
	    { int i ;
	      ZPH(&prd.ptSrc) ; prd.ptSrc.Dim = spt->Dim ; prd.ptSrc.PntType = V4DPI_PntType_Char ;
	      for(i=0;i<=spt->Value.AlphaVal[0];i++) { prd.ptSrc.Value.AlphaVal[i] = spt->Value.UCVal[i] ; } ;
	      prd.ptSrc.Bytes = ALIGN(V4DPI_PointHdr_Bytes + prd.ptSrc.Value.AlphaVal[0] + 1) ;
	    } else
	    { memcpy(&prd.ptSrc,spt,spt->Bytes) ;		/* Copy Source point into proper place */
	    } ;


	   if (prd.ptSrc.PntType == V4DPI_PntType_Char)	/* If character string then have to pad out last few bytes */
	    { memset(&prd.ptSrc.Value.AlphaVal[spt->Value.AlphaVal[0]+1],0,7) ; }
	    else if (prd.ptSrc.PntType == V4DPI_PntType_UCChar)	/* Same thing for Unicode */
	    { memset(&prd.ptSrc.Value.UCVal[UCCHARSTRLEN(spt)+1],0,7) ; }
	   b = (char *)&prd.ptSrc + prd.ptSrc.Bytes ; prd.kp.fld.Bytes = ALIGN(b - (char *)&prd) ;
	   if (prjp->aid == UNUSED)				/* Have to find area ? */
	    { for(rx=gpi->HighHNum;rx>=gpi->LowHNum;rx--)	/* Find highest area allowing new entries */
	       { if (rx == V4DPI_WorkRelHNum) continue ;	/* Don't default to work area! */
	         if (gpi->RelH[rx].aid == UNUSED) continue ; if (gpi->RelH[rx].ahi.ExtDictUpd) break ;
	       } ;
	      if (rx < gpi->LowHNum && gpi->RelH[V4DPI_WorkRelHNum].aid != UNUSED) /* If all else fails - assign to process work */
	       rx = V4DPI_WorkRelHNum ;
	      if (rx < gpi->LowHNum) { v_Msg(ctx,NULL,"CtxNoUpdArea",intmodx) ; goto project_fail ; } ;
	      prjp->aid = gpi->RelH[rx].aid ;
	    } ;
	   GRABMTLOCK(prjp->prjLock) ;
	   acb = v4mm_ACBPtr(prjp->aid) ;
	   if (v4is_PositionKey(prjp->aid,(struct V4IS__Key *)&prd,(struct V4IS__Key **)&prdp,0,V4IS_PosBoKL) == V4RES_PosKey)
	    { LOGICAL doNext ;
	      BYTE *pBuf = NULL ; LENMAX pbBytes,pbMax ;
/*	      If possibility of multiple results then allocate buffer for results (don't want to call v4l_ListPoint_Modify() because it may screw up  v4is_PositionRel - yeah this was a nasty one VEH100909) */
	      if (prjp->MultiTarget)
	       { pbMax = 0x1000 ; pbBytes = 0 ;  pBuf = v4mm_AllocChunk(pbMax,FALSE) ; ; } ;
	      ipt = (P *)((char *)prdp + prdp->kp.fld.Bytes) ;
	      memcpy(respnt,ipt,ipt->Bytes) ;
	      for(ok=1,doNext=FALSE;ok>0;ok++,doNext=TRUE)
	       { 
//	         if (doNext) { if (!v4is_PositionRel(prjp->aid,V4IS_PCB_GP_Next,-1,NULL)) break ; } ;
	         if (!v4is_PositionRel(prjp->aid,V4IS_PCB_GP_Next,-1,NULL)) break ;
	         bkt = v4mm_BktPtr(acb->Lvl[acb->CurLvl].BktNum,prjp->aid,V4MM_LockIdType_Index) ;
	         ibh = (struct V4IS__IndexBktHdr *)bkt ;	/* Get the bucket */
	         ibkl = (struct V4IS__IndexBktKeyList *)&bkt->Buffer[ibh->KeyEntryTop] ;	/* Pointer to B header & Key indexes */
	         ikde = (struct V4IS__IndexKeyDataEntry *)&bkt->Buffer[ibkl->DataIndex[acb->CurPosKeyIndex]] ;
	         switch (ikde->EntryType)
	          { default:
		      v_Msg(ctx,NULL,"@%1E Unknown ikde->EntryType(%2d)",intmodx,ikde->EntryType) ;
		      FREEMTLOCK(prjp->prjLock) ; goto project_fail ;
		    case V4IS_EntryType_DataLink:			/* Don't care about these - get next one */
		      IBHINUSE ; continue ;
		    case V4IS_EntryType_DataLen:
		      prdp = (struct V4DPI__ProjectionData *)((char *)ikde + sizeof *ikde) ;
		      if (memcmp(prdp,&prd,prd.kp.fld.Bytes) != 0)
		       { ok = -1 ; break ; } ;
		      cpt = (P *)((char *)prdp + prdp->kp.fld.Bytes) ;
		      if (prjp->MultiTarget)
		       { if (pBuf == NULL)
			  { printf("pBuf is NULL ??????????????????????????????\n") ; ok = -1 ; break ; } ;
		         if (pbBytes + cpt->Bytes >= pbMax)
			  { pbMax += 0x1000 ; pBuf = (BYTE *)realloc(pBuf,pbMax) ; } ;
		         memcpy(pBuf+pbBytes,cpt,cpt->Bytes) ; pbBytes += cpt->Bytes ;
		       } ;
		      IBHINUSE ;
	          } ;
	       } ;
/*	      Did we get more than one value? */
	      if (prjp->MultiTarget ? pbBytes > 0 : FALSE)
	       { INDEX x ;
	         memcpy(&argbuf,respnt,respnt->Bytes) ; INITLP(respnt,lp,Dim_List) ;
		 v4l_ListPoint_Modify(ctx,lp,V4L_ListAction_Append,&argbuf,0) ;		/* Append first point */
		 for(x=0;x<pbBytes;)
		  { int res ; cpt = (P *)(pBuf + x) ; x += cpt->Bytes ;
		    res = v4l_ListPoint_Modify(ctx,lp,V4L_ListAction_Append,cpt,0) ;
		  } ;
		 ENDLP(respnt,lp) ;
		 v4mm_FreeChunk(pBuf) ;			/* If we had to go big then deallocate */
	       } ; 
	      ipt = respnt ;
	    } else { ipt = NULL ; } ;	/* Could not find projection in area */
	   FREEMTLOCK(prjp->prjLock) ;
	   goto finish_proj1 ;
	 } else						/* Projection not permanent - use old Wormhole stuff */
	 { 
	   if (prjp->ptrWH == NULL) { ipt = NULL ; goto finish_proj1 ; } ;	/* Still don't know how to deal with this projection */
	   whii = (struct V4DPI__WormHoleIntInt *)prjp->ptrWH ;
	   ZPH(respnt) ; respnt->Dim = tpt->Value.IntVal ; ipt = respnt ;
	   val = (spt->PntType == V4DPI_PntType_AggRef ? spt->Value.IntVal | spt->Grouping << 24 : spt->Value.IntVal) ;
	   switch (whii->WHType)
	    { 
	      case V4DPI_WHType_IntInt:
		i = val % whii->Maximum ; if (i < 0) i = -i ;	/* Hash the src value */
		for(j=whii->Maximum;;)
		 {
		  if (whii->Entry[i].Src == WH_EMPTY) { ipt = NULL ; goto finish_proj1 ; } ;
		   if (whii->Entry[i].Src == val) break ;
		   j /= 2 ; if (j < 1) j = 1 ;
		   i = (i+j) % whii->Maximum ;
		 } ;
		respnt->Value.IntVal = whii->Entry[i].Dest ; respnt->PntType = prjp->TargetPntType ;
		respnt->Bytes = V4PS_Int ;
		goto finish_proj1 ;
	      case V4DPI_WHType_IntDbl:
		whid = (struct V4DPI__WormHoleIntDbl *)whii ;
		i = val % whid->Maximum ; if (i < 0) i = -i ;	/* Hash the src value */
		for(j=whid->Maximum;;)
		 { if (whid->Entry[i].Src == WH_EMPTY)
		    { ipt = NULL ; goto finish_proj1 ; } ;
		   if (whid->Entry[i].Src == val) break ;
		   j /= 2 ; if (j < 1) j = 1 ;
		   i = (i+j) % whii->Maximum ;
		 } ;
		PUTREAL(respnt,whid->Entry[i].Dest) ;
		respnt->PntType =  respnt->PntType = prjp->TargetPntType ; ;
		respnt->Bytes = V4PS_Real ; goto finish_proj1 ;
	      case V4DPI_WHType_IntAgg:
		whia = (struct V4DPI__WormHoleIntAgg *)whii ;
		i = val % whia->Maximum ; if (i < 0) i = -i ;	/* Hash the src value */
		for(j=whia->Maximum;;)
		 { if (whia->Entry[i].Src == WH_EMPTY) { ipt = NULL ; goto finish_proj1 ; } ;
		   if (whia->Entry[i].Src == val) break ;
		   j /= 2 ; if (j < 1) j = 1 ;
		   i = (i+j) % whia->Maximum ;
		 } ;
		respnt->Value.IntVal = whia->Entry[i].AggKeyValue ; respnt->Grouping = whia->Entry[i].AggIndex ;
		respnt->PntType = V4DPI_PntType_AggRef ; respnt->Bytes = V4PS_Int ; goto finish_proj1 ;
	      case V4DPI_WHType_IntUOMPer:
		whiup = (struct V4DPI__WormHoleIntUOMPer *)whii ;
		i = val % whiup->Maximum ; if (i < 0) i = -i ;	/* Hash the src value */
		for(j=whiup->Maximum;;)
		 { if (whiup->Entry[i].Src == WH_EMPTY) { ipt = NULL ; goto finish_proj1 ; } ;
		   if (whiup->Entry[i].Src == val) break ;
		   j /= 2 ; if (j < 1) j = 1 ;
		   i = (i+j) % whiup->Maximum ;
		 } ;
		respnt->Value.UOMPerVal = whiup->Entry[i].UOMPer ;
		respnt->PntType = V4DPI_PntType_UOMPer ; respnt->Bytes = V4PS_UOMPer ; goto finish_proj1 ;
	      case V4DPI_WHType_IntGeo:
		whigeo = (struct V4DPI__WormHoleIntGeo *)whii ;
		i = val % whigeo->Maximum ; if (i < 0) i = -i ;	/* Hash the src value */
		for(j=whigeo->Maximum;;)
		 { if (whigeo->Entry[i].Src == WH_EMPTY) { ipt = NULL ; goto finish_proj1 ; } ;
		   if (whigeo->Entry[i].Src == val) break ;
		   j /= 2 ; if (j < 1) j = 1 ;
		   i = (i+j) % whigeo->Maximum ;
		 } ;
		respnt->Value.GeoCoord = whigeo->Entry[i].Geo ;
		respnt->PntType = V4DPI_PntType_GeoCoord ; respnt->Bytes = V4PS_GeoCoord ; goto finish_proj1 ;
	      case V4DPI_WHType_LIntLInt:
		whll = (struct V4DPI__WormHoleLIntLInt *)whii ;
		{ B64INT bval ; memcpy(&bval,&spt->Value,sizeof bval) ; i = bval % whll->Maximum ;
		  if (i < 0) i = -i ;	/* Hash the src value */
		  for(j=whll->Maximum;;)
		   {
		    if (whll->Entry[i].Src == WH_EMPTY) { ipt = NULL ; goto finish_proj1 ; } ;
		     if (whll->Entry[i].Src == bval) break ;
		     j /= 2 ; if (j < 1) j = 1 ;
		     i = (i+j) % whll->Maximum ;
		   } ;
		}
		memcpy(&respnt->Value,&whll->Entry[i].Dest,sizeof whll->Entry[i].Dest) ;
		respnt->PntType = prjp->TargetPntType ;	respnt->Bytes = gpi->PointBytes[respnt->PntType] ;
/*		If no length & a list then must be a SegBitMap pointing to a bitmap */
		if (respnt->Bytes == 0 && respnt->PntType == V4DPI_PntType_List)
		 { respnt->PntType = V4DPI_PntType_SegBitMap ; respnt->Bytes = V4PS_Int ;
		 } ;
		if (respnt->PntType == V4DPI_PntType_AggRef)
		 { int *ip ; ip = (int *)&whll->Entry[i].Dest ; respnt->Grouping = *(ip + 1) ; } ;
		goto finish_proj1 ;
	     } ;
	 } ;
finish_proj1:
	if (ipt != NULL) return(ipt) ;
	switch(prjp->ErrorType)			/* Projection not defined - how to handle error */
	 { case V4DPI_ProjErr_Point:
		ipt = &prjp->ErrorPt ;
		if (ipt->PntType == V4DPI_PntType_Special || ipt->PntType == V4DPI_PntType_Isct)
		 { i = v4ctx_FramePush(ctx,NULL) ;	/* Start new context frame & add 1st 2 args to context */
		   if (!v4ctx_FrameAddDim(ctx,0,argpnts[1],0,0)) { v_Msg(ctx,NULL,"CtxAddFail",intmodx) ; goto project_fail ; } ;
		   if (!v4ctx_FrameAddDim(ctx,0,argpnts[2],0,0)) { v_Msg(ctx,NULL,"CtxAddFail",intmodx) ; goto project_fail ; } ;
		   ipt = v4dpi_IsctEval(respnt,ipt,ctx,V4DPI_EM_EvalQuote,NULL,NULL) ;
		   if (ipt == NULL)
		    { v_Msg(ctx,NULL,"ProjectPtFail",intmodx,V4IM_Tag_Point,&prjp->ErrorPt) ; goto project_fail ; } ;
		   if (!v4ctx_FramePop(ctx,i,NULL)) { v_Msg(ctx,NULL,"ModCtxPopFrame",intmodx,i) ; goto project_fail ; } ;
		 } ;
		if (prjp->Update)		/* Should we update projection with the result? */
		 { if (tpt->Value.IntVal != ipt->Dim)
		    { v_Msg(ctx,NULL,"ProjectAutoUpd",intmodx,ipt,tpt->Value.IntVal) ; goto project_fail ;
		    } ;
		   args[1] = ipt ; args[2] = spt ;
		   v4im_DoProject(ctx,&argbuf,args,2,intmodx,fallthru) ;
		 } ;
		return(ipt) ;
	   case V4DPI_ProjErr_Fail:
		v_Msg(ctx,NULL,"ProjectUndef2",intmodx,tpt,spt) ; goto project_fail ;
	   case V4DPI_ProjErr_Error:
		v_Msg(ctx,NULL,"@No such projection (%1P := %2P) defined",argpnts[1],argpnts[2]) ;
/*		*** NOTE - keep below as error!! *** */
		v4_UCerror(0,0,"V4IM","Project","NOPROJECTION",ctx->ErrorMsg) ;
	 } ;

/*	Here to define projection from one dim to another */
project_define:
	if (spt->Grouping == V4DPI_Grouping_All)	/* Doing Project(value dim..) - really defining default value */
	 goto project_setup1 ;
	XDBSAVEROW(tpt) ;			/* If this is xdb point then flag it so its corresponding row data is cached */
	exists = v4prj_GetProjectionInfo(ctx,spt->Dim,tpt->Dim,&prjp) ;
	if (!exists)				/* Don't yet know if we do know how to do this */
	 { memset(&prj,0,sizeof prj) ;
#ifdef V4ENABLEMULTITHREADS
	   INITMTLOCK(prj.prjLock) ;
#endif
	   prj.kp.fld.AuxVal = V4IS_SubType_ProjectionInfo ; prj.kp.fld.KeyType = V4IS_KeyType_V4 ;
	   prj.kp.fld.KeyMode = V4IS_KeyMode_Int ; prj.kp.fld.Bytes = sizeof prj.kp + sizeof prj.KeyVal ;
	   prj.KeyVal.SrcDim = spt->Dim ; prj.KeyVal.TargetDim = tpt->Dim ;
	   for(rx=gpi->HighHNum;rx>=gpi->LowHNum;rx--)
	    { if (gpi->RelH[rx].aid == UNUSED) continue ;
	      if (v4is_PositionKey(gpi->RelH[rx].aid,(struct V4IS__Key *)&prj,(struct V4IS__Key **)&ikde,0,V4IS_PosDCKLx) != V4RES_PosKey) continue ;
	      prjp = (struct V4DPI__ProjectionInfo *)v4dpi_GetBindBuf(ctx,gpi->RelH[rx].aid,ikde,FALSE,NULL) ;
	      if ((gpi->RelH[rx].pcb->AccessMode & V4IS_PCB_AM_Update) == 0)	/* Don't allow in read-only */
	       rx = V4DPI_WorkRelHNum ;
	      break ;
	    } ;
	   if (rx >= gpi->LowHNum)		/* Did we find anything? */
	    { prjp1 = (struct V4DPI__ProjectionInfo *)v4mm_AllocChunk(prjp->Bytes,FALSE) ;
	      memcpy(prjp1,prjp,prjp->Bytes) ; prjp = prjp1 ;
	      prjp->aid = gpi->RelH[rx].aid ;
	    } else { prjp = NULL ; } ;		/* No */
	   v4prj_CacheProjectionInfo(ctx,spt->Dim,tpt->Dim,prjp) ;
	 } ;
	if (prjp == NULL)			/* If nothing yet defined, then set up some defaults */
	 { memset(&prj,0,sizeof prj) ; prj.MaxKeySize = 12 ; prj.MultiTarget = FALSE ;
#ifdef V4ENABLEMULTITHREADS
	   INITMTLOCK(prj.prjLock) ;
#endif
	   prj.ptrWH = NULL ;
	   prj.ErrorType = V4DPI_ProjErr_Fail ; prj.KeyVal.SrcDim = spt->Dim ; prj.KeyVal.TargetDim = tpt->Dim ;
	   prj.Bytes = (char *)&prj.ErrorPt - (char *)&prj ;
	   prjp = (struct V4DPI__ProjectionInfo *)v4mm_AllocChunk(prj.Bytes,FALSE) ; memcpy(prjp,&prj,prj.Bytes) ;
	   if (!v4imu_ProjectValidate(ctx,intmodx,spt->Dim,tpt->Dim))
	    { prjp->Permanent = TRUE ;		/* Can't do it with Area::False - then try Area::True */
	      v_Msg(ctx,NULL,"*ProjectAutoSet",tpt->Dim,spt->Dim,V4IM_Tag_Area,&Log_True) ;
	      vout_UCText(VOUT_Warn,0,ctx->ErrorMsg) ;
	    } ;
	   v4prj_CacheProjectionInfo(ctx,prj.KeyVal.SrcDim,prj.KeyVal.TargetDim,prjp) ;
	 } ;
	if (prjp->Permanent)					/* If a permanent projection then save in area */
	 { prd.kp.fld.AuxVal = V4IS_SubType_ProjectionData ; prd.kp.fld.KeyType = V4IS_KeyType_V4 ;
	   prd.kp.fld.KeyMode = V4IS_KeyMode_Alpha ;  prd.TargetDim = tpt->Dim ;
	   if (spt->PntType == V4DPI_PntType_UCChar)	/* If UNICODE then convert to Alpha VEH100907 */
	    { int i ;
	      ZPH(&prd.ptSrc) ; prd.ptSrc.Dim = spt->Dim ; prd.ptSrc.PntType = V4DPI_PntType_Char ;
	      for(i=0;i<=spt->Value.AlphaVal[0];i++) { prd.ptSrc.Value.AlphaVal[i] = spt->Value.UCVal[i] ; } ;
	      prd.ptSrc.Bytes = ALIGN(V4DPI_PointHdr_Bytes + prd.ptSrc.Value.AlphaVal[0] + 1) ;
	    } else
	    { memcpy(&prd.ptSrc,spt,spt->Bytes) ;		/* Copy Source point into proper place */
	    } ;
	   if (prd.ptSrc.PntType == V4DPI_PntType_Char)	/* If character string then have to pad out last few bytes */
	    { memset(&prd.ptSrc.Value.AlphaVal[spt->Value.AlphaVal[0]+1],0,7) ; } ;
	   b = (char *)&prd.ptSrc + prd.ptSrc.Bytes ; prd.kp.fld.Bytes = ALIGN(b - (char *)&prd) ; memcpy(b,tpt,tpt->Bytes) ;
	   b = b + tpt->Bytes ; bytes = b - (char *)&prd ;
	   if (prjp->aid == UNUSED)				/* Have to find area ? */
	    { for(rx=gpi->HighHNum;rx>=gpi->LowHNum;rx--)	/* Find highest area allowing new entries */
	       { if (rx == V4DPI_WorkRelHNum) continue ;	/* Don't default to work area! */
	         if (gpi->RelH[rx].aid == UNUSED) continue ; if (gpi->RelH[rx].ahi.ExtDictUpd) break ;
	       } ;
	      if (rx < gpi->LowHNum && gpi->RelH[V4DPI_WorkRelHNum].aid != UNUSED) /* If all else fails - assign to process work */
	       rx = V4DPI_WorkRelHNum ;
	      if (rx < gpi->LowHNum) { v_Msg(ctx,NULL,"CtxNoUpdArea",intmodx) ; goto project_fail ; } ;
	      prjp->aid = gpi->RelH[rx].aid ;
	    } ;
	   GRABMTLOCK(prjp->prjLock) ;
	   acb = v4mm_ACBPtr(prjp->aid) ;
	   if ((acb->AccessMode & V4IS_PCB_AM_Update) == 0)
	    { FREEMTLOCK(prjp->prjLock) ; v_Msg(ctx,NULL,"ProjectRO",intmodx,acb->pcb->UCFileName) ; goto project_fail ; } ;
	   if (prjp->MultiTarget)			/* If allowing dups then always insert */
	    { if (v4is_Insert(prjp->aid,(struct V4IS__Key *)&prd,&prd,bytes,V4IS_PCB_DataMode_Index,0,0,FALSE,prjp->MultiTarget,0,ctx->ErrorMsgAux) == -1)
	       { FREEMTLOCK(prjp->prjLock) ; v_Msg(ctx,NULL,"@%1E Err inserting PRD-1 - %0A",intmodx) ; goto project_fail ; } ;
	    } else					/*  otherwise check to see if key exists */
	    { ok = v4is_PositionKey(prjp->aid,(struct V4IS__Key *)&prd,NULL,0,V4IS_PosBoKL) ;
	      if (ok != V4RES_PosKey)			/* If no key then do "Insert" */
	       { if (v4is_Insert(prjp->aid,(struct V4IS__Key *)&prd,&prd,bytes,V4IS_PCB_DataMode_Index,0,0,FALSE,prjp->MultiTarget,0,ctx->ErrorMsgAux) == -1)
		  { FREEMTLOCK(prjp->prjLock) ; v_Msg(ctx,NULL,"@%1E Err inserting PRD-2 - %0A",intmodx) ; goto project_fail ; } ;
	       } else					/* Record exists- do an "Update", but first lets get DataId */
	       { bkt = v4mm_BktPtr(acb->Lvl[acb->CurLvl].BktNum,prjp->aid,V4MM_LockIdType_Index) ;
		 ibh = (struct V4IS__IndexBktHdr *)bkt ;			/* Bucket header @ start of bucket */
		 ibkl = (struct V4IS__IndexBktKeyList *)&bkt->Buffer[ibh->KeyEntryTop] ;	/* Get pointer to key index list below header */
		 ikde = (struct V4IS__IndexKeyDataEntry *)&bkt->Buffer[ibkl->DataIndex[acb->CurPosKeyIndex]] ;	/* then use to get begin of key entry @ bottom */
		 switch (ikde->EntryType)
		  { default: FREEMTLOCK(prjp->prjLock) ; v_Msg(ctx,NULL,"@%1E Invalid IKDE Entry Type (%2d) in Bucket %3d, AreaID %4d",intmodx,ikde->EntryType,ibh->sbh.BktNum,prjp->aid) ; goto project_fail ;
		    case V4IS_EntryType_IndexLink:
			FREEMTLOCK(prjp->prjLock) ; v_Msg(ctx,NULL,"@%1E Positioned at IndexLink key- should not be here",intmodx) ; goto project_fail ;
		    case V4IS_EntryType_DataLink:
		    case V4IS_EntryType_DataLen:
			v4is_Replace(prjp->aid,(struct V4IS__Key *)&prd,&prd,&prd,bytes,V4IS_PCB_DataMode_Data,V4IS_DataCmp_None,ikde->DataId,0) ;
			break ;
	 	  } ;
	       } ;
	    } ; FREEMTLOCK(prjp->prjLock) ;
	 } else							/* Projection not permanent - use old Wormhole stuff */
	 { GRABMTLOCK(prjp->prjLock) ;
	   if (prjp->ptrWH == NULL)
	    { DIMINFO(di,ctx,prjp->KeyVal.SrcDim) ;
	      if (gpi->PointBytes[di->PointType] > V4PS_Int)
	       { prjp->ptrWH = v4wh_InitWH_LIntLInt(ctx,NULL,(prjp->CacheSize == 0 ? UNUSED : prjp->CacheSize),NULL,tpt) ; }
	       else { prjp->ptrWH = v4wh_InitWH_IntInt(ctx,NULL,(prjp->CacheSize == 0 ? UNUSED : prjp->CacheSize),NULL,tpt) ; } ;
	    } ;
	   whii = (struct V4DPI__WormHoleIntInt *)prjp->ptrWH ;
	   switch (whii->WHType)
	    { case V4DPI_WHType_IntInt:
		i = (spt->PntType == V4DPI_PntType_AggRef ? spt->Value.IntVal | spt->Grouping << 24 : spt->Value.IntVal) ;
		prjp->ptrWH = v4wh_PutWH_IntInt(ctx,whii,i,tpt->Value.IntVal) ; break ;
	      case V4DPI_WHType_IntDbl:
		GETREAL(dnum,tpt) ;
		i = (spt->PntType == V4DPI_PntType_AggRef ? spt->Value.IntVal | spt->Grouping << 24 : spt->Value.IntVal) ;
		prjp->ptrWH = v4wh_PutWH_IntDbl(ctx,(struct V4DPI__WormHoleIntDbl *)whii,i,dnum) ; break ;
	      case V4DPI_WHType_IntAgg:
		i = (spt->PntType == V4DPI_PntType_AggRef ? spt->Value.IntVal | spt->Grouping << 24 : spt->Value.IntVal) ;
		prjp->ptrWH = v4wh_PutWH_IntAgg(ctx,(struct V4DPI__WormHoleIntAgg *)whii,i,tpt->Value.IntVal,tpt->Grouping) ; break ;
	      case V4DPI_WHType_IntUOMPer:
		i = (spt->PntType == V4DPI_PntType_AggRef ? spt->Value.IntVal | spt->Grouping << 24 : spt->Value.IntVal) ;
		prjp->ptrWH = v4wh_PutWH_IntUOMPer(ctx,(struct V4DPI__WormHoleIntUOMPer *)whii,i,&tpt->Value.UOMPerVal) ; break ;
	      case V4DPI_WHType_IntGeo:
		i = (spt->PntType == V4DPI_PntType_AggRef ? spt->Value.IntVal | spt->Grouping << 24 : spt->Value.IntVal) ;
		prjp->ptrWH = v4wh_PutWH_IntGeo(ctx,(struct V4DPI__WormHoleIntGeo *)whii,i,&tpt->Value.GeoCoord) ; break ;
	      case V4DPI_WHType_LIntLInt:
		{ B64INT src,dst ; int *ip ;
		  memcpy(&src,&spt->Value,sizeof src) ;
		  if (tpt->PntType == V4DPI_PntType_AggRef)
		   { memcpy(&dst,&tpt->Value,sizeof(int)) ; ip = (int *)&dst ; *(ip+1) = tpt->Grouping ; }
		   else { memcpy(&dst,&tpt->Value,sizeof dst) ; } ;
		  prjp->ptrWH = v4wh_PutWH_LIntLInt(ctx,(struct V4DPI__WormHoleLIntLInt *)whii,src,dst) ;
		} break ;
	    } ;
	   FREEMTLOCK(prjp->prjLock) ;
	   memcpy(respnt,tpt,tpt->Bytes) ;			/* Return 1st argument (target) */
	   return(respnt) ;
	 } ;
	memcpy(respnt,tpt,tpt->Bytes) ;				/* Return 1st argument (target) */
	return(respnt) ;

/*	Here with > 2 arguments - setup a new projection */
project_setup1:							/* Entry point for Project(value dim..) */
	targetdim = argpnts[1]->Dim ; srcdim = argpnts[2]->Dim ;
	if (!v4imu_ProjectValidate(ctx,intmodx,srcdim,targetdim)) goto project_fail ;
	exists = v4prj_GetProjectionInfo(ctx,srcdim,targetdim,&prjp) ;
	if (prjp != NULL)
	 { v_Msg(ctx,NULL,"ProjectDefined",intmodx,targetdim,srcdim) ; goto project_fail ; }
	 else { memset(&prj,0,sizeof prj) ; prj.MaxKeySize = 12 ; prj.MultiTarget = FALSE ;
#ifdef V4ENABLEMULTITHREADS
		INITMTLOCK(prj.prjLock) ;
#endif
		prj.ptrWH = NULL ;
		prj.ErrorType = V4DPI_ProjErr_Fail ; prj.KeyVal.SrcDim = srcdim ; prj.KeyVal.TargetDim = targetdim ;
		DIMINFO(di,ctx,targetdim) ; prj.TargetPntType = di->PointType ;
		prj.Bytes = (char *)&prj.ErrorPt - (char *)&prj ; prj.aid = UNUSED ;
	      } ;
	memcpy(&prj.ErrorPt,argpnts[1],argpnts[1]->Bytes) ;
	prj.Bytes = (char *)&prj.ErrorPt - (char *)&prj + prj.ErrorPt.Bytes ;
	prj.ErrorType = V4DPI_ProjErr_Point ;
	prjp = (struct V4DPI__ProjectionInfo *)v4mm_AllocChunk(prj.Bytes,FALSE) ; memcpy(prjp,&prj,prj.Bytes) ;
	v4prj_CacheProjectionInfo(ctx,prj.KeyVal.SrcDim,prj.KeyVal.TargetDim,prjp) ;
	return((P *)&Log_True) ;
project_setup:
	srcdim = 0 ; targetdim = 0 ;
	for (ok=TRUE,ix=1;ok&&ix<=argcnt;ix++)
	 { if (ix >= 3 && (targetdim == 0 || srcdim == 0))
	    { v_Msg(ctx,NULL,"@%1E first two arguments to Project(), when more than two arguments, must be dimension points",intmodx) ; goto project_fail ; } ;
	   switch (i=v4im_CheckPtArgNew(ctx,argpnts[ix],&cpt,&argbuf))
	    { default:			v_Msg(ctx,NULL,"TagBadUse",intmodx) ; goto project_fail ;
	      case V4IM_Tag_Unk:		v_Msg(ctx,NULL,"TagUnknown",intmodx) ; goto project_fail ;
	      case V4IM_Tag_Cache:	/* Cache size-of-internal-cache */
		prj.CacheSize = v4im_GetPointInt(&ok,cpt,ctx) ; break ;
	      case V4IM_Tag_Dim:	/* Dim:xxx (first 2 args must be Dim:xxx */
		switch(ix)
		 { default:	v_Msg(ctx,NULL,"Project2Dim",intmodx) ;	goto project_fail ;
		   case 1:	targetdim = cpt->Value.IntVal ; break ;
		   case 2:	srcdim = cpt->Value.IntVal ; break ;	
		 } ;
		if (ix == 1) break ;
		exists = v4prj_GetProjectionInfo(ctx,srcdim,targetdim,&prjp) ;
		if (prjp != NULL) { memcpy(&prj,prjp,prjp->Bytes) ; }
		 else { memset(&prj,0,sizeof prj) ; prj.MaxKeySize = 12 ; prj.MultiTarget = FALSE ;
#ifdef V4ENABLEMULTITHREADS
			INITMTLOCK(prj.prjLock) ;
#endif
			prj.ptrWH = NULL ;
			prj.ErrorType = V4DPI_ProjErr_Fail ; prj.KeyVal.SrcDim = srcdim ; prj.KeyVal.TargetDim = targetdim ;
			DIMINFO(di,ctx,targetdim) ; if (di == NULL) { v_Msg(ctx,NULL,"ModArgNotDim",intmodx,1,argpnts[1]) ; goto project_fail ; } ;
			prj.TargetPntType = di->PointType ;
			prj.Bytes = (char *)&prj.ErrorPt - (char *)&prj ; prj.aid = UNUSED ;
		      } ;

		break ;
	      case V4IM_Tag_Error:	/* Error::string */
		v4im_GetPointChar(&j,(char *)&prj.ErrorPt,sizeof prj.ErrorPt,cpt,ctx) ;
	       if (!j) { v_Msg(ctx,NULL,"TagValue2",intmodx,V4IM_Tag_Area,cpt) ; goto project_fail ; } ;
		prj.Bytes = (char *)&prj.ErrorPt - (char *)&prj + strlen((char *)&prj.ErrorPt) + 1 ;
		prj.ErrorType = V4DPI_ProjErr_Error ; break ;
	      case V4IM_Tag_Point:	/* Point::point-on-error */
		cpt = (ISQUOTED(cpt) ? UNQUOTEPTR(cpt) : cpt) ;
		memcpy(&prj.ErrorPt,cpt,cpt->Bytes) ;
		prj.Bytes = (char *)&prj.ErrorPt - (char *)&prj + prj.ErrorPt.Bytes ;
		prj.ErrorType = V4DPI_ProjErr_Point ; break ;
	      case V4IM_Tag_Area:	/* Area::yes/no */
	       prj.Permanent = v4im_GetPointLog(&j,cpt,ctx) ;
	       if (!j) { v_Msg(ctx,NULL,"TagValue2",intmodx,V4IM_Tag_Area,cpt) ; goto project_fail ; } ;
	       break ;
	      case V4IM_Tag_Length:	/* Length::max-length-of-alpha-src */
		prj.MaxKeySize = v4im_GetPointInt(&ok,cpt,ctx) ; break ;
	      case V4IM_Tag_Unique:	/* Unique::yes/no */
		prj.MultiTarget = !v4im_GetPointLog(&j,cpt,ctx) ;
		if (!j) { v_Msg(ctx,NULL,"TagValue2",intmodx,V4IM_Tag_Unique,cpt) ; goto project_fail ; } ;
		break ;
	      case V4IM_Tag_Update:	/* Update::yes/no */
		prj.Update = v4im_GetPointLog(&j,cpt,ctx) ;
		if (!j) { v_Msg(ctx,NULL,"TagValue2",intmodx,V4IM_Tag_Update,cpt) ; goto project_fail ; } ;
		break ;
	      case -V4IM_Tag_Delete:
	      case -V4IM_Tag_Remove:
		if (!v4prj_RemoveProjectionInfo(ctx,srcdim,targetdim,intmodx)) goto project_fail ;
		return((P *)&Log_True) ;
	      case -V4IM_Tag_Define:
		exists = v4prj_GetProjectionInfo(ctx,srcdim,targetdim,&prjp) ;
		if (exists) return((P *)&Log_True) ;
		v_Msg(ctx,NULL,"ProjectUndef",intmodx,targetdim,srcdim) ; goto project_fail ;
	    } ;
	   if (!ok) { v_Msg(ctx,NULL,"ModInvArg",intmodx,ix-1) ; goto project_fail ; } ;
	 } ;
	exists = v4prj_GetProjectionInfo(ctx,srcdim,targetdim,&prjp) ;
	if (prjp != NULL) { v_Msg(ctx,NULL,"ProjectDefined",intmodx,targetdim,srcdim) ; goto project_fail ; }
/*	If permanent then write out to area */
	if (prj.Permanent)
	 { prj.kp.fld.AuxVal = V4IS_SubType_ProjectionInfo ; prj.kp.fld.KeyType = V4IS_KeyType_V4 ;
	   prj.kp.fld.KeyMode = V4IS_KeyMode_Int ; prj.kp.fld.Bytes = sizeof prj.kp + sizeof prj.KeyVal ;
	   for(rx=gpi->HighHNum;rx>=gpi->LowHNum;rx--)			/* Find highest area allowing new entries */
	    { if (rx == V4DPI_WorkRelHNum) continue ;			/* Don't default to work area! */
	      if (gpi->RelH[rx].aid == UNUSED) continue ; if (gpi->RelH[rx].ahi.ExtDictUpd) break ;
	    } ;
	   if (rx < gpi->LowHNum && gpi->RelH[V4DPI_WorkRelHNum].aid != UNUSED) /* If all else fails - assign to process work */
	    rx = V4DPI_WorkRelHNum ;
	   if (rx < gpi->LowHNum) { v_Msg(ctx,NULL,"CtxNoUpdArea",intmodx) ; goto project_fail ; } ;
	   prj.aid = gpi->RelH[rx].aid ; acb = v4mm_ACBPtr(prj.aid) ;
	   if (exists ? v4is_PositionKey(prj.aid,(struct V4IS__Key *)&prj,(struct V4IS__Key **)&ikde,0,V4IS_PosDCKLx) == V4RES_PosKey : FALSE)
	    { v4is_Replace(prj.aid,(struct V4IS__Key *)&prj,&prj,&prj,sizeof prj,V4IS_PCB_DataMode_Data,V4IS_DataCmp_None,acb->DataId,0) ;
	    } else { if (v4is_Insert(prj.aid,(struct V4IS__Key *)&prj,&prj,prj.Bytes,V4IS_PCB_DataMode_Auto,0,0,FALSE,FALSE,0,ctx->ErrorMsgAux) == -1)
		      { v_Msg(ctx,NULL,"ProjectPrjIO",intmodx) ; goto project_fail ; } ;
		   } ;
	 } else
	 { if (!v4imu_ProjectValidate(ctx,intmodx,srcdim,targetdim)) goto project_fail ;
	 } ;
/*	Now update in-process cache with this projection info */
	prjp = (struct V4DPI__ProjectionInfo *)v4mm_AllocChunk(prj.Bytes,FALSE) ; memcpy(prjp,&prj,prj.Bytes) ;
	v4prj_CacheProjectionInfo(ctx,prj.KeyVal.SrcDim,prj.KeyVal.TargetDim,prjp) ;
	return((P *)&Log_True) ;
project_fail:
	REGISTER_ERROR(0) ; return(NULL) ;
}

LOGICAL v4imu_ProjectValidate(ctx,intmodx,srcdim,targetdim)
  struct V4C__Context *ctx ;
  int srcdim,targetdim,intmodx ;
{ struct V4DPI__DimInfo *di ;
  int ok ;

	DIMINFO(di,ctx,srcdim) ;
	switch(di->PointType)
	 { default:
		v_Msg(ctx,NULL,"ProjectCache",intmodx,di->DimId,di->PointType) ; return(FALSE) ;
	   case V4DPI_PntType_Real:
	   case V4DPI_PntType_Int2:
	   case V4DPI_PntType_TeleNum:
	   case V4DPI_PntType_Fixed:
		DIMINFO(di,ctx,targetdim) ;
		ok = FALSE ;
/*		Allow List with target dimension (assume points will be PntType_SegBitMap) */
		if (di->PointType == V4DPI_PntType_List && di->ListDimId != 0) ok = TRUE ;
		if (!ok && (gpi->PointBytes[di->PointType] > V4PS_Int2 || gpi->PointBytes[di->PointType] <= 0))
		 { v_Msg(ctx,NULL,"ProjectCache2",intmodx,di->DimId,di->PointType) ; return(FALSE) ; } ;
		break ;
	   CASEofINT
	   case V4DPI_PntType_XDict:
	   case V4DPI_PntType_Dict:
	   case V4DPI_PntType_AggRef:
	   case V4DPI_PntType_Color:
	   case V4DPI_PntType_Country:
		DIMINFO(di,ctx,targetdim) ;
		switch(di->PointType)
		 { default:
			ok = FALSE ;
/*			Allow List with target dimension (assume points will be PntType_SegBitMap) */
			if (di->PointType == V4DPI_PntType_List && di->ListDimId != 0) ok = TRUE ;
			if (!ok)
			 { v_Msg(ctx,NULL,"ProjectCache2",intmodx,di->DimId,di->PointType) ; return(FALSE) ; } ;
		   CASEofINT
		   case V4DPI_PntType_XDict:
		   case V4DPI_PntType_Dict:
		   case V4DPI_PntType_Color:
		   case V4DPI_PntType_Country:
		   case V4DPI_PntType_Real:
		   case V4DPI_PntType_Int2:
		   case V4DPI_PntType_Calendar:
		   case V4DPI_PntType_AggRef:
		   case V4DPI_PntType_GeoCoord:
		   case V4DPI_PntType_UOMPer:	break ;
		 } ;
		break ;
	 } ;
	return(TRUE) ;
}

/*	v4imu_EchoTable - Handles Echo(Table::xxx) IntMod		*/

P *v4imu_EchoTable(ctx,respnt,intmodx,argpnts,argcnt,trace,tagVal)
  struct V4C__Context *ctx ;
  INTMODX intmodx ;
  P *respnt,*argpnts[] ;
  COUNTER argcnt ; VTRACE trace ; TAGVAL tagVal ;
{ P *tpt,*ipt,ptbuf,isct ;
  struct V4DPI__DimInfo *di ;
  struct V4LEX__Table *vlt=NULL ;
  struct V4LEX__TablePrsOpt tpo ;
  int ix,i,maxwidth,bytes,date,ok,filex,lenPrefix,lenSuffix ; double d1 ;
  UCCHAR TableName[V4LEX_TCBMacro_NameMax+1] ;
  UCCHAR tbuf[V4TMBufMax],delim[2],*b1,*b2,ucbuf[V4TMBufMax] ;

/*	Form base intersection */
	INITISCT(&isct) ; NOISCTVCD(&isct) ; isct.Grouping = 1 ;
	tpt = ISCT1STPNT(&isct) ; dictPNT(tpt,Dim_NId) ; DIMINFO(di,ctx,tpt->Dim) ;
	isct.Bytes += tpt->Bytes ;
	filex = ctx->Frame[ctx->FrameCnt - 1].DataStreamFileX ;
	lenPrefix = 0 ; lenSuffix = 0 ;
/*	Get table name (we are here because we know we have a table) + any other points to be appended to isct */
	for(ix=1;ix<=argcnt;ix++)
	 {
	   if (argpnts[ix]->PntType == V4DPI_PntType_TagVal)
	    { switch (v4im_CheckPtArgNew(ctx,argpnts[ix],&ipt,&ptbuf))
	       { 
		 case V4IM_Tag_Out:
			filex = vout_PntIdToFileX(ctx,(struct V4DPI__LittlePoint *)ipt) ;
			if (filex == UNUSED) { v_Msg(ctx,NULL,"StreamNoOutput",intmodx,V4IM_Tag_Out,ipt) ; goto fail ; } ;
			break ;
	         case V4IM_Tag_NoPrefix:
		 case V4IM_Tag_Table:
			v4im_GetPointUC(&ok,TableName,UCsizeof(TableName),ipt,ctx) ;
			if (!ok) { v_Msg(ctx,NULL,"ModFailed2",intmodx) ; goto fail ; } ;
			vlt = v4eval_GetTable(ctx,TableName,NULL) ;
			if (vlt == NULL) { v_Msg(ctx,NULL,"ModFailed2",intmodx) ; goto fail ; } ;
			vlt->tpo = &tpo ; *vlt->tpo = vlt->tpoT ;	/* Set up runtime options to be default for the table */
			if (tagVal == V4IM_Tag_NoPrefix)
			 { lenPrefix = UCstrlen(vlt->colNamePrefix) ; lenSuffix = UCstrlen(vlt->colNameSuffix) ; } ;
			break ;
	       } ;
	      continue ;
	    } ;
	   ADVPNT(tpt) ; isct.Grouping++ ; isct.Bytes += argpnts[ix]->Bytes ;
	   memcpy(tpt,argpnts[ix],argpnts[ix]->Bytes) ;		/* Append this point to isct */
	 } ;
	if (vlt == NULL) { v_Msg(ctx,NULL,"TagMissing",intmodx,V4IM_Tag_Table) ; goto fail ; } ;
	tpt = ISCT1STPNT(&isct) ;				/* Put tpt back to first point in isct */
	if (vlt->tpo->Delim != UNUSED)				/* Do we have fixed format or delimited ? */
	 { ZUS(tbuf) ; delim[0] = vlt->tpo->Delim ; delim[1] = UCEOS ; }
	 else
	 { for(ix=0,maxwidth=0;ix<vlt->Columns;ix++)
	    { if (vlt->Col[ix].StartX+vlt->Col[ix].Width > maxwidth) maxwidth = vlt->Col[ix].StartX+vlt->Col[ix].Width ;
	    } ;
	   for(i=0;i<maxwidth;i++) { tbuf[i] = UClit(' ') ; } ; tbuf[i] = UCEOS ;
	 } ;

	for(ix=0;ix<vlt->Columns;ix++)
	 { 
/*	   If Column set to IGNORE then provide appropriate default (because we won't be able to evaluate [point* columnname]) */
	   if (vlt->Col[ix].ColumnType & (V4LEX_TableCT_Point | V4LEX_TableCT_Expression)) continue ;	/* Don't include POINT/EXPRESSION columns - they aren't really part of Table */
	   if (vlt->Col[ix].ColumnType & V4LEX_TableCT_Ignore)
	    { ipt = vlt->Col[ix].Dflt ;
	      if (ipt == NULL)
	       { ipt = &ptbuf ; ZPH(ipt) ;
	         switch (vlt->Col[ix].PntType)
	          { default:
		      intPNTv(ipt,0) ; break ;
	            CASEofChar
		      alphaPNTv(ipt,"") ; break ;
	          } ;
	       } ;
	    } else
	    { UCCHAR *colName,colNameBuf[UCsizeof(vlt->Col[ix].Name)] ;
	      colName = vlt->Col[ix].Name ;
	      colName += lenPrefix ;
	      if (lenSuffix > 0)
	       { UCstrcpy(colNameBuf,colName) ; colNameBuf[UCstrlen(colNameBuf) - lenSuffix] = UCEOS ;
	         colName = colNameBuf ;
	       } ;
	      tpt->Value.IntVal = v4dpi_DictEntryGet(ctx,0,colName,di,NULL) ;
	      ipt = v4dpi_IsctEval(&ptbuf,&isct,ctx,V4DPI_EM_EvalQuote,NULL,NULL) ;
	      if (ipt == NULL) ipt = vlt->Col[ix].Dflt ;
	      if (ipt == NULL) { v_Msg(ctx,NULL,"@%1E (Table::%2U column %3d %4U) Failed",intmodx,vlt->Name,ix+1,vlt->Col[ix].Name) ; goto fail ; } ;
	    } ;
	   switch(ipt->PntType)
	    { default:
		v4dpi_PointToString(ucbuf,ipt,ctx,V4DPI_FormatOpt_Echo) ;
		break ;
	      case V4DPI_PntType_CodedRange:
	      case V4DPI_PntType_Int:
		if (vlt->tpo->Delim == UNUSED) { sprintf(ASCTBUF1,"%0*d",vlt->Col[ix].Width,ipt->Value.IntVal) ; }
		 else { UCsprintf(ucbuf,UCsizeof(ucbuf),UClit("%d"),ipt->Value.IntVal) ; } ;
		break ;
	      case V4DPI_PntType_Real:
		GETREAL(d1,ipt) ;	/* Copy to get around possible alignment probs */
		if (vlt->tpo->Delim != UNUSED)
		 { if (vlt->Col[ix].Decimals == 0)
		    { UCsprintf(ucbuf,UCsizeof(ucbuf),V4DPI_PntFormat_Real,d1) ; }
		    else { UCsprintf(ucbuf,UCsizeof(ucbuf),UClit("%.*f"),vlt->Col[ix].Decimals,d1) ; } ;
		 } else
		 { if (vlt->Col[ix].Decimals == 0)
		    { UCsprintf(ucbuf,UCsizeof(ucbuf),UClit("%0*.15g"),vlt->Col[ix].Width,d1) ; }
		    else { UCsprintf(ucbuf,UCsizeof(ucbuf),UClit("%0*.*f"),vlt->Col[ix].Width,vlt->Col[ix].Decimals,d1) ; } ;
		 } ; break ;
	      case V4DPI_PntType_Calendar:
		memcpy(&d1,&ipt->Value.IntVal,sizeof d1) ; date = vcal_CalToUDate(d1,VCAL_TimeZone_Local,&ok) ;
		if (!ok)
		 { v_Msg(ctx,NULL,"@%1E Table::%2U column %3d %4s) Failed - Calendar out of range",intmodx,vlt->Name,ix+1,vlt->Col[ix].Name) ;  goto fail ; } ;
		switch(vlt->Col[ix].PntTypeInfo)
		 { case V4LEX_TablePT_Internal:		break ;
		   case V4LEX_TablePT_YYMMDD:
			date = mscu_udate_to_yyyymmdd(date) ; break ;
		   default:
		   case V4LEX_TablePT_DDMMYY:
			i = mscu_udate_to_yyyymmdd(date) ;
			date = (i % 100)*10000 + ((i/100) % 100)*100 + ((i/10000)%100) ;
			break ;
		   case V4LEX_TablePT_MMDDYY:
			i = mscu_udate_to_yyyymmdd(date) ;
			date = ((i/100) % 100)*10000 + (i % 100)*100 + ((i/10000)%100) ;
			break ;
		   case V4LEX_TablePT_DDMMMYY:
			UCstrcpy(ucbuf,mscu_udate_to_ddmmmyy(date)) ; date = UNUSED ; break ;
		 } ;
		if (date != UNUSED)
		 { if (vlt->tpo->Delim == UNUSED) { UCsprintf(ucbuf,UCsizeof(ucbuf),UClit("%0*d"),vlt->Col[ix].Width,date) ; }
		    else { UCsprintf(ucbuf,UCsizeof(ucbuf),UClit("%d"),date) ; } ;
		 } ;
		break ;
	      case V4DPI_PntType_UDT:
		date = ipt->Value.IntVal ;
		switch(vlt->Col[ix].PntTypeInfo)
		 { case V4LEX_TablePT_Internal:		break ;
		   default:
			{ int ymd = mscu_udate_to_yyyymmdd(UDTtoUD(date)) ; int secs = UDTtoSeconds(date) ;
			  UCsprintf(ucbuf,UCsizeof(ucbuf),UClit("%02d/%02d/%02d:%02d:%02d:%02d"),(ymd/100) % 100,ymd % 100,(ymd/10000)%100,secs/3600,(secs/60)%60,secs%60) ;
			  date = UNUSED ;
			}
			break ;
		 } ;
		if (date != UNUSED)
		 { if (vlt->tpo->Delim == UNUSED) { UCsprintf(ucbuf,UCsizeof(ucbuf),UClit("%0*d"),vlt->Col[ix].Width,date) ; }
		    else { UCsprintf(ucbuf,UCsizeof(ucbuf),UClit("%d"),date) ; } ;
		 } ;
		break ;
	      case V4DPI_PntType_UDate:
		date = ipt->Value.IntVal ;
		switch(vlt->Col[ix].PntTypeInfo)
		 { case V4LEX_TablePT_Internal:		break ;
		   case V4LEX_TablePT_YYMMDD:
			date = mscu_udate_to_yyyymmdd(date) ; break ;
		   case V4LEX_TablePT_DDMMYY:
			i = mscu_udate_to_yyyymmdd(date) ;
			date = (i % 100)*10000 + ((i/100) % 100)*100 + ((i/10000)%100) ;
			break ;
		   case V4LEX_TablePT_MMDDYY:
			i = mscu_udate_to_yyyymmdd(date) ;
			date = ((i/100) % 100)*10000 + (i % 100)*100 + ((i/10000)%100) ;
			break ;
		   case V4LEX_TablePT_DDMMMYY:
			UCstrcpy(ucbuf,mscu_udate_to_ddmmmyy(date)) ; date = UNUSED ; break ;
		   default:
			i = mscu_udate_to_yyyymmdd(date) ;
			UCsprintf(ucbuf,UCsizeof(ucbuf),UClit("%02d/%02d/%02d"),(i/100) % 100,i % 100,(i/10000)%100) ; date = UNUSED ;
			break ;
		 } ;
		if (date != UNUSED)
		 { if (vlt->tpo->Delim == UNUSED) { UCsprintf(ucbuf,UCsizeof(ucbuf),UClit("%0*d"),vlt->Col[ix].Width,date) ; }
		    else { UCsprintf(ucbuf,UCsizeof(ucbuf),UClit("%d"),date) ; } ;
		 } ;
		break ;
	    } ;
	   if (vlt->tpo->Delim != UNUSED) { if (ix > 0) UCstrcat(tbuf,delim) ; UCstrcat(tbuf,ucbuf) ; }
	    else { b1 = &tbuf[vlt->Col[ix].StartX] ; b2 = ucbuf ;
		   for(bytes = vlt->Col[ix].Width;bytes>0&&*b2!=UCEOS;bytes--) { *(b1++) = *(b2++) ; } ;
		 } ;
	 } ;
	switch(intmodx)
	 { default:
	   case V4IM_OpCode_Echo:
		 vout_UCTextFileX(filex,0,tbuf) ; vout_NLFileX(filex) ;
		return((P *)&Log_True) ;
	   case V4IM_OpCode_Format:
		bytes = UCstrlen(tbuf) ;
		if (bytes >= V4DPI_UCVAL_MaxSafe) { v_Msg(ctx,NULL,"ModStrTooLong",intmodx,bytes,V4DPI_UCVal_Max) ; goto fail ; } ;
		uccharPNTv(respnt,tbuf) ; return(respnt) ;
	 } ;

fail:	REGISTER_ERROR(0) ; return(NULL) ;
}



/*	v4im_DoDo - Handles Do() IntMod		*/

P *v4im_DoDo(ctx,respnt,argcnt,argpnts,intmodx)
  struct V4C__Context *ctx ;
  INTMODX intmodx ;
  P *respnt,*argpnts[] ;
  COUNTER argcnt ;
{ P *ipt,*cpt,*dpt,*tpt,*failpt,ptbuf,isctbuf,lisctbuf,*whilept, valpt ;
  struct V4DPI__Point *optbuf ;
  struct V4DPI__LittlePoint idpt ;
  struct V4L__ListPoint *lp,*lpctx ;
  struct V4DPI__TagVal *tv ;				/* Structure of a tagged value */
  struct V4DPI__DimInfo *di ;
  struct V4EVAL_OptDimList odl ;
  struct V4DPI__Point_IntMix *pim ;
  struct V4IM__XMLNest xml ;
  int optimize,frameid,ix,j,force,sx,filex ;

	frameid = v4ctx_FramePush(ctx,NULL) ;		/* Start new context frame */
	ipt = NULL ; xml.Count = 0 ; optimize = FALSE ; odl.Count = 0 ; whilept = NULL ; ZPH(&idpt) ; ZPH(&valpt) ; optbuf = NULL ; force = FALSE ;
/*	If deferred Do() then reset xml state */
	if (intmodx == V4IM_OpCode_DeferDo && ctx->vdds != NULL)
	 { xml = ctx->vdds->xml ;
	   for(cpt=ctx->vdds->ctxPts,ix=0;ix<ctx->vdds->ctxcnt;ix++)
	    { if (!v4ctx_FrameAddDim(ctx,0,cpt,0,0)) { v_Msg(ctx,NULL,"CtxAddFail",intmodx) ; ipt = NULL ; goto do_end ; } ;
	      ADVPNT(cpt) ;
	    } ;
	 } ;
	for(ix=1;ix<=argcnt;ix++)			/* Loop thru all arguments */
	 { if (whilept != NULL)			/* If While::test then see if still OK */
	    { tpt = whilept ; tpt = v4dpi_IsctEval(&ptbuf,tpt,ctx,V4DPI_EM_EvalQuote,0,NULL) ;
	      if (tpt == NULL) { v_Msg(ctx,NULL,"TagEvalFail",intmodx,V4IM_Tag_While,whilept) ; ipt = NULL ; goto do_end ; } ;
	      if (tpt->Value.IntVal < 1) break ;		/*  else if defined then best be integer > 0 */
	    } ;
	   if (argpnts[ix]->PntType != V4DPI_PntType_TagVal)
	    { if (optimize)
	       { int savertStackX, savertStackFail ;
	         if (optbuf == NULL) optbuf = v4mm_AllocChunk(optMax,FALSE) ;
		 savertStackX = ctx->rtStackX ; savertStackFail = ctx->rtStackFail ; ctx->rtStackX += 2 ;
	         optimize = v4eval_OptPoint(ctx,argpnts[ix],optbuf,optMax,(odl.Count == 0 ? NULL : &odl)) ;
	         ctx->rtStackX = savertStackX ; ctx->rtStackFail = savertStackFail ;
	         if (optimize < 1) { v_Msg(ctx,NULL,"DoNoOptimize",intmodx,ix) ;  ipt = NULL ; goto do_end ; } ;
		 if (traceGlobal & V4TRACE_Optimize)
		  { v_Msg(ctx,UCTBUF2,"*TraceDoOpt",optbuf) ; vout_UCText(VOUT_Trace,0,UCTBUF2) ; } ;
		 dpt = optbuf ;
	       } else { dpt = argpnts[ix] ; } ;
	      force = dpt->ForceEval ;
	      ipt = v4dpi_IsctEval(respnt,dpt,ctx,V4DPI_EM_EvalQuote,NULL,NULL) ;
	      if (ipt == NULL)
	       { v_Msg(ctx,NULL,"ModArgEval",intmodx,ix,dpt) ; goto do_end ; } ;
/*	      If resulting value is Continue? or Continue::label where label matches idpt then immediately exit */
tag_entry:
	      if (ipt->PntType == V4DPI_PntType_TagVal)
	       { tv = (struct V4DPI__TagVal *)&ipt->Value ;
	         if ((tv->TagVal & V4DPI_TagFlag_MaskOut) == V4IM_Tag_Continue)
		  { if (ipt->ForceEval)		/* Got Continue? - return with current Do point index */
		     { 
		       ipt = respnt ; intPNTv(ipt,ix) ; goto do_end ;
		     } ;
/*		    Have Continue::name - see if it matches name in idpt */
		    if (idpt.Bytes > 0 ? memcmp(&idpt,ipt,idpt.Bytes) == 0 : FALSE)
		     { 
/*		       Got match - as with above, return index */
		       ipt = respnt ; intPNTv(ipt,ix) ; goto do_end ;
		     } else			/* Don't have match - exit but return Continue::xxx tag point */
		     { memcpy(respnt,ipt,ipt->Bytes) ; ipt = respnt ; goto do_end ;
		     } ;
		  } ;
		 if ((tv->TagVal & V4DPI_TagFlag_MaskOut) == V4IM_Tag_End)
		  { if (ipt->ForceEval)		/* Got End? - return with End? for (hopefully) enclosing Enum() */
		     { memcpy(respnt,ipt,ipt->Bytes) ; ipt = respnt ; goto do_end ; } ;
/*		    Have End::name - see if it matches name in idpt */
		    if (idpt.Bytes > 0 ? memcmp(&idpt,ipt,idpt.Bytes) == 0 : FALSE)
		     { memcpy(respnt,ipt,ipt->Bytes) ; respnt->ForceEval = TRUE ;
/*		       Got match - as with above, return End? point for enclosing Enum() */
		       ipt = respnt ; goto do_end ;
		     } else			/* Don't have match - exit but return End::xxx tag point */
		     { memcpy(respnt,ipt,ipt->Bytes) ; ipt = respnt ; goto do_end ;
		     } ;
		  } ;
	       } ;
	      if (force ? ipt->PntType == V4DPI_PntType_Isct : FALSE)
	       { P *tipt=ipt ; ipt = v4dpi_IsctEval(respnt,ipt,ctx,V4DPI_EM_EvalQuote,NULL,NULL) ;
		 if (ipt == NULL) { v_Msg(ctx,NULL,"ModArgEval",intmodx,ix,tipt) ; goto do_end ; } ;
	       };
	      continue ;
	    } ;
	   switch (v4im_CheckPtArgNew(ctx,argpnts[ix],&cpt,NULL))
	    { default:	    		v_Msg(ctx,NULL,"TagBadUse",intmodx) ; ipt = NULL ; goto do_end ;
	      case V4IM_Tag_Unk:	v_Msg(ctx,NULL,"TagUnknown",intmodx) ; ipt = NULL ; goto do_end ;
#ifdef V4_BUILD_SECURITY
	      case V4IM_Tag_Hold:
		ipt = v4dpi_IsctEval(&isctbuf,cpt,ctx,0,NULL,NULL) ;
		if (ipt == NULL) { v_Msg(ctx,NULL,"TagEvalFail",intmodx,V4IM_Tag_Hold,cpt) ; ipt = NULL ; goto do_end ; } ;
		if (ipt->PntType == V4DPI_PntType_TagVal) goto tag_entry ;	/* If a tag then most likely Continue/End - handle, DON'T add to context */
		if (!v4ctx_FrameAddDim(ctx,V4C_FrameId_Hold,ipt,0,0)) { v_Msg(ctx,NULL,"CtxAddFail",intmodx) ; ipt = NULL ; goto do_end ; } ;
		break ;
#else
	      case V4IM_Tag_Hold:	v_Msg(ctx,NULL,"V4NotThisBuild",intmodx,argpnts[ix]) ; ipt = NULL ; goto do_end ;
#endif
	      case V4IM_Tag_Dim:
		break ;
	      case V4IM_Tag_Context:
		if (cpt->PntType == V4DPI_PntType_List && !ISQUOTED(cpt))
	         { lpctx = v4im_VerifyList(&ptbuf,ctx,cpt,intmodx) ;
		   for(sx=1;;sx++)
	            { if (v4l_ListPoint_Value(ctx,lpctx,sx,&isctbuf) <= 0) break ;
		      failpt = &isctbuf ;
		      cpt = v4dpi_IsctEval(respnt,&isctbuf,ctx,V4DPI_EM_EvalQuote,NULL,NULL) ;
		      if (cpt == NULL) break ;
		      if (cpt->PntType == V4DPI_PntType_TagVal) { ipt = cpt ; goto tag_entry ; } ; /* If a tag then most likely Continue/End - handle, DON'T add to context */
		      if (memcmp(cpt,&protoNone,V4PS_Int) != 0)		/* Don't do anything if UV4:none */
		       { if (!v4ctx_FrameAddDim(ctx,0,cpt,0,0)) { v_Msg(ctx,NULL,"CtxAddFail",intmodx) ; ipt = NULL ; goto do_end ; } ;
		       } ;
		      CLEARCACHE
		    } ;
		 } else
		 { failpt = cpt ;
		   cpt = v4dpi_IsctEval(&isctbuf,cpt,ctx,0,NULL,NULL) ;
		   if (cpt != NULL)
		    { 
		      if (cpt->PntType == V4DPI_PntType_TagVal) { ipt = cpt ; goto tag_entry ; } ; /* If a tag then most likely Continue/End - handle, DON'T add to context */
		      if (memcmp(cpt,&protoNone,V4PS_Int) != 0)		/* Don't do anything if UV4:none */
		       { if (!v4ctx_FrameAddDim(ctx,0,cpt,0,0)) { v_Msg(ctx,NULL,"CtxAddFail",intmodx) ; ipt = NULL ; goto do_end ; } ;
		       } ;
		    } ;
		 } ;
		if (cpt == NULL) { v_Msg(ctx,NULL,"TagEvalFail",intmodx,V4IM_Tag_Context,failpt) ; ipt = NULL ; goto do_end ; } ;
		ipt = cpt ;
		break ;
	      case V4IM_Tag_ContextP:
		failpt = cpt ; cpt = v4dpi_IsctEval(&isctbuf,cpt,ctx,0,NULL,NULL) ;
		if (cpt == NULL) { v_Msg(ctx,NULL,"TagEvalFail",intmodx,V4IM_Tag_Context,failpt) ; ipt = NULL ; goto do_end ; } ;
		if (cpt->PntType == V4DPI_PntType_List && !ISQUOTED(cpt))
	         { lpctx = v4im_VerifyList(NULL,ctx,cpt,intmodx) ;
		   for(sx=1;;sx++)
	            { if (v4l_ListPoint_Value(ctx,lpctx,sx,&ptbuf) <= 0) break ;
		      failpt = &isctbuf ;
		      cpt = v4dpi_IsctEval(respnt,&ptbuf,ctx,V4DPI_EM_EvalQuote,NULL,NULL) ;
		      if (cpt == NULL) break ;
		      if (cpt->PntType == V4DPI_PntType_TagVal) { ipt = cpt ; goto tag_entry ; } ; /* If a tag then most likely Continue/End - handle, DON'T add to context */
		      if (memcmp(cpt,&protoNone,V4PS_Int) != 0)		/* Don't do anything if UV4:none */
		       { if (!v4ctx_FrameAddDim(ctx,0,cpt,0,0)) { v_Msg(ctx,NULL,"CtxAddFail",intmodx) ; ipt = NULL ; goto do_end ; } ;
		       } ;
		      CLEARCACHE
		    } ;
		 } else
		 { if (cpt->PntType == V4DPI_PntType_TagVal) { ipt = cpt ; goto tag_entry ; } ; /* If a tag then most likely Continue/End - handle, DON'T add to context */
		   if (memcmp(cpt,&protoNone,V4PS_Int) != 0)		/* Don't do anything if UV4:none */
		    { if (!v4ctx_FrameAddDim(ctx,0,cpt,0,0)) { v_Msg(ctx,NULL,"CtxAddFail",intmodx) ; ipt = NULL ; goto do_end ; } ;
		    } ;
		 } ;
		ipt = cpt ;
		break ;
	      case -V4IM_Tag_Continue:
		ipt = respnt ; intPNTv(ipt,ix) ; goto do_end ;
	      case V4IM_Tag_Continue:
		if (idpt.Bytes > 0 ? memcmp(&idpt,cpt,idpt.Bytes) == 0 : FALSE)
		 { 
/*		   Got match - as with above, return index */
		   ipt = respnt ; intPNTv(ipt,ix) ; goto do_end ;
		 } else			/* Don't have match - exit but return Continue::xxx tag point */
		 { memcpy(respnt,argpnts[ix],argpnts[ix]->Bytes) ; ipt = respnt ; goto do_end ;
		 } ;
	      case V4IM_Tag_Id:
		if (cpt->Bytes > sizeof idpt) { v_Msg(ctx,NULL,"DoInvIdVal",intmodx,ix,cpt,cpt->PntType) ; ipt = NULL ; goto do_end ; } ;
		memcpy(&idpt,cpt,cpt->Bytes) ; break ;
	      case V4IM_Tag_End:		/* If argument TRUE then don't do remainder of DO */
		ipt = v4dpi_IsctEval(&isctbuf,cpt,ctx,0,NULL,NULL) ;
		if (ipt == NULL) { v_Msg(ctx,NULL,"TagEvalFail",intmodx,V4IM_Tag_End,cpt) ; ipt = NULL ; goto do_end ; } ;
		if (ipt->PntType == V4DPI_PntType_Logical || ipt->PntType == V4DPI_PntType_Int || ipt->PntType == V4DPI_PntType_Isct)
		 { if (v4im_GetPointLog(&j,ipt,ctx)) { ix = argcnt+1 ; ipt = respnt ; logPNTv(respnt,FALSE) ; } ;
	           if (!j) { v_Msg(ctx,NULL,"TagValue2",intmodx,V4IM_Tag_End,ipt) ; ipt = NULL ; goto do_end ; } ;
		   break ;
		 } else
		 { if (idpt.Bytes > 0 ? memcmp(&idpt,ipt,idpt.Bytes) == 0 : FALSE)
		    { memcpy(respnt,ipt,ipt->Bytes) ; respnt->ForceEval = TRUE ;
/*		      Got match - as with above, return End? point for enclosing Enum() */
		      ipt = respnt ; goto do_end ;
		    } else			/* Don't have match - exit but return End::xxx tag point */
		    { memcpy(respnt,argpnts[ix],argpnts[ix]->Bytes) ; ipt = respnt ; goto do_end ;
		    } ;
		 } ;
	      case V4IM_Tag_List:
		lp = v4im_VerifyList(&ptbuf,ctx,cpt,intmodx) ;
		if (lp == NULL) { v_Msg(ctx,NULL,"ModInvArgList",intmodx,ix) ; ipt = NULL ; goto do_end ; } ;
		for(j=1;v4l_ListPoint_Value(ctx,lp,j,&isctbuf) > 0;j++)	/* Loop thru each point in list */
		 { if (isctbuf.PntType == V4DPI_PntType_Isct)		/* If an ISCT then evaluate it */
		    { ipt = v4dpi_IsctEval(&lisctbuf,&isctbuf,ctx,V4DPI_EM_EvalQuote,NULL,NULL) ;
		      if (ipt == NULL) { v_Msg(ctx,NULL,"@%1E list entry failed",intmodx) ; ipt = NULL ; goto do_end ; } ;
		    } else { ipt = &isctbuf ; } ;
		 } ;
		break ;
	      case -V4IM_Tag_Optimize:		optimize = !optimize ; break ;	/* Optimize? - toggle */
	      case V4IM_Tag_Optimize:
		if (cpt->PntType == V4DPI_PntType_Dict)
		 { DIMINFO(di,ctx,cpt->Dim) ;
		   if (di == NULL || ((di->Flags & V4DPI_DimInfo_Dim) == 0))
		    { v_Msg(ctx,NULL,"@%1E Optimize::%2D - must be Dim dimension or logical value",intmodx,di->DimId) ; ipt = NULL ; goto do_end ; } ;
		   if (cpt->Grouping == V4DPI_Grouping_Single)
		    { odl.Dims[odl.Count++] = cpt->Value.IntVal ;
		    } else
		    { pim = (struct V4DPI__Point_IntMix *)&cpt->Value ;
		      for(j=0;j<cpt->Grouping;j++) { odl.Dims[odl.Count++] = pim->Entry[j].BeginInt ; } ;
		    } ;
		   optimize = TRUE ; break ;
		 } ;
		optimize = v4im_GetPointLog(&j,cpt,ctx) ;
		if (!j) { v_Msg(ctx,NULL,"@%1E Optimize::xxx not logical - %0A",intmodx) ; ipt = NULL ; goto do_end ; } ;
		break ;
	      case V4IM_Tag_Out:
		ipt = v4dpi_IsctEval(&isctbuf,cpt,ctx,0,NULL,NULL) ;
		if (ipt == NULL) { v_Msg(ctx,NULL,"TagEvalFail",intmodx,V4IM_Tag_Out,ipt) ; ipt = NULL ; goto do_end ; } ;
		filex = vout_PntIdToFileX(ctx,(struct V4DPI__LittlePoint *)ipt) ;
		if (filex == UNUSED) { v_Msg(ctx,NULL,"StreamNoOutput",intmodx,V4IM_Tag_Out,ipt) ; ipt = NULL ; goto do_end ; } ;
		ctx->Frame[ctx->FrameCnt - 1].DataStreamFileX = filex ;
		break ;
	      case V4IM_Tag_Value:
		ipt = v4dpi_IsctEval(&valpt,cpt,ctx,0,NULL,NULL) ;
		if (ipt == NULL) { v_Msg(ctx,NULL,"@%1E Value::point failed",intmodx) ; ipt = NULL ; goto do_end ; } ;
		if (ipt->PntType == V4DPI_PntType_TagVal) goto tag_entry ;	/* If a tag then most likely Continue/End  */
		memcpy(&valpt,ipt,ipt->Bytes) ;
		break ;
	      case V4IM_Tag_While:	whilept = cpt ; break ;
	      case V4IM_Tag_XML:
		switch (v4imu_XMLSTART(ctx,&xml,ctx->Frame[ctx->FrameCnt - 1].DataStreamFileX,cpt,TRUE,intmodx,NULL))
		 { default:			ipt = NULL ; goto do_end ;
		   case XMLSTART_None:		ipt = (P *)&Log_False ;break ;
		   case XMLSTART_Normal:	ipt = (P *)&Log_True ; break ;
		   case XMLSTART_Defer:
			if (intmodx != V4IM_OpCode_Do)		/* If not Do() then must be '2nd pass' - can't defer the already deferred any more! */
			 { v_Msg(ctx,NULL,"XMLDeferInv",intmodx) ; ipt = NULL ; goto do_end ; }
			if (gpi->fileIdDefer != UNUSED)
			 { v_Msg(ctx,NULL,"DeferNoMult",intmodx) ; ipt = NULL ; goto do_end ; } ;
			/* save remainder of this Do() somewhere */
			{ LENMAX tbytes ; INDEX cx,px ; P *cpt ;
			  ctx->vdds = (struct V4IM__DeferDoSteps *)v4mm_AllocChunk(sizeof *ctx->vdds,FALSE) ;
			  ctx->vdds->argcnt = 0 ; ctx->vdds->xml = xml ;
			  for(ix++;ix<=argcnt;ix++)
			   { ctx->vdds->argcnt++ ;
			     ctx->vdds->argpnts[ctx->vdds->argcnt] = (P *)v4mm_AllocChunk(argpnts[ix]->Bytes,FALSE) ;
			     memcpy(ctx->vdds->argpnts[ctx->vdds->argcnt],argpnts[ix],argpnts[ix]->Bytes) ;
			   } ;
/*			  Save all context points so we can restore later */
			  tbytes = 0 ; ctx->vdds->ctxcnt = 0 ;		/* First get total bytes of all context points */
			  for(cx=0;cx<V4C_CtxDimHash_Max;cx++)
			   { if (ctx->DimHash[cx].Dim == 0) continue ; if ((px=ctx->DimHash[cx].CtxValIndex) < 0) continue ;
			     tbytes += ctx->CtxVal[px].Point.Bytes ; ctx->vdds->ctxcnt++ ;
			   } ;
			  if (ctx->vdds->ctxcnt > 0)
			   { ctx->vdds->ctxPts = v4mm_AllocChunk(tbytes,FALSE) ; cpt = ctx->vdds->ctxPts ;
			     for(cx=0;cx<V4C_CtxDimHash_Max;cx++)
			      { if (ctx->DimHash[cx].Dim == 0) continue ; if ((px=ctx->DimHash[cx].CtxValIndex) < 0) continue ;
			        memcpy(cpt,&ctx->CtxVal[px].Point,ctx->CtxVal[px].Point.Bytes) ; ADVPNT(cpt) ;
			      } ;
			   } ;

			}
/*			Set up to defer all subsequent output to internal buffer (so everything is put together properly at the end) */
			gpi->fileIdDefer = vout_OpenStreamBuffer(NULL,ctx->ErrorMsgAux,FALSE) ;
			ipt = (P *)&Log_True ; goto do_end ;
		 } ;
		break ;
	    } ;
	 } ;
	if (!v4imu_XMLEND(ctx,&xml,ctx->Frame[ctx->FrameCnt - 1].DataStreamFileX,intmodx,NULL)) { ipt = NULL ; goto do_end ; } ;
do_end:	if (optbuf != NULL) v4mm_FreeChunk(optbuf) ;
	if (!v4ctx_FramePop(ctx,frameid,NULL)) { v_Msg(ctx,NULL,"ModCtxPopFrame",intmodx,frameid) ; ipt = NULL ; } ;			/* Pop off frame context */
	if (ipt == NULL)
	 { REGISTER_ERROR(0) ; RETURNFAILURE ; } ;
	if (valpt.Bytes > 0) { memcpy(respnt,&valpt,valpt.Bytes) ; return(respnt) ; }		/* If got Value::xxx then use it */
	return(ipt) ;
}


ETYPE v4imu_XMLSTART(ctx,xml,filex,resPt,useNL,intmodx,outBuf)  /* FILEX,ERRLBL,VALPT,RESPT,USENL) */
  struct V4C__Context *ctx ;
  struct V4IM__XMLNest *xml ;
  INDEX filex ;
  struct V4DPI__Point *resPt ;
  INTMODX intmodx ;
  LOGICAL useNL ;
  UCCHAR *outBuf ;		/* If not NULL then override filex and append any output to this buffer */
{ struct V4DPI__Point *ipt,tpnt,ppt ;
  struct V4DPI__LittlePoint deferpt ;
  struct V4RPT__RptInfo *rri ;

	if (memcmp(resPt,&protoNone,V4PS_Int) == 0) return(XMLSTART_None) ;	/* Don't do anything if UV4:none */
	dictPNTv(&deferpt,Dim_UV4,v4im_GetEnumToDictVal(ctx,DE(Defer),UNUSED)) ;
	if (memcmp(resPt,&deferpt,V4PS_Int) == 0) return(XMLSTART_Defer) ;	/* Result is UV4:Defer ? */
	if (resPt->PntType == V4DPI_PntType_List)
	 { struct V4L__ListPoint *lp ; P tlPnt ; INDEX llx ;
	   struct V4DPI__LittlePoint lpt ;
	   dictPNTv(&lpt,Dim_UV4,v4im_GetEnumToDictVal(ctx,DE(XMLEval),UNUSED)) ;
	   if (lpt.Dim == 0 || lpt.Value.IntVal == 0)
	    { v_Msg(ctx,NULL,"UV4UndefPt",intmodx,Dim_UV4,DE(XMLEval)) ; return(XMLSTART_Fail) ; } ;
	   INITISCT(&ppt) ; NOISCTVCD(&ppt) ; ppt.Grouping = 2 ;		/* Create isct: [UV4:XMLEval IntMod:xxx ... */
	   ipt = ISCT1STPNT(&ppt) ; memcpy(ipt,&lpt,lpt.Bytes) ; ppt.Bytes += lpt.Bytes ;
	   ZPH(&lpt) ; lpt.PntType = V4DPI_PntType_IntMod ; lpt.Bytes = V4PS_Int ; lpt.Dim = Dim_IntMod ; lpt.Value.IntVal = intmodx ;
	   ADVPNT(ipt) ; memcpy(ipt,&lpt,lpt.Bytes) ; ppt.Bytes += lpt.Bytes ;
	   lp = VERIFYLIST(NULL,ctx,resPt,intmodx) ;			/* Now append each of the points in the list to the intersection */
	   for (llx=1;;llx++)
	    { if (v4l_ListPoint_Value(ctx,lp,llx,&tpnt) <= 0) break ;
	      ADVPNT(ipt) ; memcpy(ipt,&tpnt,tpnt.Bytes) ; ppt.Bytes += tpnt.Bytes ; ppt.Grouping++ ;
	      ISCTSETNESTED(&ppt,&tpnt) ;
	    } ;
	   ipt = v4dpi_IsctEval(&tlPnt,&ppt,ctx,0,NULL,NULL) ;
	   if (ipt == NULL)
	    { v_Msg(ctx,NULL,"XMLTagEvalFail",intmodx,V4IM_Tag_XML,&ppt) ; return(XMLSTART_Fail) ; } ;
	   if (memcmp(ipt,&protoNone,V4PS_Int) == 0) return(XMLSTART_None) ;	/* Don't do anything if UV4:none */
	   if (memcmp(ipt,&deferpt,V4PS_Int) == 0) return(XMLSTART_Defer) ;		/* Result is UV4:Defer ? */
	   if (ipt->PntType == V4DPI_PntType_List)			/* Got list- is it single level or do we have list of lists? */
	    { struct V4L__ListPoint *llp ;
	      lp = VERIFYLIST(NULL,ctx,ipt,intmodx) ;		/* lp is top level list off of tlPnt - do not update either of these below ! */
	      v4l_ListPoint_Value(ctx,lp,1,&ppt) ;
	      if (ppt.PntType == V4DPI_PntType_List)			/* We have a list of lists */
	       { llp = lp ;
	       } else							/* Have just a single entry */
	       { llp = NULL ;
	       } ;
	      for(llx=1;;llx++)						/* llp, if not null is top level list */
	       { P llpnt,p2Pnt ;
	         if (llp != NULL)
	          { if (v4l_ListPoint_Value(ctx,llp,llx,&llpnt) <= 0) break ;
	            lp = VERIFYLIST(NULL,ctx,&llpnt,intmodx) ;
	          } ;
/*		 At this point, lp is an inner list of 2 or 3 entries */
		 v4l_ListPoint_Value(ctx,lp,1,&ppt) ;			/* ppt = first entry in [sub]list is XML tag-arguments */
		 switch (v4imu_XMLSTART(ctx,xml,filex,&ppt,useNL,intmodx,outBuf))
		  { default:			return(XMLSTART_Fail) ;
		    case XMLSTART_None:		break ;
		    case XMLSTART_Normal:	break ;
		    case XMLSTART_Defer:	return(XMLSTART_Defer) ;
		  } ;
/*		 Second entry is string, UV4:none, or yet another list of output strings */
		 if (filex == UNUSED && gpi->fileIdDefer != UNUSED && outBuf == NULL) { filex = vout_FileIdToFileX(gpi->fileIdDefer) ; } ;
		 if (v4l_ListPoint_Value(ctx,lp,2,&p2Pnt) <= 0) continue ;	/* No second point - go onto next grouping */
		 if (memcmp(&p2Pnt,&protoNone,V4PS_Int) != 0)		/* ppt = second argument, if it's UV4:none then skip it */
		  { struct V4L__ListPoint *olp ; INDEX olx ;
		    if (p2Pnt.PntType != V4DPI_PntType_List) { olp = NULL ; }
		     else { olp = VERIFYLIST(NULL,ctx,&p2Pnt,intmodx) ; } ;
/*		    olp is inner list pointer (or NULL if not a list) */
		    for(olx=1;;olx++)
		     { P olpnt,*opt ;
		       if (olp == NULL) { opt = &p2Pnt ; }
		        else { if (v4l_ListPoint_Value(ctx,olp,olx,&olpnt) <= 0) break ;
			       opt = &olpnt ;
			     } ;
/*		       opt = point to be output */
		       ipt = v4dpi_IsctEval(&tpnt,opt,ctx,V4DPI_EM_EvalQuote,NULL,NULL) ;
		       if (ipt == NULL) { v_Msg(ctx,NULL,"@%1E() fail - XML::point failed",intmodx) ; return(XMLSTART_Fail) ; } ;
		       v4dpi_PointToStringML(UCTBUF1,ipt,ctx,V4DPI_FormatOpt_Echo,V4TMBufMax) ;
		       if (UCnotempty(UCTBUF1) || olp != NULL)
		        { if (outBuf == NULL) { vout_UCTextFileX(filex,0,UCTBUF1) ; vout_NLFileX(filex) ; }
			   else { UCstrcat(outBuf,UCTBUF1) ; } ;
		        } ;
		       if (olp == NULL) break ;
		     } ;
		  } ;
/*		 If third element (probably a list) then save it for processing at the end of this tag's scope */
		 if (v4l_ListPoint_Value(ctx,lp,3,&ppt) > 0)		/* Skip if no third point */
		  { xml->Nest[xml->Count-1].eolPt = (P *)v4mm_AllocChunk(ppt.Bytes,FALSE) ;
		    memcpy(xml->Nest[xml->Count-1].eolPt,&ppt,ppt.Bytes) ;
		  } ;
/*		 Should we continue or are we done ? */
		 if (llp == NULL) break ;
	       }
	      return(XMLSTART_Normal) ;
	    } ;
/*	   Nothing special - just handle normally */
	   resPt = ipt ;
	 } ;
/*	If filex stream also bound to Rpt() and that report is not HTML/XML then ignore all of this */
	if (outBuf == NULL)
	 { rri = vout_rriGet(filex) ;
	   switch (rri != NULL ? rri->rptType : V4RPT_Type_HTML)
	    { default:			return(XMLSTART_Normal) ;
	      case V4RPT_Type_HTML:
	      case V4RPT_Type_XML:	break ;
	    } ;
	 } ;
	if (xml->Count >= XMLSegMax)
	 { v_Msg(ctx,NULL,"@%1E() fail - Too many(%2d) nested XML::points",intmodx,xml->Count) ; return(XMLSTART_Fail) ; } ;
	ctx->pi->XMLIndent++ ;
	ipt = v4dpi_IsctEval(&tpnt,resPt,ctx,V4DPI_EM_EvalQuote,NULL,NULL) ;
	if (ipt == NULL) { v_Msg(ctx,NULL,"@%1E() fail - XML::point failed",intmodx) ; return(XMLSTART_Fail) ; } ;
	if (memcmp(ipt,&protoNone,V4PS_Int) == 0) return(XMLSTART_None) ;	/* Don't do anything if UV4:none */
	v4dpi_PointToStringML(UCTBUF1,ipt,ctx,V4DPI_FormatOpt_Echo,V4TMBufMax) ;
	if (gpi->xmlCase != 0)
	 { INDEX i ;
	   for(i=0;UCTBUF1[i]!=UCEOS&&!vuc_IsWSpace(UCTBUF1[i]);i++)
	    { UCTBUF1[i] = (gpi->xmlCase == 1 ? UCTOUPPER(UCTBUF1[i]) : UCTOLOWER(UCTBUF1[i])) ;
	    } ;
	 } ;
	if (filex == UNUSED && gpi->fileIdDefer != UNUSED && outBuf == NULL) { filex = vout_FileIdToFileX(gpi->fileIdDefer) ; } ;
	if (UCnotempty(UCTBUF1))
	 { v_Msg(ctx,UCTBUF2,"@%1W<%2U>",(useNL || xml->Count == 0 ? ctx->pi->XMLIndent : 0),UCTBUF1) ;
	   if (outBuf == NULL) { vout_UCTextFileX(filex,0,UCTBUF2) ; if (useNL) vout_NLFileX(filex) ; }
	    else { UCstrcat(outBuf,UCTBUF2) ; } ;
	 } ;
	xml->b = UCstrchr(UCTBUF1,' ') ; if (xml->b != NULL) *xml->b = UCEOS ;
	UCstrncpy(xml->Nest[xml->Count].seg,UCTBUF1,UCsizeof(xml->Nest[xml->Count].seg)) ;
	xml->Nest[xml->Count].indent = ctx->pi->XMLIndent ; xml->Nest[xml->Count].UseNL = useNL ;
	xml->Nest[xml->Count].eolPt = NULL ;
	xml->Count++ ;
	return(XMLSTART_Normal) ;
}

LOGICAL v4imu_XMLEND(ctx,xml,filex,intmodx,outBuf)	/* #define XMLEND(FILEX) */
  struct V4C__Context *ctx ;
  struct V4IM__XMLNest *xml ;
  INDEX filex ; INTMODX intmodx ;
  UCCHAR *outBuf ;
{ struct V4RPT__RptInfo *rri ;
  INDEX i ;

/*	If filex stream also bound to Rpt() and that report is not HTML/XML then ignore all of this */
	if (xml->Count <= 0) return(TRUE) ;
	rri = vout_rriGet(filex) ;
	switch (rri != NULL ? rri->rptType : V4RPT_Type_HTML)
	 { default:			return(TRUE) ;
	   case V4RPT_Type_HTML:
	   case V4RPT_Type_XML:		break ;
	 } ;
	if (filex == UNUSED && gpi->fileIdDefer != UNUSED && outBuf == NULL) { filex = vout_FileIdToFileX(gpi->fileIdDefer) ; } ;
	for(i=xml->Count-1;i>=0;i--)
	 { 
	   if (xml->Nest[i].eolPt != NULL)
	    { struct V4DPI__LittlePoint lpt ; P *ipt,isct,lpnt,tpnt ; struct V4L__ListPoint *lp ; INDEX lx ;
	      dictPNTv(&lpt,Dim_UV4,v4im_GetEnumToDictVal(ctx,DE(XMLEvalEnd),UNUSED)) ;
	      if (lpt.Dim == 0 || lpt.Value.IntVal == 0)
	       { v_Msg(ctx,NULL,"UV4UndefPt",intmodx,Dim_UV4,DE(XMLEvalEnd)) ; return(FALSE) ; } ;
	      INITISCT(&isct) ; NOISCTVCD(&isct) ; isct.Grouping = 2 ;			/* Create isct: [UV4:XMLEvalEnd IntMod:xxx whatever is in eolPt] */
	      ipt = ISCT1STPNT(&isct) ; memcpy(ipt,&lpt,lpt.Bytes) ; isct.Bytes += lpt.Bytes ;
	      ZPH(&lpt) ; lpt.PntType = V4DPI_PntType_IntMod ; lpt.Bytes = V4PS_Int ; lpt.Dim = Dim_IntMod ; lpt.Value.IntVal = intmodx ;
	      ADVPNT(ipt) ; memcpy(ipt,&lpt,lpt.Bytes) ; isct.Bytes += lpt.Bytes ;
	      lp = VERIFYLIST(&lpnt,ctx,xml->Nest[i].eolPt,0) ;
	      for(lx=1;;lx++)
	       { if (v4l_ListPoint_Value(ctx,lp,lx,&tpnt) <= 0) break ;
	         ADVPNT(ipt) ; memcpy(ipt,&tpnt,tpnt.Bytes) ; isct.Bytes += tpnt.Bytes ; isct.Grouping++ ;
		 ISCTSETNESTED(&isct,&tpnt) ;
	       } ;
	      ipt = v4dpi_IsctEval(&tpnt,&isct,ctx,0,NULL,NULL) ;
	      if (ipt == NULL)
	       { v_Msg(ctx,NULL,"XMLTagEvalFail",intmodx,V4IM_Tag_XML,&isct) ; return(FALSE) ; } ;
	      v4mm_FreeChunk(xml->Nest[i].eolPt) ;
	    } ;
	   ctx->pi->XMLIndent = xml->Nest[i].indent ;
	   if (xml->Nest[i].UseNL)
	    { v_Msg(ctx,UCTBUF2,"@%1W%2U</%3U>",(xml->Nest[i].UseNL || xml->Count == 0 ? ctx->pi->XMLIndent : 0),UClit(""),xml->Nest[i].seg) ;
	    } else { v_Msg(ctx,UCTBUF2,"@</%1U>",xml->Nest[i].seg) ; } ;
	   if (UCstrlen(xml->Nest[i].seg) > 0)
	    { if (outBuf == NULL) { vout_UCTextFileX(filex,0,UCTBUF2) ; if (xml->Nest[i].UseNL) vout_NLFileX(filex) ; }
	       else { UCstrcat(outBuf,UCTBUF2) ; } ;
	    } ;
	 } ;
	ctx->pi->XMLIndent-- ;
	return(TRUE) ;
}




/*	v4im_DoFormat - Handles Format() IntMod		*/

P *v4im_DoFormat(ctx,respnt,argcnt,argpnts,intmodx)
  struct V4C__Context *ctx ;
  INTMODX intmodx ;
  P *respnt,*argpnts[] ;
  COUNTER argcnt ;
{ P *ipt,*cpt,ptbuf,rdbpt ;
  struct V4DPI__LittlePoint nonePt ;
  struct V4DPI__DimInfo *di ;
  enum DictionaryEntries rdb ;
  char mbuf[255], fill[255], fstr[V4DPI_AlphaVal_Max+100] ; UCCHAR ucbuf[V4LEX_BigText_Max+100], *ubp, *ubp1 ;
  int i,j,k,len,skip,width,lcr,ok,argx,formaton,num,maximum ; char *bp ; double dnum,dnum1 ;

	skip = UNUSED ; width = UNUSED ; ok = TRUE ; ZPH(respnt) ; ZS(fill) ; maximum = UNUSED ;
	ipt = argpnts[1] ;
/*	Treat points on Dim:Dim as special formatting points (via SSDim()) UNLESS 1st argument is on Dim:Dim and second argument is tagged value */
	if (ipt->Dim != Dim_Dim) { argx = 2 ; } else { argx = (argpnts[2]->PntType == V4DPI_PntType_TagVal ? 2 : 1) ; } ;
	lcr = UNUSED ;
	for(;ok && argx<=argcnt;argx++)
	 { if (argx == skip) continue ;
	   switch (k=v4im_CheckPtArgNew(ctx,argpnts[argx],&cpt,&ptbuf))
	    { default:			v_Msg(ctx,NULL,"TagBadUse",intmodx) ; goto format_fail ;
	      case V4IM_Tag_Unk:	v_Msg(ctx,NULL,"TagUnknown",intmodx) ; goto format_fail ;
	      case V4IM_Tag_Left:	width = v4im_GetPointInt(&ok,cpt,ctx) ; lcr = 1 ; break ;
	      case V4IM_Tag_Right:	width = v4im_GetPointInt(&ok,cpt,ctx) ; lcr = 3 ; break ;
	      case V4IM_Tag_Center:	width = v4im_GetPointInt(&ok,cpt,ctx) ; lcr = 2 ; break ;
	      case -V4IM_Tag_CSV:
		v4im_GetPointUC(&ok,ucbuf,UCsizeof(ucbuf),ipt,ctx) ; if (!ok) break ;
		j = FALSE ;
		for (i=0;ucbuf[i]!=UCEOS;i++)
		 { if (ucbuf[i] == UClit('"') || ucbuf[i] == UClit(',') || ucbuf[i] <= 26)
		    { j = TRUE ; break ; } ;
		 } ;
		if (!j)
		 { if (i >= V4DPI_UCVAL_MaxSafe)
		    { struct V4LEX__BigText bt ;
		      if (i >= V4LEX_BigText_Max) { v_Msg(ctx,NULL,"@%1E - Result string (len=%2d) exceeds max length allowed(%3d)",intmodx,i,V4LEX_BigText_Max) ; goto format_fail ; } ;
		      UCstrcpy(bt.BigBuf,ucbuf) ;
		      if (!v4dpi_SaveBigTextPoint(ctx,&bt,i,respnt,Dim_Alpha,TRUE)) { v_Msg(ctx,NULL,"StrSaveBigText",intmodx,V4DPI_PntType_BigText) ; goto format_fail ; } ;
		    } else { uccharPNTvl(respnt,ucbuf,i) ; } ;
		   return(respnt) ;
		 } ;
		UCTBUF1[0] = UClit('"') ;
		for(i=0,j=1;ucbuf[i]!=UCEOS;i++)
		 { UCTBUF1[j++] = ucbuf[i] ;
		   if (ucbuf[i] == UClit('"')) { UCTBUF1[j++] = UClit('"') ; } ;
		 } ;
		UCTBUF1[j++] = UClit('"') ; UCTBUF1[j] = UCEOS ;
		if (j >= V4DPI_UCVAL_MaxSafe)
		 { struct V4LEX__BigText bt ;
		   if (j >= V4LEX_BigText_Max) { v_Msg(ctx,NULL,"@%1E - Result string (len=%2d) exceeds max length allowed(%3d)",intmodx,j,V4LEX_BigText_Max) ; goto format_fail ; } ;
		      UCstrcpy(bt.BigBuf,UCTBUF1) ;
		      if (!v4dpi_SaveBigTextPoint(ctx,&bt,j,respnt,Dim_Alpha,TRUE)) { v_Msg(ctx,NULL,"StrSaveBigText",intmodx,V4DPI_PntType_BigText) ; goto format_fail ; } ;
		 } else { uccharPNTvl(respnt,UCTBUF1,j) ; } ;
		return(respnt) ;
	      case V4IM_Tag_Dim:
		if (argx == 2)			/* Is this second argument, if so then start with first */
		 { v4im_GetPointChar(&ok,fstr,sizeof fstr,argpnts[1],ctx) ; if (!ok) break ; }
		 else { ZS(fstr) ; } ;
		formaton = 0 ;
		for(;argx<=argcnt;argx++)
		 { ipt = argpnts[argx] ;
		   if (ipt->Dim == Dim_Dim)
		    { for(k=0;k<(vdfm == NULL ? 0 : vdfm->Count);k++)
		       { if (vdfm->dimIdList[k] != ipt->Value.IntVal) continue ;
/*			 Found dimension in list - store index+1 (0 means no index) */
			 formaton = 1 ; mbuf[0] = '\001' ; mbuf[1] = k+2 ; mbuf[2] = '\0' ; strcat(fstr,mbuf) ; break ;
		       } ;
		      if (k >= (vdfm == NULL ? 0 : vdfm->Count))
		       { v_Msg(ctx,NULL,"@%1E (arg #%2d) - Dimension not defined via SSDim() module",intmodx,argx) ; goto format_fail ; } ;
		    } else
		    { if ((formaton--) <= 0)		/* Terminate formatting with 1 index */
		       { mbuf[0] = '\001' ; mbuf[1] = 1 ; mbuf[2] = '\0' ; strcat(fstr,mbuf) ; formaton = FALSE ; } ;
		      v4im_GetPointChar(&ok,ASCTBUF1,V4TMBufMax,argpnts[argx],ctx) ; if (!ok) break ;
		      if (strlen(fstr) + strlen(ASCTBUF1) >= V4DPI_AlphaVal_Max)
		       { v_Msg(ctx,NULL,"ModArgMaxAlpha",intmodx,argx,strlen(fstr),strlen(ASCTBUF1),V4DPI_AlphaVal_Max) ; goto format_fail ; } ;
		      strcat(fstr,ASCTBUF1) ;
		    } ;
		 } ;
		width = strlen(fstr) ; strcpy(&respnt->Value.AlphaVal[1],fstr) ;
		respnt->Dim = Dim_Alpha ; respnt->PntType = V4DPI_PntType_Char ;
		CHARPNTBYTES2(respnt,width)
		return(respnt) ;
	      case V4IM_Tag_Num:
		i = v4im_GetPointInt(&ok,cpt,ctx) ; if (!ok) { argx = 2 ; break ; } ;
		v4im_GetPointChar(&ok,fstr,sizeof fstr,ipt,ctx) ; if (!ok) break ;
		bp = &respnt->Value.AlphaVal[1] ; ZS(bp) ; k = strlen(fstr) ;
		 if (k * i >= V4DPI_AlphaVal_Max) { v_Msg(ctx,NULL,"ModStrTooLong",intmodx,k*i,V4DPI_AlphaVal_Max-1) ; goto format_fail ; } ;
		for(;i>0;i--) strcat(bp,fstr) ;
		alphaPNT(respnt) ; CHARPNTBYTES1(respnt) ; ipt = respnt ;
		continue ;
	      case V4IM_Tag_NE:
		dnum = v4im_GetPointDbl(&ok,ipt,ctx) ; if (!ok) { argx = 2 ; break ; } ;
		dnum1 = v4im_GetPointDbl(&ok,cpt,ctx) ; if (!ok) break ; skip = (dnum != dnum1 ? argx+2 : argx+1) ; break ;
	      case V4IM_Tag_LT:
		dnum = v4im_GetPointDbl(&ok,ipt,ctx) ; if (!ok) { argx = 2 ; break ; } ;
		dnum1 = v4im_GetPointDbl(&ok,cpt,ctx) ; if (!ok) break ; skip = (dnum < dnum1 ? argx+2 : argx+1) ; break ;
	      case V4IM_Tag_LE:
		dnum = v4im_GetPointDbl(&ok,ipt,ctx) ; if (!ok) { argx = 2 ; break ; } ;
		dnum1 = v4im_GetPointDbl(&ok,cpt,ctx) ; if (!ok) break ; skip = (dnum <= dnum1 ? argx+2 : argx+1) ; break ;
	      case V4IM_Tag_EQ:
		dnum = v4im_GetPointDbl(&ok,ipt,ctx) ; if (!ok) { argx = 2 ; break ; } ;
		dnum1 = v4im_GetPointDbl(&ok,cpt,ctx) ; if (!ok) break ; skip = (dnum == dnum1 ? argx+2 : argx+1) ; break ;
	      case V4IM_Tag_GE:
		dnum = v4im_GetPointDbl(&ok,ipt,ctx) ; if (!ok) { argx = 2 ; break ; } ;
		dnum1 = v4im_GetPointDbl(&ok,cpt,ctx) ; if (!ok) break ; skip = (dnum >= dnum1 ? argx+2 : argx+1) ; break ;
	      case V4IM_Tag_GT:
		dnum = v4im_GetPointDbl(&ok,ipt,ctx) ; if (!ok) { argx = 2 ; break ; } ;
		dnum1 = v4im_GetPointDbl(&ok,cpt,ctx) ; if (!ok) break ; skip = (dnum > dnum1 ? argx+2 : argx+1) ; break ;
	      case -V4IM_Tag_Point:
		uccharPNT(respnt) ;
//		if (ipt->PntType != V4DPI_PntType_Special && ipt->PntType != V4DPI_PntType_Isct && ipt->PntType != V4DPI_PntType_List)
//		 { DIMINFO(di,ctx,ipt->Dim) ;
//		   if (di != NULL) { UCstrcpy((&respnt->Value.UCVal[1]),di->DimName) ; UCstrcat(&respnt->Value.UCVal[1],UClit(":")) ; }
//		    else { UCsprintf(&respnt->Value.UCVal[1],20,UClit("?%d?:"),di->DimId) ; } ;
//		 } else { respnt->Value.UCVal[1] = UCEOS ; } ;
//		v4dpi_PointToStringML(&respnt->Value.UCVal[1+UCstrlen(&respnt->Value.UCVal[1])],ipt,ctx,(ipt->PntType == V4DPI_PntType_List ? V4DPI_FormatOpt_ShowDim|V4DPI_FormatOpt_AlphaQuote : V4DPI_FormatOpt_Echo|V4DPI_FormatOpt_AlphaQuote),V4DPI_AlphaVal_Max-50) ;
		v4dpi_PointToStringML(&respnt->Value.UCVal[1],ipt,ctx,V4DPI_FormatOpt_Point,V4DPI_UCVal_Max-32) ;
		UCCHARPNTBYTES1(respnt) ; ipt = respnt ; goto format_done ;
	      case V4IM_Tag_Maximum:
		maximum = v4im_GetPointInt(&ok,cpt,ctx) ; if (!ok) break ;
		if (maximum <= 0) { v_Msg(ctx,NULL,"ModArgVal",intmodx,argx,cpt,0) ; goto format_fail ; } ;
		break ;
	      case V4IM_Tag_Fill:
		v4im_GetPointChar(&ok,fill,sizeof fill,cpt,ctx) ; break ;
	      case V4IM_Tag_Value:
		v4im_GetPointChar(&ok,&respnt->Value.AlphaVal[1],V4DPI_AlphaVal_Max-1,cpt,ctx) ; if (!ok) break ;
		width = strlen(&respnt->Value.AlphaVal[1]) ;
		alphaPNT(respnt) ; CHARPNTBYTES2(respnt,width)
		ipt = respnt ;
		continue ;
	      case -V4IM_Tag_Range:
		uccharPNT(respnt) ; ubp = &respnt->Value.UCVal[1] ;
		switch (ipt->Grouping)
		 { default:	v_Msg(ctx,NULL,"FormatTooCmplx",1,intmodx,ipt) ; goto format_fail ;
		   case 1:
			v4dpi_PointToString(UCTBUF1,ipt,ctx,V4DPI_FormatOpt_Echo) ;
			ubp1 = UCstrstr(UCTBUF1,UClit("..")) ;
			if (ubp1 == NULL) { v_Msg(ctx,NULL,"FormatTooCmplx",intmodx,1,ipt) ; goto format_fail ; } ;
			*ubp1 = '\0' ;
			v_Msg(ctx,ubp,"FormatRngThru",UCTBUF1,ubp1+2) ; break ;
		   case V4DPI_Grouping_All:	v_Msg(ctx,ubp,"FormatRngAll") ; break ;
		   case V4DPI_Grouping_Single:	v_Msg(ctx,ubp,"FormatRngEQ") ; UCstrcat(ubp,UClit(" ")) ; break ;
		   case V4DPI_Grouping_LT:	v_Msg(ctx,ubp,"FormatRngLT") ; UCstrcat(ubp,UClit(" ")) ; break ;
		   case V4DPI_Grouping_LE:	v_Msg(ctx,ubp,"FormatRngLE") ; UCstrcat(ubp,UClit(" ")) ; break ;
		   case V4DPI_Grouping_GE:	v_Msg(ctx,ubp,"FormatRngGE") ; UCstrcat(ubp,UClit(" ")) ; break ;
		   case V4DPI_Grouping_GT:	v_Msg(ctx,ubp,"FormatRngGT") ; UCstrcat(ubp,UClit(" ")) ; break ;
		   case V4DPI_Grouping_NE:	v_Msg(ctx,ubp,"FormatRngNE") ; UCstrcat(ubp,UClit(" ")) ; break ;
		 } ;
		if (ipt->Grouping != 1 && ipt->Grouping != V4DPI_Grouping_All)
		 { memcpy(&ptbuf,ipt,ipt->Bytes) ; ptbuf.Grouping = V4DPI_Grouping_Single ;
		   v4dpi_PointToString(UCTBUF2,&ptbuf,ctx,V4DPI_FormatOpt_Echo) ;
		   UCstrcat(ubp,UCTBUF2) ;
		 } ;
		UCCHARPNTBYTES1(respnt)
		ipt = respnt ;
		goto format_done ;
	      case V4IM_Tag_RDBId:
		v4im_GetPointUC(&ok,ucbuf,UCsizeof(ucbuf),ipt,ctx) ; if (!ok) break ;
		switch (rdb = v4im_GetDictToEnumVal(ctx,cpt))
		 { default:		v_Msg(ctx,NULL,"FormatRDB",intmodx,cpt) ; goto format_fail ;
		   case _MSAccess:	UCstrcpy(UCTBUF1,UClit("#")) ; UCstrcat(UCTBUF1,ucbuf) ; UCstrcat(UCTBUF1,UClit("#")) ; break ;
		   case _Oracle:
		   case _iSeries:
		   case _MSSQL:
		   case _MIDAS:		UCstrcpy(UCTBUF1,ucbuf) ; break ;
		   case _MySQL:		UCstrcpy(UCTBUF1,UClit("`")) ; UCstrcat(UCTBUF1,ucbuf) ; UCstrcat(UCTBUF1,UClit("`")) ; break ;
		 } ;
		uccharPNTv(respnt,UCTBUF1) ; ipt = respnt ;
		goto format_done ;
	      case V4IM_Tag_RDBw:
		switch (ipt->Grouping)	/* If not a single point then try to get single value from it */
		 { default:			v_Msg(ctx,NULL,"FormatRDBrVal",intmodx,V4IM_Tag_RDBw,ipt) ; goto format_fail ;
		   case V4DPI_Grouping_Single:	break ;
		   case V4DPI_Grouping_LT:
		   case V4DPI_Grouping_LE:
		   case V4DPI_Grouping_GE:
		   case V4DPI_Grouping_GT:
		   case V4DPI_Grouping_NE:	memcpy(&rdbpt,ipt,ipt->Bytes) ; ipt = &rdbpt ; ipt->Grouping = V4DPI_Grouping_Single ; break ;
		 } ;
/*		Now fall thru into RDB and handle */
	      case V4IM_Tag_RDB:
		switch (rdb = v4im_GetDictToEnumVal(ctx,cpt))
		 { default:		v_Msg(ctx,NULL,"FormatRDB",intmodx,cpt) ; goto format_fail ;
		   case _MSAccess:
		   case _Oracle:
		   case _MIDAS:
		   case _MySQL:
		   case _MSSQL:
		   case _iSeries:	break ;
		 } ;
		switch (ipt->Grouping)
		 { default:
			if (ipt->PntType == V4DPI_PntType_Dict || ipt->PntType == V4DPI_PntType_XDict) break ;
			v_Msg(ctx,NULL,"FormatRDBMult",intmodx,V4IM_Tag_RDB,ipt) ; goto format_fail ; 
		   case V4DPI_Grouping_None:
			DIMINFO(di,ctx,ipt->Dim) ;
			if (di->Flags & V4DPI_DimInfo_HaveNone)
			 { switch(di->PointType)
			    { default:			ok = FALSE ; break ;
			      case V4DPI_PntType_Int:	intPNTv((P *)&nonePt,di->ds.Int.NoneValue) ; ipt = (P *)&nonePt ; break ;
			      case V4DPI_PntType_Real:	dblPNTv((P *)&nonePt,di->ds.Real.NoneValue) ; ipt = (P *)&nonePt ; break ;
			    } ;
			 } else { ok = FALSE ; } ;
			if (!ok) { v_Msg(ctx,ctx->ErrorMsgAux,"ProjectDTProbN",ipt,di->DimId,ipt->Dim) ; continue ; } ;
			break ;
		   case V4DPI_Grouping_Single:
		   case V4DPI_Grouping_LT:
		   case V4DPI_Grouping_LE:
		   case V4DPI_Grouping_GE:
		   case V4DPI_Grouping_GT:
		   case V4DPI_Grouping_NE:	break ;
		 } ;
		uccharPNT(respnt) ;
		if (ipt->PntType == V4DPI_PntType_Shell) ipt = (P *)&ipt->Value ;
		DIMINFO(di,ctx,ipt->Dim) ;
		if ((di->Flags & V4DPI_DimInfo_RDBNumeric) != 0)	/* If RDB wants internal value then give it */
		 { UCsprintf(&respnt->Value.UCVal[1],128,UClit("%d"),ipt->Value.IntVal) ;  UCCHARPNTBYTES1(respnt) ; return(respnt) ; } ;
		switch (ipt->PntType)
		 { default:
			v_Msg(ctx,NULL,"FormatRDBType",intmodx,ipt,ipt->PntType) ; goto format_fail ;
		   case V4DPI_PntType_Delta:
		   case V4DPI_PntType_CodedRange:
		   case V4DPI_PntType_Int:
		   case V4DPI_PntType_Fixed:
		   case V4DPI_PntType_Real:
			if ((di->Flags & V4DPI_DimInfo_Displayer) != 0)
			 goto format_str_entry ;
			v4dpi_PointToString(&respnt->Value.UCVal[1],ipt,ctx,V4DPI_FormatOpt_Echo) ;
			UCCHARPNTBYTES1(respnt) ;
			return(respnt) ;
		   case V4DPI_PntType_UOM:
		   case V4DPI_PntType_UOMPer:
		   case V4DPI_PntType_UOMPUOM:
		   case V4DPI_PntType_Complex:
		   case V4DPI_PntType_Time:
		   case V4DPI_PntType_UTime:
		   case V4DPI_PntType_GeoCoord:
		   CASEofChar
		   case V4DPI_PntType_RegExpPattern:
		   case V4DPI_PntType_Country:
		   case V4DPI_PntType_Color:
		   case V4DPI_PntType_Dict:
		   case V4DPI_PntType_XDict:
//		   case V4DPI_PntType_BigText:
format_str_entry:
			v4dpi_PointToStringML(ucbuf,ipt,ctx,V4DPI_FormatOpt_Echo,V4LEX_BigText_Max) ;
			/*VEH160803 - Make sure all bytes are ASCII characters */
			/*VEH200910 - Make sure all characters will fit in byte */
			for (i = 0; ucbuf[i]!=UCEOS; i++)
			 { if (ucbuf[i] <= 255) continue;
			   switch (ucbuf[i])
			    {
			      default:		ucbuf[i] = UClit('.'); break ;
			      case 0x2018:	/* Replace fancy single left/right/apostrophe with single quote*/
			      case 0x2019:
			      case 0x02bc:	ucbuf[i] = UClit('\'') ; break ;
			      case 0x201c:	/* Replace fancy double left/right with double quote */
			      case 0x201d:	ucbuf[i] = UClit('"') ; break ;
			    };
			 };
			switch (rdb)
			 {
			   case _MIDAS:
				i = 0 ; j = 0 ; UCTBUF1[i++] = UClit('\'') ;
				for(;i < V4LEX_BigText_Max - 5 && ucbuf[j] != UCEOS;)
				 { if (ucbuf[j] == UClit('`')) ucbuf[j] = UClit('\'') ;		/* Back-tick causes problems in shell parsing on MIDAS side, convert to regular quote */
				   if (ucbuf[j] == UClit('\'')) UCTBUF1[i++] = UClit('\'') ;
				   UCTBUF1[i++] = ucbuf[j++] ;
				 } ;
				UCTBUF1[i++] = UClit('\'') ; UCTBUF1[i] = UCEOS ;
				len = UCstrlen(UCTBUF1) ;
				break ;
			   case _iSeries:
			   case _MSAccess:
			   case _MSSQL:
			   case _Oracle:
				i = 0 ; j = 0 ; UCTBUF1[i++] = UClit('\'') ;
				for(;i < V4LEX_BigText_Max - 5 && ucbuf[j] != UCEOS;)
				 { if (ucbuf[j] == UClit('\'')) UCTBUF1[i++] = UClit('\'') ;
				   UCTBUF1[i++] = ucbuf[j++] ;
				 } ;
				UCTBUF1[i++] = UClit('\'') ; UCTBUF1[i] = UCEOS ;
				len = UCstrlen(UCTBUF1) ;
				break ;
			   case _MySQL:
				if ((di->Flags & V4DPI_DimInfo_CaseSensitive) != 0)
				 { UCstrcpy(UCTBUF1,UClit("binary ")) ; len = 7 ;
				 } else { len = 0 ; } ;
				len += v_StringLit(ucbuf,&UCTBUF1[len],V4TMBufMax,'\'','\\') ;
				break ;
			 } ;
			if (len >= V4DPI_UCVAL_MaxSafe)
			 { struct V4LEX__BigText bt ;
			   if (len >= V4LEX_BigText_Max) { v_Msg(ctx,NULL,"@%1E - Result string (len=%2d) exceeds max length allowed(%3d)",intmodx,len,V4LEX_BigText_Max) ; goto format_fail ; } ;
			   UCstrcpy(bt.BigBuf,UCTBUF1) ;
			   if (!v4dpi_SaveBigTextPoint(ctx,&bt,len,respnt,Dim_Alpha,TRUE)) { v_Msg(ctx,NULL,"StrSaveBigText",intmodx,V4DPI_PntType_BigText) ; goto format_fail ; } ;
			 } else	{ UCstrcpy(&respnt->Value.UCVal[1],UCTBUF1) ; UCCHARPNTBYTES2(respnt,len) ; } ;
			return(respnt) ;
		   case V4DPI_PntType_TeleNum:
			if (ipt->Value.IntVal == 0) { uccharPNTv(respnt,UClit("NULL")) ; return(respnt) ; } ;
			switch (rdb)
			 {
			   case _MIDAS:
			    if (ipt->Value.Tele.Number == 0 && ipt->Value.Tele.AreaCode == 0)
			     { uccharPNTv(respnt,UClit("'none'")) ; return(respnt) ; } ;    /* MIDAS wants to see 'none' for empty phone number */
/*			    Otherwise, fall thru and handle like all the others */
			   case _iSeries:
			   case _MSSQL:
			   case _MSAccess:
			   case _MySQL:
			   case _Oracle:
			    goto format_str_entry ;
			 } ;
			break ;
		   case V4DPI_PntType_UPeriod:
//xxx format(rdb) di of ipt
			if (ipt->Value.IntVal == 0) { uccharPNTv(respnt,UClit("NULL")) ; return(respnt) ; } ;
			switch (rdb)
			 { default:
			    { int y,period,ppy ;
			      DIMINFO(di,ctx,ipt->Dim) ; ppy = (di->ds.UPeriod.periodsPerYear == 0 ? 13 : di->ds.UPeriod.periodsPerYear) ;
			      if (ipt->Value.IntVal > 100000)				/* Got regular period or year end adjustment? */
			        { y = ipt->Value.IntVal / 100 ; period = (ipt->Value.IntVal % 100) ; }
			        else { y = (ipt->Value.IntVal / ppy) + VCAL_BaseYear ; period = (ipt->Value.IntVal % ppy) + 1 ; } ;
			      num = y * 100 + period ;
			    }
			 } ;
			UCsprintf(&respnt->Value.UCVal[1],25,UClit("%d"),num) ;
			UCCHARPNTBYTES1(respnt) ; return(respnt) ;
			break ;
		   case V4DPI_PntType_UYear:
			if (ipt->Value.IntVal == 0) { uccharPNTv(respnt,UClit("NULL")) ; return(respnt) ; } ;
			switch (rdb)
			 { default:
			    num = ipt->Value.IntVal ; break ;
			 } ;
			UCsprintf(&respnt->Value.UCVal[1],25,UClit("%d"),num) ;
			UCCHARPNTBYTES1(respnt) ; return(respnt) ;
			break ;
		   case V4DPI_PntType_UQuarter:
			if (ipt->Value.IntVal == 0) { uccharPNTv(respnt,UClit("NULL")) ; return(respnt) ; } ;
			switch (rdb)
			 { default:
			    { 
//			      int y,w ;
//			      y = (ipt->Value.IntVal / 4) + VCAL_BaseYear ; w = (ipt->Value.IntVal % 4) + 1 ;
//			      num = y * 10 + w ;
			      num = UQTRtoUYEAR(ipt->Value.IntVal) * 10 + UQTRtoQTR(ipt->Value.IntVal) ;
			    }
			 } ;
			UCsprintf(&respnt->Value.UCVal[1],25,UClit("%d"),num) ;
			UCCHARPNTBYTES1(respnt) ; return(respnt) ;
			break ;
		   case V4DPI_PntType_UWeek:
			if (ipt->Value.IntVal == 0) { uccharPNTv(respnt,UClit("NULL")) ; return(respnt) ; } ;
			switch (rdb)
			 { default:
			    { int y,w ;
			      y = (ipt->Value.IntVal / 52) + VCAL_BaseYear ; w = (ipt->Value.IntVal % 52) + 1 ;
			      num = y * 100 + w ;
			    }
			 } ;
			UCsprintf(&respnt->Value.UCVal[1],25,UClit("%d"),num) ;
			UCCHARPNTBYTES1(respnt) ; return(respnt) ;
			break ;
		   case V4DPI_PntType_UMonth:
			if (ipt->Value.IntVal == 0) { uccharPNTv(respnt,UClit("NULL")) ; return(respnt) ; } ;
			switch (rdb)
			 { default:
			    { int y,m ;
			      y = (ipt->Value.IntVal / 12) + VCAL_BaseYear ; m = (ipt->Value.IntVal % 12)+1 ;
			      num = y * 100 + m ;
			    } break ;
			   case _MIDAS:
			    num = ipt->Value.IntVal ; break ;
			 } ;
			UCsprintf(&respnt->Value.UCVal[1],25,UClit("%d"),num) ;
			UCCHARPNTBYTES1(respnt) ; return(respnt) ;
			break ;
		   case V4DPI_PntType_Logical:
			if(ipt->Value.IntVal <= 0) { uccharPNTv(respnt,UClit("0")) ; }
			 else { switch (rdb)
				 { case _MIDAS:
				   case _MySQL:
				   case _Oracle:	uccharPNTv(respnt,UClit("1")) ; break ; 
				   case _iSeries:
				   case _MSSQL:
				   case _MSAccess:	uccharPNTv(respnt,UClit("-1")) ; break ; 
				 } ;
			      } ;
			return(respnt) ;
		   case V4DPI_PntType_Calendar:
			GETREAL(dnum,ipt) ;
			if (dnum == VCal_NullDate)
			 { uccharPNTv(respnt,UClit("NULL")) ; return(respnt) ; } ;
		   case V4DPI_PntType_UDT:
			if (ipt->Value.IntVal == VCAL_UDT_None) { uccharPNTv(respnt,UClit("NULL")) ; return(respnt) ; } ;
			switch (rdb)
			 {
			   case _iSeries:
			    i = v_FormatDate(&ipt->Value.IntVal,ipt->PntType,VCAL_CalType_UseDeflt,VCAL_TimeZone_Local,UClit("yyyy-0m-0d:0h:0n:0s"),ucbuf) ;
			    respnt->Value.UCVal[1] = UClit('\'') ; UCstrcpy(&respnt->Value.UCVal[2],ucbuf) ;
			    UCstrcat(&respnt->Value.UCVal[2],UClit("'")) ;
			    UCCHARPNTBYTES1(respnt) ; return(respnt) ;
			    break ;
			   case _MySQL:
			   case _MSSQL:
			    i = v_FormatDate(&ipt->Value.IntVal,ipt->PntType,VCAL_CalType_UseDeflt,VCAL_TimeZone_Local,UClit("yyyy-0m-0d 0h:0n:0s"),ucbuf) ;
			    respnt->Value.UCVal[1] = UClit('\'') ; UCstrcpy(&respnt->Value.UCVal[2],ucbuf) ;
			    UCstrcat(&respnt->Value.UCVal[2],UClit("'")) ;
			    UCCHARPNTBYTES1(respnt) ; return(respnt) ;
			    break ;
			   case _MIDAS:
			   case _MSAccess:
			    i = v_FormatDate(&ipt->Value.IntVal,ipt->PntType,VCAL_CalType_UseDeflt,VCAL_TimeZone_Local,UClit("0d-mmm-yyyy 0h:0n:0s"),ucbuf) ;
			    respnt->Value.UCVal[1] = UClit('#') ; UCstrcpy(&respnt->Value.UCVal[2],ucbuf) ;
			    UCstrcat(&respnt->Value.UCVal[2],UClit("#")) ;
			    UCCHARPNTBYTES1(respnt) ; return(respnt) ;
			    break ;
			   case _Oracle:
			    i = v_FormatDate(&ipt->Value.IntVal,ipt->PntType,VCAL_CalType_UseDeflt,VCAL_TimeZone_Local,UClit("yyyy/0m/0d 0h:0n:0s"),ucbuf) ;
			    v_Msg(ctx,&respnt->Value.UCVal[1],"@to_date('%1U','yyyy/mm/dd hh24:mi:ss')",ucbuf) ;
			    UCCHARPNTBYTES1(respnt) ; return(respnt) ;
			    break ;
			 } ;
			break ;
		   
		   case V4DPI_PntType_UDate:
			if (ipt->Value.IntVal == VCAL_UDate_None) { uccharPNTv(respnt,UClit("NULL")) ; return(respnt) ; } ;
//VEH160609 - Next line is temp for YC conversion - take out after July 2016
//			if (ipt->Value.IntVal == 51911) { uccharPNTv(respnt,UClit("NULL")) ; return(respnt) ; } ;
			switch (rdb)
			 {
			   case _MySQL:
			   case _iSeries:
			   case _MSSQL:
			    i = v_FormatDate(&ipt->Value.IntVal,ipt->PntType,VCAL_CalType_UseDeflt,VCAL_TimeZone_Local,UClit("yyyy-0m-0d"),ucbuf) ;
			    respnt->Value.UCVal[1] = UClit('\'') ; UCstrcpy(&respnt->Value.UCVal[2],ucbuf) ;
			    UCstrcat(&respnt->Value.UCVal[2],UClit("'")) ;
			    break ;
			   case _MSAccess:
			   case _MIDAS:
			    i = v_FormatDate(&ipt->Value.IntVal,ipt->PntType,VCAL_CalType_UseDeflt,VCAL_TimeZone_Local,UClit("0d-mmm-yyyy"),ucbuf) ;
			    respnt->Value.UCVal[1] = UClit('#') ; UCstrcpy(&respnt->Value.UCVal[2],ucbuf) ;
			    UCstrcat(&respnt->Value.UCVal[2],UClit("#")) ;
			    break ;
			   case _Oracle:
			    i = v_FormatDate(&ipt->Value.IntVal,ipt->PntType,VCAL_CalType_UseDeflt,VCAL_TimeZone_Local,UClit("yyyy/0m/0d"),ucbuf) ;
			    v_Msg(ctx,&respnt->Value.UCVal[1],"@to_date('%1U','yyyy/mm/dd')",ucbuf) ;
			    break ;
			 } ;
			UCCHARPNTBYTES1(respnt) ; return(respnt) ;
			break ;
		   
		 } ;
		break ;				/* Should not get here, ok most likely FALSE */
	      case V4IM_Tag_Mask:
		v4im_GetPointUC(&ok,ucbuf,UCsizeof(ucbuf),cpt,ctx) ; if (!ok) break ;
		switch(cpt->PntType)
		 { default:			respnt->Dim = Dim_Alpha ; break ;
		   CASEofChar			respnt->Dim = cpt->Dim ; break ;
		 } ;
		if ((i = v4im_FormatMask(ctx,intmodx,ipt,ucbuf,&respnt->Value.UCVal[1])) == UNUSED) goto format_fail ;
		if (width == UNUSED) { width = i ; }
		 else if (i > width)
		 { v_Msg(ctx,NULL,"@%1E Width(%2d) of result(%3U) exceeds prior max width(%4d)",intmodx,i,&respnt->Value.UCVal[1],width) ; goto format_fail ; } ;
		uccharPNT(respnt) ; UCCHARPNTBYTES1(respnt) ;
		ipt = respnt ;
		continue ;
	      case V4IM_Tag_Table:
		return(v4imu_EchoTable(ctx,respnt,intmodx,argpnts,argcnt,traceGlobal,V4IM_Tag_Table)) ;
	      case V4IM_Tag_NoPrefix:
		return(v4imu_EchoTable(ctx,respnt,intmodx,argpnts,argcnt,traceGlobal,V4IM_Tag_NoPrefix)) ;
	      case V4IM_Tag_Round:
		j = v4im_GetPointInt(&ok,cpt,ctx) ; if (!ok) break ;
		if (j > 9)
		 { if (j == 10 || j == 100 || j == 1000 || j == 10000 || j == 100000 || j == 1000000)
		    { k = v4im_GetPointInt(&ok,ipt,ctx) ; if (!ok) break ;
		      memcpy(respnt,ipt,ipt->Bytes) ;
		      if (k >= 0) { k = (k + (j/2)) / j ; }
		       else { k = (k - (j/2)) / j ; } ;
		      switch(respnt->PntType)
		       { default:			v_Msg(ctx,NULL,"@%1E Invalid number to Round",intmodx) ; goto format_fail ;
		         case V4DPI_PntType_CodedRange:
			 case V4DPI_PntType_Int:	respnt->Value.IntVal = k ; break ;
			 case V4DPI_PntType_Real:	dnum = (double)k ; PUTREAL(respnt,dnum) ; break ;
		       } ;
		      ipt = respnt ; break ;
		    } else
		    { v_Msg(ctx,NULL,"@%1E Round::%2d must be 1-8 or power of 10",intmodx,j) ;
		     goto format_fail ;
		    } ;
		 } ;
		switch (ipt->PntType)
		 { default:
		   CASEofINT
			dnum = v4im_GetPointDbl(&ok,ipt,ctx) ; if (!ok) break ;
			j = v4im_GetPointInt(&ok,cpt,ctx) ; if (!ok) break ;
			k = DtoI(dnum * powers[j]) ; dnum = (double)k / powers[j] ;			
			memcpy(respnt,ipt,ipt->Bytes) ; respnt->Value.IntVal = DtoI(dnum) ;
			break ;
		   case V4DPI_PntType_Real:
			dnum = v4im_GetPointDbl(&ok,ipt,ctx) ; if (!ok) break ;
			j = v4im_GetPointInt(&ok,cpt,ctx) ; if (!ok) break ;
			k = DtoI(dnum * powers[j]) ; dnum = (double)k / powers[j] ;			
			memcpy(respnt,ipt,ipt->Bytes) ; PUTREAL(respnt,dnum) ;
			break ;
		 } ; ipt = respnt ;
		continue ;
	      case -V4IM_Tag_UTC:
		switch(ipt->PntType)
		 { default:			v_Msg(ctx,NULL,"FormatDTMask",intmodx,ipt,ipt->PntType,V4IM_Tag_UTC) ; goto format_fail ;
		   case V4DPI_PntType_UDate:	break ;
		   case V4DPI_PntType_UDT:	memcpy(&ptbuf,ipt,ipt->Bytes) ; ipt = &ptbuf ; ipt->Value.IntVal += (60 * gpi->MinutesWest) ; break ;
		   case V4DPI_PntType_Calendar:	break ;
		 } ;
		i = v_FormatDate(&ipt->Value.IntVal,ipt->PntType,VCAL_CalType_Gregorian,VCAL_TimeZone_GMT,UClit("www, d mmm yyyy 0h:0n:0s"),ucbuf) ;
		UCstrcat(ucbuf,UClit(" GMT")) ;
		if (width == UNUSED) { width = i ; }
		 else if (i > width)
		 { v_Msg(ctx,NULL,"@%1E Width(%2d) of result(%3U) exceeds prior max width(%4d)",intmodx,i,ucbuf,width) ; goto format_fail ; } ;
		uccharPNTv(respnt,ucbuf) ;
		ipt = respnt ;
		continue ;
	      case V4IM_Tag_XML:
		v4im_GetPointUC(&ok,ucbuf,V4DPI_UCVAL_MaxSafe,ipt,ctx) ;
		switch (v4im_GetDictToEnumVal(ctx,cpt))
		 { default:	v_Msg(ctx,NULL,"@%1E Expecting URL:Encode or URL:Decode",intmodx) ; goto format_fail ;
		   case _Encode:
			for(ubp=ucbuf,ubp1=UCTBUF1;*ubp!=UCEOS;ubp++,ubp1++)
			 { int stack[30], sx, val ;
			   if (*ubp < 128 && *ubp != UClit('"') && *ubp != UClit('&') && *ubp != UClit('<') && *ubp != UClit('>')) { *ubp1 = *ubp ; continue ; } ;
			   *(ubp1++) = UClit('&') ; *(ubp1++) = UClit('#') ;
			   val = *ubp ; for(sx=0;val > 0;val /= 10) { stack[sx++] = val % 10 ; } ;
			   for(sx--;sx>=0;sx--) { *(ubp1++) = stack[sx] + UClit('0') ; } ;
			   *ubp1 = UClit(';') ;
//			   *(ubp1++) = (*ubp / 100) + UClit('0') ; *(ubp1++) = ((*ubp % 100) / 10) + UClit('0') ; *(ubp1++) = (*ubp % 10) + UClit('0') ;
			 } ;
			*ubp1 = UCEOS ; UCstrcpy(ucbuf,UCTBUF1) ; len = UNUSED ; break ;
		   case _Decode:
		      { int base = 10, num, digit ; UCCHAR *dbp, *digits = UClit("0123456789") ;
			for(ubp=ucbuf,ubp1=UCTBUF1;*ubp!=UCEOS;ubp++,ubp1++)
			 { if (*ubp != UClit('&')) { *ubp1 = *ubp ; continue ; } ;
			   ubp++ ;
			   if (*ubp == UClit('#'))		/* Have numeric form- &#nnn */
			    { ubp++ ;
			      if (*ubp == UClit('x') || *ubp == UClit('X')) { ubp++ ; base = 16 ; digits = UClit("0123456789ABCDEF") ; }
			       else if (*ubp == UClit('0')) { ubp++ ; base = 8 ; digits = UClit("01234567") ; } ;
			      for(num=0;*ubp!=UClit(';');ubp++)
			       { for(digit=0,dbp=digits;*dbp!=UCEOS;digit++,dbp++) { if (*dbp == UCTOUPPER(*ubp)) break ; } ;
			         if (digit >= base)
				  { v_Msg(ctx,NULL,"@%1E Invalid XML entity code",intmodx) ; goto format_fail ; } ;
			         num = num * base + digit ;
			       } ;
			      *ubp1 = num ;
			    } else			/* Have named form - &name; */
			    { UCCHAR *bp2 = UCTBUF2 ; *(bp2++) = UClit('&') ;
			      for(;*ubp!=UClit(';')&& *ubp!=UCEOS;) { *(bp2 ++) = *(ubp++) ; } ;
			      *(bp2++) = UClit(';') ; *bp2 = UCEOS ;
			      *ubp1 = (UCCHAR)v4xml_LookupISONamedEntity(UCTBUF2) ;
			       if (*ubp1 == UCEOS)
			        { v_Msg(ctx,NULL,"@%1E Invalid/unknown ISO named entity (%2U)",intmodx,UCTBUF1) ; goto format_fail ; } ;
			    } ;
			 } ;
			*ubp1 = UCEOS ; UCstrcpy(ucbuf,UCTBUF1) ; len = UNUSED ; break ;
		      }
		   case _RPC:
			i = vxml_RPCArg(ctx,ipt,&respnt->Value.UCVal[1],V4DPI_AlphaVal_Max-5) ;
			if (i < 0) { v_Msg(ctx,NULL,"ModInvArg",intmodx,1) ; goto format_fail ; } ;
			uccharPNT(respnt) ; UCCHARPNTBYTES2(respnt,i) ;
			return(respnt) ;
		 } ;
		if ((len = UCstrlen(UCTBUF1)) >= V4DPI_UCVAL_MaxSafe)	/* If any arguments were BigText, then return bigtext point */
		 { struct V4LEX__BigText bt ;
		   if (len >= V4LEX_BigText_Max)
		    { v_Msg(ctx,NULL,"@%1E - Result string (len=%2d) exceeds max length allowed(%3d)",intmodx,len,V4LEX_BigText_Max) ; goto format_fail ; } ;
		   UCstrcpy(bt.BigBuf,UCTBUF1) ;
		   if (!v4dpi_SaveBigTextPoint(ctx,&bt,len,respnt,Dim_Alpha,TRUE))
		    { v_Msg(ctx,NULL,"StrSaveBigText",intmodx,V4DPI_PntType_BigText) ; goto format_fail ; } ;
		 } else		/* Store as Alpha point */	
		 { uccharPNTvl(respnt,UCTBUF1,len) ; ipt = respnt ;
		 } ;
		continue ;




	    } ;
	 } ;
	if (!ok) { v_Msg(ctx,NULL,"ModInvArg",intmodx,argx-1) ; goto format_fail ; } ;
	if (respnt->Dim == 0)			/* Did not do any formatting (yet)? */
	 { memcpy(respnt,argpnts[1],argpnts[1]->Bytes) ; } ;
format_done:
/*	If a maximum length has been given then make sure result fits within it */
	if (maximum != UNUSED)
	 { v4im_GetPointChar(&ok,ASCTBUF1,V4TMBufMax,respnt,ctx) ;
	   i = strlen(ASCTBUF1) ;
	   if (i <= maximum) return(respnt) ;
	   ASCTBUF1[maximum - strlen(fill)] = '\0' ; strcat(ASCTBUF1,fill) ;
	   alphaPNTv(respnt,ASCTBUF1) ;
	   return(respnt) ;
	 } ;
/*	If result is Alpha & width specified then handle here */
	if (lcr != UNUSED)
	 { if (width >= sizeof mbuf) { v_Msg(ctx,NULL,"FormatWidth",intmodx,width,sizeof mbuf) ; goto format_fail ; } ;
	   v4im_GetPointChar(&ok,ASCTBUF1,V4TMBufMax,respnt,ctx) ;
	   if (!ok) { v_Msg(ctx,NULL,"ModFailed2",intmodx) ; goto format_fail ; } ;
	   i = strlen(ASCTBUF1) ;
	   if (i >= width) { ASCTBUF1[width+1] = '\0' ; strcpy(&respnt->Value.AlphaVal[1],ASCTBUF1) ; }
	    else { int before,after,x,y ;
		   switch(lcr)
		    { case 1:	before = 0 ; after = width - i ; break ;
		      case 2:	before = (width - i) / 2 ; after = width - (i + before) ; break ;
		      case 3:	before = width - i ; after = 0 ; break ;
		    } ;
		   if (fill[0] == '\0') strcpy(fill," ") ;
		   for(x=0,y=0;y<before;y++) { mbuf[y] = fill[x] ; if (fill[++x] == '\0') x = 0 ; } ;
		   mbuf[before] = '\0' ; strcat(mbuf,ASCTBUF1) ;
		   for(x=0,y=before+i;y<before+i+after;y++) { mbuf[y] = fill[x] ; if (fill[++x] == '\0') x = 0 ; } ;
		   mbuf[before+i+after] = '\0' ;
		   strcpy(&respnt->Value.AlphaVal[1],mbuf) ;
		 } ;
	   switch(respnt->Dim)		/* If result not a string then force to Dim:Alpha */
	    { default:		respnt->Dim = Dim_Alpha ; respnt->PntType = V4DPI_PntType_Char ; break ;
	      CASEofChar	break ;
	    } ;
	   CHARPNTBYTES2(respnt,width)
	   ipt = respnt ;
	 } ;
	return(ipt) ;
format_fail:
	REGISTER_ERROR(0) ; return(NULL) ;
}

int v4im_FormatMask(ctx,intmodx,point,mask,resbuf)
  struct V4C__Context *ctx ;
  INTMODX intmodx ;
  P *point ;
  UCCHAR *mask ;
  UCCHAR *resbuf ;
{
  struct V4DPI__DimInfo *di ;
  int width ; double dnum ; B64INT lint ;

	switch (point->PntType)
	 { default:
		v_Msg(ctx,NULL,"FormatDTMask",intmodx,point,point->PntType,V4IM_Tag_Mask) ; return(UNUSED) ;
	   case V4DPI_PntType_CodedRange:
	   case V4DPI_PntType_Delta:
	   case V4DPI_PntType_Int:
	   	width = v_FormatInt(point->Value.IntVal,mask,resbuf,NULL) ;
		break ;
	   case V4DPI_PntType_Fixed:
	   	DIMINFO(di,ctx,point->Dim) ; memcpy(&lint,&point->Value.FixVal,sizeof lint) ;
		width = v_FormatLInt(lint,di->Decimals,mask,resbuf) ;
		break ;
	   case V4DPI_PntType_Real:
		GETREAL(dnum,point) ;
		width = v_FormatDbl(dnum,mask,resbuf,NULL) ;
		break ;
	   case V4DPI_PntType_Calendar:
		GETREAL(dnum,point) ; DIMINFO(di,ctx,point->Dim) ;
	   	width = v_FormatDate(&dnum,V4DPI_PntType_Calendar,di->ds.Cal.CalendarType,di->ds.Cal.TimeZone,mask,resbuf) ;
		break ;
	   case V4DPI_PntType_UDT:
	   case V4DPI_PntType_UDate:
	   	width = v_FormatDate(&point->Value.IntVal,point->PntType,VCAL_CalType_UseDeflt,VCAL_TimeZone_Local,mask,resbuf) ;
		break ;
	   case V4DPI_PntType_UMonth:
	   	width = v_FormatDate(&point->Value.IntVal,point->PntType,VCAL_CalType_UseDeflt,VCAL_TimeZone_Local,mask,resbuf) ;
		break ;
	   case V4DPI_PntType_UWeek:
	   	width = v_FormatDate(&point->Value.IntVal,point->PntType,VCAL_CalType_UseDeflt,VCAL_TimeZone_Local,mask,resbuf) ;
		break ;
	   case V4DPI_PntType_UTime:
		GETREAL(dnum,point) ; DIMINFO(di,ctx,point->Dim) ;
	   	width = v_FormatDate(&dnum,point->PntType,VCAL_CalType_UseDeflt,VCAL_TimeZone_Local,mask,resbuf) ;
		break ;
	   case V4DPI_PntType_UPeriod:
//xxx formatmask need to embed periods in this call
		DIMINFO(di,ctx,point->Dim) ;
	   	width = v_FormatDate(&point->Value.IntVal,((di->ds.UPeriod.periodsPerYear<<16)+V4DPI_PntType_UPeriod),VCAL_CalType_UseDeflt,VCAL_TimeZone_Local,mask,resbuf) ;
		break ;
	   case V4DPI_PntType_UQuarter:
	   	width = v_FormatDate(&point->Value.IntVal,V4DPI_PntType_UQuarter,VCAL_CalType_UseDeflt,VCAL_TimeZone_Local,mask,resbuf) ;
		break ;
	   case V4DPI_PntType_UYear:
	   	width = v_FormatDate(&point->Value.IntVal,V4DPI_PntType_UYear,VCAL_CalType_UseDeflt,VCAL_TimeZone_Local,mask,resbuf) ;
		break ;
	   case V4DPI_PntType_TeleNum:
	   	width = v_FormatTele(ctx,&point->Value.Tele,mask,resbuf) ;
		break ;
	 } ;
	return(width) ;
}

/*	v4im_DoMakePm - Handles MakePm() module			*/

P *v4im_DoMakePm(ctx,respnt,argcnt,argpnts,intmodx)
  struct V4C__Context *ctx ;
  INTMODX intmodx ;
  P *respnt,*argpnts[] ;
  COUNTER argcnt ;
{ 
  struct V4DPI__DimInfo *di ;
//  struct V4DPI__Point *cpt,pntbuf ;
//  struct V4DPI__Point *toPt,*numPt ;
  struct V4DPI__Point_IntMix *pim ;
  struct V4DPI__Point_AlphaMix *pam ;
  struct V4DPI__Point_RealMix *prm ;
  INDEX ix,pamX,values ; LOGICAL ok ; DIMID mpDim ; double dnum1 ;
  char tbuf[V4PT_MaxCharLenIn0+50],pamBuf[V4DPI_AlphaVal_Max] ; UCCHAR ucbuf[V4DPI_UCVal_Max],ucpamBuf[V4DPI_UCVal_Max] ;

	if (argpnts[1]->Dim == Dim_Dim) { mpDim = argpnts[1]->Value.IntVal ; ix = 2 ; }
	 else { mpDim = argpnts[1]->Dim ; ix = 1 ; } ;
	DIMINFO(di,ctx,mpDim) ;
	if (di == NULL) { v_Msg(ctx,NULL,"ModArgNotDim",intmodx,1,argpnts[1]) ; goto fail ; } ;
	ZPH(respnt) ; respnt->Dim = di->DimId ; respnt->PntType = di->PointType ; respnt->Bytes = V4DPI_PointHdr_Bytes ;
	pim = (struct V4DPI__Point_IntMix *)&respnt->Value ;
	prm = (struct V4DPI__Point_RealMix *)&respnt->Value ;
	pam = (struct V4DPI__Point_AlphaMix *)&respnt->Value.AlphaVal ; pamX = 0 ;
/*	Need to get a 'count' of values for this point (excluding UV4:none points). If values == 1 then returning single simple point */
	for(ix=2,values=0;ix<=argcnt;ix++)
	 { if (memcmp(argpnts[ix],&protoNone,V4PS_Int) == 0) continue ;
	   values += (argpnts[ix]->Grouping == V4DPI_Grouping_Single ? 1 : 99) ;
	 } ;

	for(ok=TRUE,ix=2;ix<=argcnt&&ok;ix++)
	 { 
	   if (memcmp(argpnts[ix],&protoNone,V4PS_Int) == 0) continue ;	/* Don't include UV4:none point */
	   if (memcmp(argpnts[ix],&protoQNone,V4PS_Int) == 0) { UNQUOTE(argpnts[ix]) ; } ;
	   if (argpnts[ix]->PntType != di->PointType)
	    { switch(di->PointType)
	       { default:			v_Msg(ctx,NULL,"ModArgPntType2",intmodx,ix,argpnts[ix]->PntType,di->PointType) ; goto fail ;
		 case V4DPI_PntType_Dict:
		 case V4DPI_PntType_XDict:	switch (argpnts[ix]->PntType)
						 { default:					v_Msg(ctx,NULL,"ModArgPntType2",intmodx,ix,argpnts[ix]->PntType,di->PointType) ; goto fail ;
						   CASEofCharMBT case V4DPI_PntType_Dict:
						   case V4DPI_PntType_XDict:			break ;
						 } ;
	         CASEofCharMBT			break ;		/* Allow anything on Alpha/Unicode */
	       }
	    } ;
	   switch(di->PointType)
	    { default:
		if (gpi->PointBytes[di->PointType] == V4PS_Int)		/* If this is stored as Int value then we are OK */
		 { int i ;
/*		   If this is the only point, is not a range then make this a simple single point */
		   if (values == 1)
		    { respnt->Value.IntVal = argpnts[ix]->Value.IntVal ; respnt->Bytes = V4PS_Int ; break ; } ;
/*		   Doing compound result point - check if this src is just a single point */
		   if (argpnts[ix]->Grouping == V4DPI_Grouping_Single)
		    { if (respnt->Grouping >= V4DPI_PointIntMix_Max)
		       { v_Msg(ctx,NULL,"MaxNumModArgsXL",intmodx,V4DPI_PointIntMix_Max,ix) ; goto fail ; } ;
		      pim->Entry[respnt->Grouping].BeginInt = argpnts[ix]->Value.IntVal ; pim->Entry[respnt->Grouping].EndInt = argpnts[ix]->Value.IntVal ;
		      respnt->Grouping++ ; SETBYTESGRPINT(respnt) ;
		      break ;
		    } ;
/*		   Appending compound point to compound point */
		   for(i=0;i<argpnts[ix]->Grouping;i++)
		    { struct V4DPI__Point_IntMix *pim2 = (struct V4DPI__Point_IntMix *)&argpnts[ix]->Value ;
		      pim->Entry[respnt->Grouping++] = pim2->Entry[i] ;
		    } ;
		   SETBYTESGRPINT(respnt) ;
		   break ;
		 } ;
		v_Msg(ctx,NULL,"ModArgPntType",intmodx,ix,argpnts[ix],di->PointType) ; ok = FALSE ; break ;
	      CASEofCharmU
/*		If a single point then handle as special case */
		if (values == 1)
		    { v4im_GetPointChar(&ok,tbuf,V4PT_MaxCharLenIn0+50,argpnts[ix],ctx) ;
		      alphaPNTv(respnt,tbuf) ;
		      break ;
		    } ;
/*		Appending a single point to a compound */
		if (argpnts[ix]->Grouping == V4DPI_Grouping_Single)
		 { pam->Entry[respnt->Grouping].BeginIndex = pamX ; pam->Entry[respnt->Grouping].EndIndex = 0 ;
		   v4im_GetPointChar(&ok,tbuf,V4PT_MaxCharLenIn0+50,argpnts[ix],ctx) ;
		   if (strlen(tbuf) > V4PT_MaxCharLenIn0) { v_Msg(ctx,ctx->ErrorMsgAux,"BigTextMaxLen",strlen(tbuf),V4PT_MaxCharLenIn0,di->PointType) ; ok = FALSE ; break ; } ;
		   if (strlen(tbuf) + pamX >= V4DPI_AlphaVal_Max) { v_Msg(ctx,ctx->ErrorMsgAux,"BigTextMaxLen",strlen(tbuf)+pamX,V4DPI_AlphaVal_Max,di->PointType) ; ok = FALSE ; break ; } ;
		   strcpy(&pamBuf[pamX+1],tbuf) ; pamBuf[pamX] = strlen(tbuf) ; pamX += strlen(tbuf)+1 ;
		   respnt->Grouping++ ; break ;
		 } ;
/*		Appending multiple points to a compound */
		{ INDEX i ; struct V4DPI__Point_AlphaMix *pam2 = (struct V4DPI__Point_AlphaMix *)&argpnts[ix]->Value.AlphaVal ; char *bp = (char *)&pam2->Entry[argpnts[ix]->Grouping].BeginIndex ;
		  for(i=0;i<argpnts[ix]->Grouping;i++)
		   { pam->Entry[respnt->Grouping].BeginIndex = pamX ; pam->Entry[respnt->Grouping].EndIndex = 0 ;
		     strncpy(tbuf,bp+pam2->Entry[i].BeginIndex+1,*(bp+pam2->Entry[i].BeginIndex)) ; tbuf[*(bp+pam2->Entry[i].BeginIndex)] = 0 ;
		     if (strlen(tbuf) > V4PT_MaxCharLenIn0) { v_Msg(ctx,ctx->ErrorMsgAux,"BigTextMaxLen",strlen(tbuf),V4PT_MaxCharLenIn0,di->PointType) ; ok = FALSE ; break ; } ;
		     if (strlen(tbuf) + pamX >= V4DPI_AlphaVal_Max) { v_Msg(ctx,ctx->ErrorMsgAux,"BigTextMaxLen",strlen(tbuf)+pamX,V4DPI_AlphaVal_Max,di->PointType) ; ok = FALSE ; break ; } ;
		     strcpy(&pamBuf[pamX+1],tbuf) ; pamBuf[pamX] = strlen(tbuf) ; pamX += strlen(tbuf)+1 ;
		     respnt->Grouping++ ;
		   } ;
		  break ;
		} ;
	      case V4DPI_PntType_UCChar:
/*		If a single point then handle as special case */
		if (values == 1)
		    { v4im_GetPointUC(&ok,ucbuf,V4PT_MaxCharLenIn0+50,argpnts[ix],ctx) ;
		      uccharPNTv(respnt,ucbuf) ;
		      break ;
		    } ;
/*		Appending a single point to a compound */
		if (argpnts[ix]->Grouping == V4DPI_Grouping_Single)
		 { pam->Entry[respnt->Grouping].BeginIndex = pamX ; pam->Entry[respnt->Grouping].EndIndex = 0 ;
		   v4im_GetPointUC(&ok,ucbuf,V4PT_MaxCharLenIn0+50,argpnts[ix],ctx) ;
		   if (UCstrlen(ucbuf) > V4DPI_UCVAL_MaxSafe) { v_Msg(ctx,ctx->ErrorMsgAux,"BigTextMaxLen",UCstrlen(ucbuf),V4PT_MaxCharLenIn0,di->PointType) ; ok = FALSE ; break ; } ;
		   if (UCstrlen(ucbuf) + pamX >= V4DPI_UCVAL_MaxSafe) { v_Msg(ctx,ctx->ErrorMsgAux,"BigTextMaxLen",UCstrlen(ucbuf)+pamX,V4DPI_AlphaVal_Max,di->PointType) ; ok = FALSE ; break ; } ;
		   UCstrcpy(&ucpamBuf[pamX+1],ucbuf) ; ucpamBuf[pamX] = UCstrlen(ucbuf) ; pamX += UCstrlen(ucbuf)+1 ;
		   respnt->Grouping++ ; break ;
		 } ;
/*		Appending multiple points to a compound */
		{ int i ; struct V4DPI__Point_AlphaMix *pam2 = (struct V4DPI__Point_AlphaMix *)&argpnts[ix]->Value.AlphaVal ; UCCHAR *ucbp = (UCCHAR *)&pam2->Entry[argpnts[ix]->Grouping].BeginIndex ;
		  for(i=0;i<argpnts[ix]->Grouping;i++)
		   { pam->Entry[respnt->Grouping].BeginIndex = pamX ; pam->Entry[respnt->Grouping].EndIndex = 0 ;
		     UCstrncpy(ucbuf,ucbp+pam2->Entry[i].BeginIndex+1,*(ucbp+pam2->Entry[i].BeginIndex)) ; ucbuf[*(ucbp+pam2->Entry[i].BeginIndex)] = 0 ;
		     if (UCstrlen(ucbuf) > V4DPI_UCVAL_MaxSafe) { v_Msg(ctx,ctx->ErrorMsgAux,"BigTextMaxLen",UCstrlen(ucbuf),V4PT_MaxCharLenIn0,di->PointType) ; ok = FALSE ; break ; } ;
		     if (UCstrlen(ucbuf) + pamX >= V4DPI_UCVAL_MaxSafe) { v_Msg(ctx,ctx->ErrorMsgAux,"BigTextMaxLen",UCstrlen(ucbuf)+pamX,V4DPI_UCVal_Max,di->PointType) ; ok = FALSE ; break ; } ;
		     UCstrcpy(&ucpamBuf[pamX+1],ucbuf) ; ucpamBuf[pamX] = UCstrlen(ucbuf) ; pamX += UCstrlen(ucbuf)+1 ;
		     respnt->Grouping++ ;
		   } ;
		  break ;
		} ;
	      case V4DPI_PntType_Dict:
	      case V4DPI_PntType_XDict:
		{ DICTID did ; INDEX i ;
/*		  If this is the only point, is not a range, there is no toPt or numPt -> make this a simple single point */
		  if (values == 1)
		    { if (argpnts[ix]->PntType == di->PointType ? (di->PointType == V4DPI_PntType_Dict ? TRUE : argpnts[ix]->Dim == di->DimId) : FALSE)
		       { did = argpnts[ix]->Value.IntVal ; }
		       else { v4im_GetPointUC(&ok,ucbuf,UCsizeof(ucbuf),argpnts[ix],ctx) ;
			      did = (di->PointType == V4DPI_PntType_Dict ? v4dpi_DictEntryGet(ctx,di->DimId,ucbuf,di,NULL) : v4dpi_XDictEntryGet(ctx,ucbuf,di,0)) ;
			      if (did == 0) { v_Msg(ctx,NULL,"DPIInvPoint2",V4IM_OpCode_Project,argpnts[ix],di->DimId) ; ok = FALSE ; break ; } ;
			    } ;
		      respnt->Value.IntVal = did ; respnt->Bytes = V4PS_Int ; break ;
		    } ;
/*		  Doing compound result point - check if this src is just a single point */
		  if (argpnts[ix]->Grouping == V4DPI_Grouping_Single)
		   { if (argpnts[ix]->PntType == di->PointType ? (di->PointType == V4DPI_PntType_Dict ? TRUE : argpnts[ix]->Dim == di->DimId) : FALSE)
		      { did = argpnts[ix]->Value.IntVal ; }
		      else { v4im_GetPointUC(&ok,ucbuf,UCsizeof(ucbuf),argpnts[ix],ctx) ;
			     did = (di->PointType == V4DPI_PntType_Dict ? v4dpi_DictEntryGet(ctx,di->DimId,ucbuf,di,NULL) : v4dpi_XDictEntryGet(ctx,ucbuf,di,0)) ;
			     if (did == 0) { v_Msg(ctx,NULL,"DPIInvPoint2",V4IM_OpCode_Project,argpnts[ix],di->DimId) ; ok = FALSE ; break ; } ;
			   } ;
		     pim->Entry[respnt->Grouping].BeginInt = did ; pim->Entry[respnt->Grouping].EndInt = did ;
		     respnt->Grouping++ ; SETBYTESGRPINT(respnt) ;
		     break ;
		   } ;
/*		  Appending compound point to compound point */
		  for(i=0;i<argpnts[ix]->Grouping;i++)
		   { struct V4DPI__Point_IntMix *pim2 = (struct V4DPI__Point_IntMix *)&argpnts[ix]->Value ;
		     did = pim2->Entry[i].BeginInt ;
		     if (!(argpnts[ix]->PntType == di->PointType ? (di->PointType == V4DPI_PntType_Dict ? TRUE : argpnts[ix]->Dim == di->DimId) : FALSE))
		      { struct V4DPI__LittlePoint dlp ;
		        dictPNTv(&dlp,argpnts[ix]->Dim,did) ; dlp.PntType = argpnts[ix]->PntType ;
			v4im_GetPointUC(&ok,ucbuf,UCsizeof(ucbuf),(P *)&dlp,ctx) ;
			did = (di->PointType == V4DPI_PntType_Dict ? v4dpi_DictEntryGet(ctx,di->DimId,ucbuf,di,NULL) : v4dpi_XDictEntryGet(ctx,ucbuf,di,0)) ;
			if (did == 0) { v_Msg(ctx,NULL,"DPIInvPoint2",V4IM_OpCode_Project,argpnts[ix],di->DimId) ; ok = FALSE ; break ; } ;
		      } ;
		     pim->Entry[respnt->Grouping].BeginInt = did ; pim->Entry[respnt->Grouping++].EndInt = did ;
		   } ;
		  SETBYTESGRPINT(respnt) ;
		  break ;
		}
	      case V4DPI_PntType_Real:
	      case V4DPI_PntType_Calendar:

		{ INDEX i ;
/*		   If this is the only point, is not a range then make this a simple single point */
		   if (values == 1)
		    { dnum1 = v4im_GetPointDbl(&ok,argpnts[ix],ctx) ; if (!ok) break ;
		      dblPNTv(respnt,dnum1) ; break ;
		    } ;

/*		   Doing compound result point - check if this src is just a single point */
		   if (argpnts[ix]->Grouping == V4DPI_Grouping_Single)
		    { dnum1 = v4im_GetPointDbl(&ok,argpnts[ix],ctx) ; if (!ok) break ;
		      memcpy(&prm->Entry[respnt->Grouping].BeginReal,&dnum1,sizeof dnum1) ; memcpy(&prm->Entry[respnt->Grouping].EndReal,&dnum1,sizeof dnum1) ;
		      respnt->Grouping++ ; SETBYTESGRPDBL(respnt) ;
		      break ;
		    } ;
/*		   Appending compound point to compound point */
		   for(i=0;i<argpnts[ix]->Grouping;i++)
		    { struct V4DPI__Point_RealMix *prm2 = (struct V4DPI__Point_RealMix *)&argpnts[ix]->Value ;
		      prm->Entry[respnt->Grouping++] = prm2->Entry[i] ;
		    } ;
		   SETBYTESGRPINT(respnt) ;
		   break ;
		}
		break ;
	    } ;
	 } ;
/*	If making Alpha point then append text & determine final point size */
	switch(respnt->PntType)
	 { CASEofCharmU
	      { LENMAX len ;
		len = respnt->Grouping * sizeof pam->Entry[0] ;
		if (len + pamX + 1 >= V4DPI_AlphaVal_Max){ v_Msg(ctx,ctx->ErrorMsgAux,"BigTextMaxLen",pamX+len,V4DPI_AlphaVal_Max,di->PointType) ; ok = FALSE ; } ;
		memcpy(&respnt->Value.AlphaVal[len],pamBuf,pamX) ;
		respnt->Dim = di->DimId ; respnt->Bytes += ALIGN(len + pamX + 1) ;
	      } ; break ;
	   case V4DPI_PntType_UCChar:
	      { LENMAX len ;
		len = (respnt->Grouping * sizeof pam->Entry[0]) / sizeof(UCCHAR) ;
		if (len + pamX + 1 >= V4DPI_UCVAL_MaxSafe){ v_Msg(ctx,ctx->ErrorMsgAux,"BigTextMaxLen",pamX+len,V4DPI_UCVal_Max,di->PointType) ; ok = FALSE ; } ;
		memcpy(&respnt->Value.UCVal[len],ucpamBuf,pamX*sizeof(UCCHAR)) ;
		respnt->Dim = di->DimId ; respnt->Bytes += ALIGN(len + pamX + 1)*sizeof(UCCHAR) ;
	      } ; break ;
	 } ;
	if (!ok) { v_Msg(ctx,NULL,"ModInvArg",intmodx,ix-1) ; goto fail ; } ;
	return(respnt) ;

fail:
	REGISTER_ERROR(0) ; return(NULL) ;
}

/*	v4im_DoMakeP - Handles MakeP() module			*/

P *v4im_DoMakeP(ctx,respnt,argcnt,argpnts,intmodx,trycoerce)
  struct V4C__Context *ctx ;
  INTMODX intmodx ;
  P *respnt,*argpnts[] ;
  COUNTER argcnt ; LOGICAL *trycoerce ;
{ P *ipt,*cpt, *specPt ; P isctbuf,arg1buf,tagpnt ;
  struct V4DPI__DimInfo *di,dix ;
  struct V4DPI__TagVal *tv ;				/* Structure of a tagged value */
  struct V4DPI__Point_IntMix *pim,*pimx ;
  struct V4DPI__Point_AlphaMix *pam ;
  struct V4DPI__Point_RealMix *prm ;
  static int AutoDimCount ;
  struct V4LEX__TknCtrlBlk *tcb ;
  struct V4DPI__UOMTable *uomt ;
  struct V4DPI_UOMDetails *uomd ;
  struct V4DPI__Value_GCDSV * gcdsv ;
  char tb[2048] ;
  static double zuluoffset = UNUSED ;
  int i,grouping,j,k,ok,num,pix,tz,dls ; double dnum,dnum1,frac,ipart ; char *bp ; UCCHAR uctb[2048],*ucbp ;

	grouping = 0 ;						/* Set if got Special:LT, etc. */
	ipt = argpnts[1] ;				/* Is this point a dimension? */
	ZPH(respnt) ; ok = TRUE ;
	if (ipt->Dim == Dim_Dim && ipt->Value.IntVal == Dim_Dim) /* Making point on Dim (i.e. another dimension?) */
	 { if (argcnt < 2) { v_Msg(ctx,NULL,"ModArgMissing",intmodx,2,1) ; goto makep_fail ; } ;
	   ipt = argpnts[2] ;
	   if (ipt->Dim == Dim_Dim)
	    { DIMINFO(di,ctx,ipt->Value.IntVal) ;
	      if (di == NULL) { v_Msg(ctx,NULL,"ModArgNotDim",intmodx,2,ipt) ; goto makep_fail ; } ;
	      dix = *di ;
	      for(;;)
	       { v_Msg(ctx,dix.DimName,"@%1D_%2d",di->DimId,++AutoDimCount) ;
	         if ((ok = v4dpi_DimMake(ctx,&dix)) > 0) break ;
	         if (ok == UNUSED) continue ;		/* Dimension already exists, try with next counter value */
	         v_Msg(ctx,NULL,"ModFailed2",intmodx) ; goto makep_fail ;
	       } ;
	      memcpy(respnt,argpnts[1],argpnts[1]->Bytes) ;
	      respnt->Value.IntVal = v4dpi_DimGet(ctx,dix.DimName,DIMREF_IRT) ;
	      goto finish_make1 ;
	     } else					/* Try to make dimension from 2nd argument value */
	     { memcpy(respnt,argpnts[1],argpnts[1]->Bytes) ;
	       if (ipt->PntType == V4DPI_PntType_Special ) { respnt->Value.IntVal = ipt->Dim ; }
	        else { k = v4dpi_DimGet(ctx,v4dpi_RevDictEntryGet(ctx,ipt->Value.IntVal),DIMREF_IRT) ;
		       if (k == 0) { v_Msg(ctx,NULL,"MakePValNotDim",intmodx,argpnts[2]) ; *trycoerce = FALSE ; return(NULL) ; } ;
		       respnt->Value.IntVal = k ;
		     } ;
	       return(respnt) ;
	     } ;
	 } ;
	if (argcnt <= 1 && ipt->PntType != V4DPI_PntType_Tag)		/* Just have dim, try to make a new point */
	 { ipt = argpnts[1] ; ISVALIDDIM(ipt->Value.IntVal,1,"MakeP()") ;
	   DIMINFO(di,ctx,ipt->Value.IntVal) ;
	   if (di == NULL) { v_Msg(ctx,NULL,"ModArgNotDim",intmodx,1,ipt) ; goto makep_fail ; } ;
	   if (!di->UniqueOK) { v_Msg(ctx,NULL,"DimNoNew",intmodx,di->DimId) ; goto makep_fail ; } ;
	   respnt->Dim = di->DimId ; respnt->PntType = di->PointType ; respnt->Bytes = V4PS_Int ;
	   respnt->Value.IntVal = v4dpi_DimUnique(ctx,di,NULL) ;
	   if (respnt->Value.IntVal == UNUSED)
	    { v_Msg(ctx,NULL,"ModFailed2",intmodx) ; goto makep_fail ; } ;
	   return(respnt) ;
	 } ;
	if (ipt->PntType == V4DPI_PntType_Tag)	/* Making a point on a Tag dimension? */
	 {
	   respnt->PntType = V4DPI_PntType_TagVal ; respnt->Dim = ipt->Dim ;
	   tv = (struct V4DPI__TagVal *)&respnt->Value ;
	   tv->TagVal = ipt->Value.IntVal ;
	   if (tv->TagVal <= 0) { v_Msg(ctx,NULL,"DPIInvPoint2",intmodx,ipt,ipt->Dim) ; goto makep_fail ; } ;
	   if (argcnt == 1)			/* Only one argument - then create tag? point */
	    { respnt->ForceEval = TRUE ; respnt->Bytes = (char *)&tv->TagPt - (char *)respnt ;
	      return(respnt) ;
	    };
	   memcpy(&tv->TagPt,argpnts[2],argpnts[2]->Bytes) ;
	   if (ISQUOTED(&tv->TagPt)) { UNQUOTE(&tv->TagPt) ; } ;
	   respnt->Bytes = (char *)&tv->TagPt + argpnts[2]->Bytes - (char *)respnt ;
	   return(respnt) ;
	 } ;
	if (ipt->PntType == V4DPI_PntType_Isct || ipt->PntType == V4DPI_PntType_IntMod)
	 { v_Msg(ctx,NULL,"MakePUseMakeI",intmodx,V4IM_OpCode_MakeIsct) ; goto makep_fail ; } ;
	if (ipt->Value.IntVal < 0 || ipt->Value.IntVal > 0xffff) { di = NULL ; }
	 else { DIMINFO(di,ctx,ipt->Value.IntVal) ; } ;
	if (di == NULL)
	 { DIMINFO(di,ctx,ipt->Dim) ;
	   if (di == NULL) { v_Msg(ctx,NULL,"ModArgNotDim",intmodx,1,ipt) ; goto makep_fail ; } ;
	 } ;
	if (di->PointType == V4DPI_PntType_Isct || di->PointType == V4DPI_PntType_IntMod)
	 { v_Msg(ctx,NULL,"MakePUseMakeI",intmodx,V4IM_OpCode_MakeIsct) ; goto makep_fail ; } ;
	ipt = argpnts[2] ;
	tv = (struct V4DPI__TagVal *)&ipt->Value ;
	if (ipt->PntType == V4DPI_PntType_TagVal && abs(tv->TagVal) == V4IM_Tag_StdIn)	/* Making a point via input via stdin? */
	 { UCstrcpy(UCTBUF1,UClit(" ? ")) ;
	   switch (v4im_CheckPtArgNew(ctx,ipt,&cpt,&isctbuf))
	    { default:			v_Msg(ctx,NULL,"TagBadUse",intmodx) ; goto makep_fail ;
	      case V4IM_Tag_Unk:	v_Msg(ctx,NULL,"TagUnknown",intmodx) ; goto makep_fail ;
	      case -V4IM_Tag_StdIn:	break ;
	      case V4IM_Tag_StdIn:
		v4im_GetPointUC(&ok,UCTBUF1,256,cpt,ctx) ;
		if (!ok) { v_Msg(ctx,NULL,"ModFailed2",intmodx) ; goto makep_fail ; } ;
		break ;
	    } ;
	   v4lex_GetStdInput(UCTBUF1,uctb,UCsizeof(uctb)) ;
	   if ((num = UCstrlen(uctb)) == 0)
	    { v_Msg(ctx,NULL,"MakePNoInput",intmodx) ; goto makep_fail ; } ;
	   ISVALIDDIM(argpnts[1]->Value.IntVal,1,"MakeP()") ; DIMINFO(di,ctx,argpnts[1]->Value.IntVal) ;
	   switch (di->PointType)
	    { default:
		tcb = NULL ; INITTCB ; v4lex_NestInput(tcb,NULL,uctb,V4LEX_InpMode_String) ;
		ipt = (v4dpi_PointAccept(respnt,di,tcb,ctx,V4DPI_PointParse_RetFalse) ? respnt : NULL) ;
		v4lex_FreeTCB(tcb) ;
		if (ipt == NULL) { v_Msg(ctx,NULL,"ModFailed2",intmodx) ; goto makep_fail ; } ;
		goto finish_make ;
	      CASEofChar
		uccharPNTv(respnt,uctb) ; respnt->Dim = di->DimId ;
		return(respnt) ;
	    } ;
	   return(ipt) ;
	 } ;
	if (ipt->PntType == V4DPI_PntType_TagVal && tv->TagVal == V4IM_Tag_Special)	/* Making special point on dimension? */
	 { ipt = &tv->TagPt ;
	   respnt->Dim = di->DimId ; respnt->PntType = V4DPI_PntType_Special ; respnt->Bytes = V4DPI_PointHdr_Bytes ;
	   memcpy(&tagpnt,ipt,ipt->Bytes) ;
	   switch (v4im_GetDictToEnumVal(ctx,ipt))
	    { default:		v_Msg(ctx,NULL,"TagValue",intmodx,V4IM_Tag_Special,ipt) ; goto makep_fail ;
	      case _Current:	respnt->Grouping = V4DPI_Grouping_Current ; goto finish_make1 ;
	      case _PCurrent:	respnt->Grouping = V4DPI_Grouping_PCurrent ; goto finish_make1 ;
	      case _Undefined:	respnt->Grouping = V4DPI_Grouping_Undefined ; goto finish_make1 ;
	      case _Now:	respnt->Grouping = V4DPI_Grouping_Now ; goto finish_make1 ;
	      case _Sample:	respnt->Grouping = V4DPI_Grouping_Sample ; goto finish_make1 ;
	      case _All:	respnt->Grouping = V4DPI_Grouping_All ; goto finish_make1 ;
	      case _AllCnf:	respnt->Grouping = V4DPI_Grouping_AllCnf ; goto finish_make1 ;
	      case _LT:		grouping = V4DPI_Grouping_LT ; break ;
	      case _LE:		grouping = V4DPI_Grouping_LE ; break ;
	      case _GE:		grouping = V4DPI_Grouping_GE ; break ;
	      case _GT:		grouping = V4DPI_Grouping_GT ; break ;
	      case _NE:		grouping = V4DPI_Grouping_NE ; break ;
	    } ;
	   if (argcnt < 3) { v_Msg(ctx,NULL,"ModArgMissing",intmodx,3,argcnt) ; goto makep_fail ; } ;
/*	   Shift all arguments down one */
	   specPt = argpnts[2] ;			/* Save for possible error messages */
	   for(j=3;j<=argcnt;j++) { argpnts[j-1] = argpnts[j] ; } ; argcnt-- ;
	   ipt = argpnts[2] ;
	 } ;
/*	Check if second argument is a list - if so then if > n elements force into first args dimension otherwise expand */
	if (argcnt == 2 && ipt->PntType == V4DPI_PntType_List)
	 { struct V4L__ListPoint *lp = (struct V4L__ListPoint *)&argpnts[2]->Value ;
	   num = SIZEofLIST(lp) ;			/* Get total number of points in list */
	   if (num == 0)
	    { v_Msg(ctx,NULL,"ListSizeErr",intmodx,argpnts[2]) ; goto makep_fail ; } ;
	   if (num == 1)
	    { v4l_ListPoint_Value(ctx,lp,1,&arg1buf) ; ipt = (argpnts[2] = &arg1buf) ;	/* Fall thru and handle as point */
	    } else
	    { memcpy(respnt,argpnts[2],argpnts[2]->Bytes) ; respnt->Dim = di->DimId ; return(respnt) ;
	    } ;
	 } ;
/*	If ipt (second or third argument) same point type as dimension then assume we are going to create- dim:a,b,c,d... */
//VEH200213 - Have to migrate code from make_multval to below (see PntType_Dict) as example
	if (ipt->PntType == di->PointType && di->PointType != V4DPI_PntType_Tag)
	 { switch(di->PointType)
	    { default:				goto make_multval ;
	      case V4DPI_PntType_Dict:		break ;
	    } ;
	 } ;
/*	If second arg is NOT same then assume we are going to build point from components, ex.- MakeP(Dim:UDate year month day) */
	switch (di->PointType)				/* Maybe do some conversions based on dest Dim & src point */
	 { default:
		*trycoerce = TRUE ; return(NULL) ;			/* If don't know how to make, then try to Coerce() ! */
	   CASEofChar
	   case V4DPI_PntType_IntMod:
	   case V4DPI_PntType_Color:
	   case V4DPI_PntType_Country:
	   case V4DPI_PntType_Int:
	   case V4DPI_PntType_CodedRange:
	   case V4DPI_PntType_UYear:
	   case V4DPI_PntType_Real:
		goto make_multval ;			/* These do not have components - goto make_multval always */
	   case V4DPI_PntType_UDT:
		if (argcnt < 4 || argcnt > 7) { v_Msg(ctx,NULL,"MakePArgNum",intmodx,6,di->PointType,di->DimId) ; goto makep_fail ; } ;
		goto udate_entry ;
	   case V4DPI_PntType_Dict:
		ipt = argpnts[2] ;
		if (!(grouping == 0 || grouping == V4DPI_Grouping_NE)) { v_Msg(ctx,NULL,"DTInfoConvert3",intmodx,ipt,di->PointType,&tagpnt) ; goto makep_fail ; } ;
		switch(ipt->PntType)
		 {
		   default:
		     if (grouping != 0) { v_Msg(ctx,NULL,"DTInfoConvert3",intmodx,ipt,di->PointType,&tagpnt) ; goto makep_fail ; } ;
		     *trycoerce = TRUE ; return(NULL) ;
		   case V4DPI_PntType_CodedRange:
		   case V4DPI_PntType_Int:
		     k = ipt->Value.IntVal ; break ;
		   case V4DPI_PntType_Dict:
		     ucbp = v4dpi_RevDictEntryGet(ctx,ipt->Value.IntVal) ;
		     k = v4dpi_DictEntryGet(ctx,0,ucbp,di,NULL) ;
		     break ;
		   case V4DPI_PntType_XDict:
		     ucbp = v4dpi_RevXDictEntryGet(ctx,ipt->Dim,ipt->Value.IntVal) ;
		     k = v4dpi_DictEntryGet(ctx,0,ucbp,di,NULL) ;
		     break ;
		 } ;
		respnt->Value.IntVal = k ; respnt->Grouping = grouping ; respnt->Bytes = V4PS_Int ;
		goto finish_make ;
	   case V4DPI_PntType_UDate:
		if (argcnt != 4) { v_Msg(ctx,NULL,"MakePArgNum",intmodx,3,di->PointType,di->DimId) ; goto makep_fail ; } ;
udate_entry:
		respnt->Bytes = V4PS_Int ;
		{ int y,m,d,h,mm,s ;
		  y = v4im_GetPointInt(&ok,argpnts[2],ctx) ; if (!ok) { v_Msg(ctx,NULL,"ModInvArg",intmodx,2) ; goto makep_fail ; } ;
		  m = v4im_GetPointInt(&ok,argpnts[3],ctx) ; if (!ok) { v_Msg(ctx,NULL,"ModInvArg",intmodx,3) ; goto makep_fail ; } ;
		  d = v4im_GetPointInt(&ok,argpnts[4],ctx) ; if (!ok) { v_Msg(ctx,NULL,"ModInvArg",intmodx,4) ; goto makep_fail ; } ;
		  h = 0 ; mm = 0 ; s = 0 ;
		  if (argcnt >= 5) { h = v4im_GetPointInt(&ok,argpnts[5],ctx) ; if (!ok) { v_Msg(ctx,NULL,"ModInvArg",intmodx,5) ; goto makep_fail ; } ; } ;
		  if (argcnt >= 6) { mm = v4im_GetPointInt(&ok,argpnts[6],ctx) ; if (!ok) { v_Msg(ctx,NULL,"ModInvArg",intmodx,6) ; goto makep_fail ; } ; } ;
		  if (argcnt >= 7) { s = v4im_GetPointInt(&ok,argpnts[7],ctx) ; if (!ok) { v_Msg(ctx,NULL,"ModInvArg",intmodx,7) ; goto makep_fail ; } ; } ;
		  if (h<0 || h>23 || mm < 0 || mm > 59 || s < 0 || s > 59) { v_Msg(ctx,NULL,"MakePHMS",intmodx,h,m,(double)s) ; goto makep_fail ; } ;
		  if (di->PointType == V4DPI_PntType_UDate)
		   { VCALADJYEAR(((di->ds.UDate.calFlags & VCAL_Flags_Historical) != 0),y) ;
		     respnt->Value.IntVal = vcal_UDateFromYMD(FALSE,y,m,d,ctx->ErrorMsgAux) ;
		     if ((di->ds.UDate.calFlags & VCAL_Flags_Historical) != 0)
		      { if (respnt->Value.IntVal > valUDATEisNOW) { v_Msg(ctx,NULL,"MakePFuture",intmodx,respnt) ; goto makep_fail ; } ; } ;
		   } else
		   { VCALADJYEAR(((di->ds.UDT.calFlags & VCAL_Flags_Historical) != 0),y) ;
		     respnt->Value.IntVal = vcal_UDTFromYMD(y,m,d,h,mm,s,ctx->ErrorMsgAux) ;
		     if ((di->ds.UDate.calFlags & VCAL_Flags_Historical) != 0)
		      { if (vcal_UDateFromYMD(FALSE,y,m,d,ctx->ErrorMsgAux) > valUDATEisNOW) { v_Msg(ctx,NULL,"MakePFuture",intmodx,respnt) ; goto makep_fail ; } ; } ;
		   } ;
		  if (respnt->Value.IntVal == VCAL_BadVal)  { v_Msg(ctx,NULL,"ModFailed2",intmodx) ; goto makep_fail ; } ;
		} goto finish_make ;
	   case V4DPI_PntType_UWeek:
		if (di->ds.UWeek.baseUDate != VCAL_UDate_None)
		 { if (argcnt == 2)
		    { respnt->Value.IntVal = v4im_GetPointInt(&ok,argpnts[2],ctx) ; if (!ok) { v_Msg(ctx,NULL,"ModInvArg",intmodx,2) ; goto makep_fail ; } ;
		      goto finish_make ;
		    } ;
		   v_Msg(ctx,NULL,"MakePArgNum",intmodx,2,V4DPI_PntType_UWeek,di->DimId) ; goto makep_fail ;
		 } ;
		/* Fall thru & handle as year & week */
	   case V4DPI_PntType_UMonth:
	   case V4DPI_PntType_UPeriod:
	   case V4DPI_PntType_UQuarter:
		if (argcnt == 2)		/* If just 1 value (2nd arg) then plug in directly */
		 { respnt->Value.IntVal = v4im_GetPointInt(&ok,argpnts[2],ctx) ; if (!ok) { v_Msg(ctx,NULL,"ModInvArg",intmodx,2) ; goto makep_fail ; } ;
		    respnt->Bytes = V4PS_Int ; goto finish_make ;	
		 } ;
		if (argcnt != 3) { v_Msg(ctx,NULL,"MakePArgNum",intmodx,3,di->PointType,di->DimId) ; goto makep_fail ; } ;
		respnt->Bytes = V4PS_Int ;
		{ int y,xx ;
		  y = v4im_GetPointInt(&ok,argpnts[2],ctx) ; if (!ok) { v_Msg(ctx,NULL,"ModInvArg",intmodx,2) ; goto makep_fail ; } ;
//		  VCALADJYEAR(FALSE,y) ;
		  xx = v4im_GetPointInt(&ok,argpnts[3],ctx) ; if (!ok) { v_Msg(ctx,NULL,"ModInvArg",intmodx,3) ; goto makep_fail ; } ;
		  switch (di->PointType)
		   {
		     case V4DPI_PntType_UWeek:
			VCALADJYEAR(((di->ds.UWeek.calFlags & VCAL_Flags_Historical) != 0),y) ;
			if (xx < 1 || xx > 52) { v_Msg(ctx,NULL,"ModArgRange",intmodx,3,argpnts[3],1,52) ; goto makep_fail ; } ;
			if ((di->ds.UWeek.calFlags & VCAL_Flags_Historical) != 0)
			 { if (y > gpi->curYear) { v_Msg(ctx,NULL,"ModArgRange",intmodx,2,argpnts[2],VCAL_BaseYear,gpi->curYear) ; goto makep_fail ; } ; } ;
			respnt->Value.IntVal = (y - VCAL_BaseYear) * 52 + (xx - 1) ;
			break ;
		     case V4DPI_PntType_UMonth:
			VCALADJYEAR(((di->ds.UMonth.calFlags & VCAL_Flags_Historical) != 0),y) ;
			if (xx < 1 || xx > 12) { v_Msg(ctx,NULL,"ModArgRange",intmodx,3,argpnts[3],1,12) ; goto makep_fail ; } ;
			if ((di->ds.UWeek.calFlags & VCAL_Flags_Historical) != 0)
			 { if (y > gpi->curYear) { v_Msg(ctx,NULL,"ModArgRange",intmodx,2,argpnts[2],VCAL_BaseYear,gpi->curYear) ; goto makep_fail ; } ;
			   if (y == gpi->curYear ? xx > ((mscu_udate_to_yyyymmdd(valUDATEisNOW) / 100) % 100) : FALSE) { v_Msg(ctx,NULL,"ModArgRange",intmodx,3,argpnts[3],1,((mscu_udate_to_yyyymmdd(valUDATEisNOW) / 100) % 100)) ; goto makep_fail ; } ;
			 } ;
//			respnt->Value.IntVal = (y - VCAL_BaseYear) * 12 + (xx - 1) ;
			respnt->Value.IntVal = YYMMtoUMONTH(y,xx) ;
			break ;
		     case V4DPI_PntType_UPeriod:
			VCALADJYEAR(((di->ds.UPeriod.calFlags & VCAL_Flags_Historical) != 0),y) ;
//xxx makep di is already set
			{ int ppy = (di->ds.UPeriod.periodsPerYear == 0 ? 13 : di->ds.UPeriod.periodsPerYear) ;
			  if (xx < 1 || xx > ppy) { v_Msg(ctx,NULL,"ModArgRange",intmodx,3,argpnts[3],1,ppy) ; goto makep_fail ; } ;
			  respnt->Value.IntVal = (y - VCAL_BaseYear) * ppy + (xx - 1) ;
			}
			if ((di->ds.UPeriod.calFlags & VCAL_Flags_Historical) != 0)
			 { if (y > gpi->curYear) { v_Msg(ctx,NULL,"ModArgRange",intmodx,2,argpnts[2],VCAL_BaseYear,gpi->curYear) ; goto makep_fail ; } ;
			 } ;
			break ;
		     case V4DPI_PntType_UQuarter:
			VCALADJYEAR(((di->ds.UQuarter.calFlags & VCAL_Flags_Historical) != 0),y) ;
			if (xx < 1 || xx > 4) { v_Msg(ctx,NULL,"ModArgRange",intmodx,3,argpnts[3],1,4) ; goto makep_fail ; } ;
			if ((di->ds.UQuarter.calFlags & VCAL_Flags_Historical) != 0)
			 { if (y > gpi->curYear) { v_Msg(ctx,NULL,"ModArgRange",intmodx,2,argpnts[2],VCAL_BaseYear,gpi->curYear) ; goto makep_fail ; } ;
//			   if (y == gpi->curYear ? xx > ((((mscu_udate_to_yyyymmdd(valUDATEisNOW) / 100) % 100) + 2) / 3) : FALSE) { v_Msg(ctx,NULL,"ModArgRange",intmodx,3,argpnts[3],1,((((mscu_udate_to_yyyymmdd(valUDATEisNOW) / 100) % 100) + 2) / 3)) ; goto makep_fail ; } ;
			   if (y == gpi->curYear ? xx > UQTRtoQTR(YYYYMMDDtoUQTR(mscu_udate_to_yyyymmdd(valUDATEisNOW))) : FALSE) { v_Msg(ctx,NULL,"ModArgRange",intmodx,3,argpnts[3],1,((((mscu_udate_to_yyyymmdd(valUDATEisNOW) / 100) % 100) + 2) / 3)) ; goto makep_fail ; } ;
			 } ;
//			respnt->Value.IntVal = (y - VCAL_BaseYear) * 4 + (xx - 1) ; break ;
			respnt->Value.IntVal = YYQQtoUQTR(y,xx) ; break ;
		   } ;
		  if (y < VCAL_UYearMin || y > VCAL_UYearMax) { v_Msg(ctx,NULL,"MakePInvYear",intmodx,y,VCAL_UYearMin,VCAL_UYearMax) ; goto makep_fail ; } ;
		} goto finish_make ;
	   case V4DPI_PntType_UTime:
		if (argcnt == 2)		/* If just 1 value (2nd arg) then plug in directly */
		 { dnum = v4im_GetPointDbl(&ok,argpnts[2],ctx) ; if (!ok) { v_Msg(ctx,NULL,"ModInvArg",intmodx,2) ; goto makep_fail ; } ;
		   PUTREAL(respnt,dnum) ; respnt->Bytes = V4PS_UTime ; goto finish_make ;	
		 } ;
		{ int hh,mm ; double ss = 0 ;
		  switch(argcnt)
		   { default:	ok = FALSE ; v_Msg(ctx,NULL,"ModArgMissing",intmodx,4,argcnt) ; goto makep_fail ;
		     case 4:	ss = v4im_GetPointDbl(&ok,argpnts[4],ctx) ; if (!ok) { v_Msg(ctx,NULL,"ModInvArg",intmodx,4) ; goto makep_fail ; } ;
		     case 3:	hh = v4im_GetPointInt(&ok,argpnts[2],ctx) ; if (!ok) { v_Msg(ctx,NULL,"ModInvArg",intmodx,2) ; goto makep_fail ; } ;
				mm = v4im_GetPointInt(&ok,argpnts[3],ctx) ; if (!ok) { v_Msg(ctx,NULL,"ModInvArg",intmodx,3) ; goto makep_fail ; } ;
				break ;
		   } ;
		  if (hh < 0 || hh > 9999 || mm < 0 || mm > 59 || ss < 0 || ss >= 60)
		   { v_Msg(ctx,NULL,"MakePHMS",intmodx,hh,mm,ss) ; goto makep_fail ; } ;
		  dnum = (hh*3600+mm*60+ss) ;
		  PUTREAL(respnt,dnum) ; respnt->Bytes = V4PS_UTime ; goto finish_make ;
		}
	   case V4DPI_PntType_Int2:		/* MakeP(Dim:int2 num1 [num2]) */
		respnt->Bytes = V4PS_Int2 ;
		if (argpnts[2]->PntType == V4DPI_PntType_Dict || argpnts[2]->PntType == V4DPI_PntType_XDict) { ok = TRUE ; respnt->Value.Int2Val[0] = argpnts[2]->Value.IntVal ; }
		 else { respnt->Value.Int2Val[0] = PNTintVAL(&ok,argpnts[2],ctx) ; }
		if (argcnt == 2) { respnt->Value.Int2Val[1] = respnt->Value.Int2Val[0] ; }
		 else {	if (ok)
			 { if (argpnts[3]->PntType == V4DPI_PntType_Dict || argpnts[3]->PntType == V4DPI_PntType_XDict) { respnt->Value.Int2Val[1] = argpnts[3]->Value.IntVal ; }
			    else { respnt->Value.Int2Val[1] = PNTintVAL(&ok,argpnts[argcnt > 2 ? 3 : 2],ctx) ; } ;
			 } ;
		      } ;
		if (!ok) { v_Msg(ctx,NULL,"ModFailed2",intmodx) ; goto makep_fail ; } ;
		if (di->Flags & V4DPI_DimInfo_Normalize)
		 { if (respnt->Value.Int2Val[0] > respnt->Value.Int2Val[1])
		    { int t ; t = respnt->Value.Int2Val[0] ; respnt->Value.Int2Val[0] = respnt->Value.Int2Val[1] ; respnt->Value.Int2Val[1] = t ;
		    } ;
		 } ;
		goto finish_make ;
	   case V4DPI_PntType_XDB:		/* MakeP(Dim:xdb xdbId recId) */
		if (argcnt != 3) { v_Msg(ctx,NULL,"ModArgMissing",intmodx,3,argcnt) ; goto makep_fail ; } ;
		respnt->Bytes = V4PS_XDB ;
		respnt->Value.XDB.xdbId = PNTintVAL(&ok,argpnts[2],ctx) ; 
		if (ok) respnt->Value.XDB.recId = PNTintVAL(&ok,argpnts[3],ctx) ; 
		if (!ok) { v_Msg(ctx,NULL,"ModFailed2",intmodx) ; goto makep_fail ; } ;
		goto finish_make ;
	   case V4DPI_PntType_TeleNum:		/* MakeP(Dim:tele [country] ac number ) */
	      { int idc=0, ac=0, num=0, ext=0, type=0 ; int invcomp ;
		respnt->Bytes = V4PS_Tele ;
		switch (argcnt)
		 { default:	ok = FALSE ; v_Msg(ctx,NULL,"ModArgMissing",intmodx,3,argcnt) ; goto makep_fail ;
		   case 2:
			switch (argpnts[2]->PntType)
			 { default:	break ;
			   case V4DPI_PntType_Dict:
			   case V4DPI_PntType_XDict:
			   CASEofChar
				v4im_GetPointUC(&ok,UCTBUF1,V4TMBufMax,argpnts[2],ctx) ;	/* Check for string telephone */
				if (v_parseTeleNum(ctx,di,respnt,NULL,UCTBUF1,UCTBUF2)) goto finish_make ;
			 } ;
		   case 3:
			if (argpnts[2]->PntType != V4DPI_PntType_Int || argcnt < 3)	/* Got alternate form of tele number? (like maybe an email address?) */
			 { if (!v4im_MakePTeleAccept(ctx,di,respnt,NULL,argpnts[2],(argcnt > 2 ? argpnts[3] : NULL)))
			    { v_Msg(ctx,NULL,"ModFailed2",intmodx) ; goto makep_fail ; } ;
			   goto finish_make ;
			 } ;
			idc = gpi->ci->Cntry[gpi->ci->CurX].IntDialCode ;
			ac = v4im_GetPointInt(&ok,argpnts[2],ctx) ;
			if (ok) num = v4im_GetPointInt(&ok,argpnts[3],ctx) ;
			break ;
		   case 4: case 5: case 6:
			idc = v4im_GetPointInt(&ok,argpnts[2],ctx) ;
			if (ok) ac = v4im_GetPointInt(&ok,argpnts[3],ctx) ;
			if (ok) num = v4im_GetPointInt(&ok,argpnts[4],ctx) ;
			if (ok && argcnt >= 5)
			 { idc = -idc ;
			   ext = v4im_GetPointInt(&ok,argpnts[5],ctx) ;
			   if (ok && argcnt >= 6)
			    { switch(v4im_GetDictToEnumVal(ctx,argpnts[6]))
			       { default:	ok = FALSE ; v_Msg(ctx,ctx->ErrorMsgAux,"TeleType2") ; break ;
			         case _Cell:	type = V4DPI_TeleType_Cell ; break ;
			         case _Fax:	type = V4DPI_TeleType_Fax ; break ;
			         case _Home:	type = V4DPI_TeleType_Home ; break ;
			         case _Work:	type = V4DPI_TeleType_Work ; break ;
			       } ;
			    } ;
			 } ;
			break ;
		 } ;
		if (!ok) { v_Msg(ctx,NULL,"ModFailed2",intmodx) ; goto makep_fail ; } ;
		invcomp = idc ; if (argcnt < 5) { if (idc < 0 || idc > 9999) goto tele_fail ; } else { if (idc > 0 || idc < -9999) goto tele_fail ; } ;
		if (ac < 0 || ac > 9999) { invcomp = ac ; goto tele_fail ; } ;
		if (num <= 10000 || num > 9999999) { invcomp = num ; goto tele_fail ; } ;
		if (ext < 0 || ext > 999999) { invcomp = ext ; goto tele_fail ; } ;
		respnt->Value.Tele.Type = type ;
		respnt->Value.Tele.IntDialCode = idc ;
		respnt->Value.Tele.AreaCode = ac ;
		respnt->Value.Tele.Number = num ;
		respnt->Value.Tele.Extension = ext ;
		goto finish_make ;
tele_fail:	v_Msg(ctx,NULL,"TeleInvComp",intmodx,invcomp) ; goto makep_fail ;
	      }
	   case V4DPI_PntType_Tag:
		if (argcnt < 2) { v_Msg(ctx,NULL,"ModArgMissing",intmodx,2,argcnt) ; goto makep_fail ; } ;
		ipt = argpnts[2] ;
		respnt->PntType = V4DPI_PntType_TagVal ; respnt->Dim = ipt->Dim ;
		tv = (struct V4DPI__TagVal *)&respnt->Value ;
		if (ipt->PntType == V4DPI_PntType_Tag) { tv->TagVal = ipt->Value.IntVal ; }
		 else { v4im_GetPointUC(&ok,UCTBUF1,V4TMBufMax,ipt,ctx) ;
			tv->TagVal = v4im_TagValue(UCTBUF1) ;
			if (tv->TagVal <= 0) { v_Msg(ctx,NULL,"TagNotTag",intmodx,ipt) ; goto makep_fail ; } ;
		      } ;
		if (tv->TagVal <= 0) { v_Msg(ctx,NULL,"DPIInvPoint2",intmodx,ipt,ipt->Dim) ; goto makep_fail ; } ;
		if (argcnt == 2)			/* Only one argument - then create tag? point */
		 { respnt->ForceEval = TRUE ; respnt->Bytes = (char *)&tv->TagPt - (char *)respnt ;
		   return(respnt) ;
		 };
		memcpy(&tv->TagPt,argpnts[3],argpnts[3]->Bytes) ;
		if (tv->TagPt.PntType == V4DPI_PntType_Isct) { UNQUOTE(&tv->TagPt) ; } ;
		 respnt->Bytes = (char *)&tv->TagPt + argpnts[3]->Bytes - (char *)respnt ;
		return(respnt) ;


	   case V4DPI_PntType_UOM:		/* MakeP(Dim:uom num id index [casecount]) */
		if (gpi->uomt == NULL) v4dpi_UOMInitialize(ctx,UNUSED) ;	/* Attempt to init if necessary */
		if (argcnt < 4) { v_Msg(ctx,NULL,"ModArgMissing",intmodx,4,argcnt) ; goto makep_fail ; } ;
		k = v4im_GetPointInt(&ok,argpnts[3],ctx) ;		/* k = UOM Ref */
		if (!ok) { v_Msg(ctx,NULL,"ModFailed2",intmodx) ; goto makep_fail ; } ;
		if (k <= 0) k = di->UOMRef ;
		uomt = gpi->uomt ;
		if (uomt == NULL) { uomd = NULL ; }			/* Nothing defined - do best we can */
		 else {	for(i=0;i<=uomt->Count;i++) { if (uomt->Entry[i].Ref == k) break ; } ;
			if (i >= uomt->Count)
			 { v4dpi_UOMInitialize(ctx,k) ;
			   for(i=0;i<=uomt->Count;i++) { if (uomt->Entry[i].Ref == k) break ; } ;
			 } ;
			if (i < uomt->Count) { uomd = uomt->Entry[i].uomd ; } else { uomd = NULL ; } ;
		      } ;
		if (argpnts[4]->PntType == V4DPI_PntType_Int)
		 { j = v4im_GetPointInt(&ok,argpnts[4],ctx) ;		/* j = UOM Entry Index */
		   if (!ok) { v_Msg(ctx,NULL,"ModFailed2",intmodx) ; goto makep_fail ; } ;
		   if (uomd != NULL)
		    { if (j >= 0)						/* if j < 0 then case count (factor) */
		       { for(i=0;i<uomd->Count;i++) { if (uomd->UEntry[i].Index == j) break ; } ;
		       } else
		       { for(i=0;i<uomd->Count;i++) { if (uomd->UEntry[i].Factor == -j) break ; } ;
		       } ;
		      if (i >= uomd->Count) i = UNUSED ;
		    } else { i = UNUSED ; } ;				/* i = uomd Entry[] or UNUSED */
		 } else
		 { v4im_GetPointUC(&ok,uctb,sizeof uctb,argpnts[4],ctx) ;
		   if (!ok) { v_Msg(ctx,NULL,"ModFailed2",intmodx) ; goto makep_fail ; } ;
		   if (uomd != NULL)
		    { for(i=0;i<uomd->Count;i++) { if (UCstrcmp(uctb,uomd->UEntry[i].PSStr) == 0) break ; } ;
		      if (i >= uomd->Count) i = UNUSED ;
		    } else { i = UNUSED ; } ;
		 } ;
		if (i == UNUSED && uomd != NULL) { ipt = NULL ; goto finish_make2 ; } ;
		ipt = respnt ; ZPH(ipt) ; ipt->Dim = di->DimId ; ipt->PntType = V4DPI_PntType_UOM ;
		ipt->Bytes = V4PS_UOM ;
		ipt->Value.UOMVal.Ref = k ; ipt->Value.UOMVal.Index = (i >= 0 ? uomd->UEntry[i].Index : 0) ;
		dnum = v4im_GetPointDbl(&ok,argpnts[2],ctx) ; if (!ok) { v_Msg(ctx,NULL,"ModInvArg",intmodx,2) ; goto makep_fail ; } ;
//		dnum1 = (i >= 0 ? uomd->UEntry[i].Factor : 0.0) ;
		{ double factor, preOffset, postOffset, caseCount ;
		  if (i >= 0) { factor = uomd->UEntry[i].Factor ; preOffset = uomd->UEntry[i].preOffset ; postOffset = uomd->UEntry[i].postOffset ; }
		   else { factor = 1 ; preOffset = 0 ; postOffset = 0 ; caseCount = 0 ; } ;
		  if (argcnt >= 5) { caseCount = v4im_GetPointInt(&ok,argpnts[5],ctx) ; if (!ok) { v_Msg(ctx,NULL,"ModInvArg",intmodx,5) ; goto makep_fail ; } ; }
		   else if (uomd != NULL) { caseCount = uomd->CaseCount ; }
		   else caseCount = 0 ;
		  if (caseCount != 0)
		   { ipt->Value.UOMVal.Index += caseCount * V4DPI_CaseCount_Mult ;
		     factor = caseCount ;
		   } ;
//		  if (dnum1 == 0.0) dnum1 = (double)caseCount ;
//		  if (dnum1 != 0.0) dnum *= dnum1 ;
		  dnum = ((preOffset + dnum) * factor) + postOffset ;
		}
		memcpy(&ipt->Value.UOMVal.Num,&dnum,sizeof dnum) ;
		goto finish_make2 ;
	   case V4DPI_PntType_UOMPer:
		ipt = respnt ; ZPH(ipt) ; ipt->Dim = di->DimId ; ipt->PntType = V4DPI_PntType_UOMPer ;
		ipt->Bytes = V4PS_UOMPer ;
		dnum = v4im_GetPointDbl(&ok,argpnts[2],ctx) ; if (!ok) { v_Msg(ctx,NULL,"ModInvArg",intmodx,2) ; goto makep_fail ; } ;
		memcpy(&ipt->Value.UOMPerVal.Amount,&dnum,sizeof dnum) ;
		if (argcnt == 3 ? argpnts[3]->PntType != V4DPI_PntType_UOM : TRUE)
		 { v_Msg(ctx,NULL,"ModArgPntType2",intmodx,3,argpnts[3]->PntType,V4DPI_PntType_UOM) ; goto makep_fail ; } ;
		ipt->Value.UOMPerVal.Ref = argpnts[3]->Value.UOMVal.Ref ;
		ipt->Value.UOMPerVal.Index = argpnts[3]->Value.UOMVal.Index ;
		ipt->Value.UOMPerVal.Num = argpnts[3]->Value.UOMVal.Num ;
		goto finish_make2 ;
	   case V4DPI_PntType_UOMPUOM:
		ipt = respnt ; ZPH(ipt) ; ipt->Dim = di->DimId ; ipt->PntType = V4DPI_PntType_UOMPUOM ; ipt->Bytes = V4PS_UOMPUOM ;
		if (argcnt >= 2 ? argpnts[2]->PntType != V4DPI_PntType_UOM : TRUE)
		 { v_Msg(ctx,NULL,"ModArgPntType2",intmodx,2,argpnts[2]->PntType,V4DPI_PntType_UOM) ; goto makep_fail ; } ;
		if (argcnt == 3 ? argpnts[3]->PntType != V4DPI_PntType_UOM : TRUE)
		 { v_Msg(ctx,NULL,"ModArgPntType2",intmodx,3,argpnts[3]->PntType,V4DPI_PntType_UOM) ; goto makep_fail ; } ;
		ipt->Value.UOMPUOMVal.uomDim = argpnts[2]->Dim ; ipt->Value.UOMPUOMVal.UOM = argpnts[2]->Value.UOMVal ;
		ipt->Value.UOMPUOMVal.puomDim = argpnts[3]->Dim ; ipt->Value.UOMPUOMVal.PUOM = argpnts[3]->Value.UOMVal ;
		goto finish_make2 ;
	   case V4DPI_PntType_Complex:
		ipt = respnt ; ZPH(ipt) ; ipt->Dim = di->DimId ; ipt->PntType = V4DPI_PntType_Complex ;
		ipt->Bytes = V4PS_Complex ;
		dnum = v4im_GetPointDbl(&ok,argpnts[2],ctx) ; if (!ok) { v_Msg(ctx,NULL,"ModInvArg",intmodx,2) ; goto makep_fail ; } ;
		memcpy(&ipt->Value.Complex.r,&dnum,sizeof dnum) ;
		if (argcnt != 3) { v_Msg(ctx,NULL,"ModArgMissing",intmodx,3,argcnt) ; goto makep_fail ; } ;
		dnum = v4im_GetPointDbl(&ok,argpnts[3],ctx) ; if (!ok) { v_Msg(ctx,NULL,"ModInvArg",intmodx,3) ; goto makep_fail ; } ;
		memcpy(&ipt->Value.Complex.i,&dnum,sizeof dnum) ;
		goto finish_make2 ;
	   case V4DPI_PntType_GeoCoord:
		if (argcnt < 3) { v_Msg(ctx,NULL,"ModArgMissing",intmodx,4,argcnt) ; goto makep_fail ; } ;
		ipt = respnt ; ZPH(ipt) ; ipt->Dim = di->DimId ; ipt->PntType = V4DPI_PntType_GeoCoord ; ipt->Bytes = V4PS_GeoCoord ;
		dnum = v4im_GetPointDbl(&ok,argpnts[2],ctx) ; if (!ok) { v_Msg(ctx,NULL,"ModInvArg",intmodx,2) ; goto makep_fail ; } ;
		dnum1 = v4im_GetPointDbl(&ok,argpnts[3],ctx) ; if (!ok) { v_Msg(ctx,NULL,"ModInvArg",intmodx,3) ; goto makep_fail ; } ;
		if (dnum < -90.0 || dnum >= 90.0) { v_Msg(ctx,NULL,"ModArgRange",intmodx,2,argpnts[2],-90,90) ; goto makep_fail ; } ;
		if (dnum1 < -180.0 || dnum1 > 180.0) { v_Msg(ctx,NULL,"ModArgRange",intmodx,3,argpnts[3],-180,180) ; goto makep_fail ; } ;
		ipt->Value.GeoCoord.Coord1 = DtoI(dnum * V4DPI_GeoCoord_Factor) ; ipt->Value.GeoCoord.Coord2 = DtoI(dnum1 * V4DPI_GeoCoord_Factor) ;
		ipt->Value.GeoCoord.GCType = V4DPI_GCType_LatLonMeter ;
		if (argcnt == 3) { SETGEOALT(&ipt->Value.GeoCoord,0.0) ; ipt->Value.GeoCoord.TimeZone = VCAL_TimeZone_Local ; goto finish_make2 ; } ;
		if (argcnt >= 4)
		 { dnum = v4im_GetPointDbl(&ok,argpnts[4],ctx) ; if (!ok) { ok  = -4 ; goto not_ok ; } ;
		   if (dnum < -V4DPI_GeoCoordCoord3_Offset || dnum > 1000000) { v_Msg(ctx,NULL,"ModArgRange",intmodx,4,argpnts[4],-V4DPI_GeoCoordCoord3_Offset,1000000) ; goto makep_fail ; } ;
		   SETGEOALT(&ipt->Value.GeoCoord,dnum) ; ipt->Value.GeoCoord.TimeZone = VCAL_TimeZone_Local ;
		 } ;
		if (argcnt >= 5)
		 { i = v4im_GetPointInt(&ok,argpnts[5],ctx) ; if (!ok) break ;
		   if (i != VCAL_TimeZone_Local)
		    { if (i < -12) i += 24 ; if (i > 12) i -= 24 ;
		      if (i < -12 || i > 12) { v_Msg(ctx,NULL,"ModArgRange",intmodx,5,argpnts[5],-12,12) ; goto makep_fail ; } ;
		      ipt->Value.GeoCoord.TimeZone = i ;
		    } ;
		 } ;
		if (argcnt <= 5) {  goto finish_make2 ; } ;
		if (argcnt != 12) { v_Msg(ctx,NULL,"ModArgMissing",intmodx,12,argcnt) ; goto makep_fail ; } ;

		gcdsv = (struct V4DPI__Value_GCDSV *)&ipt->Value ;
		gcdsv->GCType = V4DPI_GCType_Distance ; ipt->Bytes = V4PS_GeoCoordGCDSV ;
		dnum = v4im_GetPointDbl(&ok,argpnts[6],ctx) ; if (!ok) { ok = -6 ; goto not_ok ; } ;
		if (dnum < 0 || dnum > 100000000) { v_Msg(ctx,NULL,"ModArgRange",intmodx,6,argpnts[6],0,100000000) ; goto makep_fail ; } ;
		frac = modf(dnum,&ipart) ; gcdsv->distInt = DtoI(ipart) ; gcdsv->distFrac = DtoI(frac * V4DPI_GeoCoordDist_Factor) ;
		gcdsv->distUOM = v4im_GetPointInt(&ok,argpnts[7],ctx) ; if (!ok) { ok = -7 ; goto not_ok ; } ;
		if (gcdsv->distUOM < 0 || gcdsv->distUOM > V4DPI_GeoCoordDist_MaxVal) { v_Msg(ctx,NULL,"ModArgRange",intmodx,7,argpnts[7],0,V4DPI_GeoCoordDist_MaxVal) ; goto makep_fail ; } ;
		gcdsv->speedUnit = v4im_GetPointInt(&ok,argpnts[8],ctx) ; if (!ok) { ok = -8 ; goto not_ok ; } ;
		if (gcdsv->speedUnit < 0 || gcdsv->speedUnit > V4DPI_GeoCoordSpeed_MaxVal) { v_Msg(ctx,NULL,"ModArgRange",intmodx,8,argpnts[8],0,V4DPI_GeoCoordSpeed_MaxVal) ; goto makep_fail ; } ;
		gcdsv->hgtUOM = v4im_GetPointInt(&ok,argpnts[9],ctx) ; if (!ok) { ok = -9 ; goto not_ok ; } ;
		if (gcdsv->hgtUOM < 0 || gcdsv->hgtUOM > V4DPI_GeoCoordDist_MaxVal) { v_Msg(ctx,NULL,"ModArgRange",intmodx,9,argpnts[9],0,V4DPI_GeoCoordDist_MaxVal) ; goto makep_fail ; } ;
		dnum = v4im_GetPointDbl(&ok,argpnts[10],ctx) ; if (!ok) { ok = -10 ; goto not_ok ; } ;
		if (dnum == V4DPI_GeoCoord_NoBearing ? FALSE : (dnum < -180 || dnum > 180)) { v_Msg(ctx,NULL,"ModArgRange",intmodx,10,argpnts[10],-180,180) ; goto makep_fail ; } ;
		  gcdsv->bearingDeg1 = dnum * V4DPI_GeoCoord_Factor ;
		dnum = v4im_GetPointDbl(&ok,argpnts[11],ctx) ; if (!ok) { ok = -11 ; goto not_ok ; } ;
		if (dnum == V4DPI_GeoCoord_NoBearing ? FALSE : (dnum < -90 || dnum > 90)) { v_Msg(ctx,NULL,"ModArgRange",intmodx,11,argpnts[11],-90,90) ; goto makep_fail ; } ;
		  gcdsv->bearingDeg2 = dnum * V4DPI_GeoCoord_Factor ;
		dnum = v4im_GetPointCal(&ok,argpnts[12],ctx) ; if (!ok) { ok = -12 ; goto not_ok ; } 
		SETDBL(gcdsv->calDateTime,dnum) ;
		goto finish_make2 ;
	   case V4DPI_PntType_Calendar:
/*		Here to make calendar point from (UDate UTime TimeZone DaylightSaving) or (UDT TimeZone DaylightSaving) */
		dls = FALSE ;
		if (argpnts[2]->PntType == V4DPI_PntType_UDT)
		 { dnum = (double)((argpnts[2]->Value.IntVal / VCAL_SecsInDay) + VCAL_UDTUDateOffset + VCal_MJDOffset)
			   +  (double)(argpnts[2]->Value.IntVal % VCAL_SecsInDay) / (60.0 * 60.0 * 24.0) ;
		   tz = (argcnt > 2 ? v4im_GetPointInt(&ok,argpnts[3],ctx) : VCAL_TimeZone_Local) ; if (!ok) ok = -3 ;
		   if (ok && argcnt > 3) { dls = v4im_GetPointLog(&ok,argpnts[4],ctx) ; if (!ok) ok = -4 ; } ;
		 } else
		 { dnum = VCal_MJDOffset + v4im_GetPointUD(&ok,argpnts[2],ctx) ; if (!ok) ok = -2 ;
		   if (ok)
		    { if (argpnts[3]->PntType != V4DPI_PntType_UTime)
		       { v_Msg(ctx,NULL,"ModArgPntType2",intmodx,3,argpnts[3]->PntType,V4DPI_PntType_UTime) ; goto makep_fail ;
		       } else { GETREAL(dnum1,argpnts[3]) ; dnum += (dnum1 / (24.0 * 60.0 * 60.0)) ; } ;
		    } ;
		   tz = (ok && argcnt > 3 ? v4im_GetPointInt(&ok,argpnts[4],ctx) : VCAL_TimeZone_Local) ;
		   if (ok && argcnt > 4) { dls = v4im_GetPointLog(&ok,argpnts[5],ctx) ; if (!ok) ok = -5 ; } ;
		 } ;
		if (!ok) { v_Msg(ctx,NULL,"ModInvArg",intmodx,-ok) ; goto makep_fail ; } ;
		if (zuluoffset == (double)UNUSED) zuluoffset = -(double)mscu_minutes_west() / (24 * 60) ;
		dnum -= (tz == VCAL_TimeZone_Local ? zuluoffset : (double)tz / 24.0) ;
		if (dls) { dnum -= (1.0 / 24.0) ; } ;
		{ double frac,intdbl ; frac = modf(dnum,&intdbl) ; if (frac == 0.0) dnum += VCAL_MidnightValue ;
		} ;
		PUTREAL(respnt,dnum) ;
		respnt->Bytes = V4PS_Calendar ; goto finish_make ;
	   case V4DPI_PntType_PntIdx:			/* Target dimension is point-pointer - copy 2nd arg */
		pix = v4dpi_PntIdx_AllocPnt() ; cpt = v4dpi_PntIdx_CvtIdxPtr(pix) ;
		memcpy(cpt,ipt,ipt->Bytes) ;		/* Copy 2nd arg into allocated point */
		respnt->Value.IntVal = pix ;	/* Save point index */
		respnt->Bytes = V4PS_Int ;
		goto finish_make ;
	 } ;

not_ok:	v_Msg(ctx,NULL,"ModInvArg",intmodx,-ok) ; goto makep_fail ;

/*	Here to create dim:pt,pt,pt,.... for as many args as we got */
make_multval:	 
	if (argcnt > 2 && ((di->Flags & V4DPI_DimInfo_ListOK) == 0)) { v_Msg(ctx,NULL,"MakePNoMult",intmodx,di->DimId) ; goto makep_fail ; } ;
	switch (di->PointType)				/* Maybe do some conversions based on dest Dim & src point */
	 { default:
		if (argcnt == 2 && di->PointType == argpnts[2]->PntType)	/* Same type of point - then just copy & fix dimension */
		 { memcpy(respnt,argpnts[2],argpnts[2]->Bytes) ; goto finish_make ;
		 } ;
		v_Msg(ctx,NULL,"MakePPTInv",intmodx,di->DimId,di->PointType) ; goto makep_fail ;
	   case V4DPI_PntType_Color:
		if (grouping == V4DPI_Grouping_NE)
		 { respnt->Grouping = grouping ; respnt->Value.IntVal = ipt->Value.IntVal ; SETBYTESGRPINT(respnt) ;
		   goto finish_make ;
		 } ;
		if (grouping != 0)
		 { v_Msg(ctx,NULL,"MakePSpecial",intmodx,specPt,di->DimId,di->PointType) ; goto makep_fail ; } ;
		if (argcnt == 2) { *trycoerce = TRUE ; return(NULL) ; } ;
		pim = (struct V4DPI__Point_IntMix *)&respnt->Value ;
		grouping = 0 ;
		for(i=2;i<=argcnt;i++)
		 { ipt = argpnts[i] ;
		   if (ipt->Grouping == V4DPI_Grouping_Single)
		    { switch (ipt->PntType)
		       { default:
				v_Msg(ctx,NULL,"DTInfoConvert",intmodx,ipt,di->PointType) ; goto makep_fail ;
		         case V4DPI_PntType_CodedRange:
			 case V4DPI_PntType_Int:
				bp = "" ; k = v_ColorNumToRef(ipt->Value.IntVal) ; break ;
		         case V4DPI_PntType_Dict:
				ucbp = v4dpi_RevDictEntryGet(ctx,ipt->Value.IntVal) ;
				k = v_ColorNameToRef(ucbp) ;
				break ;
		         case V4DPI_PntType_XDict:
				ucbp = v4dpi_RevXDictEntryGet(ctx,ipt->Dim,ipt->Value.IntVal) ;
				k = v_ColorNameToRef(ucbp) ;
				break ;
		       } ;
		      if (k == 0) { v_Msg(ctx,NULL,"DPIInvPoint2",intmodx,ipt,di->DimId) ;goto makep_fail ; } ;
		      pim->Entry[grouping].BeginInt = k ; pim->Entry[grouping].EndInt = k ;
		      grouping++ ;
		    } else
		    { pimx = (struct V4DPI__Point_IntMix *)&ipt->Value ;
		      for(k=0;k<ipt->Grouping;k++)
		       { pim->Entry[grouping++] = pimx->Entry[k] ; } ;
		    } ;
		   continue ;
		 } ;
//		if (argcnt == 2 && argpnts[2]->Grouping == V4DPI_Grouping_Single) grouping = V4DPI_Grouping_Single ;	/* Don't have multiple points in this case */
//		respnt->Grouping = grouping ; respnt->Bytes = (char *)&pim->Entry[respnt->Grouping].BeginInt - (char *)respnt ;
		if (argcnt == 2 && argpnts[2]->Grouping == V4DPI_Grouping_Single)
		 { grouping = V4DPI_Grouping_Single ; respnt->Bytes = V4PS_Int ; }	/* Don't have multiple points in this case */
		 else { respnt->Grouping = grouping ; SETBYTESGRPINT(respnt) ; } ;
		goto finish_make ;
	   case V4DPI_PntType_Country:
		if (grouping == V4DPI_Grouping_NE)
		 { respnt->Grouping = grouping ; respnt->Value.IntVal = ipt->Value.IntVal ; SETBYTESGRPINT(respnt) ;
		   goto finish_make ;
		 } ;
		if (grouping != 0)
		 { v_Msg(ctx,NULL,"MakePSpecial",intmodx,specPt,di->DimId,di->PointType) ; goto makep_fail ; } ;
		if (argcnt == 2) { *trycoerce = TRUE ; return(NULL) ; } ;
		pim = (struct V4DPI__Point_IntMix *)&respnt->Value ;
		grouping = 0 ;
		for(i=2;i<=argcnt;i++)
		 { ipt = argpnts[i] ;
		   if (ipt->Grouping == V4DPI_Grouping_Single)
		    { switch (ipt->PntType)
		       { default:
				v_Msg(ctx,NULL,"DTInfoConvert",intmodx,ipt,di->PointType) ; goto makep_fail ;
		         case V4DPI_PntType_CodedRange:
			 case V4DPI_PntType_Int:
				bp = "" ; k = ipt->Value.IntVal ; break ;
		         case V4DPI_PntType_Dict:
				ucbp = v4dpi_RevDictEntryGet(ctx,ipt->Value.IntVal) ;
				k = v_CountryNameToRef(ucbp) ;
				break ;
		         case V4DPI_PntType_XDict:
				ucbp = v4dpi_RevXDictEntryGet(ctx,ipt->Dim,ipt->Value.IntVal) ;
				k = v_CountryNameToRef(ucbp) ;
				break ;
		       } ;
		      if (k == 0) { v_Msg(ctx,NULL,"DPIInvPoint2",intmodx,ipt,di->DimId) ; goto makep_fail ; } ;
		      pim->Entry[grouping].BeginInt = k ; pim->Entry[grouping].EndInt = k ;
		      grouping++ ;
		    } else
		    { pimx = (struct V4DPI__Point_IntMix *)&ipt->Value ;
		      for(k=0;k<ipt->Grouping;k++)
		       { pim->Entry[grouping++] = pimx->Entry[k] ; } ;
		    } ;
		   continue ;
		 } ;
//		if (argcnt == 2 && argpnts[2]->Grouping == V4DPI_Grouping_Single) grouping = V4DPI_Grouping_Single ;	/* Don't have multiple points in this case */
//		respnt->Grouping = grouping ; respnt->Bytes = (char *)&pim->Entry[respnt->Grouping].BeginInt - (char *)respnt ;
		if (argcnt == 2 && argpnts[2]->Grouping == V4DPI_Grouping_Single)
		 { grouping = V4DPI_Grouping_Single ; respnt->Bytes = V4PS_Int ; }	/* Don't have multiple points in this case */
		 else { respnt->Grouping = grouping ; SETBYTESGRPINT(respnt) ; } ;
		goto finish_make ;
	   case V4DPI_PntType_XDict:
		if (grouping == V4DPI_Grouping_NE)
		 { respnt->Grouping = grouping ; respnt->Value.IntVal = ipt->Value.IntVal ; SETBYTESGRPINT(respnt) ;
		   goto finish_make ;
		 } ;
		if (grouping != 0)
		 { v_Msg(ctx,NULL,"MakePSpecial",intmodx,specPt,di->DimId,di->PointType) ; goto makep_fail ; } ;
		if (argcnt == 2) { *trycoerce = TRUE ; return(NULL) ; } ;
		pim = (struct V4DPI__Point_IntMix *)&respnt->Value ;
		grouping = 0 ;
		for(i=2;i<=argcnt;i++)
		 { ipt = argpnts[i] ;
		   if (ipt->Grouping == V4DPI_Grouping_Single)
		    { switch (ipt->PntType)
		       { default:
				v_Msg(ctx,NULL,"DTInfoConvert",intmodx,ipt,di->PointType) ; goto makep_fail ;
		         case V4DPI_PntType_CodedRange:
			 case V4DPI_PntType_Int:
				bp = "" ; k = ipt->Value.IntVal ; break ;
		         case V4DPI_PntType_Dict:
				ucbp = v4dpi_RevDictEntryGet(ctx,ipt->Value.IntVal) ;
				k = v4dpi_XDictEntryGet(ctx,ucbp,di,0) ;
				break ;
		         case V4DPI_PntType_XDict:
				ucbp = v4dpi_RevXDictEntryGet(ctx,ipt->Dim,ipt->Value.IntVal) ;
				k = v4dpi_XDictEntryGet(ctx,ucbp,di,0) ;
				break ;
		       } ;
		      if (k <= 0)
		       { v_Msg(ctx,NULL,"DPIInvPoint2",intmodx,ipt,di->DimId) ; goto makep_fail ; } ;
		      pim->Entry[grouping].BeginInt = k ; pim->Entry[grouping].EndInt = k ;
		      grouping++ ;
		    } else
		    { pimx = (struct V4DPI__Point_IntMix *)&ipt->Value ;
		      for(k=0;k<ipt->Grouping;k++)
		       { pim->Entry[grouping++] = pimx->Entry[k] ; } ;
		    } ;
		   continue ;
		 } ;
//		if (argcnt == 2 && argpnts[2]->Grouping == V4DPI_Grouping_Single) grouping = V4DPI_Grouping_Single ;	/* Don't have multiple points in this case */
//		respnt->Grouping = grouping ; respnt->Bytes = (char *)&pim->Entry[respnt->Grouping].BeginInt - (char *)respnt ;
		if (argcnt == 2 && argpnts[2]->Grouping == V4DPI_Grouping_Single)
		 { grouping = V4DPI_Grouping_Single ; respnt->Bytes = V4PS_Int ; }	/* Don't have multiple points in this case */
		 else { respnt->Grouping = grouping ; SETBYTESGRPINT(respnt) ; } ;
		goto finish_make ;
	   case V4DPI_PntType_Dict:
		v_Msg(ctx,NULL,"RptOptNYI") ; goto makep_fail ;		/* Should not ever get to this section! */
//		ipt = argpnts[2] ;
//		if (!(grouping == 0 || grouping == V4DPI_Grouping_NE)) { v_Msg(ctx,NULL,"DTInfoConvert3",intmodx,ipt,di->PointType,&tagpnt) ; goto makep_fail ; } ;
//		switch(ipt->PntType)
//		 {
//		   default:
//		     if (grouping != 0) { v_Msg(ctx,NULL,"DTInfoConvert3",intmodx,ipt,di->PointType,&tagpnt) ; goto makep_fail ; } ;
//		     *trycoerce = TRUE ; return(NULL) ;
//		   case V4DPI_PntType_CodedRange:
//		   case V4DPI_PntType_Int:
//		     k = ipt->Value.IntVal ; break ;
//		   case V4DPI_PntType_Dict:
//		     ucbp = v4dpi_RevDictEntryGet(ctx,ipt->Value.IntVal) ;
//		     k = v4dpi_DictEntryGet(ctx,0,ucbp,di,NULL) ;
//		     break ;
//		   case V4DPI_PntType_XDict:
//		     ucbp = v4dpi_RevXDictEntryGet(ctx,ipt->Dim,ipt->Value.IntVal) ;
//		     k = v4dpi_DictEntryGet(ctx,0,ucbp,di,NULL) ;
//		     break ;
//		 } ;
//		respnt->Value.IntVal = k ; respnt->Grouping = grouping ; respnt->Bytes = V4PS_Int ;
//		goto finish_make ;
//
//		pim = (struct V4DPI__Point_IntMix *)&respnt->Value ;
//		grouping = 0 ;
//		for(i=2;i<=argcnt;i++)
//		 { ipt = argpnts[i] ;
//		   if (ipt->Grouping == V4DPI_Grouping_Single)
//		    { switch (ipt->PntType)
//		       { default:
//				if (argcnt == 2) { *trycoerce = TRUE ; return(NULL) ; } ;
//				v_Msg(ctx,NULL,"DTInfoConvert",intmodx,ipt,di->PointType) ; goto makep_fail ;
//		         case V4DPI_PntType_CodedRange:
//			 case V4DPI_PntType_Int:
//				k = ipt->Value.IntVal ; break ;
//		         case V4DPI_PntType_Dict:
//				ucbp = v4dpi_RevDictEntryGet(ctx,ipt->Value.IntVal) ;
//				k = v4dpi_DictEntryGet(ctx,0,ucbp,di,NULL) ;
//				break ;
//		         case V4DPI_PntType_XDict:
//				ucbp = v4dpi_RevXDictEntryGet(ctx,ipt->Dim,ipt->Value.IntVal) ;
//				k = v4dpi_DictEntryGet(ctx,0,ucbp,di,NULL) ;
//				break ;
//		       } ;
//		      if (k <= 0) { v_Msg(ctx,NULL,"DPIInvPoint2",intmodx,ipt,di->DimId) ; goto makep_fail ; } ;
//		      pim->Entry[grouping].BeginInt = k ; pim->Entry[grouping].EndInt = k ;
//		      grouping++ ;
//		    } else
//		    { pimx = (struct V4DPI__Point_IntMix *)&ipt->Value ;
//		      for(k=0;k<ipt->Grouping;k++)
//		       { pim->Entry[grouping++] = pimx->Entry[k] ; } ;
//		    } ;
//		   continue ;
//		 } ;
////		if (argcnt == 2 && argpnts[2]->Grouping == V4DPI_Grouping_Single) grouping = V4DPI_Grouping_Single ;	/* Don't have multiple points in this case */
////		respnt->Grouping = grouping ; respnt->Bytes = (char *)&pim->Entry[respnt->Grouping].BeginInt - (char *)respnt ;
//		if (argcnt == 2 && argpnts[2]->Grouping == V4DPI_Grouping_Single)
//		 { grouping = V4DPI_Grouping_Single ; respnt->Bytes = V4PS_Int ; }	/* Don't have multiple points in this case */
//		 else { respnt->Grouping = grouping ; SETBYTESGRPINT(respnt) ; } ;
//		goto finish_make ;
	   CASEofINT
/*		See if got MakeP(Dim:UDT calendarpoint ...) - if so then go to special UDT code */
		if (argcnt == 2)
		 { if (ipt->Grouping == V4DPI_Grouping_Single)		/* A single point? */
		    { respnt->Bytes = V4PS_Int ;
		      switch (ipt->PntType)
		       { default:			{ double d = v4im_GetPointDbl(&ok,ipt,ctx) ; respnt->Value.IntVal = DtoI(d) ; }
							if (ok) break ;
							v_Msg(ctx,NULL,"ModFailed2",intmodx) ; goto makep_fail ;
		         case V4DPI_PntType_Dict:
			 case V4DPI_PntType_XDict:	respnt->Value.IntVal = ipt->Value.IntVal ; break ;
		       } ;
		    } else
		    { switch(ipt->PntType)
		       { default:
				v_Msg(ctx,NULL,"DTInfoConvert",intmodx,ipt,di->PointType) ; goto makep_fail ;
		         CASEofINT
				memcpy(respnt,ipt,ipt->Bytes) ;		/* Just blast over 2nd arg value */
				break ;
		       } ;
		    } ;
		   if (di->PointType == V4DPI_PntType_UYear)
		    { VCALADJYEAR(((di->ds.UYear.calFlags & VCAL_Flags_Historical) != 0),respnt->Value.IntVal) ;
		      if (respnt->Value.IntVal < VCAL_UYearMin || respnt->Value.IntVal > VCAL_UYearMax) { v_Msg(ctx,NULL,"MakePInvYear",intmodx,respnt->Value.IntVal,VCAL_UYearMin,VCAL_UYearMax) ; goto makep_fail ; } ;
		    } ;
		 } else
		 { pim = (struct V4DPI__Point_IntMix *)&respnt->Value ;
		   grouping = 0 ; ok = TRUE ;
		   for(i=2;i<=argcnt;i++)
		    { ipt = argpnts[i] ;
		      if (ipt->PntType != V4DPI_PntType_TagVal)
		       { pim->Entry[grouping].BeginInt = v4im_GetPointInt(&ok,argpnts[i],ctx) ;
		         if (!ok) break ;
			 pim->Entry[grouping].EndInt = pim->Entry[grouping].BeginInt ;
			 grouping++ ; continue ;
		       } ;
		      switch (v4im_CheckPtArgNew(ctx,argpnts[i],&cpt,&isctbuf))
		       { default:			v_Msg(ctx,NULL,"TagBadUse",intmodx) ; goto makep_fail ;
		         case V4IM_Tag_Unk:		v_Msg(ctx,NULL,"TagUnknown",intmodx) ; goto makep_fail ;
		         case V4IM_Tag_To:
			   if (grouping <= 0) { v_Msg(ctx,NULL,"TagBadUse",intmodx) ; goto makep_fail ; } ;
			   pim->Entry[grouping-1].EndInt = v4im_GetPointInt(&ok,cpt,ctx) ; break ;
			 case V4IM_Tag_Number:
			   if (grouping <= 0) { v_Msg(ctx,NULL,"TagBadUse",intmodx) ; goto makep_fail ; } ;
			   pim->Entry[grouping-1].EndInt = pim->Entry[grouping-1].BeginInt+v4im_GetPointInt(&ok,cpt,ctx)-1 ;
			   if (!ok) { v_Msg(ctx,NULL,"ModInvArg",intmodx,i) ; goto makep_fail ; } ;
			   break ;
		       } ; if (!ok) break ;
		    } ;
		   if (!ok) { v_Msg(ctx,NULL,"ModFailed2",intmodx) ; goto makep_fail ; } ;
		   if (di->PointType == V4DPI_PntType_UYear)
		    { int maxYear = (((di->ds.UYear.calFlags & VCAL_Flags_Historical) != 0) ? gpi->curYear : VCAL_UYearMax) ;
		      for(i=0;i<grouping;i++)
		       { VCALADJYEAR(((di->ds.UYear.calFlags & VCAL_Flags_Historical) != 0),pim->Entry[i].BeginInt) ; VCALADJYEAR(((di->ds.UYear.calFlags & VCAL_Flags_Historical) != 0),pim->Entry[i].EndInt) ;
		         if (pim->Entry[i].BeginInt < VCAL_UYearMin || pim->Entry[i].BeginInt > maxYear) { v_Msg(ctx,NULL,"MakePInvYear",intmodx,pim->Entry[i].BeginInt,VCAL_UYearMin,maxYear) ; goto makep_fail ; } ;
		         if (pim->Entry[i].EndInt < VCAL_UYearMin || pim->Entry[i].EndInt > maxYear) { v_Msg(ctx,NULL,"MakePInvYear",intmodx,pim->Entry[i].EndInt,VCAL_UYearMin,maxYear) ; goto makep_fail ; } ;
		       } ;
		    } ;
//		   respnt->Grouping = grouping ; respnt->Bytes = (char *)&pim->Entry[respnt->Grouping].BeginInt - (char *)respnt ;
		 } ;
//		if (argcnt == 2 && argpnts[2]->Grouping == V4DPI_Grouping_Single) grouping = V4DPI_Grouping_Single ;	/* Don't have multiple points in this case */
//		respnt->Grouping = grouping ; respnt->Bytes = (char *)&pim->Entry[respnt->Grouping].BeginInt - (char *)respnt ;
		if (argcnt == 2 && argpnts[2]->Grouping == V4DPI_Grouping_Single && grouping == 1)
		 { grouping = V4DPI_Grouping_Single ; respnt->Bytes = V4PS_Int ; }	/* Don't have multiple points in this case */
		 else { respnt->Grouping = grouping ; SETBYTESGRPINT(respnt) ; } ;
		goto finish_make ;
	   CASEofCharmU
		
		if (argcnt == 2)			/* Only one alpha value ? */
		 { v4im_GetPointChar(&ok,&respnt->Value.AlphaVal[1],(sizeof respnt->Value.AlphaVal)-2,argpnts[2],ctx) ;
		   if (!ok) { v_Msg(ctx,NULL,"ModFailed2",intmodx) ; goto makep_fail ; } ;
		   CHARPNTBYTES1(respnt)
		   goto finish_make ;
		 } ;
		if (argcnt > V4DPI_PointAlphaMix_Max) { v_Msg(ctx,NULL,"DPIMaxVals",intmodx,V4DPI_PointAlphaMix_Max) ; goto makep_fail ; } ;
		pam = (struct V4DPI__Point_AlphaMix *)&respnt->Value.AlphaVal ;
		respnt->Grouping = argcnt - 1 ;		/* Determine number of values in this point reference */
		bp = (char *)&pam->Entry[respnt->Grouping].BeginIndex ; num = V4DPI_AlphaVal_Max - (bp - (char *)&respnt->Value.AlphaVal) ;
		for(i=0,pix=0;i<respnt->Grouping;i++)
		 { v4im_GetPointChar(&ok,tb,250,argpnts[i+2],ctx) ;
		   if (!ok) { v_Msg(ctx,NULL,"ModFailed2",intmodx) ; goto makep_fail ; } ;
		   k = strlen(tb) ;
		   if (k + 4 > num) { v_Msg(ctx,NULL,"MakePMaxSize",intmodx,i+2) ; goto makep_fail ; } ;
		   strcpy(bp+1,tb) ; *bp = k ; bp += (k+1) ; num -= (k + 1) ;
		   pam->Entry[i].BeginIndex = pix ; pam->Entry[i].EndIndex = 0 ; pix += (k + 1) ;
		 } ;
		respnt->Bytes = ALIGN(bp - (char *)respnt) ;
		goto finish_make ;
	   case V4DPI_PntType_UCChar:
		if (argcnt == 2)			/* Only one alpha value ? */
		 { v4im_GetPointUC(&ok,&respnt->Value.UCVal[1],(sizeof respnt->Value.AlphaVal)-2,argpnts[2],ctx) ;
		   if (!ok) { v_Msg(ctx,NULL,"ModFailed2",intmodx) ; goto makep_fail ; } ;
		   UCCHARPNTBYTES1(respnt)
		   goto finish_make ;
		 } ;
		if (argcnt > V4DPI_PointAlphaMix_Max) { v_Msg(ctx,NULL,"DPIMaxVals",intmodx,V4DPI_PointAlphaMix_Max) ; goto makep_fail ; } ;
		pam = (struct V4DPI__Point_AlphaMix *)&respnt->Value.AlphaVal ;
		respnt->Grouping = argcnt - 1 ;		/* Determine number of values in this point reference */
		ucbp = (UCCHAR *)&pam->Entry[respnt->Grouping].BeginIndex ; num = V4DPI_AlphaVal_Max - ((char *)ucbp - (char *)&respnt->Value.AlphaVal) ;
		for(i=0,pix=0;i<respnt->Grouping;i++)
		 { v4im_GetPointUC(&ok,uctb,UCsizeof(uctb),argpnts[i+2],ctx) ;
		   if (!ok) { v_Msg(ctx,NULL,"ModFailed2",intmodx) ; goto makep_fail ; } ;
		   k = UCstrlen(uctb) ;
		   if (k + 4 > num) { v_Msg(ctx,NULL,"MakePMaxSize",intmodx,i+2) ; goto makep_fail ; } ;
		   UCstrcpy(ucbp+1,uctb) ; *ucbp = k ; ucbp += (k+1) ; num -= (k + 1) ;
		   pam->Entry[i].BeginIndex = pix ; pam->Entry[i].EndIndex = 0 ; pix += (k + 1) ;
		 } ;
		respnt->Bytes = ALIGN((char *)ucbp - (char *)respnt) ;
		goto finish_make ;
	   case V4DPI_PntType_Calendar:
	   case V4DPI_PntType_Int2:
		
		if (argcnt == 2)
		 { if (ipt->Grouping == V4DPI_Grouping_Single)		/* A single point? */
		    { respnt->Bytes = V4PS_Real ;
		      dnum = v4im_GetPointDbl(&ok,ipt,ctx) ; if (!ok) { v_Msg(ctx,NULL,"ModInvArg",intmodx,2) ; goto makep_fail ; } ;
		      PUTREAL(respnt,dnum) ;
		    } else
		    { switch(ipt->PntType)
		       { default:
				v_Msg(ctx,NULL,"DTInfoConvert",intmodx,ipt,di->PointType) ; goto makep_fail ;
		         CASEofINT
				memcpy(respnt,ipt,ipt->Bytes) ;		/* Just blast over 2nd arg value */
				break ;
		       } ;
		    } ;
		 } else
		 { prm = (struct V4DPI__Point_RealMix *)&respnt->Value ;
		   grouping = 0 ; ok = TRUE ;
		   for(i=2;i<=argcnt;i++)
		    { ipt = argpnts[i] ;
		      if (ipt->PntType != di->PointType) { v_Msg(ctx,NULL,"MakePSameType",intmodx,2,argpnts[i],argpnts[i]->PntType,di->PointType,di->DimId) ; goto makep_fail ; } ;
		      dnum = v4im_GetPointDbl(&ok,argpnts[i],ctx) ; if (!ok) break ;
		      SETDBL(prm->Entry[grouping].BeginReal,dnum) ; SETDBL(prm->Entry[grouping].EndReal,dnum) ;
		      grouping++ ;
		    } ;
		   if (!ok) { v_Msg(ctx,NULL,"ModFailed2",intmodx) ; goto makep_fail ; } ;
		   respnt->Grouping = grouping ;
//		   respnt->Bytes = (char *)&prm->Entry[respnt->Grouping].BeginReal - (char *)respnt ;
		   SETBYTESGRPDBL(respnt) ;
		 } ;
		goto finish_make ;
	   case V4DPI_PntType_Real:
		
		if (argcnt == 2)
		 { if (ipt->Grouping == V4DPI_Grouping_Single)		/* A single point? */
		    { respnt->Bytes = V4PS_Real ;
		      dnum = v4im_GetPointDbl(&ok,ipt,ctx) ; if (!ok) { v_Msg(ctx,NULL,"ModInvArg",intmodx,2) ; goto makep_fail ; } ;
		      PUTREAL(respnt,dnum) ;
		    } else
		    { switch(ipt->PntType)
		       { default:
				v_Msg(ctx,NULL,"DTInfoConvert",intmodx,ipt,di->PointType) ; goto makep_fail ;
		         CASEofINT
				memcpy(respnt,ipt,ipt->Bytes) ;		/* Just blast over 2nd arg value */
				break ;
		       } ;
		    } ;
		 } else
		 { prm = (struct V4DPI__Point_RealMix *)&respnt->Value ;
		   grouping = 0 ; ok = TRUE ;
		   for(i=2;i<=argcnt;i++)
		    { ipt = argpnts[i] ;
		      if (ipt->PntType != V4DPI_PntType_TagVal)
		       { dnum = v4im_GetPointDbl(&ok,argpnts[i],ctx) ; SETDBL(prm->Entry[grouping].BeginReal,dnum) ;
			 if (!ok) break ;
			 SETDBL(prm->Entry[grouping].EndReal,dnum) ;
			 grouping++ ; continue ;
		       } ;
		      switch (v4im_CheckPtArgNew(ctx,argpnts[i],&cpt,&isctbuf))
		       { default:			v_Msg(ctx,NULL,"TagBadUse",intmodx) ; goto makep_fail ;
		         case V4IM_Tag_Unk:		v_Msg(ctx,NULL,"TagUnknown",intmodx) ; goto makep_fail ;
		         case V4IM_Tag_To:
			   dnum = v4im_GetPointDbl(&ok,cpt,ctx) ; if (!ok) { v_Msg(ctx,NULL,"ModInvArg",intmodx,i) ; goto makep_fail ; } ;
			   memcpy(&prm->Entry[grouping-1].EndReal,&dnum,sizeof dnum) ; break ;
			 case V4IM_Tag_Number:
			   SETDBL(dnum,prm->Entry[grouping-1].BeginReal) ;
			   dnum += v4im_GetPointDbl(&ok,cpt,ctx)-1 ; if (!ok) { v_Msg(ctx,NULL,"ModInvArg",intmodx,i) ; goto makep_fail ; } ;
			   SETDBL(prm->Entry[grouping-1].EndReal,dnum) ;
			   break ;
		       } ; if (!ok) break ;
		    } ;
		   if (!ok) { v_Msg(ctx,NULL,"ModFailed2",intmodx) ; goto makep_fail ; } ;
		   respnt->Grouping = grouping ;
//		   respnt->Bytes = (char *)&prm->Entry[respnt->Grouping].BeginReal - (char *)respnt ;
		   SETBYTESGRPDBL(respnt) ;
		 } ;
		goto finish_make ;
	 } ;	 
finish_make:
	if (grouping != 0) respnt->Grouping = grouping ;				/* Maybe set the grouping */
	respnt->Dim = di->DimId ; respnt->PntType = di->PointType ;
finish_make1:
	ipt = respnt ;
finish_make2:
	return(ipt) ;
/*	Here to convert alpha string to point */
	tcb = NULL ; INITTCB ;
	if (argpnts[1]->Grouping <= 1)
	 { v4im_GetPointUC(&ok,UCTBUF1,V4TMBufMax,ipt,ctx) ;
	   if (!ok) { v_Msg(ctx,NULL,"ModFailed2",intmodx) ; goto makep_fail ; } ;
	   v4lex_NestInput(tcb,NULL,UCTBUF1,V4LEX_InpMode_String) ;
	   if (v4dpi_PointAccept(respnt,di,tcb,ctx,V4DPI_PointParse_RetFalse))
	    { ipt = respnt ; ipt->Dim = di->DimId ; }
	    else { v4lex_FreeTCB(tcb) ; v_Msg(ctx,NULL,"DTInfoConvert2",intmodx,ipt,di->PointType) ; goto makep_fail ; } ;
	 } else
	 { pim = (struct V4DPI__Point_IntMix *)&argpnts[1]->Value ;
	   for(i=0;i<argpnts[1]->Grouping;i++)
	    { DIMINFO(di,ctx,pim->Entry[i].BeginInt) ;
	      if (di->PointType == V4DPI_PntType_Char)		/* If alpha then just copy it over */
	       { memcpy(respnt,ipt,ipt->Bytes) ; ipt = respnt ; break ; } ;
	      v4im_GetPointUC(&ok,UCTBUF1,V4TMBufMax,ipt,ctx) ; v4lex_NestInput(tcb,NULL,UCTBUF1,V4LEX_InpMode_String) ;
	      if (!ok) { v4lex_FreeTCB(tcb) ; v_Msg(ctx,NULL,"ModFailed2",intmodx) ; goto makep_fail ; } ;
	      if (v4dpi_PointAccept(respnt,di,tcb,ctx,V4DPI_PointParse_RetFalse))
	       { ipt = respnt ; ipt->Dim = di->DimId ; break ; } ;
	    } ; if (i >= argpnts[1]->Grouping) ipt = NULL ; 
	 }
	v4lex_FreeTCB(tcb) ;
	return(ipt) ;
makep_fail:
	*trycoerce = FALSE ; REGISTER_ERROR(0) ; return(NULL) ;
}



/*	v4im_MakePTeleAccept - Accepts alternate "telephone" (connection) number	*/
/*	Call: ok = v4im_MakePTeleAccept( ctx , respnt , strval , ptval1 , ptval2 )
	  where ok is TRUE if ok, FALSE if error (in ctx->ErrorMsgAux),
		ctx is context,
		di is DimInfo for target point,
		respnt is updated result point,
		strval is string containing value to be accepted (ptval1/2 NULL),
		ptval1 is point value to be accepted (or NULL if strval used),
		ptval2 is optional second point value to be accepted			*/

LOGICAL v4im_MakePTeleAccept(ctx,di,respnt,strval,ptval1,ptval2)
  struct V4C__Context *ctx ;
  struct V4DPI__DimInfo *di ;
  P *respnt ;
  UCCHAR *strval ;
  P *ptval1,*ptval2 ;
{
  struct V4DPI__LittlePoint lpt ;
  struct V4DPI__Point tpnt,isctbuf,*ipt ;
  struct V4L__ListPoint *lp ;
  enum DictionaryEntries deval ;
  int len,ok ;

	dictPNTv(&lpt,Dim_UV4,v4im_GetEnumToDictVal(ctx,deval=_AcceptorTele,UNUSED)) ;
	if (lpt.Value.IntVal <= 0) { v_Msg(ctx,ctx->ErrorMsgAux,"TeleAcptFail3",di->DimId) ; return(FALSE) ; } ;
	INITISCT(&isctbuf) ; NOISCTVCD(&isctbuf) ; ipt = ISCT1STPNT(&isctbuf) ; memcpy(ipt,&lpt,lpt.Bytes) ; ADVPNT(ipt) ;
	if (strval != NULL)				/* Do we have string or points ? */
	 { 
	   len = UCstrlen(strval) ;
	   if (len >= V4DPI_UCVal_Max-100) { v_Msg(ctx,ctx->ErrorMsgAux,"TeleStrTooBig",strval,len,V4DPI_AlphaVal_Max-100) ; return(FALSE) ; } ;
	   uccharPNTv(ipt,strval) ;
	   ADVPNT(ipt) ; isctbuf.Grouping = 2 ;
	 } else
	 { memcpy(ipt,ptval1,ptval1->Bytes) ; ADVPNT(ipt) ; isctbuf.Grouping = 2 ;
	   if (ptval2 != NULL)
	    { memcpy(ipt,ptval2,ptval2->Bytes) ;  ADVPNT(ipt) ; isctbuf.Grouping = 3 ; } ;
	 } ;
	ISCTLEN(&isctbuf,ipt) ;
	ipt = v4dpi_IsctEval(&tpnt,&isctbuf,ctx,V4DPI_EM_EvalQuote,NULL,NULL) ;
	if (ipt == NULL) { v_Msg(ctx,ctx->ErrorMsgAux,"TeleAcptFail",di->DimId,&isctbuf) ; return(FALSE) ; } ;
	if (ipt->PntType == V4DPI_PntType_List)
	 { lp = v4im_VerifyList(NULL,ctx,ipt,0) ;
	   v4l_ListPoint_Value(ctx,lp,1,&isctbuf) ;
	   respnt->Value.Tele.AreaCode = v4im_GetPointInt(&ok,&isctbuf,ctx) ;
	   if (!ok) { v_Msg(ctx,ctx->ErrorMsgAux,"TeleAcptFail2",ipt,di->DimId) ; return(FALSE) ; } ;
	   v4l_ListPoint_Value(ctx,lp,2,&isctbuf) ;
	   respnt->Value.Tele.Number = v4im_GetPointInt(&ok,&isctbuf,ctx) ;
	   if (!ok) { v_Msg(ctx,ctx->ErrorMsgAux,"TeleAcptFail2",ipt,di->DimId) ; return(FALSE) ; } ;
	 } else
	 { if (ipt->PntType == V4DPI_PntType_Int2)
	    { respnt->Value.Tele.AreaCode = ipt->Value.Int2Val[0] ; respnt->Value.Tele.Number = ipt->Value.Int2Val[1] ;
	    } else
	    { respnt->Value.Tele.AreaCode = 0 ; respnt->Value.Tele.Number = v4im_GetPointInt(&ok,ipt,ctx) ;
	      if (!ok) { v_Msg(ctx,ctx->ErrorMsgAux,"TeleAcptFail2",ipt,di->DimId) ; return(FALSE) ; } ;
	    } ;
	 } ;
	respnt->Value.Tele.IntDialCode = V4DPI__Tele_IDCSpecial ;
	respnt->Dim = di->DimId ; respnt->PntType = di->PointType ; respnt->Bytes = V4PS_Int2 ;
	return(TRUE) ;
}


/*	v4im_DoCoerce - Handles old Coerce() function (now called by Project()) */

int v4im_DoCoerce(ctx,respnt,di,dipt,srcpt)
  struct V4C__Context *ctx ;
  struct V4DPI__DimInfo *di ;
  P *respnt,*dipt,*srcpt ;
{ P *cpt,*spt ; P isctbuf ;
  struct V4L__ListPoint *lp ;
  struct V4L__ListBitMap *vlbm ;
  struct V4DPI__Point_IntMix *pim,*pim1 ;
  struct V4DPI__Point_AlphaMix *pam ;
  struct V4DPI__Point_RealMix *prm ;
  struct V4LEX__TknCtrlBlk *tcb ;
  regex_t *repattern ;
  int i,j,k,ok,d,y,m,pix,ppy ; double dnum,dnum1,dnum2 ; B64INT b64 ; char *bp ; UCCHAR *ucbp,*ucbp1 ; UCCHAR ucbuf[512] ;

	if (di->PointType == srcpt->PntType)		/* Same point type ? (veh070130) */
	 { switch(di->PointType)
	    { default:	   memcpy(respnt,srcpt,srcpt->Bytes) ; respnt->Dim = di->DimId ; break ;
	      case V4DPI_PntType_List:
		if (di->ListDimId != 0)	/* Converting list to SegBitMap - src best be bitmap */
		 { lp = v4im_VerifyList(&isctbuf,ctx,srcpt,V4IM_OpCode_Project) ;
		   if (lp->ListType != V4L_ListType_BitMap)
		    { v_Msg(ctx,NULL,"ProjectSBM",V4IM_OpCode_Project,srcpt->Dim,di->DimId,srcpt) ; return(FALSE) ; } ;
		   respnt->Bytes = V4PS_Int ; respnt->PntType = V4DPI_PntType_SegBitMap ;
		   vlbm = (struct V4L__ListBitMap *)&lp->Buffer ;
		   respnt->Value.IntVal = v4seg_PutSegments(ctx,vlbm->bm1,BM1_StructBytes(vlbm->bm1->MaxBit),TRUE,TRUE) ;
		   break ;
		 } ;
		memcpy(respnt,srcpt,srcpt->Bytes) ; respnt->Dim = di->DimId ; respnt->PntType = di->PointType ;
		break ;
	      case V4DPI_PntType_XDict:
		ZPH(respnt) ; respnt->Dim = di->DimId ; respnt->PntType = di->PointType ; respnt->Bytes = V4PS_XDict ;
		respnt->Value.IntVal = v4dpi_XDictEntryGet(ctx,v4dpi_RevXDictEntryGet(ctx,srcpt->Dim,srcpt->Value.IntVal),di,0) ;
		if (respnt->Value.IntVal == 0) { v_Msg(ctx,NULL,"ProjectUndefX",V4IM_OpCode_Project,di->DimId,srcpt) ; return(FALSE) ; } ;
		break ;
	      case V4DPI_PntType_Dict:
		memcpy(respnt,srcpt,srcpt->Bytes) ; respnt->Dim = di->DimId ;
		if (srcpt->Dim == Dim_Dim)		/* If source point is Dim dimension then have to do some work */
		 { struct V4DPI__DimInfo *di1 = (struct V4DPI__DimInfo *)v4dpi_DimInfoGet(ctx,srcpt->Value.IntVal) ;
		   respnt->Value.IntVal = v4dpi_DictEntryGet(ctx,0,di1->DimName,di,NULL) ;
		 } ;
		break ;
	    } ;
	   return(TRUE) ;
	 } ;
	ZPH(respnt) ; respnt->Dim = di->DimId ; respnt->PntType = di->PointType ;
	switch (di->PointType)				/* Maybe do some conversions based on dest Dim & src point */
	 { default:
		v_Msg(ctx,NULL,"ModNoDefined",V4IM_OpCode_Project,di->DimId,di->PointType) ; return(FALSE) ;
	   case V4DPI_PntType_UCChar:
		switch (srcpt->PntType)
		 { default:
			v4dpi_PointToStringML(&respnt->Value.UCVal[1],srcpt,ctx,V4DPI_FormatOpt_Echo,V4DPI_UCVAL_MaxSafe ) ;
			UCCHARPNTBYTES1(respnt) ; respnt->PntType = V4DPI_PntType_UCChar ;
			break ;
		   case V4DPI_PntType_BigText:		/* VEH110314 - Don't bother to convert BigText/Alpha/UCChar - they are all the same at this point */
		   CASEofCharmU
		   case V4DPI_PntType_UCChar:
			memcpy(respnt,srcpt,srcpt->Bytes) ; respnt->Dim = di->DimId ; break ;

//		   CASEofCharmU
//			j = CHARSTRLEN(srcpt) ;
//			if (j >= V4DPI_UCVal_Max - 2)
//			 { for(i=1;i<=j;i++) { UCTBUF1[i-1] = srcpt->Value.AlphaVal[i] ; } ; UCTBUF1[j] = UCEOS ;
//			   if (!v4dpi_SaveBigTextPoint2(ctx,UCTBUF1,respnt,di->DimId,FALSE)) return(FALSE) ;
//			   break ;
//			 } ;
//			for(i=1;i<=j;i++) { respnt->Value.UCVal[i] = srcpt->Value.AlphaVal[i] ; } ;
//			srcpt->Value.UCVal[i] = UCEOS ; break ;
		 } ;
		return(TRUE) ;
	   CASEofCharmU
		switch (srcpt->PntType)
		 { default:
			v4dpi_PointToStringML(&respnt->Value.UCVal[1],srcpt,ctx,V4DPI_FormatOpt_Echo,V4DPI_UCVAL_MaxSafe ) ;
			UCCHARPNTBYTES1(respnt) ; respnt->PntType = V4DPI_PntType_UCChar ;
			break ;
		   case V4DPI_PntType_BigText:		/* VEH110314 - Don't bother to convert BigText/Alpha/UCChar - they are all the same at this point */
		   CASEofCharmU
		   case V4DPI_PntType_UCChar:
			memcpy(respnt,srcpt,srcpt->Bytes) ; respnt->Dim = di->DimId ; break ;

//		   CASEofCharmU
//			memcpy(respnt,srcpt,srcpt->Bytes) ; respnt->Dim = di->DimId ; break ;
//		   case V4DPI_PntType_UCChar:
//			UCUTF16toUTF8(&respnt->Value.AlphaVal[1],V4DPI_AlphaVal_Max-2,&srcpt->Value.UCVal[1],UCCHARSTRLEN(srcpt)) ;
//			CHARPNTBYTES1(respnt) ; break ;
		 } ;
		return(TRUE) ;
	   case V4DPI_PntType_BigText:
		v4im_GetPointUC(&ok,UCTBUF1,V4TMBufMax,srcpt,ctx) ; if (!ok) goto not_ok ;
//VEH170120 - set localOK to TRUE - why not?
		if (!v4dpi_SaveBigTextPoint2(ctx,UCTBUF1,respnt,di->DimId,TRUE)) { v_Msg(ctx,NULL,"ModFailed2",V4IM_OpCode_Project) ; return(FALSE) ; } ;
		return(TRUE) ;
	   case V4DPI_PntType_AggRef:
		respnt->Value.IntVal = srcpt->Value.IntVal ; respnt->Grouping = srcpt->Grouping ;
		respnt->Bytes = V4PS_Int ;
		return(TRUE) ;
	   case V4DPI_PntType_Shell:		/* Dest is Shell - create shell point */
		memcpy(&respnt->Value,srcpt,srcpt->Bytes) ; respnt->Bytes = V4DPI_PointHdr_Bytes + srcpt->Bytes ;
		return(TRUE) ;
	   case V4DPI_PntType_Logical:
		respnt->Value.IntVal = v4im_GetPointLog(&i,srcpt,ctx) ;
		if (!i) { v_Msg(ctx,NULL,"ModFailed2",V4IM_OpCode_Project) ; return(FALSE) ; } ;
		respnt->Bytes = V4PS_Int ; return(TRUE) ;
	   case V4DPI_PntType_RegExpPattern:
		v4dpi_PointToString(UCTBUF2,srcpt,ctx,V4DPI_FormatOpt_Echo) ;
		UCstrcpyToASC(ASCTBUF1,UCTBUF2) ;
		strcpy(&respnt->Value.AlphaVal[1],ASCTBUF1) ; k = strlen(ASCTBUF1) ;
		CHARPNTBYTES2(respnt,k)
		repattern = (regex_t *)&respnt->Value.AlphaVal[respnt->Bytes-V4DPI_PointHdr_Bytes] ;
		if (i=vregexp_RegComp(repattern,ASCTBUF1,REG_EXTENDED))
		 { vregexp_Error(i,repattern,ctx->ErrorMsgAux,255) ; v_Msg(ctx,NULL,"ModFailed2",V4IM_OpCode_Project) ; return(FALSE) ;
		 } ;
		respnt->Bytes += sizeof *repattern ;
		return(TRUE) ;		
	   case V4DPI_PntType_Time:
		respnt->Value.IntVal = v4im_GetPointInt(&ok,srcpt,ctx) ; if (!ok) goto not_ok ;
		respnt->Bytes = V4PS_Int ; return(TRUE) ;
	   case V4DPI_PntType_TeleNum:
		switch(srcpt->PntType)
		 { default:
		    v_Msg(ctx,NULL,"ProjectDTErr",V4IM_OpCode_Project,srcpt,V4DPI_PntType_TeleNum) ; return(FALSE) ;
		   CASEofChar
		    goto CoerceFromChar1 ;
		 } ;
		break ;
	   case V4DPI_PntType_UTime:
		switch(srcpt->PntType)
		 { default:
		    v_Msg(ctx,NULL,"ProjectDTErr",V4IM_OpCode_Project,srcpt,V4DPI_PntType_UTime) ; return(FALSE) ;
		   CASEofChar
		    goto CoerceFromChar1 ;
		   case V4DPI_PntType_UDT:
		    dnum = srcpt->Value.IntVal % VCAL_SecsInDay ; break ;
		   case V4DPI_PntType_Calendar:
		    GETREAL(dnum,srcpt) ; i = vcal_CalToUDT(dnum,VCAL_TimeZone_Local,&ok) ;
 /*		    If we got valid UDT then pull time from it, otherwise take fraction part of calendar value */
		    if (i >= 0)
		     { if (!ok) { v_Msg(ctx,NULL,"ProjectCalNoTim",V4IM_OpCode_Project,V4DPI_PntType_Calendar) ; return(FALSE) ; } ;
		       dnum = i % VCAL_SecsInDay ;
		     } else
		     { double frac,ipart ;
		       frac = modf(dnum,&ipart) ;dnum = frac * (24 * 60 * 60) ;
		     } ;

		    break ;
		   case V4DPI_PntType_Real:
		    dnum = v4im_GetPointDbl(&ok,srcpt,ctx) ; break ;
		   case V4DPI_PntType_Int:
		    dnum = srcpt->Value.IntVal ; break ;
		 } ;
		PUTREAL(respnt,dnum) ; respnt->Bytes = V4PS_UTime ; return(TRUE) ; 
	   case V4DPI_PntType_Calendar:
		switch(srcpt->PntType)
		 { default:
		    v_Msg(ctx,NULL,"ProjectDTErr",V4IM_OpCode_Project,srcpt,V4DPI_PntType_Calendar) ; return(FALSE) ;
		   CASEofChar
		    goto CoerceFromChar1 ;
		   case V4DPI_PntType_UWeek:
		    { struct V4DPI__DimInfo *di1 ; DIMINFO(di1,ctx,srcpt->Dim) ;
		      dnum = VCal_MJDOffset + mscu_uweek_to_udate(srcpt->Value.IntVal,di->ds.UWeek.baseUDate) ;
		    } ; break ;
		   case V4DPI_PntType_CodedRange:
		   case V4DPI_PntType_Int:
		    if (srcpt->Value.IntVal > 18000101)		/* Got yyyymmdd ? */
		     { d = srcpt->Value.IntVal%100 ; y = srcpt->Value.IntVal / 10000 ; m = (srcpt->Value.IntVal / 100) % 100 ;
		       dnum = VCal_MJDOffset + mscu_ymd_to_ud(y,m,d) ;
		     } else { dnum = (srcpt->Value.IntVal == 0 ? VCal_NullDate : srcpt->Value.IntVal) ; } ;
		    break ;
		   case V4DPI_PntType_UDate:
		    dnum = (srcpt->Value.IntVal == VCAL_UDate_None ? VCal_NullDate : VCal_MJDOffset + srcpt->Value.IntVal) ; break ;
		   case V4DPI_PntType_UMonth:
		    if (srcpt->Value.IntVal == VCAL_UMonth_None) { dnum = VCal_NullDate ; break ; } ;
		    prm = (struct V4DPI__Point_RealMix *)&respnt->Value ;
		    y = (srcpt->Value.IntVal / 12) + VCAL_BaseYear ; m = (srcpt->Value.IntVal%12)+1 ;
		    dnum1 = VCal_MJDOffset + mscu_ymd_to_ud(y,m,1) ;
		    m ++ ; if (m > 12) { m = 1 ; y++ ; } ;
		    dnum2 = VCal_MJDOffset + mscu_ymd_to_ud(y,m,1) - 1 ;
		    memcpy(&prm->Entry[0].BeginReal,&dnum1,sizeof dnum1) ;
		    memcpy(&prm->Entry[0].EndReal,&dnum2,sizeof dnum1) ;
		    respnt->Grouping = 1 ;
//		    respnt->Bytes = (char *)&prm->Entry[2].BeginReal - (char *)respnt ;
		    SETBYTESGRPDBL(respnt) ;
		    srcpt = respnt ; return(TRUE) ;
		   case V4DPI_PntType_UYear:
		    if (srcpt->Value.IntVal == VCAL_UYear_None) { dnum = VCal_NullDate ; break ; } ;
		    prm = (struct V4DPI__Point_RealMix *)&respnt->Value ;
		    dnum1 = VCal_MJDOffset + mscu_ymd_to_ud(srcpt->Value.IntVal,1,1) ;
		    dnum2 = VCal_MJDOffset + mscu_ymd_to_ud(srcpt->Value.IntVal+1,1,1)-1 ;
		    memcpy(&prm->Entry[0].BeginReal,&dnum1,sizeof dnum1) ;
		    memcpy(&prm->Entry[0].EndReal,&dnum2,sizeof dnum1) ;
		    respnt->Grouping = 1 ;
//		    respnt->Bytes = (char *)&prm->Entry[2].BeginReal - (char *)respnt ;
		    SETBYTESGRPDBL(respnt) ;
		    srcpt = respnt ; return(TRUE) ;
		   case V4DPI_PntType_UDT:
		    dnum = UDTtoCAL(srcpt->Value.IntVal) ;
//		    dnum = (double)((srcpt->Value.IntVal / VCAL_SecsInDay) + VCAL_UDTUDateOffset + VCal_MJDOffset)
//			    + (double)(srcpt->Value.IntVal % VCAL_SecsInDay) / ((double)VCAL_SecsInDay) + gpi->MinutesWest / (24.0 * 60.0) ;
		 } ;
		PUTREAL(respnt,dnum) ;
		respnt->Bytes = V4PS_Calendar ; return(TRUE) ; 
	   case V4DPI_PntType_UDT:
		if (srcpt->Grouping != V4DPI_Grouping_Single)	/* Can convert single range of these points to UDT */
		 { switch(srcpt->Grouping != 1 ? -1 : srcpt->PntType)
		    { default:				v_Msg(ctx,NULL,"ProjectMP",V4IM_OpCode_Project,srcpt,di->DimId) ; return(FALSE) ;
		      case V4DPI_PntType_Int:
		      case V4DPI_PntType_UDate:
		      case V4DPI_PntType_UMonth:
		      case V4DPI_PntType_UYear:		break ;
		    } ;
		 } ;
		switch(srcpt->PntType)
		 { default:
		    v_Msg(ctx,NULL,"ProjectDTErr",V4IM_OpCode_Project,srcpt,V4DPI_PntType_UDT) ; return(FALSE) ;
		   CASEofChar
		    goto CoerceFromChar1 ;
		   case V4DPI_PntType_Int:
		    respnt->Value.IntVal = srcpt->Value.IntVal ; break ;
		   case V4DPI_PntType_UDate:
		    pim = (struct V4DPI__Point_IntMix *)&respnt->Value ;
		    if (srcpt->Grouping == V4DPI_Grouping_Single)
		     { if (srcpt->Value.IntVal == 0) { respnt->Value.IntVal = 0 ; break ; } ;
		       pim->Entry[0].BeginInt = UDtoUDT(srcpt->Value.IntVal) ;
		       pim->Entry[0].EndInt = pim->Entry[0].BeginInt + VCAL_SecsInDay - 1 ;
		     } else
		     { pim1 = (struct V4DPI__Point_IntMix *)&srcpt->Value ;
		       if (pim1->Entry[0].BeginInt == 0) { pim->Entry[0].BeginInt = 0 ; }
		        else { pim->Entry[0].BeginInt = UDtoUDT(pim1->Entry[0].BeginInt) ; } ;
		       pim->Entry[0].EndInt = UDtoUDT(pim1->Entry[0].EndInt) + VCAL_SecsInDay - 1 ;
		     } ;
		    respnt->Grouping = 1 ;
		    SETBYTESGRPINT(respnt) ;
//		    respnt->Bytes = (char *)&pim->Entry[1].BeginInt - (char *)respnt ;
		    return(TRUE) ;
		   case V4DPI_PntType_UMonth:
		    pim = (struct V4DPI__Point_IntMix *)&respnt->Value ;
		    if (srcpt->Grouping == V4DPI_Grouping_Single)
		     { if (srcpt->Value.IntVal == 0) { respnt->Value.IntVal = 0 ; break ; } ;
		       y = (srcpt->Value.IntVal / 12) + VCAL_BaseYear ; m = (srcpt->Value.IntVal%12)+1 ;
		       pim->Entry[0].BeginInt = UDtoUDT(mscu_ymd_to_ud(y,m,1)) ;
		       if (m == 12) { m = 1 ; y++ ; } else { m++ ; } ;
		       pim->Entry[0].EndInt = UDtoUDT(mscu_ymd_to_ud(y,m,1)) - 1 ;
		     } else
		     { pim1 = (struct V4DPI__Point_IntMix *)&srcpt->Value ;
		       if (pim1->Entry[0].BeginInt == 0) { pim->Entry[0].BeginInt = 0 ; }
		        else { y = (pim1->Entry[0].BeginInt / 12) + VCAL_BaseYear ; m = (pim1->Entry[0].BeginInt % 12) + 1 ;
			       pim->Entry[0].BeginInt = UDtoUDT(mscu_ymd_to_ud(y,m,1)) ;
			     } ;
		       y = (pim1->Entry[0].EndInt / 12) + VCAL_BaseYear ; m = (pim1->Entry[0].EndInt % 12) + 1 ;
		       if (m == 12) { m = 1 ; y++ ; } else { m++ ; } ;
		       pim->Entry[0].EndInt = UDtoUDT(mscu_ymd_to_ud(y,m,1)) - 1 ;
		     } ;
		    respnt->Grouping = 1 ;
//		    respnt->Bytes = (char *)&pim->Entry[1].BeginInt - (char *)respnt ;
		    SETBYTESGRPINT(respnt) ;
		    return(TRUE) ;
		   case V4DPI_PntType_UYear:
		    pim = (struct V4DPI__Point_IntMix *)&respnt->Value ;
		    if (srcpt->Grouping == V4DPI_Grouping_Single)
		     { if (srcpt->Value.IntVal == 0) { respnt->Value.IntVal = 0 ; break ; } ;
		       pim = (struct V4DPI__Point_IntMix *)&respnt->Value ;
		       pim->Entry[0].BeginInt = UDtoUDT(mscu_ymd_to_ud(srcpt->Value.IntVal,1,1)) ;
		       pim->Entry[0].EndInt = UDtoUDT(mscu_ymd_to_ud(srcpt->Value.IntVal,12,31)) + VCAL_SecsInDay - 1 ;
		     } else
		     { pim1 = (struct V4DPI__Point_IntMix *)&srcpt->Value ;
		       if (pim1->Entry[0].BeginInt == 0) { pim->Entry[0].BeginInt = 0 ; }
			else { pim->Entry[0].BeginInt = UDtoUDT(mscu_ymd_to_ud(pim1->Entry[0].BeginInt,1,1)) ; } ;
		       pim->Entry[0].EndInt = UDtoUDT(mscu_ymd_to_ud(pim1->Entry[0].EndInt,12,31)) + VCAL_SecsInDay - 1 ;
		     } ;
		    respnt->Grouping = 1 ;
//		    respnt->Bytes = (char *)&pim->Entry[1].BeginInt - (char *)respnt ;
		    SETBYTESGRPINT(respnt) ;
		    return(TRUE) ;
		   case V4DPI_PntType_Calendar:
		    GETREAL(dnum,srcpt) ; respnt->Value.IntVal = vcal_CalToUDT(dnum,VCAL_TimeZone_Local,&i) ;
		    if (respnt->Value.IntVal < 0) { v_Msg(ctx,NULL,"DTInfoConvert",V4IM_OpCode_Project,srcpt,V4DPI_PntType_UDT) ; return(FALSE) ; } ;
		    break ;
		 } ;
		respnt->Bytes = V4PS_Int ; return(TRUE) ; 
	   case V4DPI_PntType_UDate:
		switch(srcpt->PntType)
		 { default:
		    v_Msg(ctx,NULL,"ProjectDTErr",V4IM_OpCode_Project,srcpt,V4DPI_PntType_UDate) ; return(FALSE) ;
//		   case V4DPI_PntType_BigText:
		   CASEofChar
		    goto CoerceFromChar1 ;
		   case V4DPI_PntType_UWeek:
		    { struct V4DPI__DimInfo *di1 ; DIMINFO(di1,ctx,srcpt->Dim) ;
		      respnt->Value.IntVal = mscu_uweek_to_udate(srcpt->Value.IntVal,di1->ds.UWeek.baseUDate) ;
		    } ; break ;
		   case V4DPI_PntType_CodedRange:
		   case V4DPI_PntType_Int:
		    if (srcpt->Value.IntVal > 18000101)		/* Got yyyymmdd ? */
		     { d = srcpt->Value.IntVal%100 ; y = srcpt->Value.IntVal / 10000 ; m = (srcpt->Value.IntVal / 100) % 100 ;
		       respnt->Value.IntVal = vcal_UDateFromYMD(FALSE,y,m,d,ctx->ErrorMsgAux) ;
		       if (respnt->Value.IntVal == VCAL_BadVal) { v_Msg(ctx,NULL,"ProjectNoUD",V4IM_OpCode_Project) ; return(FALSE) ; } ;
		     } else { respnt->Value.IntVal = srcpt->Value.IntVal ; } ;
		    break ;
		   case V4DPI_PntType_Calendar:
		    GETREAL(dnum,respnt) ; respnt->Value.IntVal = vcal_CalToUDate(dnum,VCAL_TimeZone_Local,&ok) ; break ;
		   case V4DPI_PntType_UMonth:
		    if (srcpt->Value.IntVal == 0) { respnt->Value.IntVal = 0 ; break ; } ;
		    pim = (struct V4DPI__Point_IntMix *)&respnt->Value ;
		    y = (srcpt->Value.IntVal / 12) + VCAL_BaseYear ; m = (srcpt->Value.IntVal%12)+1 ;
		    pim->Entry[0].BeginInt = mscu_ymd_to_ud(y,m,1) ;
		    m ++ ; if (m > 12) { m = 1 ; y++ ; } ;
		    pim->Entry[0].EndInt = mscu_ymd_to_ud(y,m,1) - 1 ;
		    respnt->Grouping = 1 ;
//		    respnt->Bytes = (char *)&pim->Entry[1].BeginInt - (char *)respnt ;
		    SETBYTESGRPINT(respnt) ;
		    return(TRUE) ;
		   case V4DPI_PntType_UQuarter:
		    if (srcpt->Value.IntVal == 0) { srcpt = respnt ; srcpt->Bytes = V4PS_Int ; srcpt->Value.IntVal = 0 ; return(TRUE) ; } ;
		    pim = (struct V4DPI__Point_IntMix *)&respnt->Value ;
//		    pim->Entry[0].BeginInt = mscu_ymd_to_ud(VCAL_BaseYear+(srcpt->Value.IntVal/4),((srcpt->Value.IntVal % 4) * 3) + 1,1) ;
//		    pim->Entry[0].EndInt = mscu_ymd_to_ud(VCAL_BaseYear+(srcpt->Value.IntVal/4),((srcpt->Value.IntVal % 4) * 3) + 4,1) - 1 ;		/* Get next begin of next month - 1 for last day! */
		    pim->Entry[0].BeginInt = mscu_ymd_to_ud(UQTRtoUYEAR(srcpt->Value.IntVal),((UQTRtoQTR(srcpt->Value.IntVal) - 1) * 3) + 1,1) ;
		    pim->Entry[0].EndInt = mscu_ymd_to_ud(UQTRtoUYEAR(srcpt->Value.IntVal),((UQTRtoQTR(srcpt->Value.IntVal) - 1) * 3) + 4,1) - 1 ;	/* Get next begin of next month - 1 for last day! */
		    respnt->Grouping = 1 ;
//		    respnt->Bytes = (char *)&pim->Entry[1].BeginInt - (char *)respnt ;
		    SETBYTESGRPINT(respnt) ;
		    return(TRUE) ;
		   case V4DPI_PntType_UYear:
		    if (srcpt->Value.IntVal == 0) { respnt->Value.IntVal = 0 ; break ; } ;
		    pim = (struct V4DPI__Point_IntMix *)&respnt->Value ;
		    pim->Entry[0].BeginInt = mscu_ymd_to_ud(srcpt->Value.IntVal,1,1) ;
		    pim->Entry[0].EndInt = mscu_ymd_to_ud(srcpt->Value.IntVal+1,1,1)-1 ;
		    respnt->Grouping = 1 ;
//		    respnt->Bytes = (char *)&pim->Entry[1].BeginInt - (char *)respnt ;
		    SETBYTESGRPINT(respnt) ;
		    return(TRUE) ;
		   case V4DPI_PntType_UDT:
		    respnt->Value.IntVal = (srcpt->Value.IntVal <= 0 ? 0 : UDTtoUD(srcpt->Value.IntVal)) ; break ;
		 } ;
		respnt->Bytes = V4PS_Int ; return(TRUE) ; 
	   case V4DPI_PntType_UMonth:
		switch(srcpt->PntType)
	         { default:
		    v_Msg(ctx,NULL,"ProjectDTErr",V4IM_OpCode_Project,srcpt,V4DPI_PntType_UMonth) ; return(FALSE) ;
		   CASEofChar
		    goto CoerceFromChar1 ;
		   case V4DPI_PntType_CodedRange:
		   case V4DPI_PntType_Int:
		    if (srcpt->Value.IntVal <= 0) { respnt->Value.IntVal = srcpt->Value.IntVal ; }
		     else { y = srcpt->Value.IntVal / 100 ; VCALADJYEAR(((di->ds.UMonth.calFlags & VCAL_Flags_Historical) != 0),y) ; m = (srcpt->Value.IntVal % 100) ;
//			    respnt->Value.IntVal = (y-VCAL_BaseYear)*12+m-1 ;
			    respnt->Value.IntVal = YYMMtoUMONTH(y,m) ;
			  } ;
		   break ;
		   case V4DPI_PntType_Calendar:
		    GETREAL(dnum,srcpt) ;
		    if (dnum == VCal_NullDate) { respnt->Value.IntVal = 0 ; }
		     else { 
//			    i = mscu_udate_to_yyyymmdd(vcal_CalToUDate(dnum,VCAL_TimeZone_Local,&ok)) ;
//			    if (!ok) { v_Msg(ctx,NULL,"CalInvRange",V4IM_OpCode_Project,srcpt,V4DPI_PntType_UMonth) ; return(FALSE) ; } ;
//			    respnt->Value.IntVal = (i/10000 - VCAL_BaseYear)*12 + ((i/100) % 100)-1 ;
			    UDtoUMONTH(respnt->Value.IntVal,vcal_CalToUDate(dnum,VCAL_TimeZone_Local,&ok)) ;
			    if (!ok) { v_Msg(ctx,NULL,"CalInvRange",V4IM_OpCode_Project,srcpt,V4DPI_PntType_UMonth) ; return(FALSE) ; } ;
			  } ;
		    break ;
		   case V4DPI_PntType_UDate:
		    if (srcpt->Value.IntVal == VCAL_UDate_None) { respnt->Value.IntVal = VCAL_UDate_None ; }
		     else { 
//		            i = mscu_udate_to_yyyymmdd(srcpt->Value.IntVal) ;
//			    respnt->Value.IntVal = (i/10000 - VCAL_BaseYear)*12 + ((i/100) % 100)-1 ;
			    UDtoUMONTH(respnt->Value.IntVal,srcpt->Value.IntVal) ;
			  } ;
		    break ;
		   case V4DPI_PntType_UDT:
		    if (srcpt->Value.IntVal == VCAL_UDT_None) { respnt->Value.IntVal = VCAL_UDT_None ; }
		     else { 
//			    i = UDTtoUD(srcpt->Value.IntVal) ;
//			    i = mscu_udate_to_yyyymmdd(i) ;
//			    respnt->Value.IntVal = (i/10000 - VCAL_BaseYear)*12 + ((i/100) % 12)-1 ;
			    UDtoUMONTH(respnt->Value.IntVal,UDTtoUD(srcpt->Value.IntVal)) ;
			  } ;
		    break ;
		   case V4DPI_PntType_UQuarter:
		    if (srcpt->Value.IntVal == VCAL_UQuarter_None) { srcpt = respnt ; srcpt->Bytes = V4PS_Int ; srcpt->Value.IntVal = VCAL_UQuarter_None ; return(TRUE) ; } ;
		    pim = (struct V4DPI__Point_IntMix *)&respnt->Value ;
//		    pim->Entry[0].BeginInt = (srcpt->Value.IntVal / 4)*12 + (srcpt->Value.IntVal % 4)*3 ;
//		    pim->Entry[0].EndInt = pim->Entry[0].BeginInt + 2;
		    pim->Entry[0].BeginInt = YYMMtoUMONTH(UQTRtoUYEAR(srcpt->Value.IntVal),(UQTRtoQTR(srcpt->Value.IntVal) - 1) * 3 + 1) ;
		    pim->Entry[0].EndInt = pim->Entry[0].BeginInt + 2;
		    respnt->Grouping = 1 ;
//		    respnt->Bytes = (char *)&pim->Entry[1].BeginInt - (char *)respnt ;
		    SETBYTESGRPINT(respnt) ;
		    return(TRUE) ;
		   case V4DPI_PntType_UYear:
		    if (srcpt->Value.IntVal == VCAL_UYear_None) { srcpt = respnt ; srcpt->Bytes = V4PS_Int ; srcpt->Value.IntVal = VCAL_UYear_None ; return(TRUE) ; } ;
		    pim = (struct V4DPI__Point_IntMix *)&respnt->Value ;
		    pim->Entry[0].BeginInt = (srcpt->Value.IntVal - VCAL_BaseYear)*12 ;
		    pim->Entry[0].EndInt = pim->Entry[0].BeginInt + 11;
		    respnt->Grouping = 1 ;
//		    respnt->Bytes = (char *)&pim->Entry[1].BeginInt - (char *)respnt ;
		    SETBYTESGRPINT(respnt) ;
		    return(TRUE) ;
		 } ;
//ZZZZ
		respnt->Bytes = V4PS_Int ; return(TRUE) ; 
	   case V4DPI_PntType_UYear:
		switch(srcpt->PntType)
		 { default:
		    v_Msg(ctx,NULL,"ProjectDTErr",V4IM_OpCode_Project,srcpt,V4DPI_PntType_UYear) ; return(FALSE) ;
		   CASEofChar
		    goto CoerceFromChar1 ;
		   case V4DPI_PntType_Calendar:
		    GETREAL(dnum,srcpt) ;
		    i = mscu_udate_to_yyyymmdd(vcal_CalToUDate(dnum,VCAL_TimeZone_Local,&ok)) ;
		    if (!ok) { v_Msg(ctx,NULL,"CalInvRange",V4IM_OpCode_Project,srcpt,V4DPI_PntType_UYear) ; return(FALSE) ; } ;
		    respnt->Value.IntVal = i / 10000 ; break ;
		   case V4DPI_PntType_UDate:
		    i = mscu_udate_to_yyyymmdd(srcpt->Value.IntVal) ;
		    respnt->Value.IntVal = i / 10000 ; break ;
		   case V4DPI_PntType_UDT:
		    i = mscu_udate_to_yyyymmdd(UDTtoUD(srcpt->Value.IntVal)) ;
		    respnt->Value.IntVal = i / 10000 ; break ;
		   case V4DPI_PntType_UMonth:
		    respnt->Value.IntVal = (srcpt->Value.IntVal == VCAL_UMonth_None ? VCAL_UYear_None : (srcpt->Value.IntVal / 12) + VCAL_BaseYear) ; break ;
		   case V4DPI_PntType_UQuarter:
//		    respnt->Value.IntVal = (srcpt->Value.IntVal == 0 ? 0 : (srcpt->Value.IntVal / 4) + VCAL_BaseYear) ; break ;
		    respnt->Value.IntVal = (srcpt->Value.IntVal == VCAL_UQuarter_None ? VCAL_UYear_None : UQTRtoUYEAR(srcpt->Value.IntVal)) ; break ;
		   case V4DPI_PntType_UPeriod:
//xxx coerce di already set
		    if (srcpt->Value.IntVal > 100000)		/* Got regular period or year end adjustment? */
		     { respnt->Value.IntVal = srcpt->Value.IntVal / 100 ;
		     }  else if (srcpt->Value.IntVal == VCAL_UPeriod_None) { respnt->Value.IntVal = VCAL_UYear_None ; }
			else { struct V4DPI__DimInfo *di1 ;  DIMINFO(di1,ctx,srcpt->Dim) ;
			       ppy = (di1->ds.UPeriod.periodsPerYear == 0 ? 13 : di1->ds.UPeriod.periodsPerYear) ;
			       respnt->Value.IntVal = (srcpt->Value.IntVal / ppy) + VCAL_BaseYear ;
			     } ;
		    break ;
		   case V4DPI_PntType_UWeek:
		    { struct V4DPI__DimInfo *di1 ;  DIMINFO(di1,ctx,srcpt->Dim) ;
		      if (di1->ds.UWeek.baseUDate != VCAL_UDate_None) { respnt->Value.IntVal = mscu_udate_to_yyyymmdd(mscu_uweek_to_udate(srcpt->Value.IntVal,di1->ds.UWeek.baseUDate)) / 10000 ; }
		       else { respnt->Value.IntVal = (srcpt->Value.IntVal == VCAL_UWeek_None ? VCAL_UWeek_None : (srcpt->Value.IntVal / 52) + VCAL_BaseYear) ; } ;
		    } ; break ;
		   case V4DPI_PntType_CodedRange:
		   case V4DPI_PntType_Int:
		    y = srcpt->Value.IntVal ; VCALADJYEAR(((di->ds.UYear.calFlags & VCAL_Flags_Historical) != 0),y) ;
		    respnt->Value.IntVal = y ; break ;
		 } ;
		if ((di->ds.UYear.calFlags & VCAL_Flags_Historical) != 0)
		 { if (respnt->Value.IntVal > gpi->curYear) { v_Msg(ctx,NULL,"CalInvRange",V4IM_OpCode_Project,srcpt,V4DPI_PntType_UYear) ; return(FALSE) ; } ;
		 } ;
		respnt->Bytes = V4PS_Int ; return(TRUE) ; 
	   case V4DPI_PntType_UWeek:
		switch(srcpt->PntType)
		 { default:
		    v_Msg(ctx,NULL,"ProjectDTErr",V4IM_OpCode_Project,srcpt,V4DPI_PntType_UWeek) ; return(FALSE) ;
		   CASEofChar
		    goto CoerceFromChar1 ;
		   case V4DPI_PntType_Calendar:
		    GETREAL(dnum,srcpt) ; ok = TRUE ;
		    respnt->Value.IntVal = (dnum == VCal_NullDate ? VCAL_UWeek_None : mscu_udate_to_uweek(vcal_CalToUDate(dnum,VCAL_TimeZone_Local,&ok),di->ds.UWeek.baseUDate)) ;
		    if (respnt->Value.IntVal == VCAL_BadVal) ok = FALSE ;
		    if (!ok) { v_Msg(ctx,NULL,"CalInvRange",V4IM_OpCode_Project,srcpt,V4DPI_PntType_UWeek) ; return(FALSE) ; } ;
		    break ;
		   case V4DPI_PntType_UDate:
		    respnt->Value.IntVal = (srcpt->Value.IntVal == VCAL_UDate_None ? VCAL_UWeek_None : mscu_udate_to_uweek(srcpt->Value.IntVal,di->ds.UWeek.baseUDate)) ;
		    if (respnt->Value.IntVal == VCAL_BadVal) { v_Msg(ctx,NULL,"CalInvRange",V4IM_OpCode_Project,srcpt,V4DPI_PntType_UWeek) ; return(FALSE) ; } ;
		    break ;
		   case V4DPI_PntType_UDT:
		    respnt->Value.IntVal = (srcpt->Value.IntVal == VCAL_UDT_None ? VCAL_UWeek_None : mscu_udate_to_uweek(UDTtoUD(srcpt->Value.IntVal),di->ds.UWeek.baseUDate)) ;
		    if (respnt->Value.IntVal == VCAL_BadVal) { v_Msg(ctx,NULL,"CalInvRange",V4IM_OpCode_Project,srcpt,V4DPI_PntType_UWeek) ; return(FALSE) ; } ;
		    break ;
		   case V4DPI_PntType_UQuarter:
		    if (srcpt->Value.IntVal == VCAL_UQuarter_None) { respnt->Value.IntVal = VCAL_UWeek_None ; break ; } ;
		    pim = (struct V4DPI__Point_IntMix *)&respnt->Value ;
//		    y = (srcpt->Value.IntVal / 4) + VCAL_BaseYear ; m = (srcpt->Value.IntVal % 4) ;
		    y = UQTRtoUYEAR(srcpt->Value.IntVal) ; m = UQTRtoQTR(srcpt->Value.IntVal) - 1 ;
		    pim->Entry[0].BeginInt = (y - VCAL_BaseYear)*52 + (m * 13) ;
		    pim->Entry[0].EndInt = (y - VCAL_BaseYear)*52 + (m * 13) + 12 ;
		    respnt->Grouping = 1 ;
//		    respnt->Bytes = (char *)&pim->Entry[1].BeginInt - (char *)respnt ;
		    SETBYTESGRPINT(respnt) ;
		    return(TRUE) ;
		   case V4DPI_PntType_UYear:
		    if (srcpt->Value.IntVal == VCAL_UYear_None) { respnt->Value.IntVal = VCAL_UWeek_None ; break ; } ;
		    pim = (struct V4DPI__Point_IntMix *)&respnt->Value ;
		    pim->Entry[0].BeginInt = (srcpt->Value.IntVal - VCAL_BaseYear)*52 ;
		    pim->Entry[0].EndInt = pim->Entry[0].BeginInt + 51;
		    respnt->Grouping = 1 ;
//		    respnt->Bytes = (char *)&pim->Entry[1].BeginInt - (char *)respnt ;
		    SETBYTESGRPINT(respnt) ;
		    return(TRUE) ;
		 } ;
		respnt->Bytes = V4PS_Int ; return(TRUE) ; 
	   case V4DPI_PntType_UQuarter:
		switch(srcpt->PntType)
		 { default:
		    v_Msg(ctx,NULL,"ProjectDTErr",V4IM_OpCode_Project,srcpt,V4DPI_PntType_UQuarter) ; return(FALSE) ;
		   CASEofChar
		    goto CoerceFromChar1 ;
		   case V4DPI_PntType_Calendar:
		    GETREAL(dnum,srcpt) ;
		    if (dnum == VCal_NullDate) { respnt->Value.IntVal = VCAL_UQuarter_None ; }
		     else { i = mscu_udate_to_yyyymmdd(vcal_CalToUDate(dnum,VCAL_TimeZone_Local,&ok)) ;
			    if (!ok) { v_Msg(ctx,NULL,"CalInvRange",V4IM_OpCode_Project,srcpt,V4DPI_PntType_UQuarter) ; return(FALSE) ; } ;
//			    y = i/10000 ; m = (i/100)%100 ;
//			    m -= 1 ; if (m < 0) { y-- ; m += 12 ; } ;
//			    respnt->Value.IntVal = (y-VCAL_BaseYear)*4 + m/3 ;
			    respnt->Value.IntVal = YYYYMMDDtoUQTR(i) ;
			  } ;
		    break ;
		   case V4DPI_PntType_UDate:
		    if (srcpt->Value.IntVal == VCAL_UDate_None) { respnt->Value.IntVal = VCAL_UQuarter_None ; }
		     else { i = mscu_udate_to_yyyymmdd(srcpt->Value.IntVal) ;
//			    y = i/10000 ; m = (i/100)%100 ;
//			    m -= 1 ; if (m < 0) { y-- ; m += 12 ; } ;
//			    respnt->Value.IntVal = (y-VCAL_BaseYear)*4 + m/3 ;
			    respnt->Value.IntVal = YYYYMMDDtoUQTR(i) ;
			  } ;
		    break ;
		   case V4DPI_PntType_UDT:
		    if (srcpt->Value.IntVal == VCAL_UDT_None) { respnt->Value.IntVal = VCAL_UQuarter_None ; }
		     else { i = mscu_udate_to_yyyymmdd(UDTtoUD(srcpt->Value.IntVal)) ;
//			    y = i/10000 ; m = (i/100)%100 ;
//			    m -= 1 ; if (m < 0) { y-- ; m += 12 ; } ;
//			    respnt->Value.IntVal = (y-VCAL_BaseYear)*4 + m/3 ;
			    respnt->Value.IntVal = YYYYMMDDtoUQTR(i) ;
			  } ;
		    break ;
		   case V4DPI_PntType_UMonth:
		    if (srcpt->Value.IntVal == VCAL_UMonth_None) { respnt->Value.IntVal = VCAL_UQuarter_None ; }
		     else { 
//			    y = srcpt->Value.IntVal / 12 + VCAL_BaseYear ; m = (srcpt->Value.IntVal % 12) + 1 ;
//			    m -= 1 ; if (m < 0) { y-- ; m += 12 ; } ;
//			    respnt->Value.IntVal = (y-VCAL_BaseYear)*4 + m/3 ;
			    respnt->Value.IntVal = YYMMtoUQTR(UMONTHtoUYEAR(srcpt->Value.IntVal),UMONTHtoMONTH(srcpt->Value.IntVal)) ;
			  } ;
		    break ;
		   case V4DPI_PntType_UWeek:
		    if (srcpt->Value.IntVal == VCAL_UWeek_None) { respnt->Value.IntVal = VCAL_UQuarter_None ; }
		     else { struct V4DPI__DimInfo *di1 ;  DIMINFO(di1,ctx,srcpt->Dim) ;
			    if (di1->ds.UWeek.baseUDate == VCAL_UDate_None)
			     { y = (srcpt->Value.IntVal / 52) + VCAL_BaseYear ; m = (srcpt->Value.IntVal % 52) ;
			       respnt->Value.IntVal = (y-VCAL_BaseYear)*4 + m/13 ;
			     } else
			     { 
//			       y = mscu_udate_to_yyyymmdd(mscu_uweek_to_udate(srcpt->Value.IntVal,di1->ds.UWeek.baseUDate)) ;
//			       m = (y / 100) % 100 ;
//			       respnt->Value.IntVal = ((y / 10000) - VCAL_BaseYear)*4 + m/13 ;
			       respnt->Value.IntVal = YYYYMMDDtoUQTR(mscu_uweek_to_udate(srcpt->Value.IntVal,di1->ds.UWeek.baseUDate)) ;
			     }
			  } ;
		    break ;
		   case V4DPI_PntType_CodedRange:
		   case V4DPI_PntType_Int:
		    if (srcpt->Value.IntVal == 0) { respnt->Value.IntVal = VCAL_UQuarter_None ; }
		     else { y = srcpt->Value.IntVal / 10 ; VCALADJYEAR(FALSE,y) ;
			    m = srcpt->Value.IntVal % 10 ;
			    if (m < 1 || m > 4) { v_Msg(ctx,NULL,"ProjectQtr",V4IM_OpCode_Project,V4DPI_PntType_UQuarter,m) ; return(FALSE) ; } ;
//			    respnt->Value.IntVal = (y-VCAL_BaseYear)*4 + m-1 ;
			    respnt->Value.IntVal = YYQQtoUQTR(y,m) ;
			  } ;
		    break ;
		   case V4DPI_PntType_UYear:
		    if (srcpt->Value.IntVal == VCAL_UYear_None) { respnt->Value.IntVal = VCAL_UQuarter_None ; break ; } ;
		    pim = (struct V4DPI__Point_IntMix *)&respnt->Value ;
		    pim->Entry[0].BeginInt = (srcpt->Value.IntVal - VCAL_BaseYear)*4 ;
		    pim->Entry[0].EndInt = pim->Entry[0].BeginInt + 3 ;
		    respnt->Grouping = 1 ;
//		    respnt->Bytes = (char *)&pim->Entry[1].BeginInt - (char *)respnt ;
		    SETBYTESGRPINT(respnt) ;
		    srcpt = respnt ; return(TRUE) ;
		 } ;
//ZZZZ
		respnt->Bytes = V4PS_Int ; return(TRUE) ; 
	   case V4DPI_PntType_UPeriod:
		ppy = (di->ds.UPeriod.periodsPerYear == 0 ? 13 : di->ds.UPeriod.periodsPerYear) ;
		switch(srcpt->PntType)
		 { default:
		    v_Msg(ctx,NULL,"ProjectDTErr",V4IM_OpCode_Project,srcpt,V4DPI_PntType_UPeriod) ; return(FALSE) ;
		   CASEofChar
		    goto CoerceFromChar1 ;
		   case V4DPI_PntType_CodedRange:
		   case V4DPI_PntType_Int:
//xxx coerce di already set
		    if (srcpt->Value.IntVal == 0) { respnt->Value.IntVal = VCAL_UPeriod_None ; }
		     else { y = srcpt->Value.IntVal/100 ; VCALADJYEAR(((di->ds.UPeriod.calFlags & VCAL_Flags_Historical) != 0),y) ; m = srcpt->Value.IntVal%100 ;
			    if (m >= 90)					/* "Month" between 90 & 99 are for year end adjustments */
			     { respnt->Value.IntVal = y*100 + m ; break ; } ;
			    if (m < 1 || m > ppy) { v_Msg(ctx,NULL,"ProjectQtr",V4IM_OpCode_Project,V4DPI_PntType_UPeriod,m) ; return(FALSE) ; } ;
			    respnt->Value.IntVal = (y - VCAL_BaseYear) * ppy + m-1 ;
			  } ;
		    break ;
//		   case V4DPI_PntType_Calendar:
//		    GETREAL(dnum,srcpt) ;
//xxx coerce di already set
//		    if (dnum == VCal_NullDate) { respnt->Value.IntVal = 0 ; }
//		     else { i = mscu_udate_to_yyyymmdd(vcal_CalToUDate(dnum,VCAL_TimeZone_Local,&ok)) ;
//			    if (!ok) { v_Msg(ctx,NULL,"CalInvRange",V4IM_OpCode_Project,srcpt,V4DPI_PntType_UPeriod) ; return(FALSE) ; } ;
//			    y = i/10000 ; m = (i/100)%100 ;
//			    m -= 1 ; if (m < 0) { y-- ; m += 12 ; } ;
//			    respnt->Value.IntVal = (y-VCAL_BaseYear) * ppy + m ;
//			  } ;
//		    break ;
//		   case V4DPI_PntType_UDate:
//xxx coerce di already set
//		    if (srcpt->Value.IntVal == 0) { respnt->Value.IntVal = 0 ; }
//		     else { i = mscu_udate_to_yyyymmdd(srcpt->Value.IntVal) ;
//			    y = i/10000 ; m = (i/100)%100 ;
//			    m -= 1 ; if (m < 0) { y-- ; m += 12 ; } ;
//			    respnt->Value.IntVal = (y-VCAL_BaseYear) * ppy + m ;
//			  } ;
//		    break ;
//		   case V4DPI_PntType_UDT:
////xxx coerce di already set
//		    if (srcpt->Value.IntVal == 0) { respnt->Value.IntVal = 0 ; }
//		     else { i = mscu_udate_to_yyyymmdd(UDTtoUD(srcpt->Value.IntVal)) ;
//			    y = i/10000 ; m = (i/100)%100 ;
//			    m -= 1 ; if (m < 0) { y-- ; m += 12 ; } ;
//			    respnt->Value.IntVal = (y-VCAL_BaseYear) * ppy + m ;
//			  } ;
//		    break ;
		   case V4DPI_PntType_UYear:
//xxx coerce di already set
		    if (srcpt->Value.IntVal == VCAL_UYear_None) { respnt->Value.IntVal = VCAL_UPeriod_None ; break ; } ;
		    pim = (struct V4DPI__Point_IntMix *)&respnt->Value ;
		    pim->Entry[0].BeginInt = (srcpt->Value.IntVal - VCAL_BaseYear) * ppy ;
		    pim->Entry[0].EndInt = pim->Entry[0].BeginInt + (ppy - 1) ;
		    respnt->Grouping = 1 ;
//		    respnt->Bytes = (char *)&pim->Entry[1].BeginInt - (char *)respnt ;
		    SETBYTESGRPINT(respnt) ;
		    srcpt = respnt ; return(TRUE) ;
		   case V4DPI_PntType_UMonth:
		    if (srcpt->Value.IntVal == 0) { respnt->Value.IntVal = 0 ; }
		     else { y = srcpt->Value.IntVal / 12 + VCAL_BaseYear ; m = (srcpt->Value.IntVal % 12) + 1 ;
			    m -= 1 ; if (m < 0) { y-- ; m += 12 ; } ;
			    respnt->Value.IntVal = (y-VCAL_BaseYear) * ppy + m ;
			  } ;
		    break ;
		 } ;
//ZZZZ
		respnt->Bytes = V4PS_Int ; return(TRUE) ; 
	   case V4DPI_PntType_Int2:
		switch(srcpt->PntType)
		 { default:	respnt->Value.IntVal = v4im_GetPointInt(&ok,srcpt,ctx) ; if (ok) break ; goto not_ok ;
		   CASEofINT
			ZPH(respnt) ;  respnt->Bytes = V4PS_Int ; respnt->Dim = di->DimId ; respnt->PntType = di->PointType ;
			respnt->Value.Int2Val[0] = srcpt->Value.IntVal ;
			respnt->Value.Int2Val[1] = 0 ; return(TRUE) ;
		   case V4DPI_PntType_Real:
			ZPH(respnt) ;  respnt->Dim = di->DimId ; respnt->PntType = di->PointType ; respnt->Bytes = V4PS_Real ;
			memcpy(&respnt->Value.Int2Val,&srcpt->Value,V4PS_Real) ;
			return(TRUE) ;
		 } ;
		return(FALSE) ;
	   case V4DPI_PntType_Delta:
	   case V4DPI_PntType_CodedRange:
	   case V4DPI_PntType_Int:
		switch(srcpt->PntType)
		 {		/* Comment out below - want to fall thru if not Alpha/Dict */
		   default:	respnt->Value.IntVal = v4im_GetPointInt(&ok,srcpt,ctx) ; if (ok) break ; goto not_ok ;
		   case V4DPI_PntType_IntMod:
		   case V4DPI_PntType_Tag:	respnt->Value.IntVal = srcpt->Value.IntVal ; break ;
		   CASEofINT
			memcpy(respnt,srcpt,srcpt->Bytes) ; respnt->Dim = di->DimId ; respnt->PntType = di->PointType ;
			return(TRUE) ;
		   CASEofChar
			v4im_GetPointUC(&ok,ucbuf,UCsizeof(ucbuf),srcpt,ctx) ;
			ucbp = ucbuf ;
			intPNT(respnt) ; respnt->Dim = di->DimId ;
			if (ucbp[0] == '^' && (ucbp[1] == 'x' || ucbp[1] == 'X'))
			 { UCCHAR *bp ;
			   for(bp=ucbp+2,respnt->Value.IntVal=0;*bp!=UCEOS;bp++)
			    { respnt->Value.IntVal = respnt->Value.IntVal << 4 ;
			      if (*bp >= UClit('0') && *bp <= UClit('9')) { respnt->Value.IntVal += (*bp - UClit('0')) ; }
			       else if (*bp >= UClit('a') && *bp <= UClit('f')) { respnt->Value.IntVal += (10 + *bp - UClit('a')) ; }
			       else if (*bp >= UClit('A') && *bp <= UClit('F')) { respnt->Value.IntVal += (10 + *bp - UClit('A')) ; }
			       else { break ; } ;
			    } ;
			 } else
			 { if (di->ds.Int.IFormat != 0)
			    { 
/*			      VEH200106 - I think IFormat is getting trashed somehow/sometimes and ending up with hex value instead of correct decimal value */
			      v_Msg(ctx,UCTBUF2,"@?????? Dimension %1D IFormat is %2d, clearing to zero!\n",di->DimId,di->ds.Int.IFormat) ; 
//printf("IFormat = %d (%p)\n",di->ds.Int.IFormat,&di->ds.Int.IFormat) ;
			      di->ds.Int.IFormat = 0 ; vout_UCText(VOUT_Trace,0,UCTBUF2) ;
			    } ;
			   respnt->Value.IntVal = UCstrtol(ucbp,&ucbp1,(di->ds.Int.IFormat == V4LEX_TablePT_Hexadecimal ? 16 : 10)) ;
			   if (*ucbp1 != UCEOS) respnt = NULL ;
			 } ;
			if (respnt == NULL)
			 { v_Msg(ctx,NULL,"DTInfoConvert",V4IM_OpCode_Project,srcpt,di->PointType) ; return(FALSE) ; } ;
			break ;
		   case V4DPI_PntType_Color:
			i = v_ColorRefToRGB(srcpt->Value.IntVal) ;
			srcpt = respnt ; ZPH(srcpt) ; srcpt->Dim = di->DimId ; srcpt->PntType = V4DPI_PntType_Int ;
			srcpt->Bytes = V4PS_Int ; srcpt->Value.IntVal = i ;
			break ;
		   case V4DPI_PntType_Country:
			i = srcpt->Value.IntVal ;
			srcpt = respnt ; ZPH(srcpt) ; srcpt->Dim = di->DimId ; srcpt->PntType = V4DPI_PntType_Int ;
			srcpt->Bytes = V4PS_Int ; srcpt->Value.IntVal = i ;
			break ;
		   case V4DPI_PntType_XDict:
		   case V4DPI_PntType_Dict:			/* Note: Coerce converts Dict to int, MakeP just copies Dict value! */
			v4dpi_PointToString(UCTBUF2,srcpt,ctx,V4DPI_FormatOpt_Echo) ;
			UCstrcpyToASC(ASCTBUF1,UCTBUF2) ;
			ZPH(respnt) ; respnt->Dim = di->DimId ;
			respnt->PntType = V4DPI_PntType_Int ; respnt->Bytes = V4PS_Int ;
			respnt->Value.IntVal = strtol(ASCTBUF1,&bp,10) ; if (*bp != '\0') respnt = NULL ;
			if (respnt == NULL) { v_Msg(ctx,NULL,"DTInfoConvert",V4IM_OpCode_Project,srcpt,di->PointType) ; return(FALSE) ; } ;
			break ;
		    } ;
		respnt->Bytes = V4PS_Int ; return(TRUE) ;
	   case V4DPI_PntType_UOM:
		switch(srcpt->PntType)
		 { case V4DPI_PntType_Int:
		    if (srcpt->Value.IntVal == 0)			/* Only allow if setting to 0 */
		     { respnt->Value.UOMVal.Ref = 0 ; respnt->Value.UOMVal.Index = 0 ; respnt->Value.UOMVal.Num = 0 ;
		       break ;
		     } ;
		   default:
		    v_Msg(ctx,NULL,"ProjectDTErr",V4IM_OpCode_Project,srcpt,V4DPI_PntType_UOM) ; return(FALSE) ;
		   case V4DPI_PntType_UOMPer:
		   case V4DPI_PntType_UOM:
		    respnt->Value.UOMVal = srcpt->Value.UOMVal ; break ;
		 } ;
		respnt->Bytes = V4PS_UOM ; return(TRUE) ; 
	   case V4DPI_PntType_UOMPer:
		switch(srcpt->PntType)
		 { default:
		    v_Msg(ctx,NULL,"ProjectDTErr",V4IM_OpCode_Project,srcpt,V4DPI_PntType_UOMPer) ; return(FALSE) ;
		 } ;
//		respnt->Bytes = V4PS_UOMPer ; return(TRUE) ; 
//		break ;
	   case V4DPI_PntType_GeoCoord:
		switch(srcpt->PntType)
		 { default:
		    v_Msg(ctx,NULL,"ProjectDTErr",V4IM_OpCode_Project,srcpt,V4DPI_PntType_GeoCoord) ; return(FALSE) ;
//		   case V4DPI_PntType_BigText:
		   CASEofChar
		    goto CoerceFromChar1 ;
		 } ;
		return(TRUE) ; 
	   case V4DPI_PntType_Fixed:
		if (srcpt->PntType == V4DPI_PntType_Char || srcpt->PntType == V4DPI_PntType_UCChar) goto CoerceFromChar1 ;
		respnt->LHSCnt = di->Decimals ;
		if (srcpt->PntType == V4DPI_PntType_Int2)
		 { memcpy(respnt->Value.FixVal,srcpt->Value.Int2Val,sizeof srcpt->Value.FixVal) ;
		 } else
		 { b64 = v4im_GetPointFixed(&ok,srcpt,ctx,di->Decimals) ;
		   if (!ok) { v_Msg(ctx,NULL,"ProjectDTErr",V4IM_OpCode_Project,srcpt,V4DPI_PntType_Fixed) ; return(FALSE) ; }
		   memcpy(respnt->Value.FixVal,&b64,sizeof b64) ;
		 } ;
		respnt->Bytes = V4PS_Fixed ; return(TRUE) ;
	   case V4DPI_PntType_Real:
		if (srcpt->PntType == V4DPI_PntType_Char || srcpt->PntType == V4DPI_PntType_UCChar)
		 { v4im_GetPointUC(&ok,ucbuf,UCsizeof(ucbuf),srcpt,ctx) ; dnum = UCstrtod(ucbuf,&ucbp) ;
		   if (*ucbp != UCEOS) { v_Msg(ctx,NULL,"DTInfoConvert",V4IM_OpCode_Project,srcpt,V4DPI_PntType_Real) ; return(FALSE) ; } ;
		 } else if (srcpt->PntType == V4DPI_PntType_Complex)
		 { memcpy(&dnum,&srcpt->Value.Complex.r,sizeof dnum) ;
		 } else if (srcpt->PntType == V4DPI_PntType_Int2)
		 { memcpy(&dnum,&srcpt->Value.Int2Val,sizeof dnum) ; }
		 else { dnum = v4im_GetPointDbl(&ok,srcpt,ctx) ; if (!ok) goto not_ok ; } ;
		PUTREAL(respnt,dnum) ;
		respnt->Bytes = V4PS_Real ; return(TRUE) ;
	   case V4DPI_PntType_SSVal:		
		respnt->Value.IntVal = v_ColorRefToXL(srcpt->Value.IntVal,TRUE) ;
		respnt->Bytes = V4PS_Int ; return(TRUE) ;
	   case V4DPI_PntType_Color:
		switch (srcpt->PntType)
		 { default:
			v_Msg(ctx,NULL,"ProjectDTErr",V4IM_OpCode_Project,srcpt,V4DPI_PntType_Color) ; return(FALSE) ;
		    case V4DPI_PntType_XDict:
		    case V4DPI_PntType_Dict:
		    CASEofChar
			v4im_GetPointUC(&ok,ucbuf,UCsizeof(ucbuf),srcpt,ctx) ; if (!ok) goto not_ok ;
			respnt->Value.IntVal = v_ColorNameToRef(ucbuf) ;
			if (respnt->Value.IntVal == 0) { v_Msg(ctx,NULL,"DPIInvPoint2",V4IM_OpCode_Project,srcpt,di->DimId) ; return(FALSE) ; } ;
			break ;
		    case V4DPI_PntType_CodedRange:
		    case V4DPI_PntType_Int:
			respnt->Value.IntVal = v_ColorRGBNameToRef(NULL,srcpt->Value.IntVal) ; break ;
			break ;
		 } ;
		respnt->Bytes = V4PS_Int ; return(TRUE) ;
	   case V4DPI_PntType_Country:
		switch (srcpt->PntType)
		 { default:
			v_Msg(ctx,NULL,"ProjectDTErr",V4IM_OpCode_Project,srcpt,V4DPI_PntType_Country) ; return(FALSE) ;
		    case V4DPI_PntType_XDict:
		    case V4DPI_PntType_Dict:
		    CASEofChar
			v4im_GetPointUC(&ok,ucbuf,UCsizeof(ucbuf),srcpt,ctx) ;  if (!ok) goto not_ok ;
			respnt->Value.IntVal = v_CountryNameToRef(ucbuf) ;
			if (respnt->Value.IntVal == 0) { v_Msg(ctx,NULL,"DPIInvPoint2",V4IM_OpCode_Project,srcpt,di->DimId) ; return(FALSE) ; } ;
			break ;
		    case V4DPI_PntType_CodedRange:
		    case V4DPI_PntType_Int:
			respnt->Value.IntVal = srcpt->Value.IntVal ; break ;
			break ;
		 } ;
		respnt->Bytes = V4PS_Int ; return(TRUE) ;
	   case V4DPI_PntType_XDict:
		switch (srcpt->PntType)
		 { default:
			v_Msg(ctx,NULL,"ProjectDTErr",V4IM_OpCode_Project,srcpt,V4DPI_PntType_XDict) ; return(FALSE) ;
		    CASEofChar
			v4im_GetPointUC(&ok,ucbuf,UCsizeof(ucbuf),srcpt,ctx) ;
			respnt->Value.IntVal = v4dpi_XDictEntryGet(ctx,ucbuf,di,0) ;
			if (respnt->Value.IntVal == 0) { v_Msg(ctx,NULL,"DPIInvPoint2",V4IM_OpCode_Project,srcpt,di->DimId) ; return(FALSE) ; } ;
			break ;
		    case V4DPI_PntType_CodedRange:
		    case V4DPI_PntType_Int:
			respnt->Value.IntVal = srcpt->Value.IntVal ; break ;
		    case V4DPI_PntType_Dict:
			respnt->Value.IntVal =
			 v4dpi_XDictEntryGet(ctx,v4dpi_RevDictEntryGet(ctx,srcpt->Value.IntVal),di,0) ;
			if (respnt->Value.IntVal == 0) { v_Msg(ctx,NULL,"DPIInvPoint2",V4IM_OpCode_Project,srcpt,di->DimId) ; return(FALSE) ; } ;
			break ;
		 } ;
		respnt->Bytes = V4PS_Int ; return(TRUE) ;
	   case V4DPI_PntType_Dict:
		switch (srcpt->PntType)
		 { default:
			v_Msg(ctx,NULL,"ProjectDTErr",V4IM_OpCode_Project,srcpt,V4DPI_PntType_Dict) ; return(FALSE) ;
		    case V4DPI_PntType_Color:
			v4dpi_PointToString(UCTBUF1,srcpt,ctx,V4DPI_FormatOpt_Echo) ;
			respnt->Value.IntVal = v4dpi_DictEntryGet(ctx,di->DimId,UCTBUF1,di,NULL) ;
			break ;
		    case V4DPI_PntType_Country:
			v4dpi_PointToString(UCTBUF1,srcpt,ctx,V4DPI_FormatOpt_Echo) ;
			respnt->Value.IntVal = v4dpi_DictEntryGet(ctx,di->DimId,UCTBUF1,di,NULL) ;
			break ;
		    case V4DPI_PntType_UYear:
		    case V4DPI_PntType_Int: case V4DPI_PntType_CodedRange:
			{ struct V4DPI__DimInfo *di1 ; DIMINFO(di1,ctx,srcpt->Dim) ;
			  if (di1->Flags & V4DPI_DimInfo_Displayer)
			   { v4dpi_PointToString(UCTBUF1,srcpt,ctx,V4DPI_FormatOpt_Echo) ;
			     respnt->Value.IntVal = v4dpi_DictEntryGet(ctx,di->DimId,UCTBUF1,di,NULL) ;
			     break ;
			   } ;
			} ;
			v4dpi_PointToString(UCTBUF1,srcpt,ctx,V4DPI_FormatOpt_Echo) ;
			respnt->Value.IntVal = v4dpi_DictEntryGet(ctx,di->DimId,UCTBUF1,di,NULL) ;
			break ;
		    CASEofChar
			v4im_GetPointUC(&ok,UCTBUF1,100,srcpt,ctx) ;
			respnt->Value.IntVal = v4dpi_DictEntryGet(ctx,di->DimId,UCTBUF1,di,NULL) ;
			break ;
		    case V4DPI_PntType_XDict:
			ucbp = v4dpi_RevXDictEntryGet(ctx,srcpt->Dim,srcpt->Value.IntVal) ;
			respnt->Value.IntVal = v4dpi_DictEntryGet(ctx,0,ucbp,di,NULL) ;
			break ;
		 } ;
		respnt->Bytes = V4PS_Int ; return(TRUE) ;
	   case V4DPI_PntType_List:			/* Dest is List - convert to list */
		if (srcpt->PntType == V4DPI_PntType_Char && srcpt->Grouping == V4DPI_Grouping_Single) goto CoerceFromChar ;
		switch (srcpt->PntType)
		 { default:
			INITLP(respnt,lp,Dim_List)
			v4l_ListPoint_Modify(ctx,lp,V4L_ListAction_Append,srcpt,0) ;
			ENDLP(respnt,lp)
			break ;
		   CASEofCharmU
			ZPH(respnt) ; INITLP(respnt,lp,Dim_List)
			if (srcpt->Grouping == V4DPI_Grouping_Single)
			 { v4l_ListPoint_Modify(ctx,lp,V4L_ListAction_Append,srcpt,0) ;
			 } else
			 { pam = (struct V4DPI__Point_AlphaMix *)&srcpt->Value.AlphaVal ;
			   bp = (char *)&pam->Entry[srcpt->Grouping].BeginIndex ;
			   ZPH(&isctbuf) ; isctbuf.Dim = srcpt->Dim ; isctbuf.PntType = V4DPI_PntType_Char ;
			   for(i=0;i<srcpt->Grouping;i++)
			    { if (pam->Entry[i].EndIndex == 0)
			       { strncpy(&isctbuf.Value.AlphaVal[1],bp+pam->Entry[i].BeginIndex+1,*(bp+pam->Entry[i].BeginIndex)) ;
			         isctbuf.Value.AlphaVal[1+*(bp+pam->Entry[i].BeginIndex)] = '\0' ;
			       } else { v_Msg(ctx,NULL,"ProjectRngStr",V4IM_OpCode_Project,srcpt->PntType,srcpt) ; return(FALSE) ; } ;
			      CHARPNTBYTES1(&isctbuf) ; v4l_ListPoint_Modify(ctx,lp,V4L_ListAction_Append,&isctbuf,0) ;
			    } ;
			 } ;
			ENDLP(respnt,lp)
			break ;
		   case V4DPI_PntType_UCChar:
			ZPH(respnt) ; INITLP(respnt,lp,Dim_List)
			if (srcpt->Grouping == V4DPI_Grouping_Single)
			 { v4l_ListPoint_Modify(ctx,lp,V4L_ListAction_Append,srcpt,0) ;
			 } else
			 { pam = (struct V4DPI__Point_AlphaMix *)&srcpt->Value.AlphaVal ;
			   ucbp = (UCCHAR *)&pam->Entry[srcpt->Grouping].BeginIndex ;
			   ZPH(&isctbuf) ; isctbuf.Dim = srcpt->Dim ; isctbuf.PntType = V4DPI_PntType_UCChar ;
			   for(i=0;i<srcpt->Grouping;i++)
			    { if (pam->Entry[i].EndIndex == 0)
			       { UCstrncpy(&isctbuf.Value.UCVal[1],ucbp+pam->Entry[i].BeginIndex+1,*(ucbp+pam->Entry[i].BeginIndex)) ;
				 isctbuf.Value.UCVal[1+*(ucbp+pam->Entry[i].BeginIndex)] = UCEOS ;
			       } else { v_Msg(ctx,NULL,"ProjectRngStr",V4IM_OpCode_Project,srcpt->PntType,srcpt) ; return(FALSE) ; } ;
			      UCCHARPNTBYTES1(&isctbuf) ; v4l_ListPoint_Modify(ctx,lp,V4L_ListAction_Append,&isctbuf,0) ;
			    } ;
			 } ;
			ENDLP(respnt,lp)
			break ;
		   case V4DPI_PntType_AggRef:
		   case V4DPI_PntType_Fixed:
		   case V4DPI_PntType_Delta:
		   case V4DPI_PntType_Int:
		   case V4DPI_PntType_Real:
		   case V4DPI_PntType_Int2:
		   case V4DPI_PntType_Country:
		   case V4DPI_PntType_TeleNum:
		   case V4DPI_PntType_Complex:
		   case V4DPI_PntType_UPeriod:
		   case V4DPI_PntType_UMonth:
		   case V4DPI_PntType_UQuarter:
		   case V4DPI_PntType_UDate:
		   case V4DPI_PntType_UDT:
		   case V4DPI_PntType_UTime:
		   case V4DPI_PntType_UWeek:
		   case V4DPI_PntType_Calendar:
		   case V4DPI_PntType_GeoCoord:
		   case V4DPI_PntType_XDB:
			if (v4im_VerifyList(respnt,ctx,srcpt,V4IM_OpCode_Project) == NULL) return(FALSE) ;
			break ;
		   case V4DPI_PntType_QIsct:
		   case V4DPI_PntType_Isct:
			INITLP(respnt,lp,Dim_List) ;
			v4im_CoerceIsctToList(ctx,lp,srcpt) ;
			ENDLP(respnt,lp)
			break ;
		   case V4DPI_PntType_BigText:
			INITLP(respnt,lp,Dim_List)
			ucbp = v4_BigTextCharValue(ctx,srcpt) ;
			if (ucbp == NULL)
			 { v_Msg(ctx,NULL,"BigTextNoVal",V4IM_OpCode_Project) ; return(FALSE) ; } ;
			spt = &isctbuf ; alphaPNT(spt) ;
			for(ok=TRUE;ok;ucbp=ucbp1+1)
			 { ucbp1 = UCstrchr(ucbp,EOLbt) ;
			   if (ucbp1 == NULL)
			    { ok = FALSE ; } else { *ucbp1 = UCEOS ; } ;
			   i = UCstrlen(ucbp) ; if (i >= V4DPI_AlphaVal_Max) i = V4DPI_AlphaVal_Max-1 ;
			   for(j=0;j<i;j++) { spt->Value.AlphaVal[j+1] = ucbp[j] ; } ; spt->Value.AlphaVal[j+1] = '\0' ;
			   CHARPNTBYTES2(spt,i)
			   if (!v4l_ListPoint_Modify(ctx,lp,V4L_ListAction_Append,spt,0)) { v_Msg(ctx,NULL,"LPModFail",V4IM_OpCode_Project) ; return(FALSE) ; } ;
			   if (ok) *ucbp1 = EOLbt ;
			 } ;
			ENDLP(respnt,lp)
			break ;
		 } ;
		return(TRUE) ;
	   case V4DPI_PntType_Isct:			/* Dest is Isct, maybe create one */
		if (srcpt->PntType == V4DPI_PntType_Char) goto CoerceFromChar ;
		switch (srcpt->PntType)
		 { default:
			respnt->Grouping = 1 ; respnt->Bytes = V4DPI_PointHdr_Bytes + srcpt->Bytes ;
			memcpy(&respnt->Value,srcpt,srcpt->Bytes) ;
			break ;
		 } ;
		return(TRUE) ;
	   case V4DPI_PntType_PntIdx:			/* Target dimension is point-pointer - copy 2nd arg */
		pix = v4dpi_PntIdx_AllocPnt() ; cpt = v4dpi_PntIdx_CvtIdxPtr(pix) ;
		memcpy(cpt,srcpt,srcpt->Bytes) ;		/* Copy 2nd arg into allocated point */
		respnt->Value.IntVal = pix ;	/* Save point index */
		respnt->Bytes = V4PS_Int ; return(TRUE) ;
	 } ;
	return(FALSE) ;						/* Should not get here */
not_ok:								/* Here if lower-level return updated 'ok' to false - gen error to get ErrorMsgAux -> ErrorMsg */
	v_Msg(ctx,NULL,"ProjectDTProb1",V4IM_OpCode_Project) ; return(FALSE) ;

CoerceFromChar1:						/* Enclose string in quotes and convert to point */
	if (dipt->Grouping <= 1)
	 { v4im_GetPointUC(&ok,ucbuf,UCsizeof(ucbuf),srcpt,ctx) ; tcb = NULL ; INITTCB ;
	   v4lex_NestInput(tcb,NULL,ucbuf,V4LEX_InpMode_QString) ;
	   if (v4dpi_PointAccept(respnt,di,tcb,ctx,V4DPI_PointParse_RetFalse))
	    { v4lex_FreeTCB(tcb) ; respnt->Dim = di->DimId ; return(TRUE) ; } ;
	   v4lex_FreeTCB(tcb) ; v_Msg(ctx,NULL,"ModFailed2",V4IM_OpCode_Project) ; return(FALSE) ;
	 } ;
CoerceFromChar:							/* Here to convert alpha string to point */
	if (dipt->Grouping <= 1)
	 { v4im_GetPointUC(&ok,ucbuf,UCsizeof(ucbuf),srcpt,ctx) ; tcb = NULL ; INITTCB ;
	   v4lex_NestInput(tcb,NULL,ucbuf,V4LEX_InpMode_String) ;
	   if (v4dpi_PointAccept(respnt,di,tcb,ctx,V4DPI_PointParse_RetFalse))
	    { v4lex_FreeTCB(tcb) ; respnt->Dim = di->DimId ; respnt->PntType = di->PointType ; return(TRUE) ; } ;
	  v4lex_FreeTCB(tcb) ; v_Msg(ctx,NULL,"ModFailed2",V4IM_OpCode_Project) ; return(FALSE) ;
	 } ;
	pim = (struct V4DPI__Point_IntMix *)&dipt->Value ;
	for(i=0;i<dipt->Grouping;i++)
	 { DIMINFO(di,ctx,pim->Entry[i].BeginInt) ;
	   if (di->PointType == V4DPI_PntType_Char)		/* If alpha then just copy it over */
	    { memcpy(respnt,srcpt,srcpt->Bytes) ; return(TRUE) ; } ;
	   v4im_GetPointUC(&ok,ucbuf,UCsizeof(ucbuf),srcpt,ctx) ; tcb = NULL ; INITTCB ; v4lex_NestInput(tcb,NULL,ucbuf,V4LEX_InpMode_String) ;
	   if (v4dpi_PointAccept(respnt,di,tcb,ctx,V4DPI_PointParse_RetFalse)) { v4lex_FreeTCB(tcb) ; return(TRUE) ; } ;
	   v4lex_FreeTCB(tcb) ;
	 } ;
	return(FALSE) ;
}

/*	v4im_CoerceIsctToList - Recursive Routine to Convert Isct to List	*/

void v4im_CoerceIsctToList(ctx,lp,point)
  struct V4C__Context *ctx ;
  struct V4L__ListPoint *lp ;
  P *point ;
{ P *tpt ;
  int i ;

	if (point->PntType != V4DPI_PntType_QIsct && point->PntType != V4DPI_PntType_Isct)
	 { v4l_ListPoint_Modify(ctx,lp,V4L_ListAction_Append,point,0) ; return ; } ;
	for(tpt=ISCT1STPNT(point),i=0;i<point->Grouping;i++)
	 { v4im_CoerceIsctToList(ctx,lp,tpt) ; ADVPNT(tpt) ; } ;
} 

/*	v4im_DoMakeI - Handles MakeI() & MakeQI() Modules			*/

P *v4im_DoMakeI(ctx,respnt,argcnt,argpnts,intmodx,trace)
  struct V4C__Context *ctx ;
  INTMODX intmodx ;
  P *respnt,*argpnts[] ;
  COUNTER argcnt ; VTRACE trace ;
{ P *cpt,*tpt,*vpt,*failpt,ptbuf,isctbuf ;
#define MAXPNTS 150
  INDEX i,j,ix ; COUNTER pcnt ; DIMID dimIdList[MAXPNTS] ;
  LOGICAL dodot,dotrace,doquote,doforce,isintmod,doremove ;

	INITISCT(respnt) ; NOISCTVCD(respnt) ; tpt = ISCT1STPNT(respnt) ; j = 0 ; dodot = FALSE ; isintmod = FALSE ; dotrace = FALSE ; failpt = NULL ;
	doquote = (intmodx == V4IM_OpCode_MakeQIsct) ; doforce = FALSE ; doremove = FALSE ;
	for(i=1,pcnt=0;i<=argcnt;i++)
	 { cpt = argpnts[i] ;
	   if (memcmp(cpt,&protoNone,V4PS_Int) == 0) continue ;	/* Don't include UV4:none point */
	   if (memcmp(cpt,&protoQNone,V4PS_Int) == 0) { UNQUOTE(cpt) ; } ;
	   if (cpt->PntType == V4DPI_PntType_TagVal)	/* Don't check for tags if making IntMod */
	    { ix = v4im_CheckPtArgNew(ctx,cpt,&vpt,NULL) ;
	      if (isintmod)		/* If TRUE then in IntMod - don't parse tags except Fail::xxx */
	       { if (ix == V4IM_Tag_Fail) { failpt = vpt ; continue ; } ;
	         if (ix == -V4IM_Tag_Trace) { dotrace = TRUE ; continue ; } ;
		 if (ix == -V4IM_Tag_Force) { doforce = TRUE ; continue ; } ;
		 if (ix == -V4IM_Tag_Quote) { doquote = TRUE ; continue ; } ;
		 goto makei_addpt ;	/* Treat Tag as a regular point */
	       } ;
	      switch (ix)
	       { default:	    	v_Msg(ctx,NULL,"TagBadUse",intmodx) ; goto fail ;
	         case V4IM_Tag_Unk:	v_Msg(ctx,NULL,"TagUnknown",intmodx) ; goto fail ;
	         case -V4IM_Tag_Dot:	dodot = TRUE ; break ;
		 case -V4IM_Tag_Trace:	dotrace = TRUE ; break ;
		 case V4IM_Tag_Fail:	failpt = vpt ; break ;
		 case -V4IM_Tag_Force:	doforce = TRUE ; break ;
		 case -V4IM_Tag_Quote:	doquote = TRUE ; break ;
		 case -V4IM_Tag_Delete:
		 case -V4IM_Tag_Remove: doremove = TRUE ; continue ;
	       } ; continue ;
	    } ;
makei_addpt:
	   pcnt ++ ;		/* Number of non-tag points seen */
	   if (pcnt == 1 && cpt->PntType == V4DPI_PntType_IntMod) isintmod = TRUE ;
	   if (dodot && i ==2 && cpt->Grouping != V4DPI_Grouping_Current)	/* If first point not dim* then make it */
	    { ZPH(&ptbuf) ; ptbuf.Grouping = V4DPI_Grouping_Current ; ptbuf.PntType = V4DPI_PntType_Special ;
	      ptbuf.Bytes = V4PS_Int ; ptbuf.Dim = (cpt->Dim == Dim_Dim ? cpt->Value.IntVal : cpt->Dim) ;
	      cpt = &ptbuf ;
	    } ;
	   if (dodot && i > 3 && argcnt > 3)
	    { respnt->Bytes = (char *)tpt - (char *)respnt ; memcpy(&isctbuf,respnt,respnt->Bytes) ;
	      respnt->Grouping = 1 ; tpt = ISCT1STPNT(respnt) ; j = respnt->Bytes ; memcpy(&respnt->Value,&isctbuf,isctbuf.Bytes) ; ADVPNT(tpt) ;
	    } ;
	   j += cpt->Bytes ;
	   if (j > V4DPI_AlphaVal_Max) { v_Msg(ctx,NULL,"ModIsctTooBig",intmodx,j,V4DPI_AlphaVal_Max) ; goto fail ; } ;
	   if (respnt->Grouping >= V4DPI_IsctDimMax && !isintmod) { v_Msg(ctx,NULL,"ModIsctMaxPt",intmodx,V4DPI_IsctDimMax) ; goto fail ; } ;
	   for(ix=0;ix<respnt->Grouping;ix++)
	    { if (cpt->Dim != dimIdList[ix] || cpt->Dim == 0) continue ;
	      if (isintmod) break ;	/* IntMods can have dup dimensions */
	      v_Msg(ctx,NULL,"ModIsctDupDim",intmodx,ix+1,respnt->Grouping+1,cpt) ; goto fail ;
	    } ;
	   dimIdList[respnt->Grouping] = cpt->Dim ;
	   memcpy(tpt,cpt,cpt->Bytes) ;	/* Append points in argument list to new isct */
	   if (doremove) { tpt->AltDim = TRUE ; doremove = FALSE ; } ;
#ifndef NEWQUOTE
	   UNQUOTE(tpt) ;
#endif
	   ADVPNT(tpt) ; respnt->Grouping ++ ;
	   ISCTSETNESTED(respnt,cpt) ;
	 } ;
	ISCTLEN(respnt,tpt) ;
	if (failpt != NULL)		/* Have a fail? */
	 { if (respnt->Bytes + failpt->Bytes > V4DPI_AlphaVal_Max){ v_Msg(ctx,NULL,"ModIsctFailBig",intmodx,failpt) ; goto fail ; } ;
	   respnt->Continued = TRUE ; memcpy((char *)respnt+respnt->Bytes,failpt,failpt->Bytes) ; respnt->Bytes += failpt->Bytes ;
	 } ;
	if (doforce) respnt->ForceEval = TRUE ;
	if (doquote)
	 { 
#ifndef NEWQUOTE
	   respnt->PntType = V4DPI_PntType_QIsct ;		/* Slimy kludge to prevent DPI from turning off Quoted! (VEH 961025) */
#endif
	   QUOTE(respnt) ;
	 } ;
	if (dotrace) respnt->TraceEval = TRUE ;
	return(respnt) ;

fail:	REGISTER_ERROR(0) ; return(NULL) ;
}


#ifdef WANTENUMAE
/*	v4im_DoEnumAE - Handles EnumAE() Module			*/

P *v4im_DoEnumAE(ctx,respnt,argcnt,argpnts,intmodx,trace)
  struct V4C__Context *ctx ;
  INTMODX intmodx ;
  P *respnt,*argpnts[] ;
  COUNTER argcnt ; VTRACE trace ;
{ P *ipt,pt3,testpt,isctbuf,lisctbuf ;
  struct V4L__ListPoint *lp,*lp1 ;
  int i,frameid ;

	lp = v4im_VerifyList(NULL,ctx,ipt = argpnts[1],intmodx) ;
	if (lp == NULL) { v_Msg(ctx,NULL,"ModInvArgList",intmodx,1) ; goto fail ; } ;
	lp1 = ALIGNLP(&respnt->Value) ; memset(lp1,0,V4L_ListPointHdr_Bytes) ;	/* Set up resulting list point */
	lp1->ListType = V4L_ListType_Point ;
	frameid = v4ctx_FramePush(ctx,NULL) ;	/* Start new context frame */
	for(i=1;v4l_ListPoint_Value(ctx,lp,i,&isctbuf) > 0;i++)	/* Loop thru each point in list */
	 { ipt = &testpt ;		/* Convert to a pointer */
	   memcpy(ipt,argpnts[2],argpnts[2]->Bytes) ;	/* Copy test isct */
	   memcpy((char *)ipt+ipt->Bytes,&isctbuf,isctbuf.Bytes) ; /* Append next point in list */
	   ipt->Grouping++ ; ipt->Bytes += isctbuf.Bytes ;	/* Add arg to end of 1st-arg isct */
	   ipt = v4dpi_IsctEval(&lisctbuf,ipt,ctx,V4DPI_EM_EvalQuote,NULL,NULL) ;
	   if (ipt != NULL)			/* Eval OK, then append to result list */
	    { v4l_ListPoint_Modify(ctx,lp1,V4L_ListAction_Append,ipt,0) ; continue ; } ;
	   ipt = &pt3 ;			/* Append point to (arg #3) */
	   memcpy((char *)ipt+ipt->Bytes,&isctbuf,isctbuf.Bytes) ; /* Append next point in list */
	   ipt->Grouping++ ; ipt->Bytes += isctbuf.Bytes ;	/* Add arg to end of 1st-arg isct */
	 } ;
	if (pt3.Grouping != argpnts[3]->Grouping)	/* Did we append any points into arg3? */
	 { ipt = &pt3 ;			/* Yes - then eval it */
	   ipt = v4dpi_IsctEval(&lisctbuf,ipt,ctx,V4DPI_EM_EvalQuote,NULL,NULL) ;
	   if (ipt != NULL)			/* Eval OK, then append to result list */
	    v4l_ListPoint_Modify(ctx,lp1,V4L_ListAction_Append,ipt,0) ;
	 } ;
	respnt->Dim = Dim_List ; respnt->PntType = V4DPI_PntType_List ;
	respnt->Bytes = ALIGN((char *)&respnt->Value.AlphaVal[lp1->Bytes] - (char *)respnt) ;
	if (respnt->Bytes < V4DPI_PointHdr_Bytes + (&lp1->Buffer[0] - (char *)lp1))
	 respnt->Bytes = V4DPI_PointHdr_Bytes + (&lp1->Buffer[0] - (char *)lp1) ;	/* Make sure min size */
	if (!v4ctx_FramePop(ctx,frameid,NULL)) { v_Msg(ctx,NULL,"ModCtxPopFrame",intmodx,frameid) ; goto fail ; } ;		/* Pop off frame context */
	return(respnt) ;

fail:	REGISTER_ERROR(0) ; return(NULL) ;
}
#endif

/*	v4im_DoEvalBL - Handles EvalBL() Module			*/

P *v4im_DoEvalBL(ctx,respnt,argcnt,argpnts,intmodx,trace)
  struct V4C__Context *ctx ;
  INTMODX intmodx ;
  P *respnt,*argpnts[] ;
  COUNTER argcnt ; VTRACE trace ;
{ P *ipt,*cpt,*tpt,*bpnt,*arg1st,ptbuf,isctbuf,lisctbuf ;
  struct V4DPI__EvalList *el ;
  struct V4L__ListPoint *lp1 ;
  int i,ix,flags,nth,num,ok ;

	arg1st = (ISQUOTED(argpnts[1]) ? UNQUOTEPTR(argpnts[1]) : argpnts[1]) ;
	if (arg1st->PntType != V4DPI_PntType_Isct ? TRUE : (arg1st)->Grouping > 0 && ISCT1STPNT(arg1st)->PntType == V4DPI_PntType_IntMod)
	 { v_Msg(ctx,NULL,"ModArgQIsct",intmodx,1) ; goto fail ; } ;
	nth = UNUSED ; num = UNUSED ; flags = 0 ;
	for(ok=TRUE,i=2;ok&&i<=argcnt;i++)			/* Step thru the remaining arguments */
	 { ipt = argpnts[i] ;
	   switch (v4im_CheckPtArgNew(ctx,argpnts[i],&cpt,NULL))
	    { default:				v_Msg(ctx,NULL,"TagBadUse",intmodx) ; goto fail ;
	      case V4IM_Tag_Unk:		v_Msg(ctx,NULL,"TagUnknown",intmodx) ; goto fail ;
	      case V4IM_Tag_Number:		num = v4im_GetPointInt(&ok,cpt,ctx) ; break ;
	      case V4IM_Tag_Nth:		nth = v4im_GetPointInt(&ok,cpt,ctx) ; break ;
	      case -V4IM_Tag_MatchUndef:	flags = V4DPI_EM_NoCTXisAll ; break ;
	    } ;
	 } ;
	if (!ok) { v_Msg(ctx,NULL,"ModInvArg",intmodx,i-1) ; goto fail ; } ;
	if (nth == UNUSED && num == UNUSED)
	 { ipt = &ptbuf ; ctx->bpm = ipt ;		/* Set pointer so EvalDoit does its thing */
	   tpt = v4dpi_IsctEval(&lisctbuf,arg1st,ctx,(V4DPI_EM_NoNest|V4DPI_EM_EvalQuote|V4DPI_EM_NoIsctFail)|flags,NULL,NULL) ;
	   ctx->bpm = NULL ;			/* Don't want to keep this on any longer than necessary */
	   if (tpt == NULL) { v_Msg(ctx,NULL,"ModArgEval",intmodx,1,arg1st) ; goto fail ; } ;
	   INITLP(respnt,lp1,Dim_List)
	   for(bpnt=ISCT1STPNT(ipt),ix=0;ix<ipt->Grouping;ix++,ADVPNT(bpnt))
	    { v4l_ListPoint_Modify(ctx,lp1,V4L_ListAction_AppendUnique,bpnt,0) ; } ;
	   ENDLP(respnt,lp1) return(respnt) ;
	 } ;
	el = (struct V4DPI__EvalList *)v4mm_AllocChunk(sizeof *el,TRUE) ;	/* Allocate bytes for multiple searches */
	el->Init = FALSE ; el->SkipCnt = 0 ; el->ReturnCnt = 0x7fff ;
	if (num > 0 && nth == UNUSED)
	 { INITLP(respnt,lp1,Dim_List)
	   for(i=0;i<num;i++)
	    { ipt = &ptbuf ; ctx->bpm = ipt ;		/* Set pointer so EvalDoit does its thing */
	      el->Init = FALSE ; el->SkipCnt = i ; el->ReturnCnt = 0x7fff ;
	      tpt = v4dpi_IsctEval(&isctbuf,arg1st,ctx,(V4DPI_EM_NoNest|V4DPI_EM_EvalQuote|V4DPI_EM_NoIsctFail)|flags,NULL,el) ;
	      ctx->bpm = NULL ;
	      if (tpt == NULL) break ;
	      for(bpnt=ISCT1STPNT(ipt),ix=0;ix<ipt->Grouping;ix++,ADVPNT(bpnt))
	       { v4l_ListPoint_Modify(ctx,lp1,V4L_ListAction_AppendUnique,bpnt,0) ; } ;
	    } ;
	   ENDLP(respnt,lp1) return(respnt) ;
	 } else
	if (nth > 0 && num == UNUSED)
	 { INITLP(respnt,lp1,Dim_List)
	   ipt = &ptbuf ; ctx->bpm = ipt ;		/* Set pointer so EvalDoit does its thing */
	   el->Init = FALSE ; el->SkipCnt = nth-1 ; el->ReturnCnt = 0x7fff ;
	   tpt = v4dpi_IsctEval(&isctbuf,arg1st,ctx,V4DPI_EM_NoNest+V4DPI_EM_EvalQuote+flags,NULL,el) ;
	   ctx->bpm = NULL ;
	   if (tpt == NULL) { v_Msg(ctx,NULL,"EvalBLNth",intmodx,V4IM_Tag_Nth,nth) ; goto fail ; } ;
	   for(bpnt=ISCT1STPNT(ipt),ix=0;ix<ipt->Grouping;ix++,ADVPNT(bpnt))
	    { v4l_ListPoint_Modify(ctx,lp1,V4L_ListAction_Append,bpnt,0) ; } ;
	   ENDLP(respnt,lp1) return(respnt) ;
	 } else { v_Msg(ctx,NULL,"EvalBNBoth",intmodx,num,nth) ; goto fail ; } ;

fail:	REGISTER_ERROR(0) ; return(NULL) ;
}

/*	v4im_DoDrawer - Handles Drawer() Module			*/

#define LCL_MasterDrawerCache_Max 250

struct lcl__MasterDrawerCache {
  int Count ;				/* Number in the cache */
  int NextDrawerId ;			/* Next available drawer id */
  struct {
   int Dim ;				/* Dimension Associated with this drawer */
   int Id ;				/* Unique Drawer Id */
   struct V4IM__Drawer *drw ;		/* Pointer to actual drawer structure */
  } Entry[LCL_MasterDrawerCache_Max] ;
} ;


static struct lcl__MasterDrawerCache *lmdc = NULL ; /* Global structure for drawer in-memory cache */

struct V4IM__Drawer *v4im_GetDrawerPtr(dim,id)
 int dim,id ;
{ int i ;

	if (lmdc == NULL) return(NULL) ;	/* Cache not initialized - no drw to be found */
	for(i=0;i<lmdc->Count;i++)
	 { if (lmdc->Entry[i].Dim == dim && lmdc->Entry[i].Id == id) return(lmdc->Entry[i].drw) ; } ;
	return(NULL) ;
} ;

struct V4IM__Drawer *v4im_ReallocDrawer(drw,drwIncSize)
  struct V4IM__Drawer *drw ;
  LENMAX drwIncSize ;
{ INDEX i ;

	for(i=0;i<lmdc->Count;i++) { if (lmdc->Entry[i].drw == drw) break ; } ;
	if (i >= lmdc->Count) return(NULL) ;	/* We should never get this because we get initial drw via lookup within this structure */
	drw->maxBytes += (drwIncSize == UNUSED ? V4IM_DrawerBufInc : drwIncSize) ;
	drw = (struct V4IM__Drawer *)realloc(drw,drw->maxBytes+drwIncSize) ;
	lmdc->Entry[i].drw = drw ;	/* Update master table with new address */
	return(drw) ;
} ;

P *v4im_DoDrawer(ctx,respnt,argcnt,argpnts,intmodx)
  struct V4C__Context *ctx ;
  INTMODX intmodx ;
  P *respnt,*argpnts[] ;
  COUNTER argcnt ;
{ P *cpt,*tpt,argpt ;
  struct V4IM__Drawer *drw ;
  struct V4L__ListPoint *lp ;
  struct V4L__ListDrawer *ldrw ;
  int ax,i,j,ok,dimid ; TAGVAL tx ;
#ifdef V4ENABLEMULTITHREADS
  static DCLSPINLOCK drwLock = UNUSEDSPINLOCKVAL ;
#endif
#define GETdrw \
 if (cpt->PntType != V4DPI_PntType_Drawer) { v_Msg(ctx,NULL,"ModArgPntType2",intmodx,ax,cpt->PntType,V4DPI_PntType_Drawer) ; goto fail ; } ; \
 drw = v4im_GetDrawerPtr(cpt->Dim,cpt->Value.IntVal) ; if (drw == NULL) goto no_drawer ;

	GRABMTLOCK(drwLock) ;
	if (lmdc == NULL) { lmdc = (struct lcl__MasterDrawerCache *)v4mm_AllocChunk(sizeof *lmdc,TRUE) ; } ;
	dimid = UNUSED ; drw = NULL ;
	for(ax=1,ok=TRUE;ok && ax<=argcnt;ax++)			/* Loop thru all arguments */
	 { switch (argpnts[ax]->PntType)
	    { default:
	      case V4DPI_PntType_Tag:		break ;		/* Handle tags below */
	      case V4DPI_PntType_Drawer:	drw = v4im_GetDrawerPtr(argpnts[ax]->Dim,argpnts[ax]->Value.IntVal) ; continue ;
	    }
	   FREEMTLOCK(drwLock) ;		/* Free lock in case argument below generates nested call to this module */
	   tx = v4im_CheckPtArgNew(ctx,argpnts[ax],&cpt,&argpt) ;
	   GRABMTLOCK(drwLock) ;
	   switch (tx)
	    { default:	    		v_Msg(ctx,NULL,"TagBadUse",intmodx) ; goto fail ;
	      case V4IM_Tag_Unk:	v_Msg(ctx,NULL,"TagUnknown",intmodx) ; goto fail ;
	      case V4IM_Tag_Add:
		if (drw == NULL) goto no_drawer ;
		if (drw->Bytes + cpt->Bytes >= drw->maxBytes) { drw = v4im_ReallocDrawer(drw,UNUSED) ; } ;
		tpt = (P *)&drw->DrawerBuf ;
		for(i=0;i<drw->Points;i++)	/* Position to end of drawer (also look to see if already there */
		 { if (memcmp(tpt,cpt,cpt->Bytes) == 0) { memcpy(respnt,cpt,cpt->Bytes) ; goto retok ; } ;
		   ADVPNT(tpt) ;
		 } ;
/*		Point not in drawer - add to end */
		memcpy(tpt,cpt,cpt->Bytes) ; drw->Bytes += cpt->Bytes ; drw->Points ++ ;
		memcpy(respnt,cpt,cpt->Bytes) ;
		continue ;
	      case V4IM_Tag_Create:
		dimid = v4dpi_DimShellDimId(&ok,ctx,cpt) ; if (!ok) { v_Msg(ctx,NULL,"ModFailed2",intmodx) ; goto fail ; } ;
		/* Just fall through to create drawer */
	      case -V4IM_Tag_Create:
		if (lmdc->Count >= LCL_MasterDrawerCache_Max)
		 { v_Msg(ctx,NULL,"DrawerMaxCache",intmodx,intmodx,LCL_MasterDrawerCache_Max) ; goto fail ; } ;
		if (dimid == UNUSED) dimid = Dim_UV4 ;
		ZPH(respnt) ; respnt->Dim = dimid ; respnt->PntType = V4DPI_PntType_Drawer ; respnt->Bytes = V4PS_Int ;
		respnt->Value.IntVal = lmdc->NextDrawerId++ ;
		lmdc->Entry[lmdc->Count].Dim = respnt->Dim ; lmdc->Entry[lmdc->Count].Id = respnt->Value.IntVal ;
		drw = (struct V4IM__Drawer *)v4mm_AllocChunk(V4IM_DrawerBufInit,FALSE) ;
/*		Set up key even though we aren't using it yet */
		drw->kp.fld.KeyType = V4IS_KeyType_V4 ; drw->kp.fld.KeyMode = V4IS_KeyMode_Int2 ;
		drw->kp.fld.Bytes = V4IS_Int2Key_Bytes ; drw->kp.fld.AuxVal = V4IS_SubType_Drawer ;
		drw->Dim = respnt->Dim ; drw->Id = respnt->Value.IntVal ; drw->Points = 0 ;
		drw->Bytes = (char *)&drw->DrawerBuf[0] - (char *)drw ; drw->maxBytes = V4IM_DrawerBufInit ;
		lmdc->Entry[lmdc->Count].drw = drw ;
		lmdc->Count++ ;
		goto retok ;
	      case V4IM_Tag_Dim:
		if (drw == NULL) goto no_drawer ;
		if (drw->Points == 0) { v_Msg(ctx,NULL,"DrawerEmpty",intmodx) ; goto fail ; } ;
		dimid = cpt->Value.IntVal ;
		tpt = (P *)drw->DrawerBuf ;
		INITLP(respnt,lp,Dim_List) ;
		for(i=1,j=0;i<=drw->Points;i++)
		 { if (tpt->Dim == dimid) 
		    { j++ ; if (j == 1) { memcpy(&argpt,tpt,tpt->Bytes) ; } ;		/* Save first match (to return if the only match) */
		      if (!v4l_ListPoint_Modify(ctx,lp,V4L_ListAction_Append,tpt,0)) { v_Msg(ctx,NULL,"LPModFail",intmodx) ; goto fail ; } ;
		    } ;
		   ADVPNT(tpt) ;
		 } ;
/*		If we just got one match then return it, otherwise return list */
		switch (j)
		 { default:	ENDLP(respnt,lp) ; break ;
		   case 1:	memcpy(respnt,&argpt,argpt.Bytes) ; break ;
		   case 0:	v_Msg(ctx,NULL,"DrawerNoDim",intmodx,dimid) ; goto fail ;
		 } ;
		goto retok ;
	      case V4IM_Tag_Empty:
		if (drw == NULL) goto no_drawer ;
		if (cpt->PntType == V4DPI_PntType_Logical)
		 { logPNTv(respnt,(cpt->Value.IntVal ? (drw->Points == 0) : (drw->Points != 0))) ;
		 } else if (cpt->PntType == V4DPI_PntType_Dict || cpt->PntType == V4DPI_PntType_XDict)
		 { switch (v4im_GetDictToEnumVal(ctx,cpt))
		    { default:		v_Msg(ctx,NULL,"DrawerOpt",intmodx,cpt,V4IM_Tag_Empty) ; goto fail ;
		      case _All:	drw->Bytes = (char *)&drw->DrawerBuf[0] - (char *)drw ; drw->Points = 0 ; logPNTv(respnt,TRUE) ; break ;
		    } ;
		 } ;
		continue ;
	      case -V4IM_Tag_Empty:
		if (drw == NULL) goto no_drawer ;
		logPNTv(respnt,(drw->Points == 0)) ; goto retok ;
	      case V4IM_Tag_Filter:
		if (drw == NULL) goto no_drawer ;
		if (drw->Points == 0) { v_Msg(ctx,NULL,"DrawerEmpty",intmodx) ; goto fail ; } ;
		tpt = (P *)drw->DrawerBuf ;
		INITLP(respnt,lp,Dim_List) ;
		{ P filter,*ipt ; LOGICAL fOK ; INDEX bytes,pBytes ;
		  memcpy(&filter,(ISQUOTED(cpt) ? UNQUOTEPTR(cpt) : cpt),cpt->Bytes) ;
		  
		  for(i=1;i<=drw->Points;i++)
		   { P okPnt ;
		     if (!v4ctx_FrameAddDim(ctx,0,tpt,0,0)) { v_Msg(ctx,NULL,"CtxAddFail",intmodx) ; goto fail ; } ;
		     ipt = v4dpi_IsctEval(&okPnt,&filter,ctx,V4DPI_EM_EvalQuote,NULL,NULL) ;
		     if (ipt == NULL) { v_Msg(ctx,ctx->ErrorMsgAux,"ModArgEval2",intmodx,&filter) ; goto fail ; } ;
		     fOK = v4im_GetPointLog(&ok,ipt,ctx) ; if (!ok) fOK = FALSE ;
		     if (!fOK) continue ;
		     if (!v4l_ListPoint_Modify(ctx,lp,V4L_ListAction_Append,tpt,0)) { v_Msg(ctx,NULL,"LPModFail",intmodx) ; goto fail ; } ;
		     pBytes = tpt->Bytes ;					/* Number of bytes in selected point */
/*		     Now remove point from Drawer */
		     bytes = ((char *)tpt + tpt->Bytes) - (char *)drw ; 	/* Bytes to end of tpt */
		     bytes = drw->Bytes - bytes ;				/* Number of bytes past end of tpt */
		     memcpy(tpt,(char *)tpt+tpt->Bytes,bytes) ;			/* Move points past tpt over tpt */
		     drw->Bytes -= pBytes ; drw->Points -- ;			/* Adjust size & number of drawer */
		   } ;
		}
		ENDLP(respnt,lp) ; goto retok ;
	      case V4IM_Tag_Has:
		if (drw == NULL) goto no_drawer ;
		tpt = (P *)drw->DrawerBuf ;
		for(i=1;i<=drw->Points;i++)
		 { if (memcmp(cpt,tpt,tpt->Bytes) == 0) { logPNTv(respnt,TRUE) ; goto retok ; } ;
		   ADVPNT(tpt) ;
		 } ;
		v_Msg(ctx,NULL,"DrawerPtNotFnd",intmodx,cpt) ; goto fail ;
	      case V4IM_Tag_Head:
		if (drw == NULL) goto no_drawer ;
		if (drw->Bytes + cpt->Bytes >= drw->maxBytes) { drw = v4im_ReallocDrawer(drw,UNUSED) ; } ;
		j = (char *)drw->DrawerBuf - (char *)drw ;	/* j = bytes in header */
		tpt = (P *)&drw->DrawerBuf ; memmove((char *)tpt + cpt->Bytes,tpt,drw->Bytes-j) ;
		memcpy(tpt,cpt,cpt->Bytes) ; drw->Bytes += cpt->Bytes ; drw->Points ++ ;
		memcpy(respnt,cpt,cpt->Bytes) ;
		continue ;
	      case -V4IM_Tag_Head:
		if (drw == NULL) goto no_drawer ; if (drw->Points == 0) { v_Msg(ctx,NULL,"DrawerEmpty",intmodx) ; goto fail ; } ;
		tpt = (P *)drw->DrawerBuf ; memcpy(respnt,tpt,tpt->Bytes) ; goto retok ;
	      case -V4IM_Tag_ListOf:
		if (drw == NULL) goto no_drawer ; goto lo_entry ;
	      case V4IM_Tag_ListOf:
		GETdrw ; if (drw->Points == 0) { v_Msg(ctx,NULL,"DrawerEmpty",intmodx) ; goto fail ; } ;
lo_entry:	
//		tpt = (P *)drw->DrawerBuf ;
//		INITLP(respnt,lp,Dim_List) ;
//		for(i=1;i<=drw->Points;i++)
//		 { if (!v4l_ListPoint_Modify(ctx,lp,V4L_ListAction_Append,tpt,0)) { v_Msg(ctx,NULL,"LPModFail",intmodx) ; goto fail ; } ;
//		   ADVPNT(tpt) ;
//		 } ;
//		ENDLP(respnt,lp) ; goto retok ;

		INITLP(respnt,lp,Dim_List) ; lp->ListType = V4L_ListType_Drawer ;
		ldrw = (struct V4L__ListDrawer *)&lp->Buffer ;
		ldrw->drw = drw ; ldrw->index = 1 ; ldrw->dPt = (P *)&drw->DrawerBuf[0] ;
		lp->Bytes = ((char *)&lp->Buffer - (char *)lp) + sizeof *ldrw ;
		lp->Entries = drw->Points ;
		ENDLP(respnt,lp) ; goto retok ;




	      case V4IM_Tag_Num:
	      case V4IM_Tag_Number:
		GETdrw ;
		intPNTv(respnt,drw->Points) ; goto retok ;
	      case -V4IM_Tag_Num:
	      case -V4IM_Tag_Number:
		if (drw == NULL) goto no_drawer ;
		intPNTv(respnt,drw->Points) ; goto retok ;
	      case V4IM_Tag_Pop:
		if (drw == NULL) goto no_drawer ; if (drw->Points == 0) { v_Msg(ctx,NULL,"DrawerEmpty",intmodx) ; goto fail ; } ;
		switch (v4im_GetDictToEnumVal(ctx,cpt))
		 { default:	v_Msg(ctx,NULL,"DrawerBadPop",intmodx,argpnts[ax]) ; goto fail ;
		   case _LIFO:	goto pop_lifo ;
		   case _FIFO:
			tpt = (P *)drw->DrawerBuf ; memcpy(respnt,tpt,tpt->Bytes) ;
			j = (char *)drw->DrawerBuf - (char *)drw ;	/* j = bytes in header */
			j = drw->Bytes - (j + tpt->Bytes) ;		/* j = bytes beyond head point */
			drw->Bytes -= tpt->Bytes ; drw->Points -- ;
			memcpy(tpt,(char *)tpt + tpt->Bytes,j) ;
			goto retok ;
		 } ; break ;
	      case -V4IM_Tag_Pop:
		if (drw == NULL) goto no_drawer ; if (drw->Points == 0) { v_Msg(ctx,NULL,"DrawerEmpty",intmodx) ; goto fail ; } ;
pop_lifo:	tpt = (P *)&drw->DrawerBuf ;
		for(i=0;i<drw->Points-1;i++)	/* Position to end of drawer */
		 { ADVPNT(tpt) ; } ;
		memcpy(respnt,tpt,tpt->Bytes) ;
		drw->Bytes -= tpt->Bytes ; drw->Points -- ;		/* Pop this point out of drawer */
		continue ;
	      case -V4IM_Tag_Delete:
	      case -V4IM_Tag_Remove:
		if (drw == NULL) goto no_drawer ;
		for(i=0,j=UNUSED;i<lmdc->Count;i++)
		 { if (lmdc->Entry[i].drw == drw) { j = i ; } ;
		   if (i <= j) continue ;
		   lmdc->Entry[j++] = lmdc->Entry[i] ;
		 } ;
		lmdc->Count-- ; v4mm_FreeChunk(drw) ;
		logPNTv(respnt,TRUE) ; goto retok ;
	      case (V4DPI_TagFlag_Colon3|V4IM_Tag_Delete):
	      case V4IM_Tag_Delete:
	      case (V4DPI_TagFlag_Colon3|V4IM_Tag_Remove):
	      case V4IM_Tag_Remove:
		if (drw == NULL) goto no_drawer ;
		if (drw->Points == 0)
		 { if (tx & V4DPI_TagFlag_Colon3) { logPNTv(respnt,FALSE) ; continue ; } ;
		   v_Msg(ctx,NULL,"DrawerEmpty",intmodx) ; goto fail ;
		 } ;
		tpt = (P *)&drw->DrawerBuf ;
		for(i=0;i<drw->Points;i++)				/* Look for point in drawer */
		 { if (memcmp(tpt,cpt,cpt->Bytes) != 0) { ADVPNT(tpt) ; continue ; } ;
		   j = ((char *)tpt + tpt->Bytes) - (char *)drw ;	/* j = bytes to end of tpt */
		   j = drw->Bytes - j ;					/* j = number of bytes past end of tpt */
		   memcpy(tpt,(char *)tpt+tpt->Bytes,j) ;		/* Move points past tpt over tpt */
		   drw->Bytes -= cpt->Bytes ; drw->Points -- ;
		   memcpy(respnt,&Log_True,Log_True.Bytes) ; continue ;
		 } ;
		if (tx & V4DPI_TagFlag_Colon3) { logPNTv(respnt,FALSE) ; continue ; } ;
		v_Msg(ctx,NULL,"DrawerPtNotFnd",intmodx,cpt) ; goto fail ;
	      case V4IM_Tag_Push:
	      case V4IM_Tag_Tail:
		if (drw == NULL) goto no_drawer ;
		if (drw->Bytes + cpt->Bytes >= drw->maxBytes) { drw = v4im_ReallocDrawer(drw,UNUSED) ; } ;
		tpt = (P *)&drw->DrawerBuf ;
//		for(i=0;i<drw->Points;i++)	/* Position to end of drawer (also look to see if already there */
//		 { ADVPNT(tpt) ; } ;
		tpt = (P *)((char *)drw + drw->Bytes) ;
//printf("%p %p %d\n",tpt,(char *)drw + drw->Bytes,drw->Bytes) ;
/*		Point not in drawer - add to end */
		memcpy(tpt,cpt,cpt->Bytes) ; drw->Bytes += cpt->Bytes ; drw->Points ++ ;
		memcpy(respnt,cpt,cpt->Bytes) ; continue ;
	      case -V4IM_Tag_Tail:
		if (drw == NULL) goto no_drawer ; if (drw->Points == 0) { v_Msg(ctx,NULL,"DrawerEmpty",intmodx) ; goto fail ; } ;
		tpt = (P *)&drw->DrawerBuf ;
		for(i=0;i<drw->Points-1;i++)	/* Position to end of drawer */
		 { ADVPNT(tpt) ; } ;
		memcpy(respnt,tpt,tpt->Bytes) ; goto retok ;
	    } ;
	 } ;
	if (!ok) { v_Msg(ctx,NULL,"ModInvArg",intmodx,ax-1) ; goto fail ; } ;

retok:	FREEMTLOCK(drwLock) ;
	return(respnt) ;

no_drawer:
	v_Msg(ctx,NULL,"DrawerNoneSpec",intmodx,argpnts[ax]) ; goto fail ;

fail:	FREEMTLOCK(drwLock) ;
	REGISTER_ERROR(0) ; return(NULL) ;
}


/*	v4im_DoNames - Handles Names() Module			*/

#define V4IM_NamesType_Western 0
#define V4IM_NamesType_Hispanic 1
#define V4IM_NamesType_Chinese 2
#define V4IM_NamesType_Russian 3
#define V4IM_NamesType_Arabic 4

enum CASEMODE { asis, upper, lower, capitalize } ;

P *v4im_DoNames(ctx,respnt,argcnt,argpnts,intmodx,trace)
  struct V4C__Context *ctx ;
  INTMODX intmodx ;
  P *respnt,*argpnts[] ;
  COUNTER argcnt ; VTRACE trace ;
{ P *cpt,*axpt, argpt ;
  struct V4CI__CountryInfo *ci ;
  int i,ax,ok,type,res,tagx,len,ntocinit,language,sx1,sx2,hasres ; UCCHAR tbuf[128],*b,*b1 ;
  UCCHAR namebuf[256],gname[128],midname[128],nickname[128],surname[128],suffix[128],title[128] ;
  UCCHAR delims[16] ; int spacedash ; enum CASEMODE cmode ;

#define GETCOMP(comp) \
 if (UCnotempty(comp)) { v_Msg(ctx,NULL,"ModArgOnce",intmodx) ; goto fail ; } ;\
 v4im_GetPointUC(&ok,comp,UCsizeof(comp),cpt,ctx) ; break ;
#define GETCOMP2(comp,strid) \
 v4im_GetPointUC(&ok,tbuf,UCsizeof(tbuf),cpt,ctx) ;\
 len = UCstrlen(tbuf) + UCstrlen(comp) + 2 ; if (len > UCsizeof(comp)) { v_Msg(ctx,ctx->ErrorMsgAux,"NamesCompTooBig",tagx,comp,len,UCsizeof(comp)) ; ok = FALSE ; break ; } ;\
 UCstrcat(comp,tbuf) ; UCstrcat(comp,strid) ; break ;
#define RETCOMP(comp) \
  if (UCempty(comp)) { v_Msg(ctx,NULL,"NamesNoComp",intmodx,res,namebuf) ; goto fail ; } ;\
  UCstrcpy(&respnt->Value.UCVal[1],v4im_NameCompRemoveCode(comp,TRUE)) ;\
  goto trimspaceandreturn ;


	ZUS(namebuf) ZUS(gname) ZUS(midname) ZUS(nickname) ZUS(surname) ZUS(suffix) ZUS(title) type = UNUSED ; res = UNUSED ;
	ntocinit = FALSE ; hasres = UNUSED ; cmode = asis ;
	for(ax=1,ok=TRUE;ok && ax<=argcnt;ax++)			/* Loop thru all arguments */
	 { axpt = argpnts[ax] ;
	   if (axpt->PntType == V4DPI_PntType_Char || axpt->PntType == V4DPI_PntType_UCChar)		/* Got just a string - then unformatted name */
	    { v4im_GetPointUC(&ok,namebuf,UCsizeof(namebuf),axpt,ctx) ; if (!ok) break ;
	      ci = gpi->ci ; language = ci->Cntry[ci->CurX].Language ;
	      if (!v4im_RawNameToComponents(ctx,namebuf,type,language,gname,midname,nickname,surname,suffix,title)) { ok = FALSE ; break ; } ;
	      ntocinit = TRUE ; continue ;
	    } ;
	   switch (tagx=v4im_CheckPtArgNew(ctx,axpt,&cpt,&argpt))
	    { default:	    		v_Msg(ctx,NULL,"TagBadUse",intmodx) ; goto fail ;
	      case V4IM_Tag_Unk:	v_Msg(ctx,NULL,"TagUnknown",intmodx) ; goto fail ;
	      case V4IM_Tag_Append:
		if (!ntocinit) { v4im_NameToComponents(FALSE,namebuf,&type,gname,midname,nickname,surname,suffix,title) ; ntocinit = TRUE ; } ;
		axpt = cpt ;
		switch (tagx=v4im_CheckPtArgNew(ctx,axpt,&cpt,&argpt))
		 { default:	    		v_Msg(ctx,NULL,"TagBadUse",intmodx) ; goto fail ;
		   case V4IM_Tag_Unk:		v_Msg(ctx,NULL,"TagUnknown",intmodx) ; goto fail ;
		   case V4IM_Tag_GivenName:	GETCOMP2(gname,UClit("#"))
		   case V4IM_Tag_Patronymic:
		   case V4IM_Tag_MiddleName:	GETCOMP2(midname,UClit("%"))
		   case V4IM_Tag_Name:		GETCOMP(namebuf)
		   case V4IM_Tag_NickName:	GETCOMP2(nickname,UClit("+"))
		   case V4IM_Tag_Surname:	GETCOMP2(surname,UClit("!"))
		   case V4IM_Tag_Suffix:	GETCOMP2(suffix,UClit("^"))
		   case V4IM_Tag_Title:		GETCOMP2(title,UClit("*"))
		 } ;
		break ;
	      case V4IM_Tag_GivenName:	GETCOMP2(gname,UClit("#"))
	      case V4IM_Tag_Has:
		if (hasres == FALSE) break ;	/* If already failed then don't keep trying */
		if (!ntocinit) { v4im_NameToComponents(FALSE,namebuf,&type,gname,midname,nickname,surname,suffix,title) ; ntocinit = TRUE ; } ;
		axpt = cpt ;

#define CMPUC(comp,strid)\
 v4im_GetPointUC(&ok,tbuf,UCsizeof(tbuf),cpt,ctx) ; if (!ok) goto end_parse ;\
 spacedash = FALSE ;\
 for(i=0;;i++) { tbuf[i] = UCTOUPPER(tbuf[i]) ; if (tbuf[i] == UClit(' ') || tbuf[i] == UClit('-')) spacedash = TRUE ; if (tbuf[i] == UCEOS) break ; } ; UCstrcat(tbuf,strid) ;\
 UCSTRTOUPPER(comp) ;\
 if (!spacedash) \
  { UCstrcpy(delims,strid) ; UCstrcat(delims,UClit(" -")) ; \
    for(b=comp,b1=b;b1!=NULL;b=b1+1) \
     { b1 = UCstrpbrk(b,delims) ; if (b1 != NULL) *b1 = (strid)[0] ; } ; \
  } ; \
 hasres = (UCstrstr(comp,tbuf) != NULL) ; break ;

		switch (tagx=v4im_CheckPtArgNew(ctx,axpt,&cpt,&argpt))
		 { default:	    		v_Msg(ctx,NULL,"TagBadUse",intmodx) ; goto fail ;
		   case V4IM_Tag_Unk:		v_Msg(ctx,NULL,"TagUnknown",intmodx) ; goto fail ;
		   case V4IM_Tag_GivenName:	CMPUC(gname,UClit("#"))
		   case V4IM_Tag_Patronymic:
		   case V4IM_Tag_MiddleName:	CMPUC(midname,UClit("%"))
		   case V4IM_Tag_NickName:	CMPUC(nickname,UClit("+"))
		   case V4IM_Tag_Surname:	CMPUC(surname,UClit("!"))
		   case V4IM_Tag_Suffix:	CMPUC(suffix,UClit("^"))
		   case V4IM_Tag_Title:		CMPUC(title,UClit("*"))
		 } ;
		break ;
	      case -V4IM_Tag_Capitalize:	cmode = capitalize ; break ;
	      case -V4IM_Tag_LC:		cmode = lower ; break ;
	      case -V4IM_Tag_UC:		cmode = upper ; break ;
	      case V4IM_Tag_Mask:
		if (!ntocinit) { v4im_NameToComponents(FALSE,namebuf,&type,gname,midname,nickname,surname,suffix,title) ; ntocinit = TRUE ; } ;
		{ UCCHAR fbuf[256], *fp, mbuf[256], comp[256] ; LOGICAL skip ; INDEX mx ; LENMAX len ;
		  
		  v4im_GetPointUC(&ok,mbuf,UCsizeof(mbuf),cpt,ctx) ; if (!ok) goto end_parse ;
		  for(skip=FALSE,fp=fbuf,mx=0;mbuf[mx]!=UCEOS;mx++)
		   { switch(mbuf[mx])
		      { default:		if (skip) continue ; *(fp++) = mbuf[mx] ; continue ;
		        case UClit('G'):	UCstrcpy(comp,gname) ; break ;
			case UClit('g'):	comp[0] = gname[0] ; comp[1] = UCEOS ; break ;
			case UClit('P'):	
			case UClit('M'):	UCstrcpy(comp,midname) ; break ;
			case UClit('p'):
			case UClit('m'):	comp[0] = midname[0] ; comp[1] = UCEOS ; break ;
			case UClit('N'):	UCstrcpy(comp,nickname) ; break ;
			case UClit('S'):	UCstrcpy(comp,surname) ; break ;
			case UClit('s'):	comp[0] = surname[0] ; comp[1] = UCEOS ; break ;
			case UClit('T'):	UCstrcpy(comp,title) ; break ;
			case UClit('X'):	UCstrcpy(comp,suffix) ; break ;
		      } ;
/*		     Append comp (component) to end of fbuf. If comp is empty then skip following formatting up until next letter */
		     if (UCempty(comp))
		      { UCCHAR prior = *(fp-1) ;		/* Get prior character, if one of the below then delete it */
		        if (prior == UClit('(') || prior == UClit('"') || prior == UClit('\'') || prior == UClit('[') || prior == UClit('{') || prior == UClit('<'))
			 { fp-- ; } ;
		        skip = TRUE ; continue ;
		      } ;
		     len = UCstrlen(comp) ; if (!vuc_IsLetter(comp[len-1])) { comp[len-1] = UCEOS ; len-- ; } ;
		     UCstrcpy(fp,comp) ; fp += len ;
		     skip = FALSE ;
		   } ;
		 
/*		 Get rid of any trailing spaces */
		 *fp = UCEOS ; UCstrcpy(&respnt->Value.UCVal[1],fbuf) ; goto trimspaceandreturn ;
		}

	      case V4IM_Tag_Patronymic:
	      case V4IM_Tag_MiddleName:	GETCOMP2(midname,UClit("%"))
	      case V4IM_Tag_Name:	GETCOMP(namebuf)
	      case V4IM_Tag_NickName:	GETCOMP2(nickname,UClit("+"))
	      case V4IM_Tag_Replace:
		if (!ntocinit) { v4im_NameToComponents(FALSE,namebuf,&type,gname,midname,nickname,surname,suffix,title) ; ntocinit = TRUE ; } ;
		axpt = cpt ;
		switch (tagx=v4im_CheckPtArgNew(ctx,axpt,&cpt,&argpt))
		 { default:	    		v_Msg(ctx,NULL,"TagBadUse",intmodx) ; goto fail ;
		   case V4IM_Tag_Unk:		v_Msg(ctx,NULL,"TagUnknown",intmodx) ; goto fail ;
		   case V4IM_Tag_GivenName:	ZS(gname) GETCOMP2(gname,UClit("#"))
		   case V4IM_Tag_Patronymic:
		   case V4IM_Tag_MiddleName:	ZS(midname) GETCOMP2(midname,UClit("%"))
		   case V4IM_Tag_NickName:	ZS(nickname) GETCOMP2(nickname,UClit("+"))
		   case V4IM_Tag_Surname:	ZS(surname) GETCOMP2(surname,UClit("!"))
		   case V4IM_Tag_Suffix:	ZS(suffix) GETCOMP2(suffix,UClit("^"))
		   case V4IM_Tag_Title:		ZS(title) GETCOMP2(title,UClit("*"))
		 } ;
		break ;
	      case V4IM_Tag_Soundex:
		if (hasres == FALSE) break ;	/* If already failed then don't keep trying */
		if (!ntocinit) { v4im_NameToComponents(FALSE,namebuf,&type,gname,midname,nickname,surname,suffix,title) ; ntocinit = TRUE ; } ;
		axpt = cpt ;

#define CMPSNDX(comp,strid)\
 v4im_GetPointUC(&ok,tbuf,UCsizeof(tbuf),cpt,ctx) ; if (!ok) goto end_parse ;\
 sx1 = v_Soundex(tbuf,NULL) ; hasres = FALSE ;\
 for(b=comp,b1=b;b1!=NULL;b=b1+1)\
  { b1 = UCstrchrV(b,strid) ; if (b1 != NULL) *b1 = UCEOS ; sx2 = v_Soundex(b,NULL) ;\
    if (sx1 == sx2) { hasres = TRUE ; break ; } ;\
  } ; break ;

		switch (tagx=v4im_CheckPtArgNew(ctx,axpt,&cpt,&argpt))
		 { default:	    		v_Msg(ctx,NULL,"TagBadUse",intmodx) ; goto fail ;
		   case V4IM_Tag_Unk:		v_Msg(ctx,NULL,"TagUnknown",intmodx) ; goto fail ;
		   case V4IM_Tag_GivenName:	CMPSNDX(gname,UClit('#'))
		   case V4IM_Tag_Patronymic:
		   case V4IM_Tag_MiddleName:	CMPSNDX(midname,UClit('%'))
		   case V4IM_Tag_NickName:	CMPSNDX(nickname,UClit('+'))
		   case V4IM_Tag_Surname:	CMPSNDX(surname,UClit('!'))
		   case V4IM_Tag_Suffix:	CMPSNDX(suffix,UClit('^'))
		   case V4IM_Tag_Title:		CMPSNDX(title,UClit('*'))
		 } ;
		break ;
	      case V4IM_Tag_Surname:	GETCOMP2(surname,UClit("!"))
	      case V4IM_Tag_Suffix:	GETCOMP2(suffix,UClit("^"))
	      case V4IM_Tag_Title:	GETCOMP2(title,UClit("*"))
	      case V4IM_Tag_Type:	type = v4im_GetPointInt(&ok,cpt,ctx) ; break ;

	      case -V4IM_Tag_Format:
	      case -V4IM_Tag_GivenName:
	      case -V4IM_Tag_Patronymic:
	      case -V4IM_Tag_MiddleName:
	      case -V4IM_Tag_Name:
	      case -V4IM_Tag_NickName:
	      case -V4IM_Tag_Sort:
	      case -V4IM_Tag_Surname:
	      case -V4IM_Tag_Suffix:
	      case -V4IM_Tag_Title:
	      case -V4IM_Tag_Type:	if (res != UNUSED) { v_Msg(ctx,NULL,"TagOnlyOneRes",intmodx) ; goto fail ; } ;
					res = tagx ; break ;
		break ;
	    } ;
	 } ;
end_parse:
	if (!ok) { v_Msg(ctx,NULL,"ModInvArg",intmodx,ax-1) ; goto fail ; } ;
	ZPH(respnt) ;
	if (hasres != UNUSED)		/* Do we have Has:: or Soundex::	result? */
	 { logPNTv(respnt,hasres) ; return(respnt) ; } ;
	switch (res)
	 { default:		v_Msg(ctx,NULL,"TagNoRes",intmodx) ; goto fail ;
	   case -V4IM_Tag_Format:
		if (!ntocinit) { v4im_NameToComponents(FALSE,namebuf,&type,gname,midname,nickname,surname,suffix,title) ; ntocinit = TRUE ; } ;
		if (type == UNUSED) type = V4IM_NamesType_Western ;
		b = &respnt->Value.UCVal[1] ; *b = UCEOS ;
#define CN(comp) if (UCstrlen(comp) > 0) { UCstrcat(b,v4im_NameCompRemoveCode(comp,TRUE)) ; } ;
		switch (type)
		 {
		   case V4IM_NamesType_Western:
		   case V4IM_NamesType_Hispanic:
		   case V4IM_NamesType_Russian:
		   case V4IM_NamesType_Arabic:
			CN(title) CN(gname) CN(midname) CN(surname) CN(suffix) ; break ;
		   case V4IM_NamesType_Chinese:
			CN(title) CN(surname) CN(midname) CN(gname) CN(suffix) ; break ;
		 } ;
		goto trimspaceandreturn ;
	   case -V4IM_Tag_GivenName:
		if (!ntocinit) v4im_NameToComponents(TRUE,namebuf,NULL,gname,NULL,NULL,NULL,NULL,NULL) ;
		RETCOMP(gname) ;
	   case -V4IM_Tag_Patronymic:
	   case -V4IM_Tag_MiddleName:
		if (!ntocinit) v4im_NameToComponents(TRUE,namebuf,NULL,NULL,midname,NULL,NULL,NULL,NULL) ;
		RETCOMP(midname) ;
	   case -V4IM_Tag_Name:
		b = &respnt->Value.UCVal[1] ; *b = UCEOS ;
		if (type != UNUSED) { UCsprintf(tbuf,UCsizeof(tbuf),UClit("%d!"),type) ; UCstrcat(b,tbuf) ; } ;
#define APND(comp) if (UCstrlen(comp) > 0) UCstrcat(b,comp) ;
		APND(title) APND(gname) APND(nickname) APND(midname) APND(surname) APND(suffix)
		uccharPNT(respnt) ; UCCHARPNTBYTES1(respnt) ; return(respnt) ;
	   case -V4IM_Tag_NickName:
		if (!ntocinit) v4im_NameToComponents(TRUE,namebuf,NULL,NULL,NULL,nickname,NULL,NULL,NULL) ;
		RETCOMP(nickname) ;
	   case -V4IM_Tag_Sort:
		if (!ntocinit) v4im_NameToComponents(TRUE,namebuf,NULL,gname,midname,NULL,surname,NULL,NULL) ;
		v4im_NameCompRemoveCode(gname,FALSE) ; v4im_NameCompRemoveCode(midname,FALSE) ; v4im_NameCompRemoveCode(surname,FALSE) ;
		b = namebuf ; b1 = surname ; for(;*b1!=UCEOS;b1++) { *(b++) = UCTOUPPER(*b1) ; } ;
		if (UCstrlen(gname) > 0) { *(b++) = UClit(' ') ; b1 = gname ; for(;*b1!=UCEOS;b1++) { *(b++) = UCTOUPPER(*b1) ; ; } ; } ;
		if (UCstrlen(midname) > 0) { *(b++) = UClit(' ') ; b1 = midname ; for(;*b1!=UCEOS;b1++) { *(b++) = UCTOUPPER(*b1) ; ; } ; } ;
		*b = UCEOS ; RETCOMP(namebuf) ;
	   case -V4IM_Tag_Surname:
		if (!ntocinit) v4im_NameToComponents(TRUE,namebuf,NULL,NULL,NULL,NULL,surname,NULL,NULL) ;
		RETCOMP(surname) ;
	   case -V4IM_Tag_Suffix:
		if (!ntocinit) v4im_NameToComponents(TRUE,namebuf,NULL,NULL,NULL,NULL,NULL,suffix,NULL) ;
		RETCOMP(suffix) ;
	   case -V4IM_Tag_Title:
		if (!ntocinit) v4im_NameToComponents(TRUE,namebuf,NULL,NULL,NULL,NULL,NULL,NULL,title) ;
		RETCOMP(title) ;
	   case -V4IM_Tag_Type:
		if (!ntocinit) v4im_NameToComponents(TRUE,namebuf,&type,gname,NULL,NULL,NULL,NULL,NULL) ;
		intPNTv(respnt,type) ; return(respnt) ;
	 } ;
	if (res == UNUSED) {  } ;

trimspaceandreturn:					/* Here to trim trailing space & return as string */
	len = UCstrlen(&respnt->Value.UCVal[1]) ;
	if (respnt->Value.UCVal[len] == UClit(' '))
	 respnt->Value.UCVal[len--] = UClit('0') ;		/* Get rid of trailing space */
	switch(cmode)
	 { case asis:		break ;
	   case capitalize:	{ UCCHAR *bp ; LOGICAL setCap ;
				  for(bp=&respnt->Value.UCVal[1],setCap=TRUE;*bp!=UCEOS;bp++)
				   { if (setCap) { *bp = UCTOUPPER(*bp) ; } else { *bp = UCTOLOWER(*bp) ; } ;
				     setCap = !vuc_IsAlphaNum(*bp) ;
				   } ;
				} break ;
	   case lower:		UCSTRTOLOWER(&respnt->Value.UCVal[1]) ; break ;
	   case upper:		UCSTRTOUPPER(&respnt->Value.UCVal[1]) ; break ;
	 } ;
	uccharPNT(respnt) ; UCCHARPNTBYTES2(respnt,len) ;
	return(respnt) ;

fail:	REGISTER_ERROR(0) ; return(NULL) ;
}

/*	v4im_NameCompRemoveCode - Removes punctuation codes from name component */
UCCHAR *v4im_NameCompRemoveCode(comp,mode)
  UCCHAR *comp ;				/* NOTE: comp IS UPDATED */
  LOGICAL mode ;
{ UCCHAR *fb,*tb, *s, *d ;

	if (mode)				/* If mode=TRUE then just replace with space */
	 { for(fb=comp;;fb=tb+1)
	    { tb = UCstrpbrk(fb,UClit("|!#%*^+")) ;
	      if (tb == NULL) return(comp) ;
	      *tb = UClit(' ') ;
	    } ;
	 } ;
/*	Here mode=FALSE, remove entirely (slower) */
	for(s=comp,d=comp;*s!=UCEOS;s++)
	 { switch (*s)
	    { default:		*(d++) = *s ; break ;
	      case UClit('|'):
	      case UClit('!'):
	      case UClit('#'):
	      case UClit('%'):
	      case UClit('*'):
	      case UClit('^'):
	      case UClit('+'):	break ;
	    } ;
	 } ;
	*d = UCEOS ;
	return(comp) ;
}

/*	v4im_NameToComponents - Updates components of name from internal format name in namebuf */

void v4im_NameToComponents(init,namebuf,type,gname,midname,nickname,surname,suffix,title)
 UCCHAR *namebuf,*gname,*midname,*nickname,*surname,*suffix,*title ;
 LOGICAL init ; int *type ;
{
  int savebyte ; UCCHAR *tb,*fb ;

#define ZC(buf) if (buf != NULL) *buf = UCEOS ;
	if (init) { ZC(gname) ZC(midname) ZC(nickname) ZC(surname) ZC(suffix) ZC(title) } ;
	for(fb=namebuf;;fb=tb+1)
	 { tb = UCstrpbrk(fb,UClit("|!#%*^+")) ;
	   if (tb == NULL) return ;
	   savebyte = *(tb+1) ; *(tb+1) = UCEOS ;
	   switch (*tb)
	    { case UClit('|'):		if (type != NULL) *type = *fb - UClit('0') ; break ;
	      case UClit('!'):		if (surname != NULL) UCstrcat(surname,fb) ; break ;	
	      case UClit('#'):		if (gname != NULL) UCstrcat(gname,fb) ; break ;
	      case UClit('%'):		if (midname != NULL) UCstrcat(midname,fb) ; break ;
	      case UClit('*'):		if (title != NULL) UCstrcat(title,fb) ; break ;
	      case UClit('^'):		if (suffix != NULL) UCstrcat(suffix,fb) ; break ;
	      case UClit('+'):		if (nickname != NULL) UCstrcat(nickname,fb) ; break ;
	    } ; *(tb+1) = savebyte ;
	 } ;
}

/*	v4im_RawNameToComponents - Converts printed name to components based on (assumed) type	*/
/*	Call: ok = v4im_RawNameToComponents(ctx,name,type,language,gname,midname,nickname,surname,suffix,title)
	  where ok is TRUE if ok, FALSE if problem (ctx->ErrorMsgAux has error),
		ctx is context,
		name is raw name to be parsed,
		type is assumed type of name (see V4IM_NamesType_xxx),
		language is the current environment language code in use,
		gname,midname,nickname,surname,suffix,title updated with appropriate components	*/

struct V4IM__NamesTitleSuffix {
  struct V4IM__NamesTitleSuffix *next ;		/* Pointer to next structure, NULL if end-of-line */
  int Language ;				/* Language Code */
  int NameStyle ;				/* Name style (see V4IM_NamesType_xxx) */
  UCCHAR TitleList[1024] ;			/* List of semi-colon delimited titles */
  UCCHAR ucTitleList[1024] ;			/*   upper case version */
  UCCHAR SuffixList[1024] ;			/* List of semi-colon delimited suffixes */
  UCCHAR ucSuffixList[1024] ;			/*   upper case version */
} ;

int v4im_RawNameToComponents(ctx,name,type,language,gname,midname,nickname,surname,suffix,title)
 struct V4C__Context *ctx ;
 UCCHAR *name,*gname,*midname,*nickname,*surname,*suffix,*title ;
 int type,language ;
{ UCCHAR *b,*b1,*sb,*cb,tbuf[1024] ; int len,len2,i,j,eos,line,ilang,itype,ts ;
  static struct V4IM__NamesTitleSuffix *nts1 = NULL ;
  struct UC__File UCFile ;
  struct V4IM__NamesTitleSuffix *nts ;
#ifdef V4ENABLEMULTITHREADS
  static DCLSPINLOCK rawLock = UNUSEDSPINLOCKVAL ;
#endif
#define TRIM(comp)\
 len = UCstrlen(comp)-1 ;\
 for(;len>0;len--) { if (comp[len] != UClit(' ')) break ; comp[len] = UCEOS ; } ;\
 if (comp[0] == UClit(' '))\
  { for(i=0,j=0;;i++) { if (j == 0 && comp[i] == UClit(' ')) continue ; comp[j++] = comp[i] ; if (comp[i] == UCEOS) break ; } ; } ;

/*	If first time then load up v4NamesInfo.v4i file */
	GRABMTLOCK(rawLock) ;
	if (nts1 == NULL)
	 { nts1 = (struct V4IM__NamesTitleSuffix *)v4mm_AllocChunk(sizeof *nts1,TRUE) ;
	   if (!v_UCFileOpen(&UCFile,v_GetV4HomePath(UClit("v4namesinfo.v4i")),UCFile_Open_Read,TRUE,ctx->ErrorMsgAux,V4IM_OpCode_Names))
	    { v_Msg(NULL,tbuf,"*V4InitFile",errno,v_GetV4HomePath(UClit("v4namesinfo.v4i"))) ; vout_UCText(VOUT_Warn,0,tbuf) ;
	      UCstrcpy(nts1->TitleList,UClit(";MR;MRS;MS;DR;SIR;")) ; UCstrcpy(nts1->SuffixList,UClit(";JR;II;III;3RD;MD;PHD;ESQ;")) ;
	      goto end_setup ;
	    } ; UCFile.wantEOL = FALSE ;
	   for(line=1;;line++)
	    { 
	      if ((len = v_UCReadLine(&UCFile,UCRead_UC,tbuf,UCsizeof(tbuf),ctx->ErrorMsgAux)) < 0) break ;
	      if (tbuf[0] == UClit('!') || tbuf[0] == UClit('/')) continue ;
	      if (len < 5) continue ;
	      b = UCstrchr(tbuf,'\t') ; if (b == NULL) goto init_err ;
	      *b = UCEOS ;
	      if (UCstrcmpIC(tbuf,UClit("TITLE")) == 0) { ts = 1 ; }
	       else if (UCstrcmpIC(tbuf,UClit("SUFFIX")) == 0) { ts = 2 ; }
	       else goto init_err ;
	      ilang = UCstrtol(b+1,&sb,10) ; if (*sb != UClit('\t')) goto init_err ; b = sb + 1 ;
	      itype = UCstrtol(b,&sb,10) ;  if (*sb != UClit('\t')) goto init_err ; b = sb + 1 ;
	      for(nts=nts1;nts!=NULL;nts=nts->next)	/* Find proper language/name-type */
	       { if (ilang == nts->Language && itype == nts->NameStyle) break ; } ;
	      if (nts == NULL)
	       { nts = (struct V4IM__NamesTitleSuffix *)v4mm_AllocChunk(sizeof *nts,TRUE) ;
	         nts->next = nts1 ; nts1 = nts ;
	       } ;
	      len2 = UCstrlen(b) ;
	      switch (ts)
	       { case 1:	/* Titles */
		   if ((len=UCstrlen(nts->TitleList)) == 0) UCstrcpy(nts->TitleList,UClit(";")) ;
		   if (b[len2-1] != UClit(';')) UCstrcat(b,UClit(";")) ;
		   if (len + len2 >= (UCsizeof(nts->TitleList)) - 5) goto init_err ;
		   UCstrcat(nts->TitleList,b) ; break ;
	         case 2:	/* Suffixes */
		   if ((len=UCstrlen(nts->SuffixList)) == 0) UCstrcpy(nts->SuffixList,UClit(";")) ;
		   if (b[len2-1] != ';') UCstrcat(b,UClit(";")) ;
		   if (len + len2 >= (UCsizeof(nts->SuffixList)) - 5) goto init_err ;
		   UCstrcat(nts->SuffixList,b) ; break ;
	       } ;
	     continue ;
init_err:    v_Msg(ctx,NULL,"*V4InitFileErr",line,"v4_home:v4namesinfo.v4i") ; vout_UCText(VOUT_Warn,0,ctx->ErrorMsg) ;
	     continue ;
	    } ;
	   v_UCFileClose(&UCFile) ;
	   for(nts=nts1;nts!=NULL;nts=nts->next)	/* Go thru & create upper case version */
	    { for(i=0;;i++) { nts->ucTitleList[i] = UCTOUPPER(nts->TitleList[i]) ; if (nts->TitleList[i] == UCEOS) break ; } ;
	      for(i=0;;i++) { nts->ucSuffixList[i] = UCTOUPPER(nts->SuffixList[i]) ; if (nts->SuffixList[i] == UCEOS) break ; } ;
	    }
	 } ;
end_setup:
	FREEMTLOCK(rawLock) ;
	if (type == UNUSED) type = V4IM_NamesType_Western ;
	for (nts=nts1;nts!=NULL;nts=nts->next)			/* Look for proper titles/suffix list */
	 { if (nts->Language == 0 && nts->NameStyle == type) break ; } ;
	if (nts == NULL) nts = nts1 ;
	switch (type)
	 { default:
	   case V4IM_NamesType_Western:
		if ((cb = UCstrchr(name,',')) != NULL)	/* If comma then assume: last, first middle */
		 { *cb = UCEOS ;
		   for(;;)
		    { TRIM(name) ; b = UCstrrchr(name,' ') ;		/* Start with last name */
		      if (b == NULL) break ;
		      *b = UCEOS ;					/* But first check for suffix */
		      tbuf[0] = UClit(';') ; for(j=1,i=1;b[i]!=UCEOS;i++) { if (b[i] != UClit('.')) tbuf[j++] = UCTOUPPER(b[i]) ; } ; tbuf[j++] = UClit(';') ; tbuf[j] = UCEOS ;
		      if ((b1=UCstrstr(nts->ucSuffixList,tbuf)) == NULL) break ;
		      i = b1 - nts->ucSuffixList ; len = UCstrlen(tbuf) - 2 ;
		      UCstrncpy(tbuf,&nts->SuffixList[i+1],len) ; tbuf[len] = UCEOS ;
		      UCstrcat(suffix,tbuf) ; UCstrcat(suffix,UClit("^")) ;	/* Got a suffix - try again for last name */
		    } ;
		   UCstrcpy(surname,name) ; UCstrcat(surname,UClit("!")) ;
		   sb = cb + 1 ; for(;;sb++) { if (*sb != UClit(' ')) break ; } ;
		   for(;;)
		    { TRIM(sb) ; b = UCstrchr(sb,' ') ;
		      if (b == NULL) break ;
		      *b = UCEOS ;
		      tbuf[0] = UClit(';') ; for(j=1,i=1;sb[i-1]!=UCEOS;i++) { if (sb[i-1] != UClit('.')) tbuf[j++] = UCTOUPPER(sb[i-1]) ; } ; tbuf[j++] = UClit(';') ; tbuf[j] = UCEOS ;
		      if ((b1=UCstrstr(nts->ucTitleList,tbuf)) == NULL) { *b = UClit(' ') ; break ; } ;
		      i = b1 - nts->ucTitleList ; len = UCstrlen(tbuf) - 2 ;
		      UCstrncpy(tbuf,&nts->TitleList[i+1],len) ; tbuf[len] = UCEOS ;
		      UCstrcat(title,tbuf) ; UCstrcat(title,UClit("*")) ;	/* Got a suffix - try again for last name */
		      sb = b + 1 ; *b = UClit(' ') ;
		    } ;
		   b = UCstrchr(sb,' ') ;
		   if (b == NULL) { b = UCstrchr(sb,'\0') ; eos = TRUE ; } else { *b = UCEOS ; eos = FALSE ; } ;
		   if (UCstrlen(sb) > 0)
		    { UCstrcpy(gname,sb) ; UCstrcat(gname,UClit("#")) ;
		      sb = (eos ? b : b+1) ;
		      for(;;sb++) { if (*sb != UClit(' ')) break ; } ; b = UCstrchr(sb,' ') ;
		    } ;
		   if (b == NULL) { b = UCstrchr(sb,'\0') ; eos = TRUE ; } else { *b = UCEOS ; eos = FALSE ; } ;
		   if (UCstrlen(sb) > 0)
		    { for(i=0,j=0;;i++) { if (sb[i] != UClit('.')) midname[j++] = sb[i] ; if (sb[i] == UCEOS) break ; } ;
		      midname[j++] = UCEOS ; UCstrcat(midname,UClit("%")) ;
		    } ;
		   return(TRUE) ;
		 } ;
/*		Name is in: "first middle last" format */
		for(;;)
		 { TRIM(name) ; b = UCstrrchr(name,' ') ;		/* Start with last name */
		   if (b == NULL) { UCstrcpy(surname,name) ; UCstrcat(surname,UClit("!")) ; return(TRUE) ; } ;
		   *b = UCEOS ;					/* But first check for suffix */
		   tbuf[0] = UClit(';') ; for(j=1,i=1;b[i]!=UCEOS;i++) { if (b[i] != UClit('.')) tbuf[j++] = UCTOUPPER(b[i]) ; } ; tbuf[j++] = UClit(';') ; tbuf[j] = UCEOS ;
		   if ((b1=UCstrstr(nts->ucSuffixList,tbuf)) == NULL) break ;
		   i = b1 - nts->ucSuffixList ; len = UCstrlen(tbuf) - 2 ;
		   UCstrncpy(tbuf,&nts->SuffixList[i+1],len) ; tbuf[len] = UCEOS ;
		   UCstrcat(suffix,tbuf) ; UCstrcat(suffix,UClit("^")) ;	/* Got a suffix - try again for last name */
		 } ;
		UCstrcpy(surname,b+1) ; UCstrcat(surname,UClit("!")) ;
		for(;;)
		 { TRIM(name) ; b = UCstrchr(name,' ') ;
		   if (b == NULL) { UCstrcpy(gname,name) ; UCstrcat(gname,UClit("#")) ; return(TRUE) ; } ;
		   *b = UCEOS ;
		   tbuf[0] = UClit(';') ; for(j=1,i=1;name[i-1]!=UCEOS;i++) { if (name[i-1] != UClit('.')) tbuf[j++] = UCTOUPPER(name[i-1]) ; } ; tbuf[j++] = UClit(';') ; tbuf[j] = UCEOS ;
		   if ((b1=UCstrstr(nts->ucTitleList,tbuf)) == NULL) break ;
		   i = b1 - nts->ucTitleList ; len = UCstrlen(tbuf) - 2 ;
		   UCstrncpy(tbuf,&nts->TitleList[i+1],len) ; tbuf[len] = UCEOS ;
		   UCstrcat(title,tbuf) ; UCstrcat(title,UClit("*")) ;	/* Got a suffix - try again for last name */
		   name = b + 1 ;
		 } ;
		UCstrcpy(gname,name) ; UCstrcat(gname,UClit("#")) ;
		sb = b + 1 ; for(;;sb++) { if (*sb != UClit(' ')) break ; } ;
                b ++ ; TRIM(b) ;
                if ((len=UCstrlen(b)) > 0)
                 { if (b[len-1] == UClit('.')) b[len-1] = UCEOS ;
                   if (UCstrlen(sb) > 0)
                    { for(i=0,j=0;;i++) { if (sb[i] != UClit('.')) midname[j++] = sb[i] ; if (sb[i] == UCEOS) break ; } ;
                      midname[j++] = UCEOS ; UCstrcat(midname,UClit("%")) ;
                    } ;
                 } ;
                return(TRUE) ;
	   case V4IM_NamesType_Hispanic:
	   case V4IM_NamesType_Russian:
	   case V4IM_NamesType_Arabic:
	   case V4IM_NamesType_Chinese:
		v_Msg(ctx,ctx->ErrorMsgAux,"NamesTypeNYI",type) ; return(FALSE) ;
	 } ;
}


/*	v4imu_NestToModule - Calls another module to finish processing argument of current module */
/*	Call: point = v4imu_NestToModule( ctx , respnt , argcnt , argpnts , ix , intmodx , nestproc , nestintmodx )
	  where point is result, NULL if failure,
		ctx is context,
		respnt is current result & to become first point of nested module argument,
		argcnt is current module argument count,
		argpnts is current module argument list,
		ix is index to next (unprocessed) argument (to become 2nd argument in nested module),
		intmodx is current module,
		nestproc is nested procedure to handle module,
		nestintmodx is V4 opcode of nested module						*/

P *v4imu_NestToModule(ctx,respnt,argcnt,argpnts,ix,intmodx,nestproc,nestintmodx)
  struct V4C__Context *ctx ;
  P *respnt,*argpnts[] ;
  int argcnt,ix,intmodx ;
  P *nestproc() ;
  int nestintmodx ;
{ P argpnt, *ipt ;
  struct V4DPI__Point *argpntsx[V4DPI_IntModArg_Max] ;
  int i,argcntx = 0 ;

	memcpy(&argpnt,respnt,respnt->Bytes) ;	/* Copy result into temp */
	argpntsx[++argcntx] = &argpnt ;		/* First argument */
	for(i=ix;i<=argcnt;i++) { argpntsx[++argcntx] = argpnts[i] ; } ;
	if ((ipt = nestproc(ctx,respnt,&argpntsx,argcntx,V4IM_OpCode_List)) == NULL)
	 { 
	   return(NULL) ;
	 } ;
	return(ipt) ;
}


P *v4im_DoEval(ctx,respnt,argcnt,argpnts,intmodx,trace)
  struct V4C__Context *ctx ;
  P *respnt,*argpnts[] ;
  int argcnt,intmodx,trace ;
{ P *ipt,*cpt, isctbuf ;
  struct V4DPI__EvalList *el ;
  struct V4L__ListPoint *lp ;
  INDEX i,nth ; FLAGS32 flags ; LOGICAL ok,random,listof,nest ;
#define MAXONRANDOM 64

	listof = FALSE ; nest = TRUE ; nth = UNUSED ; flags = 0 ; random = FALSE ;
	for(ok=TRUE,i=2;ok&&i<=argcnt;i++)			/* Step thru the remaining arguments */
	 { ipt = argpnts[i] ;
	   switch (v4im_CheckPtArgNew(ctx,argpnts[i],&cpt,NULL))
	    { default:				v_Msg(ctx,NULL,"TagBadUse",intmodx) ; goto fail ;
	      case V4IM_Tag_Unk:		v_Msg(ctx,NULL,"TagUnknown",intmodx) ; goto fail ;
	      case -V4IM_Tag_All:
	      case -V4IM_Tag_ListOf:		listof = TRUE ; break ;
	      case -V4IM_Tag_MatchUndef:	flags = V4DPI_EM_NoCTXisAll ; break ;
	      case V4IM_Tag_Nest:
		if (gpi->RestrictionMap & V_Restrict_EvalNest) { v_Msg(ctx,NULL,"RestrictMod",intmodx) ; goto fail ; } ;
		nest = v4im_GetPointLog(&ok,cpt,ctx) ; break ;
	      case V4IM_Tag_Nth:		nth = v4im_GetPointInt(&ok,cpt,ctx) ; break ;
	      case -V4IM_Tag_Random:		random = TRUE ; break ;
	    } ;
	 } ;
	if (!ok) { v_Msg(ctx,NULL,"ModInvArg",intmodx,i-1) ; goto fail ; } ;

	el = (struct V4DPI__EvalList *)v4mm_AllocChunk(sizeof *el,TRUE) ;	/* Allocate bytes for multiple searches */
	el->Init = FALSE ; el->SkipCnt = 0 ; el->ReturnCnt = 0x7fff ;
	if (random)
	 { COUNTER bindWgt = 0 ;
	   struct V4DPI__Point *rArray[MAXONRANDOM] ;
	   for(i=0;i<MAXONRANDOM;i++)
	    { el->Init = FALSE ; el->SkipCnt = i ; el->ReturnCnt = 0x7fff ;
	      ipt = v4dpi_IsctEval(&isctbuf,argpnts[1],ctx,flags|V4DPI_EM_EvalQuote|V4DPI_EM_NoNest,NULL,el) ;
	      if (ipt == NULL) break ;				/* All done - quit with what we got */
	      if (bindWgt == 0) bindWgt = el->bindWgt ;
	      if (el->bindWgt < bindWgt) break ;
	      rArray[i] = (P *)v4mm_AllocChunk(ipt->Bytes,FALSE) ; memcpy(rArray[i],ipt,ipt->Bytes) ;
//v_Msg(ctx,NULL,"@*i=%1d, wgt=%2d, returns=%3P\n",i,bindWgt,ipt) ; vout_UCText(VOUT_Trace,0,ctx->ErrorMsg) ;
	    } ;
	   if (i == 0) return(NULL) ;
	   if (i == 1) { ipt = rArray[0] ; }
	    else { UB64INT random = vRan64_RandomU64() ;
		   nth = random % i ;
		   ipt = rArray[nth] ;
		 } ;
//v_Msg(ctx,NULL,"@*nth=%1d -> %2P\n",nth,rArray[nth]) ; vout_UCText(VOUT_Trace,0,ctx->ErrorMsg) ;
	   if (ipt->PntType == V4DPI_PntType_Isct || ipt->PntType == V4DPI_PntType_Special)
	    { ipt = v4dpi_IsctEval(respnt,ipt,ctx,flags + V4DPI_EM_EvalQuote,NULL,NULL) ;
	      if (ipt == NULL) goto fail ;
	      memcpy(respnt,ipt,ipt->Bytes) ;
	    } else
	    { memcpy(respnt,ipt,rArray[nth]->Bytes) ;
	    } ;
	   for(i--;i>=0;i--) { v4mm_FreeChunk(rArray[i]) ; } ;
	   return(respnt) ;
	 } ;
	if (listof)
	 { INITLP(respnt,lp,Dim_List)
	   for(i=0;;i++)
	    { el->Init = FALSE ; el->SkipCnt = i ; el->ReturnCnt = 0x7fff ;
	      ipt = v4dpi_IsctEval(&isctbuf,argpnts[1],ctx,flags + V4DPI_EM_EvalQuote+(nest ? 0 : V4DPI_EM_NoNest),NULL,el) ;
	      if (ipt == NULL) break ;				/* All done - quit with what we got */
	      if (!v4l_ListPoint_Modify(ctx,lp,V4L_ListAction_Append,ipt,0)) { v_Msg(ctx,NULL,"LPModFail",intmodx) ; goto fail ; } ;
	    } ;
	   if (i == 0) { v_Msg(ctx,NULL,"EvalNoEval",intmodx,argpnts[1]) ; goto fail ; } ;
	   ENDLP(respnt,lp) return(respnt) ;
	 } ;

	if (nth == UNUSED) nth = 1 ;
	el->SkipCnt = nth - 1 ;
	ipt = v4dpi_IsctEval(respnt,argpnts[1],ctx,flags + V4DPI_EM_EvalQuote+(nest ? 0 : V4DPI_EM_NoNest),NULL,el) ;
	return(ipt) ;

fail:	REGISTER_ERROR(0) ; return(NULL) ;
}


P *v4im_DoDim(ctx,respnt,argcnt,argpnts,intmodx,trace)
  struct V4C__Context *ctx ;
  P *respnt,*argpnts[] ;
  int argcnt,intmodx,trace ;
{ P *cpt, *tpt, isctbuf ; struct V4DPI__LittlePoint litpt ;
  struct V4DPI__DimInfo *di,ndi,*dix ;
  struct V4L__ListPoint *lp ;
  int i,ok,ix,setType,ymdo,tz,rtype ; UCCHAR utbuf[200] ;

#define SETFLAG(flag) if (v4im_GetPointLog(&ok,cpt,ctx)) { di->Flags |= V4DPI_DimInfo_##flag ; } else { di->Flags &= ~(V4DPI_DimInfo_##flag) ; } ;
#define RETFLAG(flag) logPNTv(respnt,(di->Flags & V4DPI_DimInfo_##flag)!=0) ; return(respnt) ;

#define SETFLAGa(flag,type) \
 if (!(di->PointType == V4DPI_PntType_Char || di->PointType == V4DPI_PntType_UCChar || di->PointType == V4DPI_PntType_BigText)) { v_Msg(ctx,NULL,"DimInvOption1",intmodx,type,di->PointType) ; goto fail ; } ; \
 if (v4im_GetPointLog(&ok,cpt,ctx)) { di->ds.Alpha.aFlags |= V4DPI_DimInfoAlpha_##flag ; } else { di->ds.Alpha.aFlags &= ~(V4DPI_DimInfoAlpha_##flag) ; } ;
#define RETFLAGa(flag) logPNTv(respnt,((di->PointType == V4DPI_PntType_Char || di->PointType == V4DPI_PntType_UCChar || di->PointType == V4DPI_PntType_BigText) && ((di->ds.Alpha.aFlags & V4DPI_DimInfoAlpha_##flag)!=0))) ; return(respnt) ;

#define SETFLAGl(flag,type) \
 if (di->PointType != V4DPI_PntType_List) { v_Msg(ctx,NULL,"DimInvOption1",intmodx,type,di->PointType) ; goto fail ; } ; \
 if (v4im_GetPointLog(&ok,cpt,ctx)) { di->ds.List.lFlags |= V4DPI_DimInfoList_##flag ; } else { di->ds.List.lFlags &= ~(V4DPI_DimInfoList_##flag) ; } ;
#define RETFLAGl(flag) logPNTv(respnt,(di->PointType == V4DPI_PntType_List && ((di->ds.List.lFlags & V4DPI_DimInfoList_##flag)!=0))) ; return(respnt) ;

#define USETFLAG(flag) if (!v4im_GetPointLog(&ok,cpt,ctx)) { di->Flags |= V4DPI_DimInfo_##flag ; } else { di->Flags &= ~(V4DPI_DimInfo_##flag) ; } ; break ;
#define URETFLAG(flag) logPNTv(respnt,(di->Flags & V4DPI_DimInfo_##flag)==0) ; return(respnt) ;

#define SETrtFLAG(flag) if (v4im_GetPointLog(&ok,cpt,ctx)) { di->rtFlags |= V4DPI_rtDimInfo_##flag ; } else { di->rtFlags &= ~(V4DPI_rtDimInfo_##flag) ; } ;
#define RETrtFLAG(flag) logPNTv(respnt,(di->rtFlags & V4DPI_rtDimInfo_##flag)!=0) ; return(respnt) ;
//#define USETrtFLAG(flag) if (!v4im_GetPointLog(&ok,cpt,ctx)) { di->rtFlags |= V4DPI_rtDimInfo_##flag ; } else { di->rtFlags &= ~(V4DPI_rtDimInfo_##flag) ; } ; break ;
//#define URETrtFLAG(flag) logPNTv(respnt,(di->rtFlags & V4DPI_rtDimInfo_##flag)==0) ; return(respnt) ;

	ok=TRUE ; setType = FALSE ;
/*	If only one argument then just return the dimension of it */
	if (argcnt == 1)
	 { 
	   DIMINFO(di,ctx,argpnts[1]->Dim) ;
	   if (di->PointType == V4DPI_PntType_Shell && argpnts[1]->PntType == V4DPI_PntType_Special && argpnts[1]->Grouping == V4DPI_Grouping_Current)
	    { DIMVAL(tpt,ctx,argpnts[1]->Dim) ; argpnts[1] = tpt ; } ;
	   dictPNTv(respnt,Dim_Dim,(argpnts[1]->PntType == V4DPI_PntType_Isct ? Dim_Isct : argpnts[1]->Dim)) ;
	   return(respnt) ;
	 } ;
/*	First argument might be a dimension name */
	if (argpnts[1]->Dim == Dim_Dim) { DIMINFO(di,ctx,argpnts[1]->Value.IntVal) ; memcpy(respnt,argpnts[1],argpnts[1]->Bytes) ; }
	 else { 
/*		Look at next argument - if tag? then want info on dimension, if not then creating a dimension & first arg is name of the dimension */
		if (v4im_CheckPtArgNew(ctx,argpnts[2],&cpt,NULL) < 0)
		 { DIMINFO(di,ctx,argpnts[1]->Dim) ;
		 } else
		 { memset(&ndi,0,sizeof ndi) ; di = &ndi ; di->DictType = V4DPI_DictType_Ext ;
		   v4im_GetPointUC(&ok,di->DimName,UCsizeof(di->DimName),argpnts[1],ctx) ;
		 } ;
	      } ;
	for(ix=2;ok&&ix<=argcnt;ix++)			/* Step thru the remaining arguments */
	 { 
	   switch (v4im_CheckPtArgNew(ctx,argpnts[ix],&cpt,&isctbuf))
	    { default:				v_Msg(ctx,NULL,"TagBadUse",intmodx) ; goto fail ;
	      case V4IM_Tag_Unk:		v_Msg(ctx,NULL,"TagUnknown",intmodx) ; goto fail ;
	      case V4IM_Tag_Acceptor:		SETFLAG(Acceptor) ;
	      case -V4IM_Tag_Acceptor:		RETFLAG(Acceptor) ; break ;
	      case V4IM_Tag_ADPoint:		if (cpt->Bytes > sizeof di->ADPnt) { v_Msg(ctx,NULL,"DimTooBig",intmodx,cpt) ; goto fail ; } ;
						v4dpi_PointToString(utbuf,cpt,ctx,V4DPI_FormatOpt_ShowDim) ;
						if (UCstrlen(utbuf) > UCsizeof(di->ADPntStr)-1) { v_Msg(ctx,NULL,"DimTooBig",intmodx,cpt) ; goto fail ; } ;
						UCstrcpy(di->ADPntStr,utbuf) ; memcpy(&di->ADPnt,cpt,cpt->Bytes) ; break ;
	      case -V4IM_Tag_ADPoint:		if (di->ADPnt.Bytes == 0) { v_Msg(ctx,NULL,"DimNotSet",intmodx,V4IM_Tag_ADPoint,di->DimId) ; goto fail ; } 
						memcpy(respnt,&di->ADPnt,di->ADPnt.Bytes) ; return(respnt) ;
	      case V4IM_Tag_All:		di->AllValue = v4im_GetPointInt(&ok,cpt,ctx) ; break ;
	      case -V4IM_Tag_All:		if (di->AllValue == 0) { v_Msg(ctx,NULL,"DimNotSet",intmodx,V4IM_Tag_All,di->DimId) ; goto fail ; } 
						intPNTv(respnt,di->AllValue) ; return(respnt) ;
	      case V4IM_Tag_AsIs:		SETFLAGa(AsIs,V4IM_Tag_AsIs) ; break ;
	      case -V4IM_Tag_AsIs:		RETFLAGa(AsIs) ;
	      case V4IM_Tag_Attributes:		v4im_GetPointUC(&ok,di->Attributes,UCsizeof(di->Attributes),cpt,ctx) ; break ;
	      case -V4IM_Tag_Attributes:	if (di->Attributes[0] == UCEOS) { v_Msg(ctx,NULL,"DimNotSet",intmodx,V4IM_Tag_Attributes,di->DimId) ; goto fail ; } 
						uccharPNTv(respnt,di->Attributes) ; return(respnt) ;
	      case V4IM_Tag_BaseDate:		if (di->PointType != V4DPI_PntType_UWeek) { v_Msg(ctx,NULL,"DimInvOption",intmodx,V4IM_Tag_UWeek,V4DPI_PntType_UWeek,di->PointType) ; goto fail ; } ;
						if (cpt->PntType != V4DPI_PntType_UDate) { v_Msg(ctx,NULL,"ModArgPntType2",intmodx,ix,cpt->PntType,V4DPI_PntType_UDate) ; goto fail ; } ;
						di->ds.UWeek.baseUDate = cpt->Value.IntVal ; break ;
	      case -V4IM_Tag_BaseDate:		if (di->PointType != V4DPI_PntType_UWeek) { v_Msg(ctx,NULL,"DimInvOption",intmodx,V4IM_Tag_UWeek,V4DPI_PntType_UWeek,di->PointType) ; goto fail ; } ;
						intPNTv(respnt,di->ds.UWeek.baseUDate) ; respnt->Dim = Dim_UDate ; respnt->PntType = V4DPI_PntType_UDate ; return(respnt) ;
	      case V4IM_Tag_BindEval:		SETFLAG(BindEval) ; break ;
	      case -V4IM_Tag_BindEval:		RETFLAG(BindEval) ;
	      case V4IM_Tag_Binding:		di->BindList = v4im_GetPointInt(&ok,cpt,ctx) ; break ;
	      case -V4IM_Tag_Binding:		intPNTv(respnt,di->BindList) ; return(respnt) ;
	      case V4IM_Tag_Calendar:		if (di->PointType != V4DPI_PntType_Calendar) { v_Msg(ctx,NULL,"DimInvOption",intmodx,V4IM_Tag_Calendar,V4DPI_PntType_Calendar,di->PointType) ; goto fail ; } ;
						switch (v4im_GetDictToEnumVal(ctx,cpt))
						 { default:		ok = FALSE ; v_Msg(ctx,ctx->ErrorMsgAux,"CalInvTkn1",intmodx,cpt) ; break ;
						   case _Gregorian:	di->ds.Cal.CalendarType = VCAL_CalType_Gregorian ; break ;
						   case _Julian:	di->ds.Cal.CalendarType = VCAL_CalType_Julian ; break ;
						   case _Islamic:	di->ds.Cal.CalendarType = VCAL_CalType_Islamic ; break ;
						   case _ISO:		di->ds.Cal.CalendarType = VCAL_CalType_ISO ; break ;
						   case _Hebrew:	di->ds.Cal.CalendarType = VCAL_CalType_Hebrew ; break ;
						   case _Chinese:	di->ds.Cal.CalendarType = VCAL_CalType_Chinese ; break ;
						   case _Hindu:		di->ds.Cal.CalendarType = VCAL_CalType_Hindu ; break ;
						 } ;
						break ;
	      case -V4IM_Tag_Calendar:		if (di->PointType != V4DPI_PntType_Calendar) { v_Msg(ctx,NULL,"DimInvOption",intmodx,V4IM_Tag_Calendar,V4DPI_PntType_Calendar,di->PointType) ; goto fail ; } ;
						switch (di->ds.Cal.CalendarType)
						 {
						   case VCAL_CalType_Gregorian:	respnt->Value.IntVal = v4im_GetEnumToDictVal(ctx,DE(Gregorian),Dim_UV4) ; break ;
						   case VCAL_CalType_Julian:	respnt->Value.IntVal = v4im_GetEnumToDictVal(ctx,DE(Julian),Dim_UV4) ; break ;
						   case VCAL_CalType_Islamic:	respnt->Value.IntVal = v4im_GetEnumToDictVal(ctx,DE(Islamic),Dim_UV4) ; break ;
						   case VCAL_CalType_ISO:	respnt->Value.IntVal = v4im_GetEnumToDictVal(ctx,DE(ISO),Dim_UV4) ; break ;
						   case VCAL_CalType_Hebrew:	respnt->Value.IntVal = v4im_GetEnumToDictVal(ctx,DE(Hebrew),Dim_UV4) ; break ;
						   case VCAL_CalType_Chinese:	respnt->Value.IntVal = v4im_GetEnumToDictVal(ctx,DE(Chinese),Dim_UV4) ; break ;
						   case VCAL_CalType_Hindu:	respnt->Value.IntVal = v4im_GetEnumToDictVal(ctx,DE(Hindu),Dim_UV4) ; break ;
						 } ; dictPNT(respnt,Dim_UV4) ; return(respnt) ;
	      case V4IM_Tag_Create:		USETFLAG(NoAutoCreate) ; break ;
	      case -V4IM_Tag_Create:		URETFLAG(NoAutoCreate) ;
	      case V4IM_Tag_Decimals:		di->Decimals = v4im_GetPointInt(&ok,cpt,ctx) ;
						if (di->Decimals < 0 || di->Decimals > V4DPI_Fixed_MaxDecimals)
						 { v_Msg(ctx,NULL,"DimDecNum",intmodx,V4IM_Tag_Decimals,di->Decimals,0,V4DPI_Fixed_MaxDecimals) ; goto fail ; } ;
						if (di->OutFormat[0] == UCEOS)		/* No format specified (yet) ? */
						 UCsprintf(di->OutFormat,UCsizeof(di->OutFormat),UClit("%%#.%df"),di->Decimals) ;
						break ;
	      case -V4IM_Tag_Decimals:		intPNTv(respnt,di->Decimals) ; return(respnt) ;
	      case V4IM_Tag_Description:	v4im_GetPointUC(&ok,di->Desc,UCsizeof(di->Desc),cpt,ctx) ; break ;
	      case -V4IM_Tag_Description:	uccharPNTv(respnt,di->Desc) ; return(respnt) ;
	      case V4IM_Tag_Displayer:		SETFLAG(Displayer) ; break ;
	      case -V4IM_Tag_Displayer:		RETFLAG(Displayer) ;
	      case V4IM_Tag_DisplayerTrace:	SETFLAG(DisplayerTrace) ; break ;
	      case -V4IM_Tag_DisplayerTrace:	RETFLAG(DisplayerTrace) ;
	      case V4IM_Tag_DotDotToList:	SETFLAG(DotDotToList) ; break ;
	      case -V4IM_Tag_DotDotToList:	RETFLAG(DotDotToList) ;
	      case V4IM_Tag_DotIndex:		SETFLAG(DotIndex) ; break ;
	      case -V4IM_Tag_DotIndex:		RETFLAG(DotIndex) ;
	      case V4IM_Tag_DotList:		SETFLAG(DotList) ; break ;
	      case -V4IM_Tag_DotList:		RETFLAG(DotList) ;
	      case V4IM_Tag_Duplicate:		USETFLAG(IsSet) ; break ;
	      case -V4IM_Tag_Duplicate:		URETFLAG(IsSet) ;
	      case V4IM_Tag_Entries:		if (cpt->Dim != Dim_Dim) { v_Msg(ctx,NULL,"ModArgNotDim",intmodx,ix,cpt) ; goto fail ; } ;
						di->ListDimId = cpt->Value.IntVal ; break ;
	      case -V4IM_Tag_Entries:		if (di->ListDimId == 0) { v_Msg(ctx,NULL,"DimNotSet",intmodx,V4IM_Tag_Entries,di->DimId) ; goto fail ; } ;
						dictPNTv(respnt,Dim_Dim,di->ListDimId) ; return(respnt) ;
	      case V4IM_Tag_FileName:		SETFLAGa(IsFileName,V4IM_Tag_FileName) ; break ;
	      case -V4IM_Tag_FileName:		RETFLAGa(IsFileName) ;
	      case V4IM_Tag_XML:		SETFLAGa(XMLOK,V4IM_Tag_XML) ; break ;
	      case -V4IM_Tag_XML:		RETFLAGa(XMLOK) ;
	      case V4IM_Tag_Format:		v4im_GetPointUC(&ok,di->OutFormat,UCsizeof(di->OutFormat),cpt,ctx) ; break ;
	      case -V4IM_Tag_Format:		if (di->OutFormat[0] == UCEOS) { v_Msg(ctx,NULL,"DimNotSet",intmodx,V4IM_Tag_Format,di->DimId) ; goto fail ; } 
						uccharPNTv(respnt,di->OutFormat) ; return(respnt) ;
	      case V4IM_Tag_HasIsa:		SETFLAG(HasIsA) ; break ;
	      case -V4IM_Tag_HasIsa:		RETFLAG(HasIsA) ;
#ifdef V4_BUILD_SECURITY
	      case V4IM_Tag_Hidden:		SETrtFLAG(Hidden) ; break ;
	      case -V4IM_Tag_Hidden:		RETrtFLAG(Hidden) ;
#else
	      case V4IM_Tag_Hidden:
	      case -V4IM_Tag_Hidden:		v_Msg(ctx,NULL,"V4NotThisBuild",intmodx,argpnts[ix]) ; goto fail ;
#endif
	      case V4IM_Tag_Hierarchy:		di->RelHNum = v4im_GetPointInt(&ok,cpt,ctx) ; break ;
	      case -V4IM_Tag_Hierarchy:		intPNTv(respnt,di->RelHNum) ; return(respnt) ;
#define SETHisFLAG(dsName) if (set) { di->ds.dsName.calFlags |= VCAL_Flags_Historical ; } else { di->ds.dsName.calFlags &= ~(VCAL_Flags_Historical) ; } ; break ;
	      case V4IM_Tag_History:	      {	LOGICAL set = v4im_GetPointLog(&ok,cpt,ctx) ; if (!ok) break ;
						switch (di->PointType)
						 { default:			v_Msg(ctx,NULL,"DimInvOption",intmodx,V4IM_Tag_History,V4DPI_PntType_Calendar,di->PointType) ; goto fail ;
						   case V4DPI_PntType_Calendar:	SETHisFLAG(Cal)
						   case V4DPI_PntType_UDate:	SETHisFLAG(UDate)
						   case V4DPI_PntType_UDT:	SETHisFLAG(UDT)
						   case V4DPI_PntType_UMonth:	SETHisFLAG(UMonth)
						   case V4DPI_PntType_UYear:	SETHisFLAG(UYear)
						   case V4DPI_PntType_UPeriod:	SETHisFLAG(UPeriod)
						   case V4DPI_PntType_UWeek:	SETHisFLAG(UWeek)
						   case V4DPI_PntType_UQuarter:	SETHisFLAG(UQuarter)
						 } ;
					      }
						break ;
#define GETHisFLAG(dsName) logPNTv(respnt,((di->ds.dsName.calFlags & VCAL_Flags_Historical) != 0)) ; break ;
	      case -V4IM_Tag_History:		switch (di->PointType)
						 { default:			v_Msg(ctx,NULL,"DimInvOption",intmodx,-V4IM_Tag_History,V4DPI_PntType_Calendar,di->PointType) ; goto fail ;
						   case V4DPI_PntType_Calendar:	GETHisFLAG(Cal)
						   case V4DPI_PntType_UDate:	GETHisFLAG(UDate)
						   case V4DPI_PntType_UDT:	GETHisFLAG(UDT)
						   case V4DPI_PntType_UMonth:	GETHisFLAG(UMonth)
						   case V4DPI_PntType_UYear:	GETHisFLAG(UYear)
						   case V4DPI_PntType_UPeriod:	GETHisFLAG(UPeriod)
						   case V4DPI_PntType_UWeek:	GETHisFLAG(UWeek)
						   case V4DPI_PntType_UQuarter:	GETHisFLAG(UQuarter)
						 } ;
						return(respnt) ;
	      case V4IM_Tag_IC:			USETFLAG(CaseSensitive) ; break ;
	      case -V4IM_Tag_IC:		URETFLAG(CaseSensitive) ;
	      case V4IM_Tag_Intersection:	SETFLAGl(IsctModOK,V4IM_Tag_Intersection) ; break ;
	      case -V4IM_Tag_Intersection:	RETFLAGl(IsctModOK) ; break ;
	      case V4IM_Tag_IsA:		if (cpt->Dim != Dim_Dim) { v_Msg(ctx,NULL,"ModArgNotDim",intmodx,ix,cpt) ; goto fail ; } ;
						DIMINFO(dix,ctx,cpt->Value.IntVal) ;
						if (dix->PointType != di->PointType) { v_Msg(ctx,NULL,"ModArgPntType2",intmodx,ix,dix->PointType,di->PointType) ; goto fail ; } ;
						di->Flags |= dix->Flags ; UCstrcpy(di->IsA,dix->DimName) ;
						break ;
	      case -V4IM_Tag_IsA:		if (di->IsA[0] == UCEOS) { v_Msg(ctx,NULL,"DimNotSet",intmodx,V4IM_Tag_IsA,di->DimId) ; goto fail ; } ;
						uccharPNTv(respnt,di->IsA) ; return(respnt) ;
	      case V4IM_Tag_JSON:		SETFLAGa(ParseJSON,V4IM_Tag_JSON) ; break ;
	      case -V4IM_Tag_JSON:		RETFLAGa(ParseJSON) ;
	      case -V4IM_Tag_ListOf:
		if (di == NULL) 
		 { v_Msg(ctx,NULL,"DimNoneGiven",intmodx) ; goto fail ; } ;
		INITLP(respnt,lp,Dim_List) ; dictPNT(&litpt,Dim_NId) ;
#define DIMBIT(bit,name) \
 if (di->Flags & bit) \
  { litpt.Value.IntVal = v4im_GetEnumToDictVal(ctx,DE(name),Dim_NId) ; \
  v4l_ListPoint_Modify(ctx,lp,V4L_ListAction_Append,(P *)&litpt,0) ; } ;
#define DIMBITa(bit,name) \
 if ((di->PointType == V4DPI_PntType_Char || di->PointType == V4DPI_PntType_UCChar || di->PointType == V4DPI_PntType_BigText) && (di->ds.Alpha.aFlags & bit)) \
  { litpt.Value.IntVal = v4im_GetEnumToDictVal(ctx,DE(name),Dim_NId) ; \
  v4l_ListPoint_Modify(ctx,lp,V4L_ListAction_Append,(P *)&litpt,0) ; } ;
						DIMBIT(V4DPI_DimInfo_RangeOK,Range) ; DIMBIT(V4DPI_DimInfo_ListOK,Multiple) ;
						DIMBIT(V4DPI_DimInfo_IsSet,Set) ;
						DIMBIT(V4DPI_DimInfo_NoAutoCreate,NoAutoCreate) ;
						DIMBIT(V4DPI_DimInfo_BindEval,BindEval) ;
						DIMBIT(V4DPI_DimInfo_Acceptor,Acceptor) ;
						DIMBIT(V4DPI_DimInfo_Displayer,Displayer) ;
						DIMBIT(V4DPI_DimInfo_DisplayerTrace,DisplayerTrace) ;
						DIMBIT(V4DPI_DimInfo_DotDotToList,DotDotToList) ;
						DIMBITa(V4DPI_DimInfoAlpha_IsFileName,FileName) ;
						DIMBITa(V4DPI_DimInfoAlpha_ParseJSON,JSON) ;
						DIMBITa(V4DPI_DimInfoAlpha_XMLOK,XML) ;
						DIMBITa(V4DPI_DimInfoAlpha_AsIs,AsIs) ;
						DIMBIT(V4DPI_DimInfo_Normalize,Normalize) ;
						DIMBIT(V4DPI_DimInfo_CaseSensitive,CaseSensitive) ;
						DIMBIT(V4DPI_DimInfo_Structure,Structure) ;
						DIMBIT(V4DPI_DimInfo_DotIndex,DotIndex) ;
						DIMBIT(V4DPI_DimInfo_RDBNumeric,RDBNumeric) ;
						DIMBIT(V4DPI_DimInfo_DotIndex,DotList) ;
						ENDLP(respnt,lp)
						return(respnt) ;
	      case V4IM_Tag_Local:		v_Msg(ctx,NULL,"ModTagNYI",intmodx,V4IM_Tag_Local) ; goto fail ;
	      case -V4IM_Tag_Local:		v_Msg(ctx,NULL,"ModTagNYI",intmodx,-V4IM_Tag_Local) ; goto fail ;
	      case V4IM_Tag_MMDDYY:		if (di->PointType == V4DPI_PntType_UDate) { di->ds.UDate.IFormat = V4LEX_TablePT_MMDDYY ; }
						 else if (di->PointType == V4DPI_PntType_Calendar) { di->ds.Cal.IFormat = V4LEX_TablePT_MMDDYY ; }
						 else if (di->PointType == V4DPI_PntType_UDT) { di->ds.UDT.IFormat = V4LEX_TablePT_MMDDYY ; }
						 else { v_Msg(ctx,NULL,"DimInvOption1",intmodx,V4IM_Tag_MMDDYY,di->PointType) ; goto fail ; } ;
						break ;
	      case -V4IM_Tag_MMDDYY:		if (di->PointType == V4DPI_PntType_UDate) { logPNTv(respnt,di->ds.UDate.IFormat == V4LEX_TablePT_MMDDYY) ; }
						 else if (di->PointType == V4DPI_PntType_Calendar) { logPNTv(respnt,di->ds.Cal.IFormat == V4LEX_TablePT_MMDDYY) ; }
						 else if (di->PointType == V4DPI_PntType_UDT) { logPNTv(respnt,di->ds.UDT.IFormat == V4LEX_TablePT_MMDDYY) ; }
						 else { v_Msg(ctx,NULL,"DimInvOption1",intmodx,V4IM_Tag_MMDDYY,di->PointType) ; goto fail ; } ;
						return(respnt) ;
	      case V4IM_Tag_MMYY:		if (di->PointType != V4DPI_PntType_UMonth) { v_Msg(ctx,NULL,"DimInvOption",intmodx,V4IM_Tag_MMYY,V4DPI_PntType_UMonth,di->PointType) ; goto fail ; } ;
						di->ds.UMonth.IFormat = V4LEX_TablePT_MMYY ; break ;
	      case -V4IM_Tag_MMYY:		if (di->PointType != V4DPI_PntType_UMonth) { v_Msg(ctx,NULL,"DimInvOption",intmodx,V4IM_Tag_MMYY,V4DPI_PntType_UMonth,di->PointType) ; goto fail ; } ;
						logPNTv(respnt,di->ds.UMonth.IFormat == V4LEX_TablePT_MMYY) ; return(respnt) ;
	      case V4IM_Tag_Multiple:		SETFLAG(ListOK) ; break ;
	      case -V4IM_Tag_Multiple:		RETFLAG(ListOK) ;
	      case V4IM_Tag_None:		switch (di->PointType)
						 { default:		v_Msg(ctx,NULL,"DimNoneVal",intmodx,V4IM_Tag_None,V4DPI_PntType_Int,V4DPI_PntType_Real,di->PointType) ; goto fail ; 
						   case V4DPI_PntType_Int:
							di->ds.Int.NoneValue = v4im_GetPointInt(&ok,cpt,ctx) ; break ;
						   case V4DPI_PntType_Real:
							di->ds.Real.NoneValue = v4im_GetPointDbl(&ok,cpt,ctx) ; break ;
						 } ; 
						di->Flags |= V4DPI_DimInfo_HaveNone ; break ;
	      case -V4IM_Tag_None:		if ((di->Flags & V4DPI_DimInfo_HaveNone) == 0) { v_Msg(ctx,NULL,"DimNotSet",intmodx,V4IM_Tag_None,di->DimId) ; goto fail ; } ;
						switch (di->PointType)
						 { default:		v_Msg(ctx,ctx->ErrorMsgAux,"DimNoneVal",intmodx,V4IM_Tag_None,V4DPI_PntType_Int,V4DPI_PntType_Real,di->PointType) ; goto fail ; 
						   case V4DPI_PntType_Int:
							intPNTv(respnt,di->ds.Int.NoneValue) ; break ;
						   case V4DPI_PntType_Real:
							dblPNTv(respnt,di->ds.Real.NoneValue) ; break ;
						 } ; return(respnt) ;
	      case V4IM_Tag_NoPrefix:		SETFLAG(NoNamePrefix) ; break ;
	      case -V4IM_Tag_NoPrefix:		RETFLAG(NoNamePrefix) ;
	      case V4IM_Tag_Normalize:		SETFLAG(Normalize) ; break ;
	      case -V4IM_Tag_Normalize:		RETFLAG(Normalize) ;
	      case V4IM_Tag_Overload:		di->PCAggExtend = v4im_GetPointInt(&ok,cpt,ctx) ;
						if (di->PCAggExtend < 0 || di->PCAggExtend > 100)
						 { v_Msg(ctx,NULL,"DimDecNum",intmodx,V4IM_Tag_Overload,di->PCAggExtend,0,100) ; goto fail ; } ;
						break ;
	      case -V4IM_Tag_Overload:		intPNTv(respnt,di->PCAggExtend) ; return(respnt) ;
	      case V4IM_Tag_Periods:		if (di->PointType != V4DPI_PntType_UPeriod) { v_Msg(ctx,NULL,"DimInvOption",intmodx,V4IM_Tag_Periods,V4DPI_PntType_UPeriod,di->PointType) ; goto fail ; } ;
						i = v4im_GetPointInt(&ok,cpt,ctx) ;
						if (i < 2 || i > 100) { v_Msg(ctx,NULL,"ModArgRange",intmodx,ix,cpt,2,100) ; goto fail ; } ;
						di->ds.UPeriod.periodsPerYear = i ;
						break ;
	      case -V4IM_Tag_Periods:		if (di->PointType != V4DPI_PntType_UPeriod) { v_Msg(ctx,NULL,"DimInvOption",intmodx,V4IM_Tag_Periods,V4DPI_PntType_UPeriod,di->PointType) ; goto fail ; } ;
						intPNTv(respnt,(di->ds.UPeriod.periodsPerYear == 0 ? 13 : di->ds.UPeriod.periodsPerYear)) ;
						return(respnt) ;
	      case V4IM_Tag_Point:		switch (v4im_GetDictToEnumVal(ctx,cpt))
						 { default:	v_Msg(ctx,ctx->ErrorMsgAux,"DimPCOptVal",intmodx,cpt,V4IM_Tag_Point,DE(New),DE(Point)) ; goto fail ;
						   case _New:	di->UniqueOK = (di->PointType == V4DPI_PntType_AggRef ? V4DPI_DimInfo_UOkAgg : V4DPI_DimInfo_UOkNew) ; break ;
						   case _Point:	di->UniqueOK = V4DPI_DimInfo_UOkPoint ; break ;
						 } ; break ;
	      case -V4IM_Tag_Point:		switch (di->UniqueOK)
						 { default:			v_Msg(ctx,NULL,"DimNotSet",intmodx,V4IM_Tag_Point,di->DimId) ; goto fail ;
						   case V4DPI_DimInfo_UOkPoint:	respnt->Value.IntVal = v4im_GetEnumToDictVal(ctx,DE(Point),Dim_UV4) ; break ;
						   case V4DPI_DimInfo_UOkAgg:
						   case V4DPI_DimInfo_UOkNew:	respnt->Value.IntVal = v4im_GetEnumToDictVal(ctx,DE(New),Dim_UV4) ; break ;
						 } ; dictPNT(respnt,Dim_UV4) ; return(respnt) ;
	      case V4IM_Tag_Range:		SETFLAG(RangeOK) ; break ;
	      case -V4IM_Tag_Range:		RETFLAG(RangeOK) ;
	      case V4IM_Tag_RDB:		if (di->PointType != V4DPI_PntType_Int) { v_Msg(ctx,NULL,"DimInvOption",intmodx,V4IM_Tag_RDB,V4DPI_PntType_Int,di->PointType) ; goto fail ; } ;
						switch (v4im_GetDictToEnumVal(ctx,cpt))
						 { default:		ok = FALSE ; v_Msg(ctx,ctx->ErrorMsgAux,"CalInvTkn1",intmodx,cpt) ; break ;
						   case _Normal:	di->Flags &= ~V4DPI_DimInfo_RDBNumeric ; break ;
						   case _Raw:		di->Flags |= V4DPI_DimInfo_RDBNumeric ; break ;
						 } ;
						break ;
	      case -V4IM_Tag_RDB:		if (di->PointType != V4DPI_PntType_Int) { v_Msg(ctx,NULL,"DimInvOption",intmodx,V4IM_Tag_RDB,V4DPI_PntType_Int,di->PointType) ; goto fail ; } ;
						respnt->Value.IntVal = v4im_GetEnumToDictVal(ctx,((di->Flags & V4DPI_DimInfo_RDBNumeric) == 0 ? DE(Normal) : DE(Raw)),Dim_UV4) ;
						dictPNT(respnt,Dim_UV4) ; return(respnt) ;
	      case V4IM_Tag_References:		switch (v4im_GetDictToEnumVal(ctx,cpt))
						 { default:	v_Msg(ctx,NULL,"ModTagValue",intmodx,ix,V4IM_Tag_References,cpt) ; ; goto fail ;
						   case _Defined:	rtype = DIMREF_DCL ; break ;
						   case _Dim:		rtype = DIMREF_DIMDIM ; break ;
						   case _Lexical:	rtype = DIMREF_LEX ; break ;
						   case _Point:		rtype = DIMREF_POINT ; break ;
						   case _Used:		rtype = -10 ; break ;			/* Everything but Defined */
						   case _Value:		rtype = DIMREF_REF ; break ;
						 } ; goto ref_entry ;
	      case -V4IM_Tag_References:	rtype = UNUSED ;
ref_entry:					if (gpi->vldd == NULL) { v_Msg(ctx,NULL,"DimNoRef",intmodx,-V4IM_Tag_References,DE(Set),DE(Trace),DE(Dimensions)) ; goto fail ; } ;
						{ struct V4LEX__DIMDIR *vldd ; INDEX i ;
						  INITLP(respnt,lp,Dim_List) ; tpt = &isctbuf ; intPNT(tpt) ;
						  for(vldd=gpi->vldd;vldd!=NULL;vldd=vldd->vlddPrior)
						   { for(i=0;i<vldd->count;i++)
						      { if (vldd->entry[i].dimId != di->DimId) continue ;
						        if (rtype != UNUSED)
						         { if (rtype == -10 && vldd->entry[i].usage == DIMREF_DCL) continue ;
						           if (rtype != -10 && vldd->entry[i].usage != rtype) continue ;
						         } ;
						        tpt->Value.IntVal = vldd->entry[i].vis.iVal ;
						        if (!v4l_ListPoint_Modify(ctx,lp,V4L_ListAction_Append,tpt,0)) { v_Msg(ctx,NULL,"LPModFail",intmodx) ; goto fail ; } ;
						      } ;
						   } ;
						  ENDLP(respnt,lp) ; 
						} ;
						return(respnt) ;
	      case V4IM_Tag_Structure:		SETFLAG(Structure) ; break ;
	      case -V4IM_Tag_Structure:		RETFLAG(Structure) ;
	      case V4IM_Tag_TimeZone:		tz = v4im_GetPointInt(&ok,cpt,ctx) ;
						if (tz < -12 || tz > 12) { v_Msg(ctx,NULL,"DimDecNum",intmodx,V4IM_Tag_TimeZone,tz,-12,12) ; goto fail ; } ;
						if (di->PointType == V4DPI_PntType_Calendar) { di->ds.Cal.TimeZone = tz ; }
						 else if (di->PointType == V4DPI_PntType_GeoCoord) { di->ds.Geo.TimeZone = tz ; }
						 else { v_Msg(ctx,NULL,"DimInvOption",intmodx,V4IM_Tag_TimeZone,V4DPI_PntType_Calendar,di->PointType) ; goto fail ; } ;
						break ;
	      case -V4IM_Tag_TimeZone:		if (di->PointType == V4DPI_PntType_Calendar) { tz = di->ds.Cal.TimeZone ; }
						 else if (di->PointType == V4DPI_PntType_GeoCoord) { tz = di->ds.Geo.TimeZone ; }
						 else { v_Msg(ctx,NULL,"DimInvOption",intmodx,V4IM_Tag_TimeZone,V4DPI_PntType_Calendar,di->PointType) ; goto fail ; } ;
						if (tz == VCAL_TimeZone_Local) { v_Msg(ctx,NULL,"DimNotSet",intmodx,V4IM_Tag_TimeZone,di->DimId) ; goto fail ; } ;
						intPNTv(respnt,tz) ; return(respnt) ;
	      case V4IM_Tag_Type:		v4im_GetPointUC(&ok,utbuf,UCsizeof(utbuf),cpt,ctx) ;
						ndi.PointType = v4im_PTId(utbuf) ; if (ndi.PointType < 0) { v_Msg(ctx,NULL,"DimNotPT",intmodx,utbuf) ; goto fail ; } ;
						v4dpi_DimInitOnType(ctx,di) ; setType = TRUE ;
						break ;
	      case -V4IM_Tag_Type:		dictPNTv(respnt,Dim_UV4,v4dpi_DictEntryGet(ctx,0,v4im_PTName(di->PointType),di,NULL)) ; return(respnt) ;
	      case V4IM_Tag_UOMId:		di->UOMRef = v4im_GetPointInt(&ok,cpt,ctx) ; break ;
	      case -V4IM_Tag_UOMId:		intPNTv(respnt,di->UOMRef) ; return(respnt) ;
	      case V4IM_Tag_Value:		if (di->PointType != V4DPI_PntType_Int) { v_Msg(ctx,NULL,"DimInvOption",intmodx,V4IM_Tag_Value,V4DPI_PntType_Int,di->PointType) ; goto fail ; } ;
						switch (v4im_GetDictToEnumVal(ctx,cpt))
						 { default:		ok = FALSE ; v_Msg(ctx,ctx->ErrorMsgAux,"CalInvTkn1",intmodx,cpt) ; break ;
						   case _List:		di->Flags &= ~V4DPI_DimInfo_ValueTree ; di->Flags |= V4DPI_DimInfo_ValueList ; break ;
						   case _None:		di->Flags &= ~(V4DPI_DimInfo_ValueList | V4DPI_DimInfo_ValueTree) ; break ;
						   case _Tree:		di->Flags &= ~V4DPI_DimInfo_ValueList ; di->Flags |= V4DPI_DimInfo_ValueTree ; break ;
						 } ;
						break ;
	      case -V4IM_Tag_Value:		if (di->PointType != V4DPI_PntType_Int) { v_Msg(ctx,NULL,"DimInvOption",intmodx,V4IM_Tag_Value,V4DPI_PntType_Int,di->PointType) ; goto fail ; } ;
						{ enum DictionaryEntries de ;
						  if ((di->Flags & (V4DPI_DimInfo_ValueList | V4DPI_DimInfo_ValueTree)) == 0)  { de = DE(None) ; }
						   else if (di->Flags & (V4DPI_DimInfo_ValueList)) { de = DE(List) ; }
						   else { de = DE(Tree) ; } ;
						  dictPNTv(respnt,Dim_UV4,v4im_GetEnumToDictVal(ctx,de,Dim_UV4)) ;
						}
						return(respnt) ;
	      case V4IM_Tag_YMDOrder:		lp = (cpt->PntType == V4DPI_PntType_List ? v4im_VerifyList(NULL,ctx,cpt,0) : NULL) ;
						for(i=0;i<VCAL_YMDOrderMax;i++)
						 { if (lp == NULL) { tpt = cpt ; }
						    else if (v4l_ListPoint_Value(ctx,lp,i+1,&isctbuf) > 0) { tpt = &isctbuf ; } else { break ; } ;
						   switch (v4im_GetDictToEnumVal(ctx,tpt))
						    { default:		ok = FALSE ; v_Msg(ctx,ctx->ErrorMsgAux,"CalYMDOrder",intmodx,cpt) ; break ;
						      case _DMY:	ymdo = V4LEX_YMDOrder_DMY ; break ;
						      case _DYM:	ymdo = V4LEX_YMDOrder_DYM ; break ;
						      case _MDY:	ymdo = V4LEX_YMDOrder_MDY ; break ;
						      case _MYD:	ymdo = V4LEX_YMDOrder_MYD ; break ;
						      case _YDM:	ymdo = V4LEX_YMDOrder_YDM ; break ;
						      case _YMD:	ymdo = V4LEX_YMDOrder_YMD ; break ;
						    } ;
						   switch (di->PointType)
						    { default:				v_Msg(ctx,NULL,"DimInvOption1",intmodx,V4IM_Tag_YMDOrder,di->PointType) ; goto fail ;
						      case V4DPI_PntType_UDate:		di->ds.UDate.YMDOrder[i] = ymdo ; break ;
						      case V4DPI_PntType_UDT:		di->ds.UDT.YMDOrder[i] = ymdo ; break ;
						      case V4DPI_PntType_Calendar:	di->ds.Cal.YMDOrder[i] = ymdo ; break ;
						      case V4DPI_PntType_GeoCoord:	di->ds.Geo.YMDOrder[i] = ymdo ; break ;
						    } ;
						   if (lp == NULL) break ;
						 } ;
						break ;
	      case -V4IM_Tag_YMDOrder:		{ YMDORDER *ymdo ;
						  enum DictionaryEntries de ;
						  switch (di->PointType)
						   { default:				v_Msg(ctx,NULL,"DimInvOption1",intmodx,V4IM_Tag_YMDOrder,di->PointType) ; goto fail ;
						     case V4DPI_PntType_UDate:		ymdo = &di->ds.UDate.YMDOrder[0] ; break ;
						     case V4DPI_PntType_UDT:		ymdo = &di->ds.UDT.YMDOrder[0] ; break ;
						     case V4DPI_PntType_Calendar:	ymdo = &di->ds.Cal.YMDOrder[0] ; break ;
						     case V4DPI_PntType_GeoCoord:	ymdo = &di->ds.Geo.YMDOrder[0] ; break ;
						   } ;
						  if (*ymdo == V4LEX_YMDOrder_None) { v_Msg(ctx,NULL,"DimNotSet",intmodx,V4IM_Tag_YMDOrder,di->DimId) ; goto fail ; } ;
						  INITLP(respnt,lp,Dim_List) ; tpt = &isctbuf ; dictPNT(tpt,Dim_UV4) ;
						  for(i=0;i<VCAL_YMDOrderMax && ymdo[i]!=V4LEX_YMDOrder_None;i++)
						   { switch (ymdo[i])
						      { case V4LEX_YMDOrder_DMY:	de = _DMY ; break ;
						        case V4LEX_YMDOrder_DYM:	de = _DYM ; break ;
						        case V4LEX_YMDOrder_MDY:	de = _MDY ; break ;
						        case V4LEX_YMDOrder_MYD:	de = _MYD ; break ;
						        case V4LEX_YMDOrder_YDM:	de = _YDM ; break ;
						        case V4LEX_YMDOrder_YMD:	de = _YMD ; break ;
						      } ;
						     tpt->Value.IntVal = v4im_GetEnumToDictVal(ctx,de,Dim_UV4) ;
						     if (!v4l_ListPoint_Modify(ctx,lp,V4L_ListAction_Append,tpt,0)) { v_Msg(ctx,NULL,"LPModFail",intmodx) ; goto fail ; } ;
						   } ;
						  ENDLP(respnt,lp) ; 
						} return(respnt) ;
	    } ;
	 } ;
	if (!ok) { v_Msg(ctx,NULL,"ModInvArg",intmodx,ix-1) ; goto fail ; } ;

/*	Should we make a new dimension ? */
	if (di == &ndi)
	 { if (!setType) { v_Msg(ctx,NULL,"TagMissing",intmodx,V4IM_Tag_Type) ; goto fail ; } ;
	   respnt->Value.IntVal = v4dpi_DimMake(ctx,&ndi) ;
	   if (respnt->Value.IntVal <= 0) { v_Msg(ctx,NULL,"DimNoCreate",intmodx,ndi.DimName) ; goto fail ; } ;
	   dictPNT(respnt,Dim_Dim) ;
	 } ;

	return(respnt) ;

fail:	REGISTER_ERROR(0) ; return(NULL) ;
}


struct V4DPI__Point *v4im_DoJSONRef(ctx,respnt,argpnts,argcnt,intmodx,isDim)
  struct V4C__Context *ctx ;
  P *respnt ;						/* Ptr for result */
  INTMODX intmodx ;
  P *argpnts[] ;
  COUNTER argcnt ;
{ struct VJSON__Value vjval ;
  P *ipt ;

	memset(&vjval,0,sizeof vjval) ;
	ipt = vjson_Dereference(ctx,respnt,NULL,&vjval,argpnts,argcnt,1,intmodx,isDim) ;
	if (ipt != NULL) return(ipt) ;
	REGISTER_ERROR(0) ; return(NULL) ;

}

struct V4DPI__Point *v4im_DoJSON(ctx,respnt,argpnts,argcnt,intmodx)
  struct V4C__Context *ctx ;
  P *respnt ;						/* Ptr for result */
  INTMODX intmodx ;
  P *argpnts[] ;
  COUNTER argcnt ;
{ P *cpt,argbuf,lpnt ;
  struct V4DPI__DimInfo *di ;
  struct V4L__ListPoint *lp ;
  FLAGS32 parseFlags ;
  LOGICAL ok,doParseToo,nq,didTop,wantAttr ; COUNTER i,ix,elcnt,nestcnt ; INDEX tx ; LENMAX len ; DIMID dimId ;
  enum jsonCaseOptions { unused, LC, UC, Dim } ; enum jsonCaseOptions nCase ;
  enum jsonDataTypes { undefined, array, object } ; enum jsonDataTypes dataType ;
  UCCHAR elname[512],termString[128],suffix[128] ;
  static LOGICAL forceQuote = FALSE ;
#define XMLILMAX 20
  UCCHAR xmlIgnoreList[XMLILMAX][64] ; LENMAX xmlILCnt ;
#define XMLLLMAX 20
  UCCHAR xmlListList[XMLILMAX][64] ; LENMAX xmlLLCnt ;
#define JSONBUFINITIAL (V4LEX_BigText_Max - 16)
  UCCHAR *ucbufP,ucbuf[JSONBUFINITIAL] ; LENMAX ucbufL ;
  UCCHAR topName[V4DPI_XDictEntryVal_Max] ;
#define JSONQUOTED(DST,SRC)\
 { UCCHAR *_p_ ; DST = FALSE ; if (forceQuote) { DST = TRUE ; } else { for(_p_=SRC;*_p_!=UCEOS;_p_++) { if(!vuc_IsContId(*_p_)) { DST = TRUE ; break ; } ; } ; } ; }  

/*	Set up initial target buffer & max size. Will pass as pointers so that they can be increased if necessary. If increased then will have to deallocate at end of this routine */
	ucbufP = ucbuf ; ucbufL = JSONBUFINITIAL ; ZUS(ucbufP) ; parseFlags = 0 ; xmlILCnt = 0 ; xmlLLCnt = 0 ; doParseToo = FALSE ; didTop = FALSE ; wantAttr = TRUE ;
	UCstrcpy(topName,UClit("xml")) ;

	elcnt = 0 ; nestcnt = 0 ; ZUS(termString) ; ZUS(suffix) ; nCase = unused ; dataType = undefined ;
	for (ok=TRUE,ix=1;ix<=argcnt && ok;ix++)
	 { 
	   if (argpnts[ix]->PntType != V4DPI_PntType_TagVal)
	    { if (memcmp(argpnts[ix],&protoNone,V4PS_Int) == 0) continue ;	/* Don't format UV4:none point */
	      if (elcnt > 0) UCstrcat(ucbufP,UClit(",")) ;		/* Separate elements with a comma */
/*	      Do we have an element name? */
	      if (argpnts[ix]->AltDim) { ZUS(elname) ; }
	       else if (argpnts[ix]->Dim != Dim_List)
	       { DIMINFO(di,ctx,argpnts[ix]->Dim) ;
		 if (di == NULL) { v_Msg(ctx,NULL,"JSONPntType",intmodx,ix,argpnts[ix],argpnts[ix]->PntType) ; goto failure ; } ;
		 UCstrcpy(elname,di->DimName) ;
	       } ;
	      if (UCstrlen(elname) > 0 && dataType != array)
	       { switch (nCase)
	          { case Dim:	dimId = v4dpi_DimGet(ctx,elname,DIMREF_REF) ;
				if (dimId > 0) { DIMINFO(di,ctx,dimId) ; if (di != NULL) { UCstrcpy(elname,di->DimName) ; } ; } ;
				break ;
	            case LC:	UCSTRTOLOWER(elname) ; break ;
	            case UC:	UCSTRTOUPPER(elname) ; break ;
	          } ;
	         UCstrcat(elname,suffix) ;
		 JSONQUOTED(nq,elname)
		 if (nq) { UCstrcat(elname,UClit("\":")) ; UCstrcat(ucbufP,UClit("\"")) ; UCstrcat(ucbufP,elname) ; }
		  else { UCstrcat(elname,UClit(":")) ; UCstrcat(ucbufP,elname) ; } ;
	       } ;
	      if (argpnts[ix]->Dim == Dim_List && dataType == undefined)
	       { lp = v4im_VerifyList(NULL,ctx,argpnts[ix],0) ;
		 switch (len=v4l_ListPoint_Value(ctx,lp,V4L_ListSize,NULL))
		  { default:	v_Msg(ctx,NULL,"JSONListSize",intmodx,intmodx,V4DPI_PntType_List,len) ; goto failure ;
		    case 1:	ZUS(elname) ;
				v4l_ListPoint_Value(ctx,lp,1,&lpnt) ; if (!v4im_JSONValString(ctx,&lpnt,&ucbufP,&ucbufL,intmodx,ix,UCstrlen(ucbufP),FALSE)) goto failure ;
				break ;
		    case 2:	v4l_ListPoint_Value(ctx,lp,1,&lpnt) ; v4im_GetPointUC(&ok,elname,UCsizeof(elname),&lpnt,ctx) ;
				v4l_ListPoint_Value(ctx,lp,2,&lpnt) ;  if (!v4im_JSONValString(ctx,&lpnt,&ucbufP,&ucbufL,intmodx,ix,UCstrlen(ucbufP),FALSE)) goto failure ;
				break ;
		  } ;
	       } else
	       { 
	         if (!v4im_JSONValString(ctx,argpnts[ix],&ucbufP,&ucbufL,intmodx,ix,UCstrlen(ucbufP),FALSE)) goto failure ;
	       } ;
//	      len = UCstrlen(UCstrcat(tbuf,ucbuf)) ;
//	      if (len >= V4LEX_BigText_Max) { v_Msg(ctx,NULL,"StrLitTooBig2",intmodx,ix,V4LEX_BigText_Max) ; goto failure ; } ;
	      elcnt++ ; continue ;
	    } ;
	   switch (tx=v4im_CheckPtArgNew(ctx,argpnts[ix],&cpt,&argbuf))
	    { default:			v_Msg(ctx,NULL,"TagBadUse",intmodx) ; goto failure ;
	      case V4IM_Tag_Unk:	v_Msg(ctx,NULL,"TagUnknown",intmodx) ; goto failure ;
	      case V4IM_Tag_Array:

		if (v4im_CouldBeList(ctx,cpt))
		 { struct V4L__ListPoint *lp ; P valpt ; INDEX lx ;
		   lp = VERIFYLIST(NULL,ctx,cpt,intmodx) ;
		   for(lx=1;xmlLLCnt<XMLLLMAX;lx++,xmlLLCnt++)
		    { if (v4l_ListPoint_Value(ctx,lp,lx,&valpt) <= 0) break ;
		      v4im_GetPointUC(&ok,xmlListList[xmlLLCnt],UCsizeof(xmlListList[xmlLLCnt]),&valpt,ctx) ;
		    } ;
	           intPNTv(respnt,xmlLLCnt) ;
		   continue ;
		 } ;

//		UCstrcat(ucbufP,UClit("'")) ;
//		v4im_GetPointUC(&ok,&ucbufP[UCstrlen(ucbufP)],ucbufL-UCstrlen(ucbufP),cpt,ctx) ;
//		UCstrcat(ucbufP,UClit("':")) ;
		{ UCCHAR jName[256] ; v4im_GetPointUC(&ok,jName,UCsizeof(jName),cpt,ctx) ; JSONQUOTED(nq,jName)
		  if (nq) { UCstrcat(ucbufP,UClit("\"")) ; UCstrcat(&ucbufP[UCstrlen(ucbufP)],jName) ; UCstrcat(ucbufP,UClit("\":")) ; }
		   else { UCstrcat(&ucbufP[UCstrlen(ucbufP)],jName) ; UCstrcat(ucbufP,UClit(":")) ; }
		}
/*	      Fall thru to handle Array */
	      case -V4IM_Tag_Array:
		UCstrcat(ucbufP,UClit("[")) ; UCstrcat(termString,UClit("]")) ;
		dataType = array ;
		break ;
	      case V4IM_Tag_Attributes:
		wantAttr = v4im_GetPointLog(&ok,cpt,ctx) ; break ;
	      case V4IM_Tag_Delete:
		{
		  switch (cpt->PntType)
		   { default:
			v_Msg(ctx,NULL,"JSONRefArg",intmodx,cpt,cpt->PntType) ; goto failure ;
		     CASEofCharmU
		     case V4DPI_PntType_UCChar:
		     case V4DPI_PntType_Int:
		     case V4DPI_PntType_Dict:
			if (!vjson_DeleteBlob(ctx,cpt)) { v_Msg(ctx,NULL,"JSONBlobNotFnd",intmodx,cpt) ; goto failure ; } ;
			logPNTv(respnt,TRUE) ; return(respnt) ;
		   } ;
		}
	      case -V4IM_Tag_Dim:	nCase = Dim ; break ;
	      case V4IM_Tag_Ignore:
		{ struct V4L__ListPoint *lp ; P valpt ; INDEX lx ;
		  lp = VERIFYLIST(NULL,ctx,cpt,intmodx) ;
		  for(lx=1;xmlILCnt<XMLILMAX;lx++,xmlILCnt++)
		   { if (v4l_ListPoint_Value(ctx,lp,lx,&valpt) <= 0) break ;
		     v4im_GetPointUC(&ok,xmlIgnoreList[xmlILCnt],UCsizeof(xmlIgnoreList[xmlILCnt]),&valpt,ctx) ;
		   } ;
		} ;
	        intPNTv(respnt,xmlILCnt) ;
		continue ;
	      case V4IM_Tag_JSON:
		v4im_GetPointUC(&ok,&ucbufP[UCstrlen(ucbufP)],ucbufL-UCstrlen(ucbufP),cpt,ctx) ;
		if (elcnt > 0) UCstrcat(ucbufP,UClit(",")) ;
		elcnt++ ;
		break ;
	      case -V4IM_Tag_LC:	nCase = LC ; break ;
	      case -V4IM_Tag_Parse:	doParseToo = TRUE ; break ;
	      case V4IM_Tag_Parse:
		if (cpt->PntType == V4DPI_PntType_ParsedJSON)
		 { v_Msg(gpi->ctx,NULL,"@*%1M(%2T::%3P) - Unecessary attempt to parse already parsed JSON string\n",intmodx,V4IM_Tag_Parse,cpt) ; vout_UCText(VOUT_Warn,0,gpi->ctx->ErrorMsg) ;
		   logPNTv(respnt,TRUE) ; return(respnt) ;
		 } ;
		{ struct V4LEX__TknCtrlBlk *tcb ; DICTID dictId ;
		  tcb = v4mm_AllocChunk(sizeof(struct V4LEX__TknCtrlBlk),FALSE) ; v4lex_InitTCB(tcb,V4LEX_TCBINIT_NoStdIn) ;
/*		  Push first argument onto tcb as its source */
		  switch (cpt->PntType)
		   { default:			v_Msg(ctx,NULL,"ModArgPntType3",intmodx,1,cpt->PntType,V4DPI_PntType_Char,V4DPI_PntType_List) ; goto failure ;

		     case V4DPI_PntType_Dict:		/* If dictionary entry then assume name of buffered stream */
			{ UCCHAR *fbuf ; FILEID fileId ;
			   fileId = vout_PntIdToFileId(ctx,(struct V4DPI__LittlePoint *)cpt) ;
			   if (fileId == UNUSED) { v_Msg(ctx,NULL,"StreamNoOutput",intmodx,V4IM_Tag_XML,cpt) ; return(NULL) ; } ;
			   fbuf = vout_GetOutputBuffer(fileId,UNUSED,ctx->ErrorMsgAux) ;
			   if (fbuf == NULL) { v_Msg(ctx,NULL,"ModInvArg2",intmodx,cpt) ; return(NULL) ; } ;
			   v4lex_NestInput(tcb,NULL,NULL,V4LEX_InpMode_RetEOF) ;
			   v4lex_NestInput(tcb,NULL,fbuf,V4LEX_InpMode_StringPtr) ;
			}
			break ;


		     case V4DPI_PntType_List:	
			{ struct V4L__ListPoint *lp ; P *tpnt = v4mm_AllocChunk(sizeof *tpnt,FALSE) ;
			  lp = (struct V4L__ListPoint *)v4im_VerifyList(tpnt,ctx,cpt,0) ;
			  v4lex_NestInput(tcb,NULL,(UCCHAR *)lp,V4LEX_InpMode_List) ;
			  break ;
			}







		     CASEofChar			v4im_GetPointUC(&ok,UCTBUF1,V4TMBufMax,cpt,ctx) ;
						if (!ok) { v_Msg(ctx,NULL,"ModInvArg",intmodx,1) ; goto failure ; } ;
						v4lex_NestInput(tcb,NULL,NULL,V4LEX_InpMode_RetEOF) ;
						v4lex_NestInput(tcb,NULL,UCTBUF1,V4LEX_InpMode_String) ; break ;
//		    case V4DPI_PntType_List:	
//						break ;
		  } ;
		 dictId = vjson_ParseString(ctx,tcb,(didTop ? topName : NULL),parseFlags) ;
//veh200102 - don't call this as it frees fbuf memory; that causes problems later when we try to free it again below
//		 v4lex_FreeTCB(tcb) ;
		 v4mm_FreeChunk(tcb) ;
		 if (dictId == 0) { v_Msg(ctx,NULL,"ParseJSON",intmodx) ; goto failure ; } ;
		 intPNTv(respnt,dictId) ; return(respnt) ;
		}
	      case -V4IM_Tag_Quoted:
		logPNTv(respnt,forceQuote) ; return(respnt) ;
	      case V4IM_Tag_Quoted:
		{ LOGICAL priorVal = forceQuote ;
		  forceQuote = v4im_GetPointLog(&ok,cpt,ctx) ; if (!ok) break ;
		  logPNTv(respnt,priorVal) ; return(respnt) ;
		}
		break ;



	      case V4IM_Tag_Release:
		{ struct VJSON__Blob *vjblob,*vjblob2,*vjblobP ; struct VJSON__Value vjval1 ; vjval1.jvType = VJSON_Type_None ;
		  vjblob = (cpt->PntType == V4DPI_PntType_List ? NULL : vjson_LocateBlob(ctx,cpt,NULL,NULL)) ;
		  if (vjblob == NULL) { v_Msg(ctx,NULL,"JSONBlobNotFnd",intmodx,argpnts[ix]) ; return(NULL) ; } ;
/*		  Loop through chain of object and remove, then deallocate */
		  for(vjblob2=gpi->vjblob,vjblobP=NULL;vjblob2!=NULL;vjblob2=vjblob2->vjblobNext)
		   { if (vjblob2 != vjblob) { vjblobP = vjblob2 ; continue ; } ;
		     if (vjblobP == NULL) { gpi->vjblob = vjblob2->vjblobNext ; }
		      else { vjblobP->vjblobNext = vjblob2->vjblobNext ; } ;
		     v4mm_FreeChunk(vjblob2) ;
		     logPNTv(respnt,TRUE) ; return(respnt) ;
		   } ;
		}


	      case V4IM_Tag_Function:
	      case V4IM_Tag_Name:
		if (elcnt > 0) UCstrcat(ucbufP,UClit(",")) ;
		{ UCCHAR jName[256] ; v4im_GetPointUC(&ok,jName,UCsizeof(jName),cpt,ctx) ; JSONQUOTED(nq,jName)
		  if (nq) { UCstrcat(ucbufP,UClit("\"")) ; UCstrcat(&ucbufP[UCstrlen(ucbufP)],jName) ; UCstrcat(ucbufP,UClit("\":")) ; }
		   else { UCstrcat(&ucbufP[UCstrlen(ucbufP)],jName) ; UCstrcat(ucbufP,UClit(":")) ; }
		}
		ix++ ; cpt = argpnts[ix] ;
		if (ix > argcnt || (argpnts[ix]->PntType == V4DPI_PntType_TagVal ? v4im_CheckPtArgNew(ctx,argpnts[ix],&cpt,&argbuf) != V4IM_Tag_Value : FALSE))
		 { v_Msg(ctx,NULL,"JSONNameVal",intmodx,V4IM_Tag_Name,V4IM_Tag_Value) ; goto failure ; } ;
		/* Fall thru to Value::xxx */
	      case V4IM_Tag_Value:
		if (cpt->PntType != V4DPI_PntType_List && cpt->Grouping == V4DPI_Grouping_Single)
		 { if (!v4im_JSONValString(ctx,argpnts[ix],&ucbufP,&ucbufL,intmodx,ix,UCstrlen(ucbufP),(tx == V4IM_Tag_Function))) goto failure ;
		   elcnt++ ;
		   break ;
		 } ;
/*		Have a list or compound point (i.e. a list) */
		{ P lvpnt ; INDEX lx ;
		  lp = v4im_VerifyList(&lvpnt,ctx,cpt,0) ;
		  UCstrcat(ucbufP,UClit("[")) ;
		  for(lx=1;v4l_ListPoint_Value(ctx,lp,lx,&lpnt)>0;lx++)
		   { if (lx > 1) UCstrcat(ucbufP,UClit(",")) ;
		     if (!v4im_JSONValString(ctx,&lpnt,&ucbufP,&ucbufL,intmodx,ix,UCstrlen(ucbufP),FALSE)) goto failure ;
		   } ;
		  UCstrcat(ucbufP,UClit("]")) ; elcnt++ ;
		}
		break ;
	      case V4IM_Tag_Style:
		parseFlags = 0 ;
		lp = (cpt->PntType == V4DPI_PntType_List ? (struct V4L__ListPoint *)&cpt->Value : NULL) ;
		for(i=1;;i++)
		 { P *ipt, ptbuf ; INDEX j ;
		   if (lp == NULL) { ipt = cpt ; }
		    else { j = v4l_ListPoint_Value(ctx,lp,i,&ptbuf) ; if (j == 0) break ;
			   if (j == LISTVALERR) { v_Msg(ctx,NULL,"ListGetErr1",intmodx,i,cpt) ; goto failure ; } ;
			   ipt = &ptbuf ;
			 } ;
		   switch (v4im_GetDictToEnumVal(ctx,ipt))
		    { default:			v_Msg(ctx,NULL,"ModTagValue",intmodx,i,V4IM_Tag_Include,cpt) ; ipt = NULL ; goto failure ; 
		      case _Comma:		parseFlags |= VJSON_Parse_RelaxComma ; break ;
		      case _LeadingZero:	parseFlags |= VJSON_Parse_LeadingZero ; break ;
		    } ;
		  if (lp == NULL) break ;
		 } ; break ;
	      case V4IM_Tag_Top:
		if (memcmp(cpt,&protoNone,V4PS_Int) == 0) { ZUS(topName) ; break ; } ;
		didTop = TRUE ; v4im_GetPointUC(&ok,topName,UCsizeof(topName),cpt,ctx) ; break ;
	      case V4IM_Tag_Object:
//		UCstrcat(ucbufP,UClit("'")) ;
//		v4im_GetPointUC(&ok,&ucbufP[UCstrlen(ucbufP)],ucbufL-UCstrlen(ucbufP),cpt,ctx) ;
//		UCstrcat(ucbufP,UClit("':")) ;
		{ UCCHAR jName[256] ; v4im_GetPointUC(&ok,jName,UCsizeof(jName),cpt,ctx) ; JSONQUOTED(nq,jName)
		  if (nq) { UCstrcat(ucbufP,UClit("\"")) ; UCstrcat(&ucbufP[UCstrlen(ucbufP)],jName) ; UCstrcat(ucbufP,UClit("\":")) ; }
		   else { UCstrcat(&ucbufP[UCstrlen(ucbufP)],jName) ; UCstrcat(ucbufP,UClit(":")) ; }
		}
	      case -V4IM_Tag_Object:
		UCstrcat(ucbufP,UClit("{")) ; UCstrcat(termString,UClit("}")) ;
		dataType = object ;
		break ;
	      case V4IM_Tag_Suffix:
		if (memcmp(argpnts[ix],&protoNone,V4PS_Int) == 0) { ZUS(suffix) ; break ; } ;
		v4im_GetPointUC(&ok,suffix,UCsizeof(suffix),cpt,ctx) ;
		break ;
	      case -V4IM_Tag_UC:	nCase = UC ; break ;
	      case V4IM_Tag_XML:
		{ UCCHAR *xml,*xp,*json,*jp ; UCCHAR elName[128],*elp ; UCCHAR value[V4LEX_BigText_Max],*vp ;
		  enum XMLS {begin, begin2, tag, tagType, xvalue, endTag, beginend, cdata } ; enum XMLS xmls ;
		  enum JTYPE { jObject, jNull, jArray, jValue, jIgnore } ;
		  LENMAX xmlSize,xmlUsed ;
#define LEVELMAX 100
		  struct {
		     INDEX lx ;
		     UCCHAR attrValList[2048] ;
		     struct {
		       UCCHAR name[UCsizeof(elName)] ;
		       UCCHAR listName[UCsizeof(elName)] ;
		       enum JTYPE jType ;
		      } level[LEVELMAX] ;
		   } xstack ;
		  xstack.lx = 0 ;
		  switch (cpt->PntType)
		   { default:
			xml = v4mm_AllocUC(xmlSize=V4LEX_BigText_Max) ; v4im_GetPointUC(&ok,xml,V4LEX_BigText_Max,cpt,ctx) ; xmlUsed = UCstrlen(xml) ; break ;
		     
		     case V4DPI_PntType_Dict:		/* If dictionary entry then assume name of buffered stream */
			{ UCCHAR *fbuf ; FILEID fileId ;
			   fileId = vout_PntIdToFileId(ctx,(struct V4DPI__LittlePoint *)cpt) ;
			   if (fileId == UNUSED) { v_Msg(ctx,NULL,"StreamNoOutput",intmodx,V4IM_Tag_XML,cpt) ; return(NULL) ; } ;
			   fbuf = vout_GetOutputBuffer(fileId,UNUSED,ctx->ErrorMsgAux) ;
			   if (fbuf == NULL) { v_Msg(ctx,NULL,"ModInvArg2",intmodx,cpt) ; return(NULL) ; } ;
			   xmlUsed = vout_CountForFile(fileId,UNUSED,FALSE,ctx->ErrorMsgAux) ;
			   xml = v4mm_AllocUC(xmlUsed+1) ; UCstrncpy(xml,fbuf,xmlUsed+1) ;
			} break ;
		     case V4DPI_PntType_List:
			xml = v4mm_AllocUC(xmlSize=V4LEX_BigText_Max) ; xmlUsed = 0 ;
			{ struct V4L__ListPoint *lp ; INDEX lx ; P valPt ;
			  lp = VERIFYLIST(NULL,ctx,cpt,intmodx) ;
			  for(lx=1;;lx++)
			   { if (v4l_ListPoint_Value(ctx,lp,lx,&valPt) <= 0) break ;
			     v4im_GetPointUC(&ok,value,V4LEX_BigText_Max,&valPt,ctx) ;
			     if (xmlUsed + UCstrlen(value) >= xmlSize)
			      { xmlSize *= 1.5 ; xml = realloc(xml,sizeof(UCCHAR) * xmlSize) ; } ;
			     UCstrcpy(&xml[xmlUsed],value) ; xmlUsed += UCstrlen(value) ;
			   } ;
			} break ;
		   } ; if (!ok) break ;
		  xmls = begin ; xp = xml ;
		  if (xmlUsed < 100) xmlUsed = 100 ;
		  json = v4mm_AllocUC(2*xmlUsed) ; jp = json ; ZUS(json) ;
		  if (UCnotempty(topName))
		   { UCstrcat(json,topName) ; UCstrcat(json,UClit(":{")) ; } ;
		  for(;*xp!=UCEOS;)
		   { 
		     jp += UCstrlen(jp) ;			/* Advance pointer to end of string */
		     if (*xp <= 0x20) { xp++ ; continue ; } ;	/* Skip control & white space */
		     switch(xmls)
		      { default:
			case begin:				/* Look for <?.....> */
			  if (*xp != UClit('<')) { xp++ ; continue ; } ;
			  if (*(xp+1) == UClit('?')) { xmls = begin2 ; continue ; }
			  xmls = tag ; continue ;
			case begin2:				/* Scan until end of <?.....> */
			  for(;*xp != UClit('>');xp++) { } ;
			  xp++ ; xmls = tag ; continue ;
			case tag:				/* Parsing <tag ...> */
			  if (*xp == UClit('<')) xp++ ;
			  elp = elName ;
/*			  Scan until end of tag name, if name of form xxx:name then replace with 'xxx_name' portion */
			  for(;;elp++,xp++)
			   { 
///			     if (*xp == UClit(':'))
///			      { elp = elName - 1 ; continue ; } ;
			     if (*xp == UClit('-') || (*xp == UClit(':'))) { *elp = UClit('_') ; continue ; } ;
			     if (!vuc_IsContId(*xp)) break ;
			     *elp = *xp ;
			   } ;
			  *elp = UCEOS ;
/*			  Now scan until ending '>' but look for any embedded attributes */
			  { UCCHAR attrName[UCsizeof(elName)],attrValue[512],endDelim ; INDEX anx,avx ;
			    ZUS(xstack.attrValList) ;
			    for(;*xp != UClit('>');xp++)
			     { if (*xp <= 32) continue ;
			       if (*xp == UClit('>')) break ;
			       if (*xp == UClit('/') && *(xp+1) == UClit('>'))
			        { xp++ ; break ; } ;
			       anx = 0 ;
			       for(;*xp!=UClit('=') && anx < UCsizeof(attrName)-1;xp++)
			        { 
///				  if (*xp == UClit(':')) { anx = 0 ; continue ; } ;
				  if (*xp == UClit(':')) { attrName[anx++] = UClit('_') ; continue ; } ;
				  if (*xp <= 32) break ;
				  attrName[anx++] = *xp ;
				} ; attrName[anx++] = UCEOS ; xp++ ;
			       if (*xp != UClit('"') && *xp != UClit('\''))
			        { v_Msg(ctx,NULL,"ParseXMLErr8",intmodx) ; goto failure ; } ;
			       endDelim = *xp ; avx = 0 ; xp++ ;
			       for(;*xp!=endDelim;xp++)
			        { attrValue[avx++] = *xp ;
				} ; attrValue[avx++] = UCEOS ; xp++ ;
			       if (UCnotempty(xstack.attrValList)) UCstrcat(xstack.attrValList,UClit(",")) ;
			       if (UCstrlen(xstack.attrValList) + UCstrlen(attrName) + UCstrlen(attrValue) + 10 > UCsizeof(xstack.attrValList))
			        { v_Msg(ctx,NULL,"ParseXMLErr8",intmodx) ; goto failure ; } ;
			       UCstrcat(xstack.attrValList,attrName) ; UCstrcat(xstack.attrValList,UClit(":\"")) ; UCstrcat(xstack.attrValList,attrValue) ; UCstrcat(xstack.attrValList,UClit("\"")) ;
			       if (*xp == UClit('>')) break ;
			     } ;
			  }
			  xp++ ;
			  if (*(xp-2) != UClit('/')) { xmls = tagType ; continue ; } ;
/*			  Have <xxxxx .... /> - tag begins and end all at once */
			  for(i=0;i<xmlILCnt;i++)
			   { if (UCstrcmpIC(xmlIgnoreList[i],elName) == 0) break ; } ;
/*			  Just output null value unless we are supposed to ignore this tag */
			  if (i < xmlILCnt) continue ;
			  if (!(jp[UCstrlen(jp)-1] == UClit('{') || jp[UCstrlen(jp)-1] == UClit('[') || jp[UCstrlen(jp)-1] == UClit(',')))	/* Tack "," onto end of jp if necessary */
			   { UCstrcat(jp,UClit(",")) ; } ;
			  if (UCempty(xstack.attrValList) || !wantAttr)
			   { UCstrcat(jp,elName) ; UCstrcat(jp,UClit(":null")) ;
			   } else
			   { UCstrcat(jp,elName) ; UCstrcat(jp,UClit(":{attr:{")) ; UCstrcat(jp,xstack.attrValList) ; UCstrcat(jp,UClit("}}")) ;
			   } ;
			  xmls = beginend ; continue ;
			case tagType:				/* elName has new tag, see what is next to determine if value, array or object */
			  if (xstack.lx >= LEVELMAX) { v_Msg(ctx,NULL,"ParseXMLErr2a",intmodx,LEVELMAX,elName) ; goto failure ; } ;
			  UCstrcpy(xstack.level[xstack.lx].name,elName) ; ZUS(xstack.level[xstack.lx].listName) ;
/*			  Check for '</' - ending tag, if got it then have <xxx></xxx> - add object will null value */
			  if (*xp == UClit('<') && *(xp+1) == UClit('/'))
			   { xmls = endTag ; xstack.level[xstack.lx].jType = jNull ; xstack.lx ++ ; continue ; } ;
//			  if (UCstrncmp(xp,UClit("<![CDATA["),9) == 0)
//			   { xmls = cdata ; xstack.level[xstack.lx].jType = jValue ; xstack.lx++ ; continue ; } ;
			  if (jp != json)			/* If not just starting then... */
			   { UCCHAR prior = jp[UCstrlen(jp)-1] ;
			     if (!(prior == UClit('{') || prior == UClit('[') || prior == UClit(',')))	/* Tack "," onto end of jp if necessary */
			      { UCstrcat(jp,UClit(",")) ; } ;
			   } ;
			  if (*xp != UClit('<') || (UCstrncmp(xp,UClit("<![CDATA["),9) == 0))		/* Have value following opening tag */
			   { LOGICAL isCDATA = (*xp == UClit('<')) ;
/*			     If have attributes then have to kind-of force in with new entry elName_attr (not very clean but what can you do?) */
			     if (UCnotempty(xstack.attrValList) && wantAttr)
			      { UCstrcat(jp,elName) ; UCstrcat(jp,UClit("_attr:{")) ; UCstrcat(jp,xstack.attrValList) ; UCstrcat(jp,UClit("},")) ;
			      } ;
/*			     Check to see if we should continue or end an 'array' */
			     if (UCnotempty(xstack.level[xstack.lx-1].listName))
			      { if (UCstrcmpIC(xstack.level[xstack.lx-1].listName,elName) == 0)		/* Current tag matches our current array name - just append value */
			         { xstack.level[xstack.lx].jType = jValue ; xmls = (isCDATA ? cdata : xvalue) ;
				   xstack.lx ++ ; continue ;
				 } ;
				ZUS(xstack.level[xstack.lx-1].listName) ;
			        jp[UCstrlen(jp)-1] = UCEOS ;		/* Strip off trailing comma */
				UCstrcat(jp,UClit("],")) ;
			      } ;
			     xstack.level[xstack.lx].jType = jValue ; UCstrcat(jp,elName) ; UCstrcat(jp,UClit(":")) ; xmls = (isCDATA ? cdata : xvalue) ;
			     for(i=0;i<xmlLLCnt;i++)			/* See if this is to be treated as an array */
			      { if (UCstrcmpIC(xmlListList[i],elName) == 0) break ; } ;
			     if (i < xmlLLCnt)
			      { /* Got a level that matches one of our List::() entries - start an array */
				UCstrcpy(xstack.level[xstack.lx-1].listName,elName) ;
				UCstrcat(jp,UClit("[")) ;
			      } ;
			     xstack.lx ++ ;
			     continue ;
			   } ;
/*			  Got nested tag, elName must refer to an object */
			  xstack.level[xstack.lx].jType = jObject ; xmls = tag ;
			  for(i=0;i<xmlILCnt;i++)
			   { if (UCstrcmpIC(xmlIgnoreList[i],elName) != 0) continue ;
			     xstack.level[xstack.lx].jType = jIgnore ; break ;
			   } ;
			  if (xstack.level[xstack.lx].jType == jIgnore)
			   { xstack.lx ++ ; continue ; } ;
/*			  If we have a 'list' name in prior level then see if this is a continuation of it */
			  if (UCnotempty(xstack.level[xstack.lx-1].listName))
			   { if (UCstrcmpIC(xstack.level[xstack.lx-1].listName,elName) == 0)
			      { /*	Continuation of the list - don't do anything */
			        jp[UCstrlen(jp)-1] = UCEOS ;		/* Strip off trailing comma */
				UCstrcat(jp,UClit(",{")) ;
			        if (UCnotempty(xstack.attrValList) && wantAttr)
			         { UCstrcat(jp,UClit("attr:{")) ; UCstrcat(jp,xstack.attrValList) ; UCstrcat(jp,UClit("},")) ;
			         } ;
				xstack.lx ++ ; continue ;
			      } else
			      { /*	Does not match list name - end the prior list */
			        ZUS(xstack.level[xstack.lx-1].listName) ;
			        jp[UCstrlen(jp)-1] = UCEOS ;		/* Strip off trailing comma */
				UCstrcat(jp,UClit("],")) ;
			      } ;
			   } ;
			  for(i=0;i<xmlLLCnt;i++)
			   { if (UCstrcmpIC(xmlListList[i],elName) == 0) break ; } ;
			  if (i < xmlLLCnt)
			   { /* Got a level that matches one of our List::() entries - start an array */
			     UCstrcpy(xstack.level[xstack.lx-1].listName,elName) ;
			     UCstrcat(jp,elName) ; UCstrcat(jp,UClit(":[{")) ;
			     if (UCnotempty(xstack.attrValList) && wantAttr)
			      { UCstrcat(jp,UClit("attr:{")) ; UCstrcat(jp,xstack.attrValList) ; UCstrcat(jp,UClit("},")) ;
			      } ;
			     xstack.lx ++ ; continue ;
			   } ;
			  UCstrcat(jp,elName) ; UCstrcat(jp,UClit(":{")) ;
			  if (UCnotempty(xstack.attrValList) && wantAttr)
			   { UCstrcat(jp,UClit("attr:{")) ; UCstrcat(jp,xstack.attrValList) ; UCstrcat(jp,UClit("},")) ;
			   } ;
			  xstack.lx ++ ; continue ;


//			  if (*xp == UClit('<'))		/* Got nested tag, elName must refer to an object */
//			   { xstack.level[xstack.lx].jType = jObject ; xmls = tag ;
//			     for(i=0;i<xmlILCnt;i++)
//			      { if (UCstrcmpIC(xmlIgnoreList[i],elName) != 0) continue ;
//				xstack.level[xstack.lx].jType = jIgnore ; break ;
//			      } ;
//			     if (xstack.level[xstack.lx].jType != jIgnore) { UCstrcat(jp,elName) ; UCstrcat(jp,UClit(":{")) ; } ;
//			   }
//			   else { xstack.level[xstack.lx].jType = jValue ; UCstrcat(jp,elName) ; UCstrcat(jp,UClit(":")) ; xmls = xvalue ; } ;
//			  xstack.lx ++ ; continue ;




			case xvalue:
			  { LENMAX chars ;
			    for(vp=value,chars=0;*xp!=UClit('<') && *xp!=UCEOS && chars < UCsizeof(value)-1;xp++,vp++,chars++) { *vp = *xp ; } ;
			    if (*xp == UCEOS) { v_Msg(ctx,NULL,"ParseXMLErr6",intmodx) ; goto failure ; } ;
			    if (chars >= UCsizeof(value) - 2) { value[100] = UCEOS ; v_Msg(ctx,NULL,"ParseXMLErr7",intmodx,chars,value) ; goto failure ; } ;
			    for(chars--;value[chars] < 0x20;chars--) { } ;	/* Get rid of any trailing control or white space characters */
			    value[chars+1] = UCEOS ;
			    if (UCstrcmp(value,UClit("false")) == 0 || UCstrcmp(value,UClit("true")) == 0) { UCstrcat(jp,value) ; }
			     else { UCCHAR *eos ; UCstrtod(value,&eos) ;
				    if (*eos == UCEOS && UCstrlen(value) < 10) { UCstrcat(jp,value) ; }
				     else { UCCHAR *s=value, *d=value ;
/*					    Maybe clean up the value if it has embedded newlines/returns */
					    for(;*s!=UCEOS;)
					     { if (*s >= UClit(' ')) { if (s != d) *d = *s ; s++ ; d++ ; continue ; } ;
					       for (;*s <= UClit(' ');s++) { } ;
					       *d = UClit(' ') ; d++ ;			/* Replace with single space */
					     } ; *d = UCEOS ;
					    v_StringLit(value,&jp[UCstrlen(jp)],V4DPI_UCVAL_MaxSafe,UClit('"'),'\0') ;
					  } ;
				  } ;
			    xmls = endTag ;
			  } ;
			  continue ;
			case cdata:				/* Parsing </tag ...> */
			  if (UCstrncmp(xp,UClit("<![CDATA["),9) == 0)
			   xp += 9 ;
			  { UCCHAR *p ; LENMAX chars ;
			    ZUS(value) ;
			    for(;;)
			     { p = UCstrstr(xp,UClit("]]>")) ;
			       if (p == NULL) 
				{ v_Msg(ctx,NULL,"ParseXMLErr9",intmodx,xstack.level[xstack.lx-1].name) ; goto failure ; } ;
			       chars = p - xp ;
			       UCstrncpy(value,xp,(chars >= UCsizeof(value) - 2 ? UCsizeof(value)-2 : chars)) ;
			       if (chars >= UCsizeof(value) - 2) { value[100] = UCEOS ; v_Msg(ctx,NULL,"ParseXMLErr7",intmodx,chars,value) ; goto failure ; } ;
			       value[chars] = UCEOS ; xp += (chars + 3) ;
			       if (UCstrncmp(xp,UClit("<![CDATA["),9) == 0)
			        { xp += 9 ; }
				else { break ; } ;
			     }
			    for(chars--;value[chars] < 0x20;chars--) { } ;	/* Get rid of any trailing control or white space characters */
			    value[chars+1] = UCEOS ;
			    if (UCstrcmp(value,UClit("false")) == 0 || UCstrcmp(value,UClit("true")) == 0) { UCstrcat(jp,value) ; }
			     else { UCCHAR *eos ; UCstrtod(value,&eos) ;
				    if (*eos == UCEOS && UCstrlen(value) < 10) { UCstrcat(jp,value) ; }
				     else { UCCHAR *s=value, *d=value ;
/*					    Maybe clean up the value if it has embedded newlines/returns */
					    for(;*s!=UCEOS;)
					     { if (*s >= UClit(' ')) { if (s != d) *d = *s ; s++ ; d++ ; continue ; } ;
					       for (;*s <= UClit(' ');s++) { } ;
					       *d = UClit(' ') ; d++ ;			/* Replace with single space */
					     } ; *d = UCEOS ;
					    v_StringLit(value,&jp[UCstrlen(jp)],V4DPI_UCVAL_MaxSafe,UClit('"'),'\0') ;
					  } ;
				  } ;
			    xmls = endTag ;
			  }
			  continue ;
			case endTag:				/* Parsing </tag ...> */
			  if (*xp == UClit('<')) xp++ ; if (*xp == UClit('/')) xp++ ;
			  elp = elName ;


			  for(;;elp++,xp++)
			   { 
//			     if (*xp == UClit(':'))
//			      { elp = elName - 1 ; continue ; } ;
			     if (*xp == UClit('-') || (*xp == UClit('_')) || (*xp == UClit(':'))) { *elp = UClit('_') ; continue ; } ;
			     if (!vuc_IsContId(*xp)) break ;
			     *elp = *xp ;
			   } ;
			  *elp = UCEOS ; for(;*xp != UClit('>');) { xp++ ; } ;
			  xp++ ;
			  if (UCstrcmp(elName,xstack.level[xstack.lx-1].name) != 0)
			   { v_Msg(ctx,NULL,"ParseXMLErr4a",intmodx,elName,xstack.level[xstack.lx-1].name,UClit("")) ; goto failure ; } ;
/*			  Does the level we are closing off have a nested array? If so then close off the lower level array first */
			  if (UCnotempty(xstack.level[xstack.lx-1].listName))
			   { ZUS(xstack.level[xstack.lx-1].listName) ;
			     UCstrcat(jp,UClit("]")) ;
			   } ;

			  xstack.lx -- ;
			  switch(xstack.level[xstack.lx].jType)
			   { case jObject:	UCstrcat(jp,UClit("}")) ; break ;
			     case jNull:	switch(*(jp-1))
						 { default:		UCstrcat(jp,UClit(",")) ; break ;
						   case UClit('{'):	break ;
						   case UClit('['):	break ;
						   case UClit(','):	break ;
						 } ;
						UCstrcat(jp,xstack.level[xstack.lx].name) ; UCstrcat(jp,UClit(":null")) ;
						break ;
			     case jArray:	UCstrcat(jp,UClit("]")) ; break ;
			     case jValue:	break ;
			     case jIgnore:	break ;
			   } ;
			  xmls = beginend ; continue ;
			case beginend:				/* Could be begin tag OR end tag - let's see */
			  if (*xp == UClit('<')) xp++ ;
			  xmls = (*xp == UClit('/') ? endTag : tag) ;
			  continue ;
		      } ;
		   } ;
		  if (UCnotempty(topName))
		   { UCstrcat(jp,UClit("}")) ; } ;		/* End the enclosing xml:{ } object */
		  v4mm_FreeChunk(xml) ;				/* All done with this */

/*		  If want to parse it then take care of it here */
		  if (doParseToo)
		   { struct V4LEX__TknCtrlBlk *tcb ; DICTID dictId ;
		     tcb = v4mm_AllocChunk(sizeof(struct V4LEX__TknCtrlBlk),FALSE) ; v4lex_InitTCB(tcb,V4LEX_TCBINIT_NoStdIn) ;
		     v4lex_NestInput(tcb,NULL,NULL,V4LEX_InpMode_RetEOF) ;
		     v4lex_NestInput(tcb,NULL,json,V4LEX_InpMode_StringPtr) ;
		     dictId = vjson_ParseString(ctx,tcb,NULL,parseFlags) ;
		     v4lex_FreeTCB(tcb) ;
		     json = NULL ;		/* Side effect of FreeTCB - frees up nested string pointers */
		     if (dictId == 0) { v_Msg(ctx,NULL,"ParseJSON",intmodx) ; goto failure ; } ;
		     intPNTv(respnt,dictId) ; goto json_xml_ret ;
		   }

/*		  Here to actually store result - have to determine how (or maybe store as BigText) */
		  if (UCstrlen(json) >= V4DPI_UCVAL_MaxSafe)	/* If any arguments were BigText, then return bigtext point */
		   { struct V4LEX__BigText *bt ;
		     if (UCstrlen(json) >= V4LEX_BigText_Max)
		      { v_Msg(ctx,NULL,"@%1E - Result string (len=%2d) exceeds max length allowed(%3d)",intmodx,len,V4LEX_BigText_Max) ; goto failure ; } ;
		     bt = (struct V4LEX__BigText *)v4mm_AllocChunk(sizeof *bt,FALSE) ;
		     UCstrcpy(bt->BigBuf,json) ;
		     if (!v4dpi_SaveBigTextPoint(ctx,bt,UCstrlen(bt->BigBuf),respnt,Dim_Alpha,TRUE))
		      { v_Msg(ctx,NULL,"StrSaveBigText",intmodx,V4DPI_PntType_BigText) ; goto failure ; } ;
		     v4mm_FreeChunk(bt) ;
		   } else		/* Store as Alpha point */	
		   { uccharPNTv(respnt,json) ;
		   } ;
json_xml_ret:	  if (json != NULL) v4mm_FreeChunk(json) ;
		  return(respnt) ;
		}
	    } ;
	 } ;
	if (!ok) { v_Msg(ctx,NULL,"ModInvArg",intmodx,ix-1) ; goto failure ; } ;
/*	Terminate with whatever is needed (characters in termString are in reverse order!) */
	for(i=UCstrlen(termString)-1;i>=0;i--)
	 { UCCHAR ucb[2] ; ucb[0] = termString[i] ; ucb[1] = UCEOS ;
	   UCstrcat(ucbufP,ucb) ;
	 } ;
	
	if (ucbufL > JSONBUFINITIAL)			/* If result is huge return memory pointer to it */
	 { memPNTv(respnt,ucbufP) ; respnt->AltDim = TRUE ;
v_Msg(ctx,UCTBUF1,"@*%1M returning very long (%2d characters) result\n",intmodx,ucbufL) ; vout_UCText(VOUT_Warn,0,UCTBUF1) ;
	   return(respnt) ;				/* NOTE - ucbufP MUST BE DEALLOCATED AFTER IT IS USED */
	 } ;
	len = UCstrlen(ucbufP) ;
	if (len >= V4DPI_UCVAL_MaxSafe)
	 { struct V4LEX__BigText *bt ;
//	   if (len >= V4LEX_BigText_Max) { v_Msg(ctx,NULL,"@%1E - Result string (len=%2d) exceeds max length allowed(%3d)",intmodx,len,V4LEX_BigText_Max) ; goto failure ; } ;
	   if (len >= V4LEX_BigText_Max) { v_Msg(ctx,NULL,"BigTextLineTL",intmodx,1,len,V4LEX_BigText_Max,V4DPI_PntType_BigText) ; goto failure ; } ;
	   bt = (struct V4LEX__BigText *)v4mm_AllocChunk(sizeof *bt,FALSE) ;
	   UCstrcpy(bt->BigBuf,ucbufP) ;
	   if (!v4dpi_SaveBigTextPoint(ctx,bt,UCstrlen(bt->BigBuf),respnt,Dim_Alpha,TRUE)) { v_Msg(ctx,NULL,"StrSaveBigText",intmodx,V4DPI_PntType_BigText) ; goto failure ; } ;
	   v4mm_FreeChunk(bt) ;		
	 } else		/* Store as UCChar point */	
	 { uccharPNTv(respnt,ucbufP) ;
	 } ;
/*	Return as quoted string so if nested in another JSON we know not to enclose in quotes */
	respnt->AltDim = TRUE ;
	if (ucbufP != ucbuf) v4mm_FreeChunk(ucbufP) ;		/* If we had to allocate extra space then free it up now */
	return(respnt) ;



failure:
	if (ucbufP != ucbuf) v4mm_FreeChunk(ucbufP) ;
	REGISTER_ERROR(0) ; return(NULL) ;

}

LOGICAL v4im_JSONValString(ctx,jpt,dstP,dstmaxP,intmodx,ix,offset,isFunc)
  struct V4C__Context *ctx ;
  P *jpt ;						/* Ptr for result */
  UCCHAR **dstP ; LENMAX *dstmaxP ;
  INTMODX intmodx ;
  INDEX ix ;
  INDEX offset ;
  LOGICAL isFunc ;
{ struct V4DPI__DimInfo *di ;
  UCCHAR ucbuf1[V4LEX_BigText_Max*2] ;
  UCCHAR *dst ; LENMAX dstmax ;
  LOGICAL ok ;
  extern struct V4DPI__LittlePoint protoNull ;

#define INCREASEBUFFER(NUMCHARS) \
  if (*dstmaxP == JSONBUFINITIAL) /* If increasing for first time the take care because initial buffer off of stack */ \
   { UCCHAR *__p ; *dstmaxP += NUMCHARS ; __p = v4mm_AllocUC(*dstmaxP) ; UCstrcpy(__p,*dstP) ; *dstP = __p ; } \
   else { *dstmaxP += NUMCHARS ; *dstP = realloc(*dstP,sizeof(UCCHAR) * (*dstmaxP)) ; } ; \
  dst = &(*dstP)[offset] ; dstmax = *dstmaxP - offset ;

	dst = &(*dstP)[offset] ; dstmax = *dstmaxP - offset ;
	ZUS(dst) ;
	if (memcmp(jpt,&protoNone,V4PS_Int) == 0) return(TRUE) ;	/* Don't format UV4:none point */
	if (memcmp(jpt,&protoNull,V4PS_Int) == 0) { UCstrcpy(dst,UClit("null")) ; return(TRUE) ; } ;
	switch(jpt->PntType)
	 { default:
		if (!v4sxi_SpecialDisplayer(ctx,jpt,UCsizeof(ucbuf1),ucbuf1))
		 v4dpi_PointToStringML(ucbuf1,jpt,ctx,V4DPI_FormatOpt_Echo,UCsizeof(ucbuf1)) ;
		if (dstmax < UCstrlen(ucbuf1) * 1.5) { INCREASEBUFFER(UCstrlen(ucbuf1) * 2) ; } ;
		if (isFunc) { UCstrncpy(dst,ucbuf1,dstmax) ; }
		 else { v_StringLit(ucbuf1,dst,dstmax,UClit('"'),UClit('\\')) ; } ;
		break ;
	   case V4DPI_PntType_Int:
	   case V4DPI_PntType_Real:
	   case V4DPI_PntType_Fixed:
		if (dstmax < 255) { INCREASEBUFFER(512) ; } ;
		DIMINFO(di,ctx,jpt->Dim) ;
		if ((di->Flags & V4DPI_DimInfo_Displayer) != 0 || jpt->Grouping != V4DPI_Grouping_Single)	/* If dimension has displayer OR not a single value then treat string */
		 { v4dpi_PointToStringML(ucbuf1,jpt,ctx,V4DPI_FormatOpt_Echo,UCsizeof(ucbuf1)) ;
		   v_StringLit(ucbuf1,dst,dstmax,UClit('"'),UClit('\\')) ;
		 } else { v4dpi_PointToStringML(dst,jpt,ctx,V4DPI_FormatOpt_Echo,dstmax) ; } ;
		break ;
	   case V4DPI_PntType_Logical:
		if (dstmax < 32) { INCREASEBUFFER(512) ; } ;
		UCstrcpy(dst,(jpt->Value.IntVal > 0 ? UClit("true") : UClit("false"))) ;
		break ;
	   case V4DPI_PntType_List:
		if (dstmax < 255) { INCREASEBUFFER(512) ; } ;
		{ struct V4L__ListPoint *lp ; INDEX lx ; P valpt ;
		  UCstrcpy(dst,UClit("[")) ;
		  lp = VERIFYLIST(NULL,ctx,jpt,intmodx) ;
		  for(lx=1;;lx++)
		   { if (v4l_ListPoint_Value(ctx,lp,lx,&valpt) <= 0) break ;
		     if (lx > 1) UCstrcat(dst,UClit(",")) ;
		     if (!v4im_JSONValString(ctx,&valpt,dstP,dstmaxP,intmodx,ix,offset+UCstrlen(dst),FALSE)) return(FALSE) ;
		     dst = &(*dstP)[offset] ; dstmax = *dstmaxP - (offset + UCstrlen(dst)) ;	/* Have to reset these because they may have changed drastically */
		     if (dstmax < 255) { INCREASEBUFFER(512) ; } ;
		   } ;
		  UCstrcat(dst,UClit("]")) ;
//		  if (UCstrlen(ucbuf1) >= dstmax) { v_Msg(ctx,NULL,"ListPtLen1",intmodx,UCstrlen(ucbuf1),dstmax) ; return(FALSE) ; } ;
//		  UCstrcpy(dst,ucbuf1) ;
		}
		break ;
//		v_Msg(ctx,NULL,"JSONPntType",intmodx,ix,jpt,jpt->PntType) ; return(FALSE) ;
	   case V4DPI_PntType_MemPtr:		/* This may be a huge UCCHAR string from nested JSON() call or just a huge string */
		{ UCCHAR *p ; LENMAX pLen ;
		  memcpy(&p,&jpt->Value.MemPtr,sizeof p) ;
		  pLen = UCstrlen(p) ; if (pLen > dstmax) { INCREASEBUFFER(pLen*1.5) ; } ;
		  if (jpt->AltDim)		/* If set then this is result of nested JSON - don't need to quote it */
		   { UCstrcpy(dst,p) ; }
		   else { v_StringLit(p,dst,dstmax,UClit('"'),UClit('\\')) ; } ;
		  v4mm_FreeChunk(p) ;		/* Release the memory associated with this now that we don't need it anymore */
		  break ;
		}
//	   case V4DPI_PntType_BigText:
	   CASEofChar
		v4im_GetPointUC(&ok,ucbuf1,UCsizeof(ucbuf1),jpt,ctx) ;
		{ LENMAX len = UCstrlen(ucbuf1) ;
		  if (dstmax - (2 *len) < 16) { INCREASEBUFFER(2*len) ; } ;
		}
		if (!(jpt->AltDim || isFunc))				/* Nested JSON or JS function - don't put double quotes around it */
		 { v4im_GetPointUC(&ok,ucbuf1,UCsizeof(ucbuf1),jpt,ctx) ;
		   v_StringLit(ucbuf1,dst,dstmax,UClit('"'),UClit('\\')) ;
		 } else
		 { v4im_GetPointUC(&ok,dst,dstmax,jpt,ctx) ;
		 } ;
		break ;
	 } ;
	return(TRUE) ;
}


struct V4DPI__Point *v4im_DoTable(ctx,respnt,argpnts,argcnt,intmodx,trace)
  struct V4C__Context *ctx ;
  P *respnt ;						/* Ptr for result */
  INTMODX intmodx ;
  P *argpnts[] ;
  COUNTER argcnt ; VTRACE trace ;
{ P *cpt, ptbuf ;
  struct V4DPI__LittlePoint lpnt ;
  struct V4DPI__Point valpt ;
  struct V4DPI__DimInfo *di ;
  struct V4L__ListPoint *lp ;
  struct V4LEX__TablePrsOpt *tpo ;
  struct V4LEX__Table_Tran *vtt ;
  struct V4LEX__Table *vlt,*tvlt,vltNew ;
  UCCHAR tablename[V4LEX_TCBMacro_NameMax+1] ;
  LOGICAL ok,isNewTable ;
  INDEX ix,i,colx,tx ; DIMID dimId ;

#define GOTVLT if (!v4im_vltDoTable(ctx,vlt)) goto fail ;
#define GOTVLTCOL if (!v4im_vltcolDoTable(ctx,vlt,colx)) goto fail ;
#undef SETFLAG
#define SETFLAG(flag) if (v4im_GetPointLog(&ok,cpt,ctx)) { vlt->Col[colx].ColumnType |= V4LEX_TableCT_##flag ; } else { vlt->Col[colx].ColumnType &= ~(V4LEX_TableCT_##flag) ; } ;
#undef RETFLAG
#define RETFLAG(flag) \
 if ((vlt->Col[colx].ColumnType & V4LEX_TableCT_##flag)!=0) { logPNTv(respnt,TRUE) ; } \
  else { v_Msg(ctx,NULL,"TableValUndef",intmodx,tx) ; goto fail ; } ;

	vlt = NULL ; colx = UNUSED ; tpo = NULL ; isNewTable = FALSE ; dimId = UNUSED ;
	for(ix=1,ok=TRUE;ok&&ix<=argcnt;ix++)			/* Step thru the remaining arguments */
	 { 
	   if (argpnts[ix]->PntType != V4DPI_PntType_TagVal && argpnts[ix]->Dim != Dim_Dim)
	    { switch (argpnts[ix]->PntType)
	       { default:	v_Msg(ctx,NULL,"TableInvName",intmodx,ix,argpnts[ix]) ; goto fail ;
	         case V4DPI_PntType_Dict:
	         CASEofChar
//	         case V4DPI_PntType_BigText:
		   v4im_GetPointUC(&ok,tablename,UCsizeof(tablename),argpnts[ix],ctx) ; if (!ok) break ;
		   vlt = v4eval_GetTable(ctx,tablename,NULL) ;
		   if (vlt == NULL) { v_Msg(ctx,NULL,"TableNotDef1",intmodx,V4IM_Tag_Table,tablename) ; goto fail ; } ;
		   break ;
	       } ;
	      continue ;
	    } ;
	   if (tpo == NULL && vlt != NULL) tpo = (vlt->tpo == NULL ? &vlt->tpoT : vlt->tpo) ;

	   switch ((tx=v4im_CheckPtArgNew(ctx,argpnts[ix],&cpt,&ptbuf)))
	    { default:				v_Msg(ctx,NULL,"TagBadUse",intmodx) ; goto fail ;
	      case V4IM_Tag_Unk:		v_Msg(ctx,NULL,"TagUnknown",intmodx) ; goto fail ;
	      case V4IM_Tag_Acceptor:
		GOTVLTCOL
		if ((vtt = vlt->Col[colx].vtt) == NULL)
		 vtt = (vlt->Col[colx].vtt = (struct V4LEX__Table_Tran *)v4mm_AllocChunk(sizeof *vtt,TRUE)) ;
		vtt->acpt = (P *)v4mm_AllocChunk(cpt->Bytes,FALSE) ; memcpy(vtt->acpt,cpt,cpt->Bytes) ;
		break ;
	      case -V4IM_Tag_Acceptor:
		GOTVLTCOL
		if ((vtt = vlt->Col[colx].vtt) == NULL)
		 { v_Msg(ctx,NULL,"TableValUndef",intmodx,-V4IM_Tag_Acceptor) ; goto fail ; } ;
		if (vtt->acpt == NULL) { v_Msg(ctx,NULL,"TableValUndef",intmodx,-V4IM_Tag_Error) ; goto fail ; } ;
		memcpy(respnt,vtt->acpt,vtt->acpt->Bytes) ; return(respnt) ;
	      case V4IM_Tag_AggKey:
		GOTVLTCOL ; SETFLAG(AggKey) ; break ;
	      case -V4IM_Tag_AggKey:
		GOTVLTCOL ; RETFLAG(AggKey) ; return(respnt) ;
	      case V4IM_Tag_Column:
		GOTVLT
		switch (cpt->PntType)
		 { default:			v_Msg(ctx,NULL,"TableInvCol",intmodx,ix,cpt) ; goto fail ;
		   case V4DPI_PntType_Int:
			i = v4im_GetPointInt(&ok,cpt,ctx) ; if (!ok) break ;
			for(colx=0;i>0;colx++)		/* Have to skip over IGNORED columns */
			 { if (vlt->Col[colx].ColumnType & V4LEX_TableCT_Ignore) continue ;
			   i-- ;
			 } ;
			colx-- ;
			if (colx < 0 || colx >= vlt->Columns) { v_Msg(ctx,NULL,"TableNotCol",intmodx,V4IM_Tag_Column,cpt,vlt->Name) ; goto fail ; } ;
			break ;
		   case V4DPI_PntType_Dict:
		   case V4DPI_PntType_XDict:
		   CASEofChar
			v4im_GetPointUC(&ok,UCTBUF1,V4TMBufMax,cpt,ctx) ; if (!ok) break ;
			for(colx=0;colx<vlt->Columns;colx++) { if (UCstrcmpIC(vlt->Col[colx].Name,UCTBUF1) == 0) break ; } ;
			if (colx >= vlt->Columns) { v_Msg(ctx,NULL,"TableNotCol",intmodx,V4IM_Tag_Column,cpt,vlt->Name) ; goto fail ; } ;
			break ;
		 } ;
		break ;
	      case V4IM_Tag_Comment:
		GOTVLT ; v4im_GetPointUC(&ok,tpo->Comment,UCsizeof(tpo->Comment),cpt,ctx) ; if (!ok) break ;
		break ;
	      case -V4IM_Tag_Comment:
		GOTVLT ;
		if (UCempty(tpo->Comment)) { v_Msg(ctx,NULL,"TableValUndef",intmodx,-V4IM_Tag_Comment) ; goto fail ; } ;
		uccharPNTv(respnt,tpo->Comment) ; return(respnt) ;
	      case V4IM_Tag_Create:
		if (vlt == NULL)		/* If no VLT then assume we are creating a table, otherwise a column */
		 { vlt = &vltNew ; memset(vlt,0,sizeof *vlt) ; isNewTable = TRUE ;
		   v4im_GetPointUC(&ok,vlt->Name,V4LEX_TCBMacro_NameMax,cpt,ctx) ; if (!ok) break ;
		 } else
		 { if (vlt->Columns >= V4LEX_Table_ColMax) { v_Msg(ctx,NULL,"TableColMax",intmodx,V4LEX_Table_ColMax) ; goto fail ; } ;
		   colx = vlt->Columns ;
		   v4im_GetPointUC(&ok,vlt->Col[colx].Name,V4DPI_DimInfo_DimNameMax+1,cpt,ctx) ; if (!ok) break ;
		   vlt->Col[vlt->Columns].PntTypeInfo = UNUSED ; vlt->Col[vlt->Columns].PntType1 = UNUSED ;
		   vlt->Col[vlt->Columns].Decimals = UNUSED ; vlt->Col[vlt->Columns].Width = UNUSED ; vlt->Col[vlt->Columns].inclusionMask = UNUSED ;
		   vlt->Col[vlt->Columns].StartX = UNUSED ; vlt->Col[vlt->Columns].EndX = UNUSED ;
		 } ;
		break ;
	      case V4IM_Tag_Decimal:
		GOTVLTCOL
		vlt->Col[colx].Decimals = v4im_GetPointInt(&ok,cpt,ctx) ; if (!ok) break ;
		if (vlt->Col[colx].Decimals < 0 || vlt->Col[colx].Decimals > V4DPI_Fixed_MaxDecimals) { v_Msg(ctx,NULL,"ModArgRange",intmodx,ix,cpt,0,V4DPI_Fixed_MaxDecimals) ; goto fail ; } ;
		break ;
	      case -V4IM_Tag_Decimal:
		GOTVLTCOL ;
		if (vlt->Col[colx].Decimals == UNUSED) { v_Msg(ctx,NULL,"TableValUndef",intmodx,-V4IM_Tag_Decimal) ; goto fail ; } ;
		intPNTv(respnt,vlt->Col[colx].Decimals) ; return(respnt) ;
	      case V4IM_Tag_Default:
		GOTVLTCOL
		vlt->Col[colx].Dflt = (P *)v4mm_AllocChunk(cpt->Bytes,FALSE) ; memcpy(vlt->Col[colx].Dflt,cpt,cpt->Bytes) ;
		break ;
	      case -V4IM_Tag_Default:
		GOTVLTCOL
		if (vlt->Col[colx].Dflt == NULL) { v_Msg(ctx,NULL,"TableValUndef",intmodx,-V4IM_Tag_Default) ; goto fail ; } ;
		memcpy(respnt,vlt->Col[colx].Dflt,vlt->Col[colx].Dflt->Bytes) ; return(respnt) ;
	      case V4IM_Tag_Delimiter:
		GOTVLT
		if (cpt->PntType == V4DPI_PntType_Dict)
		 { switch (v4im_GetDictToEnumVal(ctx,cpt))
		    { default:		v_Msg(ctx,NULL,"ModTagValue",intmodx,ix,V4IM_Tag_Delimiter,cpt) ; goto fail ;
		      case _CSV:	tpo->Delim = UClit(',') ; break ;
		      case _None:	tpo->Delim = UCEOS ; break ;
		      case _Tab:	tpo->Delim = UClit('\t') ; break ;
		    } ;
		 } else
		 { v4im_GetPointUC(&ok,UCTBUF1,2,cpt,ctx) ; if (!ok) break ;
		   tpo->Delim = UCTBUF1[0] ;
		 } ;
		break ;
	      case -V4IM_Tag_Delimiter:
		GOTVLT
		if (tpo->Delim == UCEOS) { v_Msg(ctx,NULL,"TableValUndef",intmodx,-V4IM_Tag_Delimiter) ; goto fail ; } ;
		respnt->Value.UCVal[0] =  1 ; respnt->Value.UCVal[1] = tpo->Delim ; respnt->Value.UCVal[2] = UCEOS ;
		uccharPNT(respnt) ; UCCHARPNTBYTES1(respnt) ; return(respnt) ;
	      case V4IM_Tag_Description:
		GOTVLTCOL
		v4im_GetPointUC(&ok,UCTBUF1,V4TMBufMax,cpt,ctx) ; if(!ok) break ;
		vlt->Col[colx].Desc = v4mm_AllocUC(UCstrlen(UCTBUF1)) ;	UCstrcpy(vlt->Col[colx].Desc,UCTBUF1) ;
		break ;
	      case -V4IM_Tag_Description:
		GOTVLTCOL
		if (vlt->Col[colx].Desc == NULL) { v_Msg(ctx,NULL,"TableValUndef",intmodx,-V4IM_Tag_Description) ; goto fail ; } ;
		uccharPNTv(respnt,vlt->Col[colx].Desc) ; return(respnt) ;
	      case V4IM_Tag_Dim:
		GOTVLT ;
		if (colx == UNUSED)		/* Handle differently depending on if we have column defined or not */
		 { dimId = cpt->Value.IntVal ;	/* Save dim for possible use by ListOf? */
		  if (cpt->Grouping == V4DPI_Grouping_Single) { vlt->dimIds[0] = cpt->Value.IntVal ; vlt->dimCount = 1 ; }
		    else { INDEX px ;
			   struct V4DPI__Point_IntMix *pim  = (struct V4DPI__Point_IntMix *)&cpt->Value ;
			   for (px=0;px<V4LEX_Table_DimMax;px++) { vlt->dimIds[px] = pim->Entry[px].BeginInt ; } ;
			   vlt->dimCount = px ;
			 } ;
		 } else
		 { DIMINFO(di,ctx,cpt->Value.IntVal) ; vlt->Col[colx].di = di ; vlt->Col[colx].PntType = di->PointType ;
		 } ;
		break ;
	      case -V4IM_Tag_Dim:
		GOTVLT ;
	        if (colx == UNUSED)
	         { INDEX px ;
		   struct V4DPI__Point_IntMix *pim  = (struct V4DPI__Point_IntMix *)&respnt->Value ;
		   if (vlt->dimCount <= 0) { v_Msg(ctx,NULL,"TableNoDimTable",intmodx) ; goto fail ; } ;
	           if (vlt->dimCount == 1)
	            { dictPNTv(respnt,Dim_Dim,vlt->dimIds[0]) ; }
	            else { dictPNT(respnt,Dim_Dim) ;
			   for(px=0;px<vlt->dimCount;px++) { pim->Entry[px].BeginInt = (pim->Entry[px].EndInt = vlt->dimIds[px]) ; } ;
			   respnt->Grouping = vlt->dimCount ;
//			   respnt->Bytes = V4DPI_PointHdr_Bytes + (respnt->Grouping * sizeof pim->Entry[0]) ;
			   SETBYTESGRPINT(respnt) ;

			 } ;
	         } else { dictPNTv(respnt,Dim_Dim,vlt->Col[colx].di->DimId) ; } ;
		return(respnt) ;
	      case V4IM_Tag_Embed:
	      case V4IM_Tag_End:
	      case V4IM_Tag_Ending:
		GOTVLTCOL
		vlt->Col[colx].EndX = v4im_GetPointInt(&ok,cpt,ctx) - 1 ; if (!ok) break ;	/* Internally we use 0-based indexing */
		if (vlt->Col[colx].EndX < 0 || vlt->Col[colx].EndX > 5000) { v_Msg(ctx,NULL,"ModArgRange",intmodx,ix,cpt,1,5000) ; goto fail ; } ;
		break ;
	      case -V4IM_Tag_End:
	      case -V4IM_Tag_Ending:
		GOTVLTCOL
		if (tpo->Delim != UNUSED) { v_Msg(ctx,NULL,"TableUndVal1",intmodx,-V4IM_Tag_End) ; goto fail ; } ;
		intPNTv(respnt,vlt->Col[colx].EndX+1) ; return(respnt) ;
	      case V4IM_Tag_Error:
		GOTVLTCOL
		vlt->Col[colx].Err = (P *)v4mm_AllocChunk(cpt->Bytes,FALSE) ; memcpy(vlt->Col[colx].Err,cpt,cpt->Bytes) ;
		break ;
	      case -V4IM_Tag_Error:
		GOTVLTCOL
		if (vlt->Col[colx].Err == NULL) { v_Msg(ctx,NULL,"TableValUndef",intmodx,-V4IM_Tag_Error) ; goto fail ; } ;
		memcpy(respnt,vlt->Col[colx].Err,vlt->Col[colx].Err->Bytes) ; return(respnt) ;
	      case V4IM_Tag_Expression:
		GOTVLTCOL ; SETFLAG(Expression) ;
		vlt->Col[colx].Cur = v4mm_AllocChunk(cpt->Bytes,FALSE) ;
		memcpy(vlt->Col[colx].Cur,cpt,cpt->Bytes) ; 
		break ;
	      case -V4IM_Tag_Expression:
		GOTVLTCOL ;
		if ((vlt->Col[colx].ColumnType & V4LEX_TableCT_Expression) == 0) { v_Msg(ctx,NULL,"TableValUndef",intmodx,V4IM_Tag_Expression) ; goto fail ; } ;
		memcpy(respnt,vlt->Col[colx].Cur,vlt->Col[colx].Cur->Bytes) ;
		return(respnt) ;
	      case V4IM_Tag_Filter:
		GOTVLT ; tpo->filterPt = (P *)v4mm_AllocChunk(cpt->Bytes,FALSE) ; memcpy(tpo->filterPt,cpt,cpt->Bytes) ;
		break ;
	      case -V4IM_Tag_Filter:
		GOTVLT
		if (tpo->filterPt == NULL) { v_Msg(ctx,NULL,"TableValUndef",intmodx,-V4IM_Tag_Filter) ; goto fail ; } ;
		memcpy(respnt,tpo->filterPt,tpo->filterPt->Bytes) ; return(respnt) ;
	      case V4IM_Tag_FixedLength:
		GOTVLTCOL
		vlt->Col[colx].FixedLength = v4im_GetPointInt(&ok,cpt,ctx) ; if (!ok) break ;
		if (vlt->Col[colx].FixedLength < 1 || vlt->Col[colx].FixedLength > 5000) { v_Msg(ctx,NULL,"ModArgRange",intmodx,ix,cpt,1,5000) ; goto fail ; } ;
		break ;
	      case -V4IM_Tag_FixedLength:
		GOTVLTCOL ;
		if (vlt->Col[colx].FixedLength == 0) { v_Msg(ctx,NULL,"TableValUndef",intmodx,-V4IM_Tag_FixedLength) ; goto fail ; } ;
		intPNTv(respnt,vlt->Col[colx].FixedLength) ; return(respnt) ;
	      case V4IM_Tag_Format:
		GOTVLTCOL
#define SETFORMAT(FTYPE) case _##FTYPE: vlt->Col[colx].PntTypeInfo = V4LEX_TablePT_##FTYPE ; break ;
		switch (v4im_GetDictToEnumVal(ctx,cpt))
		 { default:		v_Msg(ctx,NULL,"ModTagValue",intmodx,ix,V4IM_Tag_Format,cpt) ; goto fail ;
		   SETFORMAT(Default)
		   SETFORMAT(Internal)
		   SETFORMAT(YYMMDD)
		   SETFORMAT(MMDDYY)
		   SETFORMAT(DDMMMYY)
		   SETFORMAT(Hex4)
		   SETFORMAT(Hexadecimal)
		   SETFORMAT(Money)
		   SETFORMAT(YYMM)
		   SETFORMAT(MMYY)
		   SETFORMAT(MMM)
		 } ;
		break ;
	      case -V4IM_Tag_Format:
		GOTVLTCOL
#define RETFORMAT(FTYPE) case V4LEX_TablePT_##FTYPE: dictPNTv(respnt,Dim_UV4,v4im_GetEnumToDictVal(ctx,DE(FTYPE),Dim_UV4)) ; break ;
		switch (vlt->Col[colx].PntTypeInfo)
		 { default:
		   case V4LEX_TablePT_Default:	v_Msg(ctx,NULL,"TableValUndef",intmodx,-V4IM_Tag_Format) ; goto fail ;
		   RETFORMAT(Internal)
		   RETFORMAT(YYMMDD)
		   RETFORMAT(MMDDYY)
		   RETFORMAT(DDMMMYY)
		   RETFORMAT(Hex4)
		   RETFORMAT(Hexadecimal)
		   RETFORMAT(Money)
		   RETFORMAT(YYMM)
		   RETFORMAT(MMYY)
		   RETFORMAT(MMM)
		 } ;
		return(respnt) ;
	      case V4IM_Tag_Header:
		GOTVLT
		tpo->HeaderLines = v4im_GetPointInt(&ok,cpt,ctx) ; if (!ok) break ;
		if (tpo->HeaderLines < 0 || tpo->HeaderLines > 5000) { v_Msg(ctx,NULL,"ModArgRange",intmodx,ix,cpt,0,5000) ; goto fail ; } ;
		break ;
	      case -V4IM_Tag_Header:
		GOTVLT ;
		if (tpo->HeaderLines == 0) { v_Msg(ctx,NULL,"TableValUndef",intmodx,-V4IM_Tag_Header) ; goto fail ; } ;
		intPNTv(respnt,tpo->HeaderLines) ; return(respnt) ;
	      case V4IM_Tag_Ignore:
		GOTVLTCOL ; SETFLAG(Ignore) ; break ;
	      case -V4IM_Tag_Ignore:
		GOTVLTCOL ; RETFLAG(Ignore) ; return(respnt) ;
	      case V4IM_Tag_Include:
	      case V4IM_Tag_Index:
		GOTVLTCOL
		{ int mask = v4im_GetPointInt(&ok,cpt,ctx) ; if (!ok) break ;
		  if (mask == 0) goto allIndexEntry ;
		  if (mask < 1 || mask > 32) { v_Msg(ctx,NULL,"TableBadMask",intmodx,V4IM_Tag_Index,mask) ; goto fail ; } ;
		  mask = (1 << (mask-1)) ;
		  if ((((vlt->Col[colx].inclusionMask & mask) == 0) && (vlt->Col[colx].inclusionMask != 0))
			|| (vlt->Col[colx].ColumnType & (V4LEX_TableCT_NPTableName|V4LEX_TableCT_TableName|V4LEX_TableCT_AggKey|V4LEX_TableCT_Ignore|V4LEX_TableCT_Expression)))
		   { v_Msg(ctx,NULL,"TableNoIndex",intmodx,vlt->Col[colx].Name,-V4IM_Tag_Index) ; goto fail ; } ;
		  for(ix=0,i=0;i<=colx;i++)
		   { if ((((vlt->Col[i].inclusionMask & mask) == 0) && (vlt->Col[i].inclusionMask != 0))
			  || (vlt->Col[i].ColumnType & (V4LEX_TableCT_NPTableName|V4LEX_TableCT_TableName|V4LEX_TableCT_AggKey|V4LEX_TableCT_Ignore|V4LEX_TableCT_Expression))) continue ;
		     ix++ ;
		   } ;
		}
		intPNTv(respnt,ix) ; return(respnt) ;
	      case -V4IM_Tag_Index:
allIndexEntry:	GOTVLTCOL
		if (vlt->Col[colx].ColumnType & (V4LEX_TableCT_NPTableName|V4LEX_TableCT_TableName|V4LEX_TableCT_AggKey|V4LEX_TableCT_Ignore|V4LEX_TableCT_Expression))
		 { v_Msg(ctx,NULL,"TableNoIndex",intmodx,vlt->Col[colx].Name,-V4IM_Tag_Index) ; goto fail ; } ;
		for(ix=0,i=0;i<=colx;i++)
		 { if (vlt->Col[i].ColumnType & (V4LEX_TableCT_NPTableName|V4LEX_TableCT_TableName|V4LEX_TableCT_AggKey|V4LEX_TableCT_Ignore|V4LEX_TableCT_Expression)) continue ;
		   ix++ ;
		 } ;
		intPNTv(respnt,ix) ; return(respnt) ;
	      case V4IM_Tag_Link:
		GOTVLTCOL
		switch (v4im_GetDictToEnumVal(ctx,cpt))
		 { default:		v_Msg(ctx,NULL,"ModTagValue",intmodx,ix,V4IM_Tag_Delimiter,cpt) ; goto fail ;
		   case _NoPrefix:	vlt->Col[colx].ColumnType |= V4LEX_TableCT_NPTableName ; break ;
		   case _Prefix:	vlt->Col[colx].ColumnType |= V4LEX_TableCT_TableName ; break ;
		 } ;
		break ;
	      case -V4IM_Tag_Link:
		GOTVLTCOL
		if ((vlt->Col[colx].ColumnType & V4LEX_TableCT_NPTableName) != 0) { dictPNTv(respnt,Dim_UV4,v4im_GetEnumToDictVal(ctx,DE(NoPrefix),Dim_UV4)) ; }
		 else if ((vlt->Col[colx].ColumnType & V4LEX_TableCT_TableName) != 0) { dictPNTv(respnt,Dim_UV4,v4im_GetEnumToDictVal(ctx,DE(Prefix),Dim_UV4)) ; }
		 else { v_Msg(ctx,NULL,"TableValUndef",intmodx,-V4IM_Tag_Link) ; goto fail ; } ;
		return(respnt) ;
	      case V4IM_Tag_ListOf:
	      {	enum DictionaryEntries de ;
		GOTVLT
		de = v4im_GetDictToEnumVal(ctx,cpt) ;
		DIMINFO(di,ctx,Dim_NId) ; INITLP(respnt,lp,Dim_List) ;
		for(i=0;i<vlt->Columns;i++)
		 { if (de == _All ? FALSE : vlt->Col[i].ColumnType & V4LEX_TableCT_Ignore) continue ;
		   switch (de)
		    { default:		v_Msg(ctx,NULL,"ModTagValue",intmodx,ix,V4IM_Tag_ListOf,cpt) ; goto fail ;
		      case _All:	/* All is same as Name except that ALL columns return (i.e. ignored columns also returned) */
			dictPNTv(&lpnt,Dim_NId,v4dpi_DictEntryGet(ctx,0,vlt->Col[i].Name,di,0)) ;
			if (dimId != UNUSED) lpnt.Dim = dimId ;
			break ;
		      case _Dim:
			dictPNTv(&lpnt,Dim_Dim,vlt->Col[i].di->DimId) ; break ;
		      case _Name:
			dictPNTv(&lpnt,Dim_NId,v4dpi_DictEntryGet(ctx,0,vlt->Col[i].Name,di,0)) ;
			if (dimId != UNUSED) lpnt.Dim = dimId ;
			break ;
		      case _Position:
			if (tpo->Delim != UNUSED) { v_Msg(ctx,NULL,"TableUndVal",intmodx,V4IM_Tag_ListOf,DE(Position)) ; goto fail ; } ;
			int2PNTv(&lpnt,vlt->Col[i].StartX,vlt->Col[i].EndX) ; break ;
		      case _Width:
			if (tpo->Delim != UNUSED) { v_Msg(ctx,NULL,"TableUndVal",intmodx,V4IM_Tag_ListOf,DE(Position)) ; goto fail ; } ;
			intPNTv(&lpnt,vlt->Col[i].Width) ; break ;
		    } ;
		   if (!v4l_ListPoint_Modify(ctx,lp,V4L_ListAction_Append,(P *)&lpnt,0)) { v_Msg(ctx,NULL,"LPModFail",intmodx) ; goto fail ; } ;
		 } ;
		ENDLP(respnt,lp) ; return(respnt) ;
	      }
	      case -V4IM_Tag_ListOf:
		if (vlt == NULL)			/* If vlt undefined then return list of all tables */
		 { DIMINFO(di,ctx,Dim_NId) ; INITLP(respnt,lp,Dim_List) ;
		   for(tvlt=gpi->vlt;tvlt!=NULL;tvlt=tvlt->link)	/* First look for all currently defined tables */
		    { dictPNTv(&lpnt,Dim_NId,v4dpi_DictEntryGet(ctx,0,tvlt->Name,di,0)) ; lpnt.Dim = (dimId == UNUSED ? Dim_UTable : dimId) ;
		      if (!v4l_ListPoint_Modify(ctx,lp,V4L_ListAction_Append,(P *)&lpnt,0)) { v_Msg(ctx,NULL,"LPModFail",intmodx) ; goto fail ; } ;
		    } ;
		   { struct V4LEX__MacroDirectory *vlmd = v4eval_GetMacroDir(ctx) ;
		     INDEX mx ;
/*		     Add all table entries (that we have not included from above) into list */
		     for(mx=0;(vlmd==NULL?FALSE:mx<vlmd->numEntries);mx++)
		      { if (vlmd->macro[mx].macType != V4LEX_MACTYPE_Table) continue ;
		        dictPNTv(&lpnt,Dim_NId,v4dpi_DictEntryGet(ctx,0,vlmd->macro[mx].macNameNC,di,0)) ;
		        for(ok=TRUE,tvlt=gpi->vlt;tvlt!=NULL;tvlt=tvlt->link)	/* If we already dumped out this table, don't repeat */
		         { DICTID did = v4dpi_DictEntryGet(ctx,0,tvlt->Name,di,0) ;
		           if (did == lpnt.Value.IntVal) { ok = FALSE ; break ; } ;
		         } ; if (!ok) continue ;
		        lpnt.Dim = (dimId == UNUSED ? Dim_UTable : dimId) ;
		        if (!v4l_ListPoint_Modify(ctx,lp,V4L_ListAction_Append,(P *)&lpnt,0)) { v_Msg(ctx,NULL,"LPModFail",intmodx) ; goto fail ; } ;
		      } ;
		   }
		   ENDLP(respnt,lp) ; return(respnt) ;
		 } ;
		DIMINFO(di,ctx,Dim_NId) ; INITLP(respnt,lp,Dim_List) ;
		for(i=0;i<vlt->Columns;i++)
		 { if (vlt->Col[i].ColumnType & V4LEX_TableCT_Ignore) continue ;
		   dictPNTv(&lpnt,Dim_NId,v4dpi_DictEntryGet(ctx,0,vlt->Col[i].Name,di,0)) ;
		   if (dimId != UNUSED) lpnt.Dim = dimId ;
		   if (!v4l_ListPoint_Modify(ctx,lp,V4L_ListAction_Append,(P *)&lpnt,0)) { v_Msg(ctx,NULL,"LPModFail",intmodx) ; goto fail ; } ;
		 } ;
		ENDLP(respnt,lp) ; return(respnt) ;
	      case V4IM_Tag_Macro:
		GOTVLT ; v4im_GetPointUC(&ok,tpo->Macro,UCsizeof(tpo->Macro),cpt,ctx) ; if (!ok) break ;
		break ;
	      case -V4IM_Tag_Macro:
		GOTVLT
		if (UCempty(tpo->Macro)) { v_Msg(ctx,NULL,"TableValUndef",intmodx,-V4IM_Tag_Macro) ; goto fail ; } ;
		uccharPNTv(respnt,tpo->Macro) ; return(respnt) ;
	      case V4IM_Tag_Mask:
		GOTVLTCOL
		vlt->Col[colx].inclusionMask = 0 ;
		{ P *ipt ; INDEX lx,bit ;
		  lp = (cpt->PntType == V4DPI_PntType_List ? VERIFYLIST(NULL,ctx,cpt,intmodx) : NULL) ;
		  for(lx=1;;lx++)
		   { if (lp == NULL) { ipt = cpt ; } else { if (v4l_ListPoint_Value(ctx,lp,lx,&valpt) <= 0) break ; ipt = &valpt ; } ;
		     bit = v4im_GetPointInt(&ok,ipt,ctx) ; if (!ok) break ;
		     if (bit < 1 || bit > 32) { v_Msg(ctx,NULL,"ModArgRange",intmodx,ix,cpt,1,32) ; goto fail ; } ;
		     vlt->Col[colx].inclusionMask |= (1 << (bit-1)) ;
		     if (lp == NULL) break ;
		   } ;
		}
		break ;
	      case -V4IM_Tag_Mask:
		GOTVLTCOL
		if (vlt->Col[colx].inclusionMask == 0 || vlt->Col[colx].inclusionMask == UNUSED) { v_Msg(ctx,NULL,"TableValUndef",intmodx,-V4IM_Tag_Mask) ; goto fail ; } ;
		INITLP(respnt,lp,Dim_List) ;
		for(i=0;i<31;i++)
		 { if ((vlt->Col[colx].inclusionMask & (1<<i)) == 0) continue ;
		   intPNTv(&lpnt,i+1) ;
		   if (!v4l_ListPoint_Modify(ctx,lp,V4L_ListAction_Append,(P *)&lpnt,0)) { v_Msg(ctx,NULL,"LPModFail",intmodx) ; goto fail ; } ;
		 } ;
		ENDLP(respnt,lp) ; return(respnt) ;
	      case V4IM_Tag_Minimum:
		GOTVLT
		tpo->MinLength = v4im_GetPointInt(&ok,cpt,ctx) ; if (!ok) break ;
		if (tpo->MinLength < 0 || tpo->MinLength > 5000) { v_Msg(ctx,NULL,"ModArgRange",intmodx,ix,cpt,0,5000) ; goto fail ; } ;
		break ;
	      case -V4IM_Tag_Minimum:
		GOTVLT
		if (tpo->MinLength <= 0) { v_Msg(ctx,NULL,"TableValUndef",intmodx,-V4IM_Tag_Minimum) ; goto fail ; } ;
		intPNTv(respnt,tpo->MinLength) ; return(respnt) ;
	      case V4IM_Tag_Missing:
		GOTVLTCOL ; vlt->Col[colx].Missing = (P *)v4mm_AllocChunk(cpt->Bytes,FALSE) ; memcpy(vlt->Col[colx].Missing,cpt,cpt->Bytes) ;
		break ;
	      case -V4IM_Tag_Missing:
		GOTVLTCOL
		if (vlt->Col[colx].Missing == NULL) { v_Msg(ctx,NULL,"TableValUndef",intmodx,-V4IM_Tag_Missing) ; goto fail ; } ;
		memcpy(respnt,vlt->Col[colx].Missing,vlt->Col[colx].Missing->Bytes) ; return(respnt) ;
	      case V4IM_Tag_Name:
		GOTVLTCOL ; v4im_GetPointUC(&ok,vlt->Col[colx].Name,UCsizeof(vlt->Col[colx].Name),cpt,ctx) ; if(!ok) break ;
		break ;
	      case -V4IM_Tag_Name:
		GOTVLTCOL ; uccharPNTv(respnt,vlt->Col[colx].Name) ; return(respnt) ;
	      case V4IM_Tag_Other:
		GOTVLT
		if (vlt->otherList != NULL) { v4mm_FreeChunk(vlt->otherList) ; vlt->otherList = NULL ; } ;
		if (memcmp(cpt,&protoNone,V4PS_Int) == 0) break ;	/* If 'none' point then return empty string */
		v4im_GetPointUC(&ok,UCTBUF1,V4TMBufMax,cpt,ctx) ; if (!ok) break ;
		{ struct V4LEX__TknCtrlBlk *tcb ;
		  tcb = v4mm_AllocChunk(sizeof *tcb,FALSE) ; v4lex_InitTCB(tcb,V4LEX_TCBINIT_NoStdIn) ;
		  v4lex_NestInput(tcb,NULL,UCTBUF1,V4LEX_InpMode_String) ;
		  ok = v4im_vltParseOther(ctx,vlt,tcb) ; v4lex_FreeTCB(tcb) ;
		  if (!ok) goto fail ;
		}
/*		Just fall thru and return processed "Other" value */
	      case -V4IM_Tag_Other:
		GOTVLT
		if (vlt->otherList == NULL) { v_Msg(ctx,NULL,"TableValUndef",intmodx,-V4IM_Tag_Other) ; goto fail ; } ;
		uccharPNTv(respnt,vlt->otherList) ; return(respnt) ;
	      case V4IM_Tag_Point:
		GOTVLTCOL ; SETFLAG(Point) ;
		vlt->Col[colx].Cur = v4mm_AllocChunk(cpt->Bytes,FALSE) ;
		memcpy(vlt->Col[colx].Cur,cpt,cpt->Bytes) ;
		break ;
	      case -V4IM_Tag_Point:
		GOTVLTCOL ;
		if ((vlt->Col[colx].ColumnType & V4LEX_TableCT_Point) == 0) { v_Msg(ctx,NULL,"TableValUndef",intmodx,V4IM_Tag_Point) ; goto fail ; } ;
		memcpy(respnt,vlt->Col[colx].Cur,vlt->Col[colx].Cur->Bytes) ;
		return(respnt) ;
	      case V4IM_Tag_Quoted:
		GOTVLTCOL ; SETFLAG(Quoted) ; break ;
	      case -V4IM_Tag_Quoted:
		GOTVLTCOL ; RETFLAG(Quoted) ; return(respnt) ;
	      case V4IM_Tag_Scale:
		GOTVLTCOL
		if ((vtt = vlt->Col[vlt->Columns].vtt) == NULL)
		 vtt = (vlt->Col[vlt->Columns].vtt = (struct V4LEX__Table_Tran *)v4mm_AllocChunk(sizeof *vtt,TRUE)) ;
		vtt->scale = v4im_GetPointDbl(&ok,cpt,ctx) ; break ;
	      case -V4IM_Tag_Scale:
		GOTVLTCOL
		if ((vtt = vlt->Col[colx].vtt) == NULL)
		 { v_Msg(ctx,NULL,"TableValUndef",intmodx,-V4IM_Tag_Scale) ; goto fail ; } ;
		if (vtt->acpt == NULL) { v_Msg(ctx,NULL,"TableValUndef",intmodx,-V4IM_Tag_Error) ; goto fail ; } ;
		dblPNTv(respnt,vtt->scale) ; return(respnt) ;
	      case V4IM_Tag_Start:
		GOTVLTCOL
		vlt->Col[colx].StartX = v4im_GetPointInt(&ok,cpt,ctx) - 1 ; if (!ok) break ;	/* Internally use 0-based indexing */
		if (vlt->Col[colx].StartX < 0 || vlt->Col[colx].StartX > 5000) { v_Msg(ctx,NULL,"ModArgRange",intmodx,ix,cpt,1,5000) ; goto fail ; } ;
		break ;
	      case -V4IM_Tag_Start:
		GOTVLTCOL
		if (tpo->Delim != UNUSED) { v_Msg(ctx,NULL,"TableUndVal1",intmodx,-V4IM_Tag_Start) ; goto fail ; } ;
		intPNTv(respnt,vlt->Col[colx].StartX+1) ;
		return(respnt) ;
	      case V4IM_Tag_Table:
		v4im_GetPointUC(&ok,tablename,UCsizeof(tablename),cpt,ctx) ; if (!ok) break ;
		vlt = v4eval_GetTable(ctx,tablename,NULL) ;
		if (vlt == NULL) { v_Msg(ctx,NULL,"TableNotDef1",intmodx,V4IM_Tag_Table,tablename) ; goto fail ; } ;
		break ;
	      case V4IM_Tag_Trim:
		GOTVLTCOL ; SETFLAG(Trim) ; break ;
	      case -V4IM_Tag_Trim:
		GOTVLTCOL ; RETFLAG(Trim) ; return(respnt) ;
	      case -V4IM_Tag_Type:
		{ enum DictionaryEntries de ;
		  if (vlt->Col[colx].ColumnType & V4LEX_TableCT_Ignore) { de = _Ignore ; }
		   else if (vlt->Col[colx].ColumnType & V4LEX_TableCT_AggKey) { de = _AggKey ; }
		   else if (vlt->Col[colx].ColumnType & V4LEX_TableCT_Point) { de = _Point ; }
		   else if (vlt->Col[colx].ColumnType & V4LEX_TableCT_Expression) { de = _Expression ; }
		   else if (vlt->Col[colx].ColumnType & V4LEX_TableCT_NPTableName) { de = _NoPrefix ; }
		   else if (vlt->Col[colx].ColumnType & V4LEX_TableCT_TableName) { de = _Prefix ; }
		   else { de = _Normal ; }
		  dictPNTv(respnt,Dim_UV4,v4im_GetEnumToDictVal(ctx,de,Dim_UV4)) ;
		}
		return(respnt) ;
	      case V4IM_Tag_Width:
		GOTVLTCOL
		vlt->Col[colx].Width = v4im_GetPointInt(&ok,cpt,ctx) ; if (!ok) break ;
		if (vlt->Col[colx].Width < 1 || vlt->Col[colx].Width > 5000) { v_Msg(ctx,NULL,"ModArgRange",intmodx,ix,cpt,1,5000) ; goto fail ; } ;
		break ;
	      case -V4IM_Tag_Width:
		GOTVLTCOL
		if (tpo->Delim != UNUSED) { v_Msg(ctx,NULL,"TableUndVal1",intmodx,-V4IM_Tag_Width) ; goto fail ; } ;
		intPNTv(respnt,vlt->Col[colx].Width) ; return(respnt) ;
	    } ;
	 } ;
	if (!ok) { v_Msg(ctx,NULL,"ModInvArg",intmodx,ix-1) ; goto fail ; } ;
	if (colx != UNUSED && vlt->Col[colx].di == NULL) { v_Msg(ctx,NULL,"TableNoDim",intmodx,vlt->Col[colx].Name) ; goto fail ; } ;
	if (colx == vlt->Columns) vlt->Columns++ ;	/* If we created new column then remember by upping total count for table */
/*	If we just created a new table then allocate it */
	if (isNewTable)
	 { tvlt = (struct V4LEX__Table *)v4mm_AllocChunk(sizeof *vlt,FALSE) ;
	   *tvlt = *vlt ; vlt = tvlt ;
	 } ;	 
	if (!v4im_vltEndTable(ctx,vlt,isNewTable)) { v_Msg(ctx,NULL,"TableEnd",intmodx) ; goto fail ; } ;
	return((P *)&Log_True) ;			/* We have to return something! */
fail:
	REGISTER_ERROR(0) ; return(NULL) ;
}

LOGICAL v4im_vltDoTable(ctx,vlt)
  struct V4C__Context *ctx ;
  struct V4LEX__Table *vlt ;
{
	if (vlt == NULL) { v_Msg(ctx,NULL,"TableNoSel",V4IM_OpCode_Table) ; return(FALSE) ; } ;
	return(TRUE) ;
}

LOGICAL v4im_vltcolDoTable(ctx,vlt,colx)
  struct V4C__Context *ctx ;
  struct V4LEX__Table *vlt ;
  INDEX colx ;
{
	if (vlt == NULL) { v_Msg(ctx,NULL,"TableNoSel",V4IM_OpCode_Table) ; return(FALSE) ; } ;
	if (colx == UNUSED) { v_Msg(ctx,NULL,"TableNoSelCol",V4IM_OpCode_Table) ; return(FALSE) ; } ;
	return(TRUE) ;
}

LOGICAL v4im_vltEndTable(ctx,vlt,isNewTable)
  struct V4C__Context *ctx ;
  struct V4LEX__Table *vlt ;
  LOGICAL isNewTable ;
{
  INDEX i ;
  struct V4LEX__Table *tvlt ;

	for(i=0;i<vlt->Columns;i++)
	 { if (vlt->Col[i].StartX != UNUSED && vlt->Col[i].Width == UNUSED)
	    { if (i == vlt->Columns - 1)
	       { v_Msg(ctx,ctx->ErrorMsgAux,"CmdColStart",vlt->Col[vlt->Columns].StartX) ; return(FALSE) ; } ;
	      vlt->Col[i].Width = vlt->Col[i+1].StartX - vlt->Col[i].StartX ;
	    } ;
	 } ;
	tvlt = NULL ;
	if (vlt->IsDefault && gpi->vlt != NULL)
	 { for(tvlt=gpi->vlt;tvlt!=NULL;tvlt=tvlt->link)
	    { if (tvlt->IsDefault) break ; } ;			/* Look for existing defaults */
	 } ;
	if (isNewTable && tvlt == NULL)
	 { vlt->link = gpi->vlt ; gpi->vlt = vlt ; } ;		/* Link up this table definition */
	vlt->ctx = ctx ;					/* Link up to current context */
	return(TRUE) ;
}

/*	v4im_vltParseOther - Parses list of 'other' arguments/options for a table	*/
/*	Call: ok = v4im_vltParseOther( ctx , vlt , tcb )
	  where ok is TRUE if OK, FALSE if error (ctx->ErrorMsgAux),
		ctx is context,
		vlt is table structure to be updated,
		tcb is control block with input to be parsed				*/

LOGICAL v4im_vltParseOther(ctx,vlt,tcb)
  struct V4C__Context *ctx ;
  struct V4LEX__Table *vlt ;
  struct V4LEX__TknCtrlBlk *tcb ;
{
  UCCHAR optName[V4LEX_Tkn_KeywordMax+5], optVal[4096], optArg[256], optList[V4LEX_Tkn_StringMax] ;

#define TKN(flags) { v4lex_NextTkn(tcb,flags) ; if (tcb->type == V4LEX_TknType_Error) goto parse_err ; }
#define OPTARG(VALUE) \
 if (UCstrlen(VALUE) + UCstrlen(optVal) >= sizeof optVal) { v_Msg(ctx,ctx->ErrorMsgAux,"MacroArgLen",tcb->type,UCstrlen(VALUE) + UCstrlen(optVal),sizeof optVal) ; return(FALSE) ; } ; \
 UCstrcat(optVal,VALUE) ;

	ZUS(optList) ;
/*	Loop through as many optspec=valuespec, optspec=valuespec,... that we have */
	for(;;)
	 { ZUS(optArg) ; ZUS(optVal) ;
	   TKN(V4LEX_Option_ForceAsIsULC+V4LEX_Option_ExpandArgs) ;
	   if (tcb->opcode !=  V_OpCode_Keyword) { v_Msg(ctx,ctx->ErrorMsgAux,"TableOptName",tcb->type,DE(Other)) ; return(FALSE) ; } ;
	   UCstrcpy(optName,tcb->UCstring) ; TKN(V4LEX_Option_ForceAsIsULC+V4LEX_Option_ExpandArgs) ;
/*	   Now see if we have just simple 'name=value' or something more complicated such as 'dim:name.name...=value' */
	   switch (tcb->opcode)
	    { default:
		v_Msg(ctx,ctx->ErrorMsgAux,"TableOptBadSyn",tcb->type,DE(Other),1) ; return(FALSE) ;
	      case V_OpCode_Equal:
		UCstrcpy(optArg,optName) ;
		break ;			/* Drop down to get value */
	      case V_OpCode_Dot:
	      case V_OpCode_Colon:
		UCstrcat(optArg,UClit("(")) ; UCstrcat(optArg,optName) ;
		for(;;)
		 {
		   if (tcb->opcode == V_OpCode_Dot)
		    { UCstrcat(optArg,UClit(" ")) ; TKN(0) ; if (tcb->opcode != V_OpCode_Keyword) { v_Msg(ctx,ctx->ErrorMsgAux,"TableOptBadSyn",tcb->type,DE(Other),2) ; return(FALSE) ; } ;
		    } else if (tcb->opcode == V_OpCode_Colon)
		    { UCstrcat(optArg,UClit(":")) ;
		      TKN(V4LEX_Option_ForceAsIsULC+V4LEX_Option_ExpandArgs) ;
		      UCstrcat(optArg,tcb->UCstring) ;
		      TKN(0) ;
		      if (tcb->opcode == V_OpCode_Equal) break ;
		      if (tcb->opcode != V_OpCode_Dot) { v_Msg(ctx,ctx->ErrorMsgAux,"TableOptBadSyn",tcb->type,DE(Other),3) ; return(FALSE) ; } ;
		      UCstrcat(optArg,UClit(" ")) ; TKN(0) ; if (tcb->opcode != V_OpCode_Keyword) break ;
		    } else
		    { v_Msg(ctx,ctx->ErrorMsgAux,"TableOptBadSyn",tcb->type,DE(Other),4) ; return(FALSE) ; } ;
		   UCstrcat(optArg,tcb->UCkeyword) ;
		   TKN(0) ; if (tcb->opcode == V_OpCode_Equal) break ;
		 } ;
		UCstrcat(optArg,UClit(")")) ; 
		break ;
	    } ;
/*	   Here to parse the value */
	   TKN(V4LEX_Option_ForceAsIsULC+V4LEX_Option_ExpandArgs) ;
	   switch (tcb->opcode)
	    { default:
	      case V_OpCode_Keyword:
	      case V_OpCode_QString:
	      case V_OpCode_DQString:
		OPTARG(tcb->UCstring) ; break ;
	      case V_OpCode_Langle:
	      case V_OpCode_LangleLangle:
	      { UCCHAR fnStart[V_FileName_Max] ; INDEX lnStart,ilxStart ;	/* Remember where we are in case we don't ever see ">" or ">>" */
	        INDEX endOp = (tcb->opcode == V_OpCode_Langle ? V_OpCode_Rangle : V_OpCode_RangleRangle) ;	/* If we start with '<' then end with '>', if start with '<<' then end with '>>' */
		ilxStart = tcb->ilx ; lnStart = tcb->ilvl[tcb->ilx].current_line ; UCstrcpy(fnStart,tcb->ilvl[tcb->ilx].file_name) ; 
		TKN(V4LEX_Option_ForceAsIsULC+V4LEX_Option_ExpandArgs) ;
		for(;;)
		 { OPTARG(tcb->UCstring) ;
		   if(vuc_IsWSpace(*tcb->ilvl[tcb->ilx].input_ptr) || (*tcb->ilvl[tcb->ilx].input_ptr < 26))
		    { OPTARG(UClit(" ")) ; } ;	/* Only append space if terminated with white space or control character (ex: end-of-line) */
		   TKN(V4LEX_Option_ForceAsIsULC+V4LEX_Option_ExpandArgs) ;
		   if (tcb->ilx != ilxStart)
		    { v_Msg(ctx,ctx->ErrorMsgAux,"TableOptValue",DE(Other),lnStart,fnStart) ; return(FALSE) ; } ;
		   if (tcb->opcode == endOp) break ;
		 } ;
	      }
		break ;
	    } ;
	   if (UCempty(optList)) { UCstrcat(optList,UClit("(")) ; } ;
	   UCstrcat(optList,UClit("(")) ; UCstrcat(optList,optArg) ; UCstrcat(optList,UClit(" ")) ; UCstrcat(optList,optVal) ; UCstrcat(optList,UClit(")")) ;
/*	   Next token best be "," or ")" */
	   TKN(V4LEX_Option_RetEOL)
	   if (tcb->opcode != V_OpCode_Comma)
	    { v4lex_NextTkn(tcb,V4LEX_Option_PushCur) ; break ; } ;
	 } ;
/*	End of options - now save the 'list' of options we just created as a UCCHAR string */
	vlt->otherList = v4mm_AllocUC(UCstrlen(optList)) ; UCstrcpy(vlt->otherList,optList) ;
	return(TRUE) ;
parse_err:
	v_Msg(NULL,ctx->ErrorMsgAux,"TablePrsErr",tcb->type,DE(Other),tcb->UCstring) ; return(FALSE) ;

}

struct V4DPI__Point *v4im_DoEvalAE(ctx,respnt,argpnts,argcnt,intmodx,trace,isct)
  struct V4C__Context *ctx ;
  struct V4DPI__Point *respnt ;
  INTMODX intmodx ;
  P *argpnts[],*isct ;
  COUNTER argcnt ; VTRACE trace ;
{ P *vpt,*cpt, apnt, *savePt ;
  struct V4LEX__TknCtrlBlk *tcb ;
  struct V4DPI__DimInfo *di ;
  DIMID resdim ; LOGICAL ok,isProb ; INDEX ix,ixSave ;
  UCCHAR tb[V4TMBufMax] ; double dnum ;

	resdim = Dim_Int ; vpt = NULL ; ZUS(tb) ; ok = TRUE ; isProb = FALSE ; savePt = NULL ;
	for(ix=1;ok&&ix<=argcnt;ix++)
	 { if (argpnts[ix]->PntType != V4DPI_PntType_TagVal && argpnts[ix]->Dim != Dim_Dim)
	    { v4im_GetPointUC(&ok,tb,UCsizeof(tb),argpnts[ix],ctx) ; continue ; } ;
	   switch (v4im_CheckPtArgNew(ctx,argpnts[ix],&cpt,&apnt))
	    { default:			v_Msg(ctx,NULL,"TagBadUse",intmodx) ; goto fail ;
	      case V4IM_Tag_Unk:	v_Msg(ctx,NULL,"TagUnknown",intmodx) ; goto fail ;
	      case V4IM_Tag_Dim:	ixSave = ix ; savePt = cpt ; resdim = cpt->Value.IntVal ; break ;
	      case V4IM_Tag_Point:	vpt = cpt ; break ;
	      case V4IM_Tag_Problem:	isProb = v4im_GetPointLog(&ok,cpt,ctx) ; break ;
	      case -V4IM_Tag_Problem:	isProb = TRUE ; break ;
	    } ;
	 } ;
	if (!ok) { v_Msg(ctx,NULL,"ModInvArg",intmodx,ix-1) ; goto fail ; } ;
	if (UCempty(tb)) { v_Msg(ctx,NULL,"ModNoString",intmodx) ; goto fail ; } ;
	tcb = v4mm_AllocChunk(sizeof *tcb,FALSE) ; v4lex_InitTCB(tcb,V4LEX_TCBINIT_NoStdIn) ; v4lex_NestInput(tcb,NULL,tb,V4LEX_InpMode_String) ;
	dnum = (double)v4im_EvalArithExp(ctx,tcb,trace,&ok,vpt,isProb) ;
	v4lex_FreeTCB(tcb) ;
	if (!ok) { v_Msg(ctx,NULL,"EvalAEFail",intmodx,tb) ; goto fail ; } ;
	if (isProb)					/* If validating then return TRUE/FALSE */
	 { if (dnum == 1.0)			/* 1.0 = no problems - fail */
	    { v_Msg(ctx,NULL,"UV4EvalNoProb",intmodx) ; goto fail ; } ;
	   ZPH(respnt) ; uccharPNTv(respnt,ctx->ErrorMsg) ;
	   return(respnt) ;
	 } ;
	DIMINFO(di,ctx,resdim) ;
	if (di == NULL) { v_Msg(ctx,NULL,"ModArgNotDim",intmodx,ixSave,savePt) ; goto fail ; } ;
	ZPH(respnt) ; respnt->Grouping = V4DPI_Grouping_Single ;
	respnt->Dim = di->DimId ; respnt->Bytes = V4PS_Real ; /* Update result with proper dimension */
	respnt->PntType = di->PointType ;
	v4im_SetPointValue(ctx,respnt,dnum) ;
	return(respnt) ;
fail:
	REGISTER_ERROR(0) ; return(NULL) ;
}

struct V4DPI__Point *v4im_DoEvalLE(ctx,respnt,argpnts,argcnt,intmodx,trace,isct)
  struct V4C__Context *ctx ;
  struct V4DPI__Point *respnt ;
  INTMODX intmodx ;
  P *argpnts[],*isct ;
  COUNTER argcnt ; VTRACE trace ;
{ P *cpt, *ipt, apnt ;
  struct V4LEX__TknCtrlBlk *tcb ;
  LOGICAL ok,isProb ; INDEX ix ; DIMID dimid ;
  UCCHAR tb[V4TMBufMax] ;
  
	ok = TRUE ; dimid = UNUSED ; isProb = FALSE ;
	for(ix=1;ok&&ix<=argcnt;ix++)
	 { if (argpnts[ix]->PntType != V4DPI_PntType_TagVal && argpnts[ix]->Dim != Dim_Dim)
	    { v4im_GetPointUC(&ok,tb,UCsizeof(tb),argpnts[ix],ctx) ; continue ; } ;
	   switch (v4im_CheckPtArgNew(ctx,argpnts[ix],&cpt,&apnt))
	    { default:			v_Msg(ctx,NULL,"TagBadUse",intmodx) ; goto fail ;
	      case V4IM_Tag_Unk:	v_Msg(ctx,NULL,"TagUnknown",intmodx) ; goto fail ;
	      case V4IM_Tag_Dim:	dimid = cpt->Value.IntVal ; break ;
	      case V4IM_Tag_Problem:	isProb = v4im_GetPointLog(&ok,cpt,ctx) ; break ;
	      case -V4IM_Tag_Problem:	isProb = TRUE ; break ;
	    } ;
	 } ;
	if (!ok) { v_Msg(ctx,NULL,"ModInvArg",intmodx,ix-1) ; goto fail ; } ;
	tcb = v4mm_AllocChunk(sizeof *tcb,FALSE) ; v4lex_InitTCB(tcb,V4LEX_TCBINIT_NoStdIn) ; v4lex_NestInput(tcb,NULL,tb,V4LEX_InpMode_String) ;
	ipt = v4im_EvalListExp(ctx,respnt,tcb,trace,&ok,dimid,isProb) ;
	v4lex_FreeTCB(tcb) ;
	if (!ok) { v_Msg(ctx,NULL,"EvalAEFail",intmodx,tb) ; goto fail ; } ;
	if (isProb)
	 { if (ipt == (P *)&Log_True)			/* If not problems then fail */
	    { v_Msg(ctx,NULL,"UV4EvalNoProb",intmodx) ; goto fail ; } ;
	 } ;
	return(ipt) ;
fail:
	REGISTER_ERROR(0) ; return(NULL) ;
}

#ifdef V4_BUILD_SECURITY
struct V4DPI__Point *v4im_DoSecure(ctx,respnt,argpnts,argcnt,intmodx,trace,isct)
  struct V4C__Context *ctx ;
  struct V4DPI__Point *respnt ;
  INTMODX intmodx ;
  P *argpnts[],*isct ;
  COUNTER argcnt ; VTRACE trace ;
{ P *cpt,apnt ;
  LOGICAL ok,prior ; INDEX ix, tx ; COUNTER maxIdle,maxKIscts,maxCPU ;
  static B64INT lockedKey = 0 ;

/*	Use 'prior' to save prior value, return it whenever we set to different value */
#define restrictMap(BIT) prior = ((gpi->RestrictionMap & V_Restrict_##BIT) != 0) ; if (v4im_GetPointLog(&ok,cpt,ctx)) { gpi->RestrictionMap |= V_Restrict_##BIT ; } else { gpi->RestrictionMap &= ~(V_Restrict_##BIT) ; } ; logPNTv(respnt,prior)
#define restrictVal(BIT) logPNTv(respnt,((gpi->RestrictionMap & V_Restrict_##BIT) != 0))
#define restrictQuota(QUOTA,BIT) \
 prior = (((gpi->RestrictionMap & V_Restrict_##BIT) == 0) ? FALSE : gpi->QUOTA) ; \
 if (cpt->PntType == V4DPI_PntType_Logical) \
  { if (v4im_GetPointLog(&ok,cpt,ctx)) { gpi->QuotaHTMLGet = 1 ; gpi->RestrictionMap |= V_Restrict_##BIT ; } \
     else { gpi->QUOTA = 0 ; gpi->RestrictionMap &= ~(V_Restrict_##BIT) ; } ; \
  } else { gpi->QUOTA = v4im_GetPointInt(&ok,cpt,ctx) ; gpi->RestrictionMap |= V_Restrict_##BIT ; } ; \
 if (prior > 0) { intPNTv(respnt,prior) ; } else { logPNTv(respnt,FALSE) ; } ;
#define restrictGetQuota(QUOTA,BIT) \
 if ((gpi->RestrictionMap & V_Restrict_##BIT) == 0) { logPNTv(respnt,FALSE) ; } else { intPNTv(respnt,gpi->QUOTA) ; }

	ok = TRUE ; maxIdle = UNUSED ; maxKIscts = UNUSED ; maxCPU = UNUSED ;
	for(ix=1;ok&&ix<=argcnt;ix++)
	 { tx = v4im_CheckPtArgNew(ctx,argpnts[ix],&cpt,&apnt) ;
	   if (lockedKey != 0 && tx != V4IM_Tag_Key) { v_Msg(ctx,NULL,"RestrictMod",intmodx) ; goto fail ; } ;
	   switch (tx)
	    { default:				v_Msg(ctx,NULL,"TagBadUse",intmodx) ; goto fail ;
	      case V4IM_Tag_Unk:		v_Msg(ctx,NULL,"TagUnknown",intmodx) ; goto fail ;
	      case V4IM_Tag_AreaAll:		restrictMap(AreaCommand) ; break ;
	      case -V4IM_Tag_AreaAll:		restrictVal(AreaCommand) ; break ;
	      case V4IM_Tag_AreaUpdate:		restrictMap(AreaUpdate) ; break ;
	      case -V4IM_Tag_AreaUpdate:	restrictVal(AreaUpdate) ; break ;
	      case V4IM_Tag_CPU:
		maxCPU = v4im_GetPointInt(&ok,cpt,ctx) ;
		break ;
	      case V4IM_Tag_Data:		restrictMap(DataStream) ; break ;
	      case -V4IM_Tag_Data:		restrictVal(DataStream) ; break ;
	      case V4IM_Tag_Echo:		restrictQuota(QuotaData,QuotaEcho) ; break ;
	      case -V4IM_Tag_Echo:		restrictGetQuota(QuotaData,QuotaEcho) ; break ;
	      case V4IM_Tag_Files:		restrictMap(FileRead) ; break ;
	      case -V4IM_Tag_Files:		restrictVal(FileRead) ; break ;
	      case V4IM_Tag_Hidden:
		{ struct V4DPI__DimInfo *di ;
		  if (cpt->Dim == Dim_Dim) { DIMINFO(di,ctx,cpt->Value.IntVal) ; }
		   else { v4im_GetPointUC(&ok,UCTBUF1,V4LEX_BigText_Max,cpt,ctx) ; if (!ok) break ;
			  DIMINFO(di,ctx,v4dpi_DimGet(ctx,UCTBUF1,DIMREF_IRT)) ;
			} ;
		  if (di == NULL) { v_Msg(ctx,NULL,"ModArgNotDim",intmodx,ix,cpt) ; goto fail ; } ;
		  di->rtFlags |= V4DPI_rtDimInfo_Hidden ;
		}
		logPNTv(respnt,TRUE) ; break ;
	      case V4IM_Tag_HTTPGet:		restrictQuota(QuotaHTMLGet,QuotaHTML) ; break ;
	      case -V4IM_Tag_HTTPGet:		restrictGetQuota(QuotaHTMLGet,QuotaHTML) ; break ;
	      case V4IM_Tag_HTTPPut:		restrictQuota(QuotaHTMLPut,QuotaHTML) ; break ;
	      case -V4IM_Tag_HTTPPut:		restrictGetQuota(QuotaHTMLPut,QuotaHTML) ; break ;
	      case V4IM_Tag_Idle:
		maxIdle = v4im_GetPointDbl(&ok,cpt,ctx) * 60 ;
		break ;
	      case V4IM_Tag_Intersection:
		maxKIscts = v4im_GetPointInt(&ok,cpt,ctx) ;
		break ;
	      case V4IM_Tag_Key:
/*		If we get the correct key the reset prior lock and allow module to continue, otherwise fail */
		if (v4im_GetPointFixed(&ok,cpt,ctx,0) == lockedKey) { lockedKey = 0 ; logPNTv(respnt,TRUE) ; break ; } ;
		HANGLOOSE(250) ;	/* Put a pause to prevent brut-force attempt at cracking key */
		v_Msg(ctx,NULL,"RestrictMod",intmodx) ; goto fail ;
	      case V4IM_Tag_Lock:
		v4im_GetPointUC(&ok,UCTBUF1,V4LEX_BigText_Max,cpt,ctx) ; if (!ok) break ;
		{ INDEX imx = v4im_Accept(UCTBUF1) ;
		  if (imx <= 0) { v_Msg(ctx,NULL,"ModNoExist",intmodx,UCTBUF1) ; goto fail ; } ;
		  prior = gpi->lockModule[imx] ;
		  gpi->lockModule[imx] = TRUE ;
		  if (imx == V4IM_OpCode_Secure) { lockedKey = vRan64_RandomU64() ; fixPNTv(respnt,lockedKey) ; } else { logPNTv(respnt,prior) ; } ;
		}
		logPNTv(respnt,TRUE) ; break ;
	      case V4IM_Tag_Module:
		v4im_GetPointUC(&ok,UCTBUF1,V4LEX_BigText_Max,cpt,ctx) ; if (!ok) break ;
		{ INDEX imx = v4im_Accept(UCTBUF1) ;
		  if (imx <= 0) { v_Msg(ctx,NULL,"ModNoExist",intmodx,UCTBUF1) ; goto fail ; } ;
		  gpi->lockModuleParse[imx] = TRUE ;
		}
		logPNTv(respnt,TRUE) ; break ;
	      case V4IM_Tag_EvalNest:		restrictMap(EvalNest) ; break ;
	      case -V4IM_Tag_EvalNest:		restrictVal(EvalNest) ; break ;
	      case V4IM_Tag_OSFileListOf:	restrictMap(OSFileListOf) ; break ;
	      case -V4IM_Tag_OSFileListOf:	restrictVal(OSFileListOf) ; break ;
	      case V4IM_Tag_OSFileInfo:		restrictMap(OSFileInfo) ; break ;
	      case -V4IM_Tag_OSFileInfo:	restrictVal(OSFileInfo) ; break ;
	      case V4IM_Tag_ProjectArea:	restrictMap(ProjectArea) ; break ;
	      case -V4IM_Tag_ProjectArea:	restrictVal(ProjectArea) ; break ;
	      case V4IM_Tag_Redirection:	restrictMap(redirection) ; break ;
	      case -V4IM_Tag_Redirection:	restrictVal(redirection) ; break ;
	      case -V4IM_Tag_SessionKey:
		{ LENMAX eLen ; INDEX i,j ; USESKEY sesKey ;
		  eLen = UCstrlen(V4XLIB_sesKey_Elements) ;
		  for(i=0;i<V4XLIB_sesKey_Length;i++)
		   { j = (int)floor(vRan64_RandomDbl() * eLen) ; if (j == eLen) j-- ;
		     sesKey[i] = V4XLIB_sesKey_Elements[j] ;
		   } ; sesKey[i] = UCEOS ;
		  uccharPNTv(respnt,sesKey) ;
		  return(respnt) ;
		}
	      case V4IM_Tag_Test:		restrictMap(Test) ; break ;
	      case -V4IM_Tag_Test:		restrictVal(Test) ; break ;
	      case V4IM_Tag_Unlock:
		v4im_GetPointUC(&ok,UCTBUF1,V4LEX_BigText_Max,cpt,ctx) ; if (!ok) break ;
		{ INDEX imx = v4im_Accept(UCTBUF1) ;
		  if (imx <= 0) { v_Msg(ctx,NULL,"ModNoExist",intmodx,UCTBUF1) ; goto fail ; } ;
		  prior = gpi->lockModule[imx] ;
		  gpi->lockModule[imx] = FALSE ;
		  logPNTv(respnt,prior) ;
		}
		break ;
//	      case -V4IM_Tag_Value:		restrictVal(Value) ; break ;
	      case V4IM_Tag_Value:
//		if (cpt->PntType == V4DPI_PntType_Logical)
//		 { restrictMap(Value) ; break ; }
//		if (gpi->RestrictionMap & V_Restrict_Value) { v_Msg(ctx,NULL,"RestrictMod",intmodx) ; goto fail ; } ;
		{ UCCHAR *v ;
		  v4im_GetPointUC(&ok,UCTBUF1,V4TMBufMax,cpt,ctx) ; if (!ok) break ;
		  v = vIni_Lookup(ctx,UCTBUF1) ;
		  if (v == NULL) { v_Msg(ctx,NULL,"V4NoIniEntry",intmodx,UCTBUF1) ; goto fail ; } ;
		  uccharPNTv(respnt,v) ; return(respnt) ;
		}
		break ;
	      case V4IM_Tag_XDBAccess:		restrictMap(XDBAccess) ; break ;
	      case -V4IM_Tag_XDBAccess:		restrictVal(XDBAccess) ; break ;
	      case V4IM_Tag_XDBXCt:		restrictMap(XDBXCT) ; break ;
	      case -V4IM_Tag_XDBXCt:		restrictVal(XDBXCT) ; break ;
	    } ;
	 } ;
	if (!ok) { v_Msg(ctx,NULL,"ModInvArg",intmodx,ix-1) ; goto fail ; } ;

/*	Should we crank up a sub-process to track maxIdle, maxCPU, maxIsct ? */
	if (maxIdle != UNUSED || maxKIscts != UNUSED || maxCPU != UNUSED)
	 { if (maxIdle != UNUSED) gpi->maxIdle = maxIdle ;
	   if (maxKIscts != UNUSED) gpi->maxKIscts = maxKIscts;
	   if (maxCPU != UNUSED) gpi->maxCPU = maxCPU ;
	   logPNTv(respnt,TRUE) ;
	   if (!gpi->watchDogEnabled)
	    {
//#ifdef WINNT
//	      DWORD dwThreadId ;
//	      gpi->watchDogThread = CreateThread(NULL,0,(LPTHREAD_START_ROUTINE)v4thread_WatchDog,NULL,0,&dwThreadId) ;
//	      intPNTv(respnt,dwThreadId) ;
//#elif defined UNIX
//	      if (pthread_create(&gpi->watchDogThread,NULL,v4thread_WatchDog,NULL) != 0)
//	       { v_Msg(ctx,NULL,"SpawnErr",intmodx,OSERROR) ; goto fail ; } ;
//	      intPNTv(respnt,gpi->watchDogThread) ;
//#else
//	      v_Msg(ctx,NULL,"ModTagNYI",intmodx,V4IM_Tag_Idle) ; goto fail ;
//#endif

#ifdef CREATE_THREAD
	      CREATE_THREAD(v4thread_WatchDog,gpi->watchDogThread,NULL,respnt,ctx->ErrorMsg)
#else
	      v_Msg(ctx,NULL,"ModTagNYI",intmodx,V4IM_Tag_Idle) ; goto fail ;
#endif


	      gpi->watchDogEnabled = TRUE ;
	    } ;
	 } ;

	return(respnt) ;
fail:
	REGISTER_ERROR(0) ; return(NULL) ;
}
#endif

struct V4DPI__Point *v4im_DoArea(ctx,respnt,argpnts,argcnt,intmodx,trace,isct)
  struct V4C__Context *ctx ;
  struct V4DPI__Point *respnt ;
  INTMODX intmodx ;
  P *argpnts[],*isct ;
  COUNTER argcnt ; VTRACE trace ;
{ P *cpt,apnt,*fnpnt ;
  struct V4DPI__LittlePoint idpt ;
  P listbuf ;
  struct V4L__ListPoint *lp ;
  LOGICAL ok,aggIndex,seqMode,trapErrors ; INDEX i, ix, tx, ax, lx, aId, retries ; UCCHAR areaName[V_FileName_Max],newfileName[V_FileName_Max],*dfltExt ; ETYPE openMode,hNum ;
  enum DictionaryEntries aType ;

	ok = TRUE ; ZUS(areaName) ; openMode = V4IS_PCB_OM_Read ; hNum = V4DPI_dfltRelHNum ; fnpnt = NULL ; aggIndex = TRUE ; seqMode = TRUE ;
	memset(&idpt,0,sizeof idpt) ; aType = _Area ; dfltExt = UClit("v4a") ; trapErrors = TRUE ; retries = 3 ;
	memcpy(respnt,(P *)&Log_True,Log_True.Bytes) ;
	for(ix=1;ok&&ix<=argcnt;ix++)
	 { if (argpnts[ix]->PntType != V4DPI_PntType_TagVal)
	    { if (fnpnt != NULL) { v_Msg(ctx,NULL,"AreaMultName",intmodx,fnpnt,ix,argpnts[ix]) ; goto fail ; } ;
	      fnpnt = argpnts[ix] ;
	      continue ;
	    } ;
	   tx = v4im_CheckPtArgNew(ctx,argpnts[ix],&cpt,&apnt) ;
	   switch (tx)
	    { default:				v_Msg(ctx,NULL,"TagBadUse",intmodx) ; goto fail ;
	      case V4IM_Tag_Unk:		v_Msg(ctx,NULL,"TagUnknown",intmodx) ; goto fail ;
	      case V4IM_Tag_BucketSize:
	      case V4IM_Tag_Close:
		lp = v4im_VerifyList(NULL,ctx,cpt,intmodx) ;
		if (lp == NULL) { v_Msg(ctx,NULL,"ModInvArgList",intmodx,ix) ; goto fail ; } ;
		for(lx=1;;lx++)
		 { if (!v4l_ListPoint_Value(ctx,lp,lx,&listbuf)) break ;
		   aId = (listbuf.PntType == V4DPI_PntType_Int ? listbuf.Value.IntVal : UNUSED) ;
		   for(ax=0;ax<gpi->AreaAggCount;ax++)
	            { if (aId != gpi->AreaAgg[ax].AggUId || gpi->AreaAgg[ax].pcb == NULL) continue ;
		      v4ctx_AreaClose(ctx,gpi->AreaAgg[ax].pcb->AreaId) ; break ;
		    } ;
		   if (ax >= gpi->AreaAggCount)		/* If not an Agg Area then look to see if one of the HNum areas */
		    { for (ax=gpi->LowHNum;ax<=gpi->HighHNum;ax++)
		       { if (aId != gpi->RelH[ax].AreaUId) continue ; } ;
		      if (ax > gpi->HighHNum) { v_Msg(ctx,NULL,"V4NotAreaId",intmodx,ix,&listbuf) ; goto fail ; } ;
		      v4ctx_AreaClose(ctx,gpi->RelH[ax].aid) ;
		    } ;
		 } ;
		return(respnt) ;
	      case V4IM_Tag_Error:
		trapErrors = v4im_GetPointLog(&ok,cpt,ctx) ; break ;
	      case V4IM_Tag_Hierarchy:
		hNum = v4im_GetPointInt(&ok,cpt,ctx) ;
		if (hNum < 0 || hNum > V4C_CtxRelH_Max || hNum == V4DPI_WorkRelHNum)
		 { v_Msg(ctx,NULL,"AreaHNum",intmodx,hNum,0,V4C_CtxRelH_Max,V4DPI_WorkRelHNum) ; goto fail ; } ;
		break ;
	      case V4IM_Tag_Id:
		if (cpt->Bytes > sizeof(struct V4DPI__LittlePoint)) { v_Msg(ctx,NULL,"DimTooBig",intmodx,cpt) ; goto fail ; } ;
		memcpy(&idpt,cpt,cpt->Bytes) ;
		if (ix == 1)		/* Wants to get internal Id associated with this tagged Id */
		for (ax=0;ax<gpi->AreaAggCount;ax++)
		 { if (memcmp(&idpt,&gpi->AreaAgg[ax].aggPId,gpi->AreaAgg[ax].aggPId.Bytes) != 0) continue ;
		   intPNTv(respnt,gpi->AreaAgg[ax].AggUId) ; return(respnt) ;
		 } ;
		for (ax=gpi->LowHNum;ax<=gpi->HighHNum;ax++)
		 { if (memcmp(&idpt,&gpi->RelH[ax].areaPId,gpi->RelH[ax].areaPId.Bytes) != 0) continue ;
		   intPNTv(respnt,gpi->RelH[ax].AreaUId) ; return(respnt) ;
		 } ;
		v_Msg(ctx,NULL,"V4NotAreaId",intmodx,ix,cpt) ; goto fail ;
	      case V4IM_Tag_Index:
		aggIndex = v4im_GetPointLog(&ok,cpt,ctx) ; break ;
	      case -V4IM_Tag_Index:
		if (gpi->RestrictionMap & V_Restrict_AreaUpdate) { v_Msg(ctx,NULL,"RestrictMod",intmodx) ; goto fail ; } ;
		if (fnpnt == NULL) { v_Msg(ctx,NULL,"AreaNoName",intmodx) ; goto fail ; } ;
		v4im_GetPointFileName(&ok,areaName,V_FileName_Max,fnpnt,ctx,dfltExt) ; if (!ok) break ;
		if (!v4im_AreaBuildIndex(ctx,areaName)) { v_Msg(ctx,NULL,"AreaFail",intmodx) ; goto fail ; } ;
		return(respnt) ;
	      case -V4IM_Tag_ListOf:

	       { P listbuf2,ptbuf ; struct V4DPI__LittlePoint lpnt ; struct V4L__ListPoint *lp2 ;

		INITLP(respnt,lp,Dim_List)
		for(i=gpi->LowHNum;i<=gpi->HighHNum;i++)
	         { if (gpi->RelH[i].aid == UNUSED) continue ;
		   INITLP(&listbuf2,lp2,Dim_List) ;
		   intPNTv((P *)&lpnt,gpi->RelH[i].AreaUId) ; v4l_ListPoint_Modify(ctx,lp2,V4L_ListAction_Append,(P *)&lpnt,0) ;
		   dictPNTv((P *)&lpnt,Dim_UV4,v4im_GetEnumToDictVal(ctx,DE(Area),Dim_UV4)) ; v4l_ListPoint_Modify(ctx,lp2,V4L_ListAction_Append,(P *)&lpnt,0) ;
		   uccharPNTv(&ptbuf,gpi->RelH[i].pcb->UCFileName) ; v4l_ListPoint_Modify(ctx,lp2,V4L_ListAction_Append,&ptbuf,0) ;
		   intPNTv((P *)&lpnt,i) ; v4l_ListPoint_Modify(ctx,lp2,V4L_ListAction_Append,(P *)&lpnt,0) ;
		   ENDLP(&listbuf2,lp2) ;
		   v4l_ListPoint_Modify(ctx,lp,V4L_ListAction_Append,&listbuf2,0) ;
		 } ;
		if (gpi->xdr != NULL)
		 { INITLP(&listbuf2,lp2,Dim_List) ;
		   intPNTv((P *)&lpnt,0) ; v4l_ListPoint_Modify(ctx,lp2,V4L_ListAction_Append,(P *)&lpnt,0) ;
		   dictPNTv((P *)&lpnt,Dim_UV4,v4im_GetEnumToDictVal(ctx,DE(Dict),Dim_UV4)) ; v4l_ListPoint_Modify(ctx,lp2,V4L_ListAction_Append,(P *)&lpnt,0) ;
		   uccharPNTv(&ptbuf,gpi->xdr->pcb->UCFileName) ; v4l_ListPoint_Modify(ctx,lp2,V4L_ListAction_Append,&ptbuf,0) ;
		   ENDLP(&listbuf2,lp2) ;
		   v4l_ListPoint_Modify(ctx,lp,V4L_ListAction_Append,&listbuf2,0) ;
		 } ;
		for(i=0;i<gpi->AreaAggCount;i++)
	         { if (gpi->AreaAgg[i].pcb == NULL) continue ;
		   INITLP(&listbuf2,lp2,Dim_List) ;
		   intPNTv((P *)&lpnt,gpi->AreaAgg[i].AggUId) ; v4l_ListPoint_Modify(ctx,lp2,V4L_ListAction_Append,(P *)&lpnt,0) ;
		   dictPNTv((P *)&lpnt,Dim_UV4,v4im_GetEnumToDictVal(ctx,DE(Agg),Dim_UV4)) ; v4l_ListPoint_Modify(ctx,lp2,V4L_ListAction_Append,(P *)&lpnt,0) ;
		   uccharPNTv(&ptbuf,gpi->AreaAgg[i].pcb->UCFileName) ; v4l_ListPoint_Modify(ctx,lp2,V4L_ListAction_Append,&ptbuf,0) ;
		   ENDLP(&listbuf2,lp2) ;
		   v4l_ListPoint_Modify(ctx,lp,V4L_ListAction_Append,&listbuf2,0) ;
		 } ;
		ENDLP(respnt,lp)
		return(respnt) ;
	       }
	      case -V4IM_Tag_NoError:
		trapErrors = FALSE ; break ;
	      case V4IM_Tag_Open:
		switch (v4im_GetDictToEnumVal(ctx,cpt))
		 { default:		v_Msg(ctx,NULL,"ModTagValue",intmodx,ix,tx,cpt) ; goto fail ;
		   case _Create:	openMode = V4IS_PCB_OM_New ; break ;
		   case _CreateIf:	openMode = V4IS_PCB_OM_NewIf ; break ;
		   case _Read:		openMode = V4IS_PCB_OM_Read ; break ;
		   case _Update:	openMode = V4IS_PCB_OM_Update ; break ;
		 } ;
		break ;
	      case V4IM_Tag_Rebuild:
		if (gpi->RestrictionMap & V_Restrict_AreaUpdate) { v_Msg(ctx,NULL,"RestrictMod",intmodx) ; goto fail ; } ;
		if (fnpnt == NULL) { v_Msg(ctx,NULL,"AreaNoName",intmodx) ; goto fail ; } ;
		v4im_GetPointFileName(&ok,areaName,V_FileName_Max,fnpnt,ctx,dfltExt) ; if (!ok) break ;
		v4im_GetPointFileName(&ok,newfileName,V_FileName_Max,cpt,ctx,dfltExt) ; if (!ok) break ;
		if (!v4im_AreaRebuild(ctx,areaName,newfileName)) { v_Msg(ctx,NULL,"AreaFail",intmodx) ; goto fail ; } ;
		return(respnt) ;
	      case -V4IM_Tag_Reset:
		if (gpi->RestrictionMap & V_Restrict_AreaUpdate) { v_Msg(ctx,NULL,"RestrictMod",intmodx) ; goto fail ; } ;
		if (fnpnt == NULL) { v_Msg(ctx,NULL,"AreaNoName",intmodx) ; goto fail ; } ;
		v4im_GetPointFileName(&ok,areaName,V_FileName_Max,fnpnt,ctx,UClit("v4x")) ; if (!ok) break ;
		if (!v4im_AreaResetExt(ctx,areaName)) { v_Msg(ctx,NULL,"AreaFail",intmodx) ; goto fail ; } ;
		return(respnt) ;
	      case V4IM_Tag_Retry:
		{ int val = v4im_GetPointInt(&ok,cpt,ctx) ;
		  if (val < 0 || val > 50) { v_Msg(ctx,NULL,"ModArgRange",intmodx,ix,argpnts[ix],0,50) ; goto fail ; } ;
		  retries = val ;
		} break ;
	      case V4IM_Tag_Sequential:
		seqMode = v4im_GetPointLog(&ok,cpt,ctx) ; break ;
	      case V4IM_Tag_Type:
		switch (v4im_GetDictToEnumVal(ctx,cpt))
		 { default:		v_Msg(ctx,NULL,"ModTagValue",intmodx,ix,tx,cpt) ; goto fail ;
		   case _Agg:		aType = _Agg ; dfltExt = UClit("v4a") ; break ;
		   case _Area:		aType = _Area ; dfltExt = UClit("v4a") ; break ;
		   case _Dictionary:
		   case _Dict:
		   case _External:	aType = _Dict ; dfltExt = UClit("v4x") ; break ;
		 } ;
		break ;

	    } ;
	 } ;
	if (!ok) { v_Msg(ctx,NULL,"ModInvArg",intmodx,ix-1) ; goto fail ; } ;
	if (fnpnt == NULL) { v_Msg(ctx,NULL,"AreaNoName",intmodx) ; goto fail ; } ;

	if (fnpnt->PntType == V4DPI_PntType_List)
	 { lp = v4im_VerifyList(NULL,ctx,fnpnt,intmodx) ;
	   if (lp == NULL) { v_Msg(ctx,NULL,"ModInvArgList",intmodx,1) ; goto fail ; } ;
	 } else { lp = NULL ; }
	for(lx=1;;lx++)
	 { P *filePnt ; COUNTER attempt ;
	   if (lp == NULL) { filePnt = fnpnt ; }
	    else { if (!v4l_ListPoint_Value(ctx,lp,lx,&listbuf)) break ; filePnt = &listbuf ; } ;
	   v4im_GetPointFileName(&ok,areaName,V_FileName_Max,filePnt,ctx,dfltExt) ; if (!ok) goto fail ;


//	   if (!v4im_AreaOpen(ctx,areaName,(idpt.Dim != 0 ? &idpt : NULL),openMode,hNum,aType,aggIndex,seqMode,respnt))
//	    { if (trapErrors) { v_Msg(ctx,NULL,"AreaFail",intmodx) ; goto fail ; } ;
//	      logPNTv(respnt,FALSE) ;
//	    } ;
	   for(attempt=0;;attempt++)
	    { if (!v4im_AreaOpen(ctx,areaName,(idpt.Dim != 0 ? &idpt : NULL),openMode,hNum,aType,aggIndex,seqMode,respnt))
	       { if (attempt >= retries)
	          { if (trapErrors) { v_Msg(ctx,NULL,"AreaFail",intmodx) ; goto fail ; } ;
		    logPNTv(respnt,FALSE) ; break ;
		  } ;
		 if (attempt > 0) { v_Msg(ctx,UCTBUF1,"AreaRetry",areaName,ctx->ErrorMsgAux,attempt+1,retries) ; vout_UCText(VOUT_Warn,0,UCTBUF1) ; } ;
		 HANGLOOSE(100) ; continue ;
	       } ;
	      break ;
	    } ;

	   if (lp == NULL) break ;
	 } ;
	return(respnt) ;
fail:
	REGISTER_ERROR(0) ; return(NULL) ;
}


LOGICAL v4im_AreaOpen(ctx,fileName,idpnt,openMode,hNum,aType,aggIndex,seqMode,respnt)
  struct V4C__Context *ctx ;
  UCCHAR *fileName ;
  struct V4DPI__LittlePoint *idpnt ;
  ETYPE openMode ;
  INDEX hNum ;
  enum DictionaryEntries aType ;
  LOGICAL aggIndex ;
  P *respnt ;
{
  struct V4IS__ParControlBlk pcb ;
  struct V4C__AreaHInfo ahi ;
  INDEX aId,ax ;
  
	memset(&pcb,0,sizeof pcb) ; strcpy(pcb.V3name,"v4a") ; pcb.BktSize = V4Area_DfltBktSize ; UCstrcpy(pcb.UCFileName,fileName) ;
	pcb.OpenMode = openMode ; pcb.DfltDataMode = V4IS_PCB_DataMode_Auto ; pcb.AccessMode = -1 ;
   	pcb.DfltPutMode = V4IS_PCB_GP_Insert ; pcb.MinCmpBytes = 100 ;
	memset(&ahi,0,sizeof ahi) ; ahi.BindingsUpd = TRUE ; ahi.IntDictUpd = TRUE ; ahi.ExtDictUpd = TRUE ;
	ahi.RelHNum = (openMode == V4IS_PCB_OM_Read ? 0 : hNum) ;

	if (pcb.OpenMode == V4IS_PCB_OM_NewIf)		/* See if we should create (want flag for later use */
	 { struct UC__File UCFile ;
	   if (v_UCFileOpen(&UCFile,pcb.UCFileName,UCFile_Open_Read,TRUE,ctx->ErrorMsgAux,0)) { v_UCFileClose(&UCFile) ; } else { pcb.OpenMode = V4IS_PCB_OM_New ; } ;
	 } ;

	switch (aType)
	 { case _Dict:	if (gpi->xdr != NULL) { v_Msg(ctx,ctx->ErrorMsgAux,"CmdAreaExtOpen",gpi->xdr->pcb->UCFileName) ; return(FALSE) ; } ;
			break ;
	   case _Agg:	if (!aggIndex)					/* If don't want index then disable it - Aggregate areas only */
			 { pcb.DfltPutMode = (pcb.DfltPutMode & 0xffff0000) + V4IS_PCB_GP_DataOnly ; break ; } ;
			if (seqMode) pcb.AreaFlags |= V4IS_PCB_OF_SeqScan ;
			break ;
	 } ;

	pcb.RelHNum = ahi.RelHNum ; pcb.AreaFlags |= V4IS_PCB_OF_NoError ;
	if (!v4is_Open(&pcb,NULL,ctx->ErrorMsgAux)) return(FALSE) ;
	if (pcb.AreaId == V4IS_AreaId_SeqOnly) { v_Msg(ctx,ctx->ErrorMsgAux,"V4ISInvFormat",pcb.UCFileName) ; return(FALSE) ; } ;

	switch (aType)
	 { case _Agg:	for(ax=0;ax<gpi->AreaAggCount;ax++)		/* Is this area already loaded? */
			 { if (gpi->AreaAgg[ax].pcb == NULL) continue ; if (UCstrcmpIC(pcb.UCFileName,gpi->AreaAgg[ax].pcb->UCFileName) == 0) break ; } ;
			if (ax < gpi->AreaAggCount)
			 { v4is_Close(&pcb) ; intPNTv(respnt,gpi->AreaAgg[ax].AggUId) ; return(TRUE) ; } ;
			if ((aId = v4im_AggLoadArea(ctx,&pcb,idpnt)) == UNUSED) return(FALSE) ;
			intPNTv(respnt,aId) ; break ;
	   case _Area:	if ((aId = v4ctx_AreaAdd(ctx,&pcb,&ahi,idpnt)) == UNUSED) return(FALSE) ;
			intPNTv(respnt,aId) ; break ;
	   case _Dict:	gpi->xdr = (struct V4DPI__XDictRuntime *)v4mm_AllocChunk(sizeof *gpi->xdr,TRUE) ;
			gpi->xdr->pcb = (struct V4IS__ParControlBlk *)v4mm_AllocChunk(sizeof *gpi->xdr->pcb,FALSE) ;
			memcpy(gpi->xdr->pcb,&pcb,sizeof pcb) ; gpi->xdr->aid = pcb.AreaId ;
#ifdef V4ENABLEMULTITHREADS
			INITMTLOCK(gpi->xdr->mtLock) ;			/* Used for multi-threaded spin-lock */
#endif
			break ;
	 } ;
	return(TRUE) ;
	
}

/*	v4im_AreaRebuild - Rebuilds Entire Area				*/
/*	Call: ok = v4im_AreaRebuild( ctx , fileName , newfileName )
	  where ok is TRUE if OK, FALSE if error (in ctx->ErrorMsgAux),
		ctx is context,
		fileName is name of area,
		newfileName is name of new (rebuilt) area		*/

LOGICAL v4im_AreaRebuild(ctx,fileName,newfileName)
  struct V4C__Context *ctx ;
  UCCHAR *fileName,*newfileName ;
{
  jmp_buf traceback ;
  struct V4IS__ParControlBlk pcb,dpcb ;
  struct V4IS__AreaCB *acb ;
  INDEX res ; UCCHAR *ucb ;

	memset(&pcb,0,sizeof pcb) ; strcpy(pcb.V3name,"index") ;
	ucb = v_UCLogicalDecoder(fileName,VLOGDECODE_Exists,0,ctx->ErrorMsgAux) ; if (ucb == NULL) return(FALSE) ;
	UCstrcpy(pcb.UCFileName,ucb) ;
	pcb.OpenMode = V4IS_PCB_OM_Read ; pcb.DfltGetMode = V4IS_PCB_GP_Next ; pcb.AreaFlags |= V4IS_PCB_OF_NoError ;
	if (!v4is_Open(&pcb,NULL,ctx->ErrorMsgAux)) return(FALSE) ;
	if (pcb.AreaId == V4IS_AreaId_SeqOnly) { v_Msg(ctx,ctx->ErrorMsgAux,"CmdSeqOnly",fileName) ; return(FALSE) ; } ;
	memset(&dpcb,0,sizeof dpcb) ;
	strcpy(dpcb.V3name,"dstu") ; UCstrcpy(dpcb.UCFileName,newfileName) ; dpcb.AreaFlags |= V4IS_PCB_OF_NoError ;
	dpcb.AccessMode = -1 ; dpcb.OpenMode = V4IS_PCB_OM_NewAppend ; dpcb.DfltPutMode = V4IS_PCB_GP_Append ;
	acb = (struct V4IS__AreaCB *)v4mm_ACBPtr(pcb.AreaId) ; dpcb.BktSize = acb->RootInfo->BktSize ;
	if (!v4is_Open(&dpcb,NULL,ctx->ErrorMsgAux)) return(FALSE) ;
	COPYJMP(traceback,(gpi->environment)) ;
	res = v4is_Reformat(&pcb,&dpcb,NULL,FALSE,V4IS_Reformat_NoContPrompt) ;
	COPYJMP((gpi->environment),traceback) ;
	v4is_Close(&pcb) ; v4is_Close(&dpcb) ;
	if (res == UNUSED) { v_Msg(ctx,ctx->ErrorMsgAux,"V4ISRefErr",pcb.UCFileName,dpcb.UCFileName) ; return(FALSE) ; } ;
	return(TRUE) ;
}

/*	v4im_AreaBuildIndex - Performs index create on named file		*/
/*	Call: ok = v4im_AreaBuildIndex( ctx , fileName )
	  where ok is TRUE if OK, FALSE if error (in ctx->ErrorMsgAux),
		ctx is context,
		fileName is name of area					*/

LOGICAL v4im_AreaBuildIndex(ctx,fileName)
  struct V4C__Context *ctx ;
  UCCHAR *fileName ;
{
  jmp_buf traceback ;
  struct V4IS__ParControlBlk pcb ;
  UCCHAR *ucb ;

	memset(&pcb,0,sizeof pcb) ; strcpy(pcb.V3name,"index") ;
	ucb = v_UCLogicalDecoder(fileName,VLOGDECODE_Exists,0,ctx->ErrorMsgAux) ; if (ucb == NULL) return(FALSE) ;
	UCstrcpy(pcb.UCFileName,ucb) ;
	pcb.OpenMode = V4IS_PCB_OM_Update ; pcb.DfltGetMode = V4IS_PCB_GP_Next ;
	v4is_Open(&pcb,NULL,NULL) ;
	if (pcb.AreaId == V4IS_AreaId_SeqOnly) { v_Msg(ctx,ctx->ErrorMsgAux,"CmdSeqOnly",fileName) ; return(FALSE) ; } ;
	COPYJMP(traceback,(gpi->environment)) ;
	v4is_RebuildAreaIndex(&pcb) ;
	COPYJMP((gpi->environment),traceback) ;

	return(TRUE) ;
}


/*	v4im_AreaResetExt - Performs 'reset' on named External Dictionary	*/
/*	Call: ok = v4im_AreaResetExt( ctx , fileName )
	  where ok is TRUE if OK, FALSE if error (in ctx->ErrorMsgAux),
		ctx is context,
		fileName is name of area					*/
LOGICAL v4im_AreaResetExt(ctx,fileName)
  struct V4C__Context *ctx ;
  UCCHAR *fileName ;
{
  jmp_buf traceback ;
  struct V4IS__ParControlBlk pcb,dpcb ;
  struct V4IS__AreaCB *acb ;
  UCCHAR ucresult[V_FileName_Max] ;
  INDEX res ; UCCHAR *ucb ;

	ucb = v_UCLogicalDecoder(fileName,VLOGDECODE_Exists,0,ctx->ErrorMsgAux) ; if (ucb == NULL) return(FALSE) ;
	UCstrcpy(pcb.UCFileName,ucb) ; UCstrcpy(fileName,pcb.UCFileName) ;
	UCstrcpy(ucresult,pcb.UCFileName) ; *(ucb=UCstrrchr(ucresult,'.')) = UCEOS ; UCstrcat(ucresult,UClit(".old")) ;
	UCremove(v_UCLogicalDecoder(ucresult,VLOGDECODE_NewFile,0,ctx->ErrorMsgAux)) ;
	if (!UCrename(pcb.UCFileName,ucresult)) { v_Msg(ctx,ctx->ErrorMsgAux,"CmdRename",pcb.UCFileName,ucresult,errno) ; return(FALSE) ; } ;
	memset(&pcb,0,sizeof pcb) ; strcpy(pcb.V3name,"testu") ;
	pcb.OpenMode = V4IS_PCB_OM_Read ; pcb.DfltGetMode = V4IS_PCB_GP_Next ;
	UCstrcpy(pcb.UCFileName,ucresult) ; v4is_Open(&pcb,NULL,NULL) ;
	if (pcb.AreaId == V4IS_AreaId_SeqOnly)
	 { v_Msg(ctx,ctx->ErrorMsgAux,"CmdSeqOnly",pcb.UCFileName) ; return(FALSE) ; } ;
	memset(&dpcb,0,sizeof dpcb) ; strcpy(dpcb.V3name,"dstu") ; UCstrcpy(dpcb.UCFileName,fileName) ;
	dpcb.AccessMode = -1 ; dpcb.OpenMode = V4IS_PCB_OM_NewAppend ; dpcb.DfltPutMode = V4IS_PCB_GP_Append ;
	acb = (struct V4IS__AreaCB *)v4mm_ACBPtr(pcb.AreaId) ; dpcb.BktSize = acb->RootInfo->BktSize ;
	v4is_Open(&dpcb,NULL,NULL) ;
	COPYJMP(traceback,(gpi->environment)) ;
	res = v4is_Reformat(&pcb,&dpcb,NULL,FALSE,V4IS_Reformat_Silent|V4IS_Reformat_XDict|V4IS_Reformat_NoContPrompt) ;
	COPYJMP((gpi->environment),traceback) ;
	v4is_Close(&pcb) ; v4is_Close(&dpcb) ;
	if (res == UNUSED) { v_Msg(ctx,ctx->ErrorMsgAux,"V4ISRefErr",pcb.UCFileName,dpcb.UCFileName) ; return(FALSE) ; } ;
	return(TRUE) ;
}

/*	v4im_DoMakeIn() - Handles MakeIn() Module			*/

P *v4im_DoMakeIn(ctx,respnt,argcnt,argpnts,intmodx)
  struct V4C__Context *ctx ;
  P *respnt,*argpnts[] ;
  int argcnt,intmodx ;
{ struct V4DPI__DimInfo *di ;
  P *ipt,*vpt,*cpt,isctBuf ;
  P *imin, *in1, *in2, ddn, in2pnt ;
  INDEX ix ; LOGICAL ok ;
  
/*	First check out second element, may have to be evaluated */
	switch (argpnts[2]->PntType)
	 { default:			break ;
	   case V4DPI_PntType_Special:
	   case V4DPI_PntType_Isct:
	   case V4DPI_PntType_QIsct:
	   case V4DPI_PntType_BigIsct:
	     if ((ipt = v4dpi_IsctEval(&isctBuf,argpnts[2],ctx,V4DPI_EM_EvalQuote,NULL,NULL)) == NULL)
	      { v_Msg(ctx,ctx->ErrorMsgAux,"ModArgEval2",intmodx,argpnts[2]) ; return(NULL) ; } ;
	     argpnts[2] = ipt ; break ;
	 } ;
/*	respnt is going to be intersection made of three points: [IntMod:In dim.point point]	*/
	INITISCT(respnt) ; NOISCTVCD(respnt) ; respnt->Grouping = 3 ; respnt->NestedIsct = TRUE ; //respnt->Quoted = TRUE ;

	ipt = ISCT1STPNT(respnt) ;		/* First point is IntMod:In */
	dictPNTv(ipt,Dim_IntMod,V4IM_OpCode_In) ; ipt->PntType = V4DPI_PntType_IntMod ; respnt->Bytes += ipt->Bytes ; imin = ipt ;
	ADVPNT(ipt) ;				/* Second point */


/*	Start ddn point (going to be dim.name) */
	in1 = &ddn ;
	INITISCT(in1) ; NOISCTVCD(in1) ; in1->Grouping = 2 ; in1->NestedIsct = TRUE ;
	vpt = ISCT1STPNT(in1) ;	ZPH(vpt) ; vpt->PntType = V4DPI_PntType_Special ; vpt->Grouping = V4DPI_Grouping_Current ; vpt->Bytes = V4DPI_PointHdr_Bytes ;
	vpt->Dim = v4dpi_PointToDimId(ctx,argpnts[1],NULL,intmodx,1) ;		/* 1st point in in1 = dim* */
	if (vpt->Dim == UNUSED) return(NULL) ;
	in1->Bytes += vpt->Bytes ; ADVPNT(vpt) ;				/* vpt now going to be the second argument on NId dimension */
	

/*	If second argument is list assume format is (name relational value) */
	if (argpnts[2]->PntType == V4DPI_PntType_List)
	 { struct V4L__ListPoint *lp = v4im_VerifyList(NULL,ctx,argpnts[2],0) ;
	   if (SIZEofLIST(lp) != 3) { v_Msg(ctx,NULL,"DPINameVal",intmodx,argpnts[2]) ; return(NULL) ; } ;
	   v4l_ListPoint_Value(ctx,lp,1,&isctBuf) ; v4im_GetPointUC(&ok,UCTBUF1,V4TMBufMax,&isctBuf,ctx) ;
	   dictPNTv(vpt,Dim_NId,v4dpi_DictEntryGet(ctx,0,UCTBUF1,NULL,NULL)) ; in1->Bytes += vpt->Bytes ;
	   in2 = &in2pnt ; v4l_ListPoint_Value(ctx,lp,3,in2) ;			/* Value point is third element in list */
	   v4l_ListPoint_Value(ctx,lp,2,&isctBuf) ;
	   switch (v4im_GetDictToEnumVal(ctx,&isctBuf))
	    { default:
	      case DE(EQ):	break ;
	      case DE(LT):	in2->Grouping = V4DPI_Grouping_LT ; break ;
	      case DE(LE):	in2->Grouping = V4DPI_Grouping_LE ; break ;
	      case DE(GE):	in2->Grouping = V4DPI_Grouping_GE ; break ;
	      case DE(GT):	in2->Grouping = V4DPI_Grouping_GT ; break ;
	      case DE(NE):	in2->Grouping = V4DPI_Grouping_NE ; break ;
	    } ;
	 } else
	 { DIMINFO(di,ctx,argpnts[2]->Dim) ; dictPNTv(vpt,Dim_NId,v4dpi_DictEntryGet(ctx,0,di->DimName,di,NULL)) ; in1->Bytes += vpt->Bytes ;
	   in2 = argpnts[2] ;
	 } ;
/*	If second argument is string then invert the arguments */
	if (in2->PntType == V4DPI_PntType_Char || in2->PntType == V4DPI_PntType_UCChar)
	 { P *temp ;
	   switch (in2->Grouping)		/* Only allow = & <> if alpha */
	    { default:				v_Msg(ctx,NULL,"MakeInAlpha",intmodx,argpnts[2]) ; return(NULL) ;
	      case V4DPI_Grouping_Single:	break ;
	      case V4DPI_Grouping_NE:		imin->Value.IntVal = V4IM_OpCode_NIn ; break ;	/* Flip IntMod from In() to NIn() */
	    } ; in2->Grouping = V4DPI_Grouping_Single ;
	   temp = in1 ; in1 = in2 ; in2 = temp ;
	 } ;

	memcpy(ipt,in1,in1->Bytes) ; respnt->Bytes += ipt->Bytes ; ADVPNT(ipt) ;
	memcpy(ipt,in2,in2->Bytes) ; respnt->Bytes += ipt->Bytes ; ADVPNT(ipt) ;

#ifdef MOOOOOO
/*	If second argument is string the want to invert the argument */
	if (argpnts[2]->PntType == V4DPI_PntType_Char || argpnts[2]->PntType == V4DPI_PntType_UCChar)
	 { memcpy(ipt,argpnts[2],argpnts[2]->Bytes) ; respnt->Bytes += ipt->Bytes ; ADVPNT(ipt) ; } ;
	INITISCT(ipt) ; NOISCTVCD(ipt) ; ipt->Grouping = 2 ; vpt = ISCT1STPNT(ipt) ;		/* vpt is going to be dim* */
	ipt->NestedIsct = TRUE ;
	ZPH(vpt) ; vpt->PntType = V4DPI_PntType_Special ; vpt->Grouping = V4DPI_Grouping_Current ; vpt->Bytes = V4DPI_PointHdr_Bytes ;
	vpt->Dim = v4dpi_PointToDimId(ctx,argpnts[1],NULL,intmodx,1) ;
	if (vpt->Dim == UNUSED) return(NULL) ;
	ipt->Bytes += vpt->Bytes ; ADVPNT(vpt) ;						/* vpt now going to be the second argument on NId dimension */
	DIMINFO(di,ctx,argpnts[2]->Dim) ;
	dictPNTv(vpt,Dim_NId,v4dpi_DictEntryGet(ctx,0,di->DimName,NULL,NULL)) ;
	ipt->Bytes += vpt->Bytes ; respnt->Bytes += ipt->Bytes ;
	ADVPNT(ipt) ;				/* ipt now points to third point in primary isct */
	if (argpnts[2]->PntType != V4DPI_PntType_Char && argpnts[2]->PntType != V4DPI_PntType_UCChar)
	 { memcpy(ipt,argpnts[2],argpnts[2]->Bytes) ; respnt->Bytes += ipt->Bytes ; ADVPNT(ipt) ;
	 } ;
#endif

/*	Parse any tagged arguments */
	for(ix=3,ok=TRUE;ix<=argcnt&&ok;ix++)
	 { switch (v4im_CheckPtArgNew(ctx,argpnts[ix],&cpt,NULL))
	    { default:			v_Msg(ctx,NULL,"TagBadUse",intmodx) ; return(NULL) ;
	      case V4IM_Tag_Unk:	v_Msg(ctx,NULL,"TagUnknown",intmodx) ; return(NULL) ;
	      case V4IM_Tag_Fail:
		if (respnt->Bytes + cpt->Bytes >= sizeof *respnt)
		 { v_Msg(ctx,NULL,"ModArgMaxIsct",ix,respnt->Bytes,cpt->Bytes,sizeof *respnt) ; return(NULL) ; } ;
		memcpy(ipt,cpt,cpt->Bytes) ; respnt->Bytes += cpt->Bytes ;
		respnt->Continued = TRUE ;
		break ;
	    } ;
	 } ;
	if (!ok) { v_Msg(ctx,NULL,"ModInvArg",intmodx,ix-1) ; return(NULL) ; } ;
	return(respnt) ;
}



struct V4DPI__Point *v4im_DoMacro(ctx,respnt,argpnts,argcnt,intmodx,trace,isct)
  struct V4C__Context *ctx ;
  struct V4DPI__Point *respnt ;
  INTMODX intmodx ;
  P *argpnts[],*isct ;
  COUNTER argcnt ; VTRACE trace ;
{ P *cpt,apnt,tpnt ;
  struct V4L__ListPoint *lp ;
  struct V4LEX__MacroDirectory *vlmd ;
  UCCHAR macNameNC[V4LEX_Tkn_KeywordMax+1] ;
  LOGICAL ok ; INDEX ix,mx,tx ; DIMID dimId ;

	ZUS(macNameNC) ; dimId = UNUSED ;
	for(ix=1,ok=TRUE;ok&&ix<=argcnt;ix++)
	 { if (argpnts[ix]->PntType != V4DPI_PntType_TagVal && argpnts[ix]->Dim != Dim_Dim)
	    { v4im_GetPointUC(&ok,macNameNC,sizeof macNameNC,argpnts[ix],ctx) ;
	      continue ;
	    } ;
	   tx = v4im_CheckPtArgNew(ctx,argpnts[ix],&cpt,&apnt) ;
	   switch (tx)
	    { default:				v_Msg(ctx,NULL,"TagBadUse",intmodx) ; goto fail ;
	      case V4IM_Tag_Unk:		v_Msg(ctx,NULL,"TagUnknown",intmodx) ; goto fail ;
	      case -V4IM_Tag_Count:
		if (UCempty(macNameNC)) { v_Msg(ctx,NULL,"MacroNoName",intmodx) ; goto fail ; } ;
		UCSTRTOUPPER(macNameNC) ;
		vlmd = v4eval_GetMacroDir(ctx) ;
		for(mx=0;(vlmd!=NULL ? mx<vlmd->numEntries : FALSE);mx++)
		 { if (vlmd->macro[mx].macType != V4LEX_MACTYPE_Macro) continue ;
		   if (UCstrcmp(vlmd->macro[mx].macNameNC,macNameNC) == 0)
		    { intPNTv(respnt,(vlmd->macro[mx].vlme == NULL ? 0 : vlmd->macro[mx].vlme->refCount)) ;
		      return(respnt) ;
		    } ;
		 } ;
		v_Msg(ctx,NULL,"MacroNotFnd1",intmodx,macNameNC) ; goto fail ;
	      case V4IM_Tag_Dim:
		dimId = cpt->Value.IntVal ; break ;
	      case -V4IM_Tag_ListOf:
		if (UCempty(macNameNC))
		 { struct V4DPI__DimInfo *di ;
		   DIMINFO(di,ctx,Dim_NId) ; INITLP(respnt,lp,Dim_List) ;
		   vlmd = v4eval_GetMacroDir(ctx) ; if (vlmd == NULL) { ENDLP(respnt,lp) ; return(respnt) ; } ;
		   for(mx=0;mx<vlmd->numEntries;mx++)
		    { if (!(vlmd->macro[mx].macType == V4LEX_MACTYPE_Macro || vlmd->macro[mx].macType == V4LEX_MACTYPE_MIDAS)) continue ;
		      dictPNTv(&tpnt,Dim_NId,v4dpi_DictEntryGet(ctx,0,vlmd->macro[mx].macNameNC,di,0)) ; tpnt.Dim = (dimId == UNUSED ? Dim_UMacro : dimId) ;
		      if (!v4l_ListPoint_Modify(ctx,lp,V4L_ListAction_Append,&tpnt,0)) { v_Msg(ctx,NULL,"LPModFail",intmodx) ; goto fail ; } ;
		    } ;
	           ENDLP(respnt,lp) ; return(respnt) ;
	         } else 
	         { struct V4LEX__MacroEntry *vlme = v4eval_GetMacroEntry(ctx,macNameNC,V4LEX_MACTYPE_Macro) ;
	           struct V4LEX__MacroBody *vlmb ;
	           UCCHAR *sb, *eb ;
	           if (vlme == NULL) { v_Msg(ctx,NULL,"ModFailed2",intmodx) ; goto fail ; } ;
	           vlmb = (struct V4LEX__MacroBody *)&vlme->macData[vlme->bodyOffset] ;
		   INITLP(respnt,lp,Dim_List) ;
	           for(sb=vlmb->macBody;;sb=eb+1)
	            { eb = UCstrchr(sb,'\032') ; if (eb != NULL) *eb = UCEOS ;
	              uccharPNTv(&tpnt,sb) ;
		      if (!v4l_ListPoint_Modify(ctx,lp,V4L_ListAction_Append,&tpnt,0)) { v_Msg(ctx,NULL,"LPModFail",intmodx) ; goto fail ; } ;
	              if (eb == NULL) break ;
	              *eb = UClit('\032') ;
	            } ;
		   ENDLP(respnt,lp) ; return(respnt) ;
	         } ;
	      case V4IM_Tag_Macro:		v4im_GetPointUC(&ok,macNameNC,sizeof macNameNC,cpt,ctx) ; break ;
	    } ;
	} ;
	return(respnt) ;
fail:
	REGISTER_ERROR(0) ; return(NULL) ;
}



/*	v4im_DoDbg - Handles Dbg() module	*/

P *v4im_DoDbg(ctx,respnt,argpnts,argcnt,intmodx,trace)
  struct V4C__Context *ctx ;
  P *respnt,*argpnts[] ;
  int argcnt,intmodx,trace ;
{ 
  P *ipt,*cpt, argPnt, sPnt ; P *isctFail ;
  P *doPt, *ifPt, *retPt ;
  struct V4L__ListPoint *lp ;
  INDEX ix,lx ; LOGICAL ok ; COUNTER inum ; FLAGS32 traceFlag, bpFlags ; INTMODX bpIntMod ; COUNTER bpAfter ; LOGICAL bpAutoStep,wantBreak ;
  INDEX bpRelH,bpVCDIndex ; COUNTER bpLineNum ; TAGVAL tMode ;

/*	If called with no arguments then set immediate breakpoint */
	if (argcnt == 0)
	 { if(!v_IsAConsole(stdin))
	    { v_Msg(ctx,UCTBUF1,"DBGBreakIgn",intmodx) ; vout_UCText(VOUT_Warn,0,UCTBUF1) ; logPNTv(respnt,FALSE) ; return(respnt) ; } ;
	   if (gpi->bpl == NULL) v4dbg_bplInit() ;
	   INITBP(&gpi->bpl->vbp[gpi->bpl->Count]) ;
	   gpi->bpl->vbp[gpi->bpl->Count].bpFlags = (V4DBG_bpFlag_Default | V4DBG_bpFlag_OneTime) ;	/* Just set up unconditional one-time breakpoint */
	   gpi->bpl->vbp[gpi->bpl->Count].bpId = ++gpi->bpl->luId ; gpi->bpl->Count++ ;
/*	   Return the new breakpoint ID */
	   intPNTv(respnt,gpi->bpl->vbp[gpi->bpl->Count].bpId) ;
	   return(respnt) ;
	 } ;
	isctFail = NULL ; bpFlags = V4DBG_bpFlag_Default ; bpIntMod = UNUSED ; bpAfter = UNUSED ;
	bpLineNum = UNUSED ; bpRelH = UNUSED ; bpVCDIndex = UNUSED ; bpAutoStep = FALSE ; wantBreak = FALSE ; tMode = UNUSED ;
	doPt = NULL ; ifPt = NULL ; retPt = NULL ;
	for(ix=1,ok=TRUE;ok&&ix<=argcnt;ix++)
	 { switch (v4im_CheckPtArgNew(ctx,argpnts[ix],&cpt,&argPnt))
	    { default:			v_Msg(ctx,NULL,"TagBadUse",intmodx) ; goto fail ;
	      case V4IM_Tag_Unk:	v_Msg(ctx,NULL,"TagUnknown",intmodx) ; goto fail ;
	      case V4IM_Tag_Break:
		wantBreak = TRUE ;
		if (cpt->PntType == V4DPI_PntType_List)
	         { lp = v4im_VerifyList(NULL,ctx,cpt,intmodx) ;
	         } else { lp = NULL ; } ;
		for(lx=1;;lx++)
	         { if (lp != NULL)
	            { if (v4l_ListPoint_Value(ctx,lp,lx,&sPnt) <= 0) break ;
	              cpt = &sPnt ;
	            } ;
		   switch (v4im_GetDictToEnumVal(ctx,cpt))
		    { default:		v_Msg(ctx,NULL,"ModTagValue",intmodx,2,V4IM_Tag_Trace,cpt) ; goto fail ;
		      case _AutoStep:	bpAutoStep = TRUE ; break ;
		      case _Break:	bpFlags |= V4DBG_bpFlag_Break ; break ;
		      case _Context:	bpFlags |= V4DBG_bpFlag_Context ; break ;
		      case _Continue:	bpFlags &= ~(V4DBG_bpFlag_Break) ; break ;
		      case _Evaluations:bpFlags |= V4DBG_bpFlag_EvalCount ; break ;
		      case _Fail:	bpFlags &= ~V4DBG_bpFlag_DoNotEval ; bpFlags |= V4DBG_bpFlag_BreakOnFail ; break ;
		      case _Location:	bpFlags |= V4DBG_bpFlag_Loc ; break ;
		      case _Once:	bpFlags |= V4DBG_bpFlag_OneTime ; break ;
		      case _Point:	bpFlags |= V4DBG_bpFlag_Isct ; break ;
		      case _Results:	bpFlags |= V4DBG_bpFlag_EvalRes ; break ;
		      case _Silent:	bpFlags |= ~(V4DBG_bpFlag_Context | V4DBG_bpFlag_Stack | V4DBG_bpFlag_Loc) ; break ;
		      case _Skip:	bpFlags &= ~V4DBG_bpFlag_BreakOnFail ; bpFlags |= V4DBG_bpFlag_DoNotEval ; break ;
		      case _Stack:	bpFlags |= V4DBG_bpFlag_Stack ; break ;
		      case _Time:	bpFlags |= (V4DBG_bpFlag_WallCPU | V4DBG_bpFlag_DeltaWallCPU) ; break ;
		    } ; if (lp == NULL) break ;
		 } ;
		break ;
	      case -V4IM_Tag_Break:
		if (gpi->bpl == NULL) v4dbg_bplInit() ;
		INITBP(&gpi->bpl->vbp[gpi->bpl->Count]) ;
		gpi->bpl->vbp[gpi->bpl->Count].bpFlags = (V4DBG_bpFlag_Default | V4DBG_bpFlag_OneTime) ;
		gpi->bpl->Count++ ;		/* Just set up unconditional one-time breakpoint */
		return((P *)&Log_True) ;
	      case V4IM_Tag_Do:
		if (cpt->PntType != V4DPI_PntType_Isct) { v_Msg(ctx,NULL,"ModArgQIsct",intmodx,ix) ; goto fail ; } ;
		doPt = cpt ; break ;
	      case V4IM_Tag_Fail:
		if (cpt->PntType != V4DPI_PntType_Isct) { v_Msg(ctx,NULL,"ModArgQIsct",intmodx,ix) ; goto fail ; } ;
		isctFail = cpt ; break ;
	      case V4IM_Tag_If:
		if (cpt->PntType != V4DPI_PntType_Isct) { v_Msg(ctx,NULL,"ModArgQIsct",intmodx,ix) ; goto fail ; } ;
		ifPt = cpt ; break ;
	      case V4IM_Tag_Line:
		bpLineNum = v4im_GetPointInt(&ok,cpt,ctx) ;
		break ;
	      case V4IM_Tag_Log:
		inum = v4im_GetPointInt(&ok,cpt,ctx) ; if (!ok) break ;
		gpi->StartTraceOutput = inum ; traceGlobal |= V4TRACE_LogIscts ;
		break ;
	      case V4IM_Tag_Module:
		v4im_GetPointUC(&ok,UCTBUF1,V4TMBufMax,cpt,ctx) ; bpIntMod = v4im_Accept(UCTBUF1) ;
		if (bpIntMod <= 0) { v_Msg(ctx,NULL,"ModNoExist",intmodx,UCTBUF1) ; goto fail ; } ;
		break ;
	      case V4IM_Tag_Progress:
		inum = v4im_GetPointInt(&ok,cpt,ctx) ; if (!ok) break ;
		gpi->traceProgressMin = inum ; traceGlobal |= V4TRACE_Progress ;
		break ;
	      case V4IM_Tag_Delete:
	      case V4IM_Tag_Remove:
		{ INDEX i ; BRKPTID bpId = v4im_GetPointInt(&ok,cpt,ctx) ; if (!ok) break ;
		  if (gpi->bpl == NULL) { v_Msg(ctx,NULL,"DBGBPNotFnd1",intmodx,bpId) ; goto fail ; } ;
		  for(i=0;i<gpi->bpl->Count;i++) { if (gpi->bpl->vbp[i].bpId == bpId) break ; } ;
		  if (i >= gpi->bpl->Count) { v_Msg(ctx,NULL,"DBGBPNotFnd1",intmodx,bpId) ; goto fail ; } ;
		  for (;i<gpi->bpl->Count;i++) { gpi->bpl->vbp[i] = gpi->bpl->vbp[i+1] ; } ;
		}
		gpi->bpl->Count-- ;
		intPNTv(respnt,gpi->bpl->Count) ;
		return(respnt) ;
	      case V4IM_Tag_Return:
		if (cpt->PntType != V4DPI_PntType_Isct) { v_Msg(ctx,NULL,"ModArgQIsct",intmodx,ix) ; goto fail ; } ;
		retPt = cpt ; break ;
	      case V4IM_Tag_Source:
	      case V4IM_Tag_SourceFile:
		if (cpt->PntType == V4DPI_PntType_Int)
		 { struct V4LEX__CompileDir *vcd ; int sfx=0 ; LOGICAL gotSrc=FALSE ; COUNTER sfxBreak ;
		   sfxBreak = v4im_GetPointInt(&ok,cpt,ctx) ; if (!ok) break ;
		   for (bpRelH=gpi->HighHNum;(!gotSrc) && bpRelH>=gpi->LowHNum;bpRelH--)
		    { if (gpi->RelH[bpRelH].aid == UNUSED) continue ;
		      if ((vcd = v4trace_LoadVCDforHNum(ctx,bpRelH,FALSE)) == NULL) continue ;
		      for(bpVCDIndex=0;(!gotSrc)&& bpVCDIndex<vcd->fileCount;bpVCDIndex++)
		       { sfx++ ; 
			 if (sfx != sfxBreak) continue ;
			 if (gpi->bpl == NULL) v4dbg_bplInit() ;
			 if (vcd->File[bpVCDIndex].spwHash64 != 0 && vcd->File[bpVCDIndex].spwHash64 != gpi->spwHash64) break ;
			 gotSrc = TRUE ;
		       } ;
		    } ;
		   if (!gotSrc) { v_Msg(ctx,NULL,"DBGNoSrcFileX1",intmodx,sfxBreak) ; goto fail ; } ;
		 } else
		 { struct V4LEX__CompileDir *vcd ; int relh,sfx=0 ; INDEX i ; COUNTER numSrc=0 ;
		   v4im_GetPointUC(&ok,UCTBUF1,V4TMBufMax,cpt,ctx) ;
		   for (relh=gpi->HighHNum;relh>=gpi->LowHNum;relh--)
		    { if (gpi->RelH[relh].aid == UNUSED) continue ;
		      if ((vcd = v4trace_LoadVCDforHNum(ctx,relh,FALSE)) == NULL) continue ;
		      for(i=0;i<vcd->fileCount;i++)
		       { sfx++ ; 
			 if (vcd->File[i].spwHash64 != 0 && vcd->File[i].spwHash64 != gpi->spwHash64) continue ;
			 if (vuc_StrStrIC(vcd->File[i].fileName,UCTBUF1) == NULL) continue ;
			 numSrc++ ; bpRelH = relh ; bpVCDIndex = i ;
		       } ;
		    } ;
		   if (numSrc > 1)
		    { v_Msg(ctx,NULL,"DBGMultSrcFile1",intmodx,UCTBUF1) ; goto fail ; } ;
		   if (numSrc == 0) { v_Msg(ctx,NULL,"DBGNoSrcFile1",intmodx,UCTBUF1) ; goto fail ; } ;
		   if (gpi->bpl == NULL) v4dbg_bplInit() ;
		 } ;
		break ;
	      case V4IM_Tag_Trace:
//		if (!gotTrace) { gotTrace = TRUE ; traceFlag = 0 ; } ;
		tMode = V4IM_Tag_Set ;		/* Default to 0 */
//Set Reset Test
		if (cpt->PntType == V4DPI_PntType_TagVal)
		 { P *cpt1 ;
		   switch (tMode=v4im_CheckPtArgNew(ctx,cpt,&cpt1,&argPnt))
		    { default:			v_Msg(ctx,NULL,"TagBadUse",intmodx) ; goto fail ;
		      case V4IM_Tag_Unk:	v_Msg(ctx,NULL,"TagUnknown",intmodx) ; goto fail ;
		      case V4IM_Tag_Minus:
		      case V4IM_Tag_Plus:
		      case V4IM_Tag_Set:
		      case V4IM_Tag_Test:	cpt = cpt1 ; break ;
		    } ;
		 } ;
		if (cpt->PntType == V4DPI_PntType_List)
	         { lp = v4im_VerifyList(NULL,ctx,cpt,intmodx) ;
	         } else { lp = NULL ; } ;
		traceFlag = 0 ;
		for(lx=1;;lx++)
	         { if (lp != NULL)
	            { if (v4l_ListPoint_Value(ctx,lp,lx,&sPnt) <= 0) break ;
	              cpt = &sPnt ;
	            } ;
		   switch (v4im_GetDictToEnumVal(ctx,cpt))
		    { default:		v_Msg(ctx,NULL,"ModTagValue",intmodx,2,V4IM_Tag_Trace,cpt) ; goto fail ;
		      case _Dimension:
		      case _Dimensions:		if (gpi->vldd == NULL) { gpi->vldd = v4mm_AllocChunk(sizeof *gpi->vldd,FALSE) ; gpi->vldd->count = 0 ; gpi->vldd->vlddPrior = NULL ; } ;
						break ;
		      case _Log:		traceFlag |= V4TRACE_LogIscts ; gpi->StartTraceOutput = 0 ; break ;
		      case _NBLBindings:	traceFlag |= V4TRACE_BindList ; break ;
		      case _Compares:		traceFlag |= V4TRACE_PointCompare ; break ;
		      case _AddContext:		traceFlag |= V4TRACE_ContextAdd ; break ;
		      case _AutoContext:	traceFlag |= V4TRACE_AutoContext ; break ;
		      case _EvalPt:		traceFlag |= V4TRACE_EvalPt ; break ;
		      case _EvalToContext:	traceFlag |= V4TRACE_EvalToContext ; break ;
		      case _Tally:
		      case _Progress:		traceFlag |= V4TRACE_Progress ; gpi->traceProgressMin = 0 ; break ;
		      case _TallyBind:		traceFlag |= V4TRACE_TallyBind ; break ;
		      case _Bind:
		      case _Binding:		traceFlag |= V4TRACE_Bindings ; break ;
		      case _Macro:		traceFlag |= V4TRACE_Macros ; break ;
		      case _Lists:		traceFlag |= V4TRACE_Lists ; break ;
		      case _Frame:		traceFlag |= V4TRACE_Context ; break ;
		      case _Point:		traceFlag |= V4TRACE_Points ; break ;
		      case _BindEval:		traceFlag |= V4TRACE_BindEval ; break ;
		      case _Arith:		traceFlag |= V4TRACE_Arith ; break ;
		      case _V4IS:		traceFlag |= V4TRACE_V4IS ; break ;
		      case _IsctFail:		traceFlag |= V4TRACE_IsctFail ; break ;
		      case _Optimize:		traceFlag |= V4TRACE_Optimize ; break ;
		      case _All:		traceFlag |= 0xffffffff ; gpi->StartTraceOutput = 0 ; break ;
		      case _None:
		      case _Off:		traceFlag = 0 ; gpi->traceProgressMin = 0 ; gpi->StartTraceOutput = 0 ; break ;
		      case _XDB:		traceFlag |= V4TRACE_XDB ; break ;
		      case _ODBC:		traceFlag |= V4TRACE_XDB ; break ;
		      case _Errors:		traceFlag |= V4TRACE_Errors ; break ;
		      case _Recursion:		traceFlag |= V4TRACE_Recursion ; break ;
		      case _TimeStamp:		traceFlag |= V4TRACE_TimeStamp ; break ;
		    } ; if (lp == NULL) break ;
		 } ;
		switch (tMode)
		 { case V4IM_Tag_Minus:		traceFlag = (traceGlobal & ~traceFlag) ; break ;	/* Turn off requested options */
		   case V4IM_Tag_Plus:		traceFlag |= traceGlobal ;				/* Add in requested options */
		   case V4IM_Tag_Set:		break ;							/* Take what was given */
		   case V4IM_Tag_Test:		logPNTv(respnt,((traceGlobal & traceFlag) == traceFlag)) ;
						return(respnt) ;					/* Test for specified flags */
		 } ;
		break ;
	      case V4IM_Tag_Value:
		if (cpt->PntType != V4DPI_PntType_Isct) { v_Msg(ctx,NULL,"ModArgQIsct",intmodx,ix) ; goto fail ; } ;
		retPt = cpt ; break ;
	      case V4IM_Tag_Web:
		if (cpt->PntType != V4DPI_PntType_List)
		 { v_Msg(ctx,NULL,"ModArgPntType2",intmodx,lx,cpt->PntType,V4DPI_PntType_List) ; goto fail ; } ;
		{ struct V4L__ListPoint *lp = v4im_VerifyList(NULL,ctx,cpt,0) ; int id,port ; UCCHAR host[256] ; struct V4Msg_Listener *vml ; USESKEY sesKey ;
		  if (v4l_ListPoint_Value(ctx,lp,V4L_ListSize,NULL) != 4)
		   { v_Msg(ctx,NULL,"DBGWebArgs",intmodx,cpt) ; goto fail ; } ;
		  v4l_ListPoint_Value(ctx,lp,1,&sPnt) ; id = v4im_GetPointInt(&ok,&sPnt,ctx) ; if (!ok) break ;
		  v4l_ListPoint_Value(ctx,lp,2,&sPnt) ; v4im_GetPointUC(&ok,host,UCsizeof(host),&sPnt,ctx) ; if (!ok) break ;
		  v4l_ListPoint_Value(ctx,lp,3,&sPnt) ; port = v4im_GetPointInt(&ok,&sPnt,ctx) ; if (!ok) break ;
		  v4l_ListPoint_Value(ctx,lp,4,&sPnt) ;  v4im_GetPointUC(&ok,sesKey,UCsizeof(sesKey),&sPnt,ctx) ; if (!ok) break ;
		  for(vml=gpi->vml;vml!=NULL;vml=vml->vmlNext)
		   { if (vml->uId == id) break ; } ;
		  if (vml == NULL)
		   { v_Msg(ctx,NULL,"MessageNoLstnr",intmodx,id) ; goto fail ; } ;
		  ix++ ; gpi->lIdDebug = id ;
		  gpi->breakOnEval = TRUE ;		/* Break on next eval */
		  gpi->portDebug = port ; UCstrcpy(gpi->hostDebug,host) ; UCstrcpy(gpi->sesKeyDebug,sesKey) ;
		}
		break ;
	    } ;
	 } ;
	if (!ok) { v_Msg(ctx,NULL,"ModInvArg",intmodx,ix-1) ; return(NULL) ; } ;
/*	Setting a breakpoint ? */
	if (wantBreak)
	 { struct V4DBG__BreakPoint *vbp ;
	   if (bpRelH == UNUSED != bpLineNum == UNUSED) { v_Msg(ctx,NULL,"DBGBPMissInfo",intmodx,V4IM_Tag_Break,V4IM_Tag_SourceFile) ; goto fail ; } ;
	   if (gpi->bpl == NULL) v4dbg_bplInit() ;
	   if (gpi->bpl->Count >= V4DBG_Breakpoint_Max) { v_Msg(ctx,NULL,"DBGBPMax1",intmodx,V4DBG_Breakpoint_Max) ; goto fail ; } ;
	   vbp = &gpi->bpl->vbp[gpi->bpl->Count] ; INITBP(vbp) ;
	   vbp->bpFlags = bpFlags ;
/*	   If no source/line number then set immediate break */
	   if (bpRelH != UNUSED) { gpi->bpl->visSource.c.HNum = bpRelH ; gpi->bpl->visSource.c.vcdIndex = bpVCDIndex ; }
	    else { vbp->bpFlags |= V4DBG_bpFlag_OneTime ; } ;
	   if (bpRelH != UNUSED) { vbp->vis = gpi->bpl->visSource ; vbp->vis.c.lineNumber = bpLineNum * 10 ; } ;
	   if (doPt != NULL) { vbp->evalPt = (P *)v4mm_AllocChunk(doPt->Bytes,FALSE) ; memcpy(vbp->evalPt,doPt,doPt->Bytes) ; } ;
	   if (ifPt != NULL) { vbp->condPt = (P *)v4mm_AllocChunk(ifPt->Bytes,FALSE) ; memcpy(vbp->condPt,ifPt,ifPt->Bytes) ; } ;
	   if (retPt != NULL) { vbp->resPt = (P *)v4mm_AllocChunk(retPt->Bytes,FALSE) ; memcpy(vbp->resPt,retPt,retPt->Bytes) ; } ;
	   if (bpIntMod != UNUSED) vbp->intmodX = bpIntMod ;
	   if (bpAfter != UNUSED) { vbp->isctEvals = bpAfter ; vbp->bpFlags |= V4DBG_bpFlag_OneTime ; } ;
	   if (bpAutoStep)
	    { vbp->lineNumber = 0 ; vbp->rtStackX = ctx->rtStackX - 1 ; } ;
	   vbp->bpId = ++gpi->bpl->luId ; gpi->bpl->Count++ ;
/*	   Return the new breakpoint ID */
	   intPNTv(respnt,vbp->bpId) ;
	   return(respnt) ;
	 } ;

/*	We got an intersection to evaluate. Trace it? or maybe traceFlag it if it fails? */
	if (doPt != NULL)
	 { VTRACE traceSave = traceGlobal ;
	   traceGlobal = (tMode != UNUSED ? traceFlag : 0) ;
	     ipt = v4dpi_IsctEval(respnt,doPt,ctx,V4DPI_EM_EvalQuote,NULL,NULL) ;
	   traceGlobal = traceSave ;
	   if (ipt == NULL) { v_Msg(ctx,NULL,"ModArgEval2",intmodx,cpt) ; goto fail ; } ;
	   return(ipt) ;
	 } else if (isctFail != NULL)
	 { ipt = v4dpi_IsctEval(respnt,isctFail,ctx,V4DPI_EM_EvalQuote,NULL,NULL) ;
	   if (ipt == NULL)
	    { VTRACE traceSave = traceGlobal ;
	      traceGlobal = (tMode != UNUSED ? traceFlag : 0) ;
	        v4dpi_IsctEval(respnt,isctFail,ctx,V4DPI_EM_EvalQuote,NULL,NULL) ;
	      traceGlobal = traceSave ;
	      v_Msg(ctx,NULL,"ModArgEval2",intmodx,cpt) ; goto fail ;
	    } ;
	   return(ipt) ;
	 } ;
/*	If we got an update on tracing then do it */
	if (tMode != UNUSED) traceGlobal = traceFlag ;
	logPNTv(respnt,TRUE) ;
	return(respnt) ;

fail:
	REGISTER_ERROR(0) ; return(NULL) ;
}


P *v4im_DoMakeT(ctx,respnt,argpnts,argcnt,intmodx,trace)
  struct V4C__Context *ctx ;
  P *respnt,*argpnts[] ;
  int argcnt,intmodx,trace ;
{ 
  P *failPt,*cpt,*tpt ;
  INDEX ix,firstX ; COUNTER num,bytes ;

	failPt = NULL ; firstX = UNUSED ;
/*	Count significant arguments and handle any tags */
	for(num=0,ix=2;ix<=argcnt;ix++)
	 { 
	   if (memcmp(argpnts[ix],&protoNone,V4PS_Int) == 0 || memcmp(argpnts[ix],&protoQNone,V4PS_Int) == 0) continue ;	/* Don't include UV4:none point */
	   if (argpnts[ix]->PntType != V4DPI_PntType_TagVal)
	    { num++ ; if (firstX == UNUSED) firstX = ix ; continue ; } ;
	   switch (v4im_CheckPtArgNew(ctx,argpnts[ix],&cpt,NULL))
	    { default:			v_Msg(ctx,NULL,"TagBadUse",intmodx) ; return(NULL) ;
	      case V4IM_Tag_Unk:	v_Msg(ctx,NULL,"TagUnknown",intmodx) ; return(NULL) ;
	      case V4IM_Tag_Fail:	failPt = cpt ; break ;
	    } ;
	 } ;
/*	num = number of 'real' arguments */
	if (num < 1)					/* If no arguments then return TRUE */
	 { logPNTv(respnt,TRUE) ; return(respnt) ; } ;
	if (num == 1)					/* If only one real argument then just return it */
	 { memcpy(respnt,argpnts[firstX],argpnts[firstX]->Bytes) ;
	   if (failPt != NULL)				/* Have a fail? */
	    { if (respnt->Bytes + failPt->Bytes > V4DPI_AlphaVal_Max)
	       { v_Msg(ctx,NULL,"ModArgMaxIsctF",intmodx,failPt,respnt->Bytes,failPt->Bytes,V4DPI_AlphaVal_Max) ; return(NULL) ; } ;
	      respnt->Continued = TRUE ; memcpy((char *)respnt+respnt->Bytes,failPt,failPt->Bytes) ; respnt->Bytes += failPt->Bytes ;
	    } ;
	   return(respnt) ;
	 } ;
/*	Construct the test */
	respnt = respnt ; INITISCT(respnt) ; NOISCTVCD(respnt) ; tpt = ISCT1STPNT(respnt) ; bytes = 0 ;
	for(ix=1;ix<=argcnt;ix++)
	 { 
	   if (memcmp(argpnts[ix],&protoNone,V4PS_Int) == 0) continue ;	/* Don't include UV4:none point */
	   if (memcmp(argpnts[ix],&protoQNone,V4PS_Int) == 0) { UNQUOTE(argpnts[ix]) ; } ;
	   if (argpnts[ix]->PntType == V4DPI_PntType_TagVal) continue ;	/* Tags already handled above */
	   bytes += argpnts[ix]->Bytes ;
	   if (bytes > V4DPI_AlphaVal_Max)
	    { v_Msg(ctx,NULL,"ModArgMaxIsct",intmodx,ix,bytes-argpnts[ix]->Bytes,argpnts[ix]->Bytes,V4DPI_AlphaVal_Max) ; return(NULL) ; } ;
	   memcpy(tpt,argpnts[ix],argpnts[ix]->Bytes) ;	/* Append points in argument list to new isct */
	   if (ix <= 2 ? FALSE : TRUE) { QUOTE(tpt) ; } else { UNQUOTE(tpt) ; } ;
	   ADVPNT(tpt) ; respnt->Grouping ++ ;
	   ISCTSETNESTED(respnt,argpnts[ix]) ;
	 } ;
	ISCTLEN(respnt,tpt) ;
	if (failPt != NULL)				/* Have a fail? */
	 { if (respnt->Bytes + failPt->Bytes > V4DPI_AlphaVal_Max)
	    { v_Msg(ctx,NULL,"ModArgMaxIsctF",intmodx,respnt->Bytes,failPt->Bytes,V4DPI_AlphaVal_Max) ; return(NULL) ; } ;
	   respnt->Continued = TRUE ; memcpy((char *)respnt+respnt->Bytes,failPt,failPt->Bytes) ; respnt->Bytes += failPt->Bytes ;
	 } ;
	return(respnt) ;
}

//#define MAX_XARGS 32
//  struct lcl__SummaryInfo {
//    UCCHAR jobId[64] ;
//    UCCHAR module[64] ;
//    USESKEY sesKey ;
//    UCCHAR userName[64] ;
//    UCCHAR ipAddress[64] ;
//    COUNTER xArgs ;
//    UDTVAL udtLast ;
//    double cpuLast,conLast ;
//    COUNTER ctxCLast,evalCLast,errCLast ;
//    P *xaPnt[MAX_XARGS] ;
//   } ; static struct lcl__SummaryInfo *lsi = NULL ;
//
//void v4im_DoSummaryOutput(ctx,respnt,delta,text)
//  struct V4C__Context *ctx ;
//  P *respnt ;
//  LOGICAL delta ;
//  UCCHAR *text ;
//{ UCCHAR buf[8192] ; INDEX ix ;
//  UDTVAL udt ; double cpu,con ; COUNTER ctxC,evalC,errC ;
//
//#define LSIARG(name) UCstrcat(buf,lsi->name) ; UCstrcat(buf,UClit("\t")) ;
//	ZUS(buf) ;
//	if (lsi != NULL)
//	 { LSIARG(jobId) LSIARG(module) LSIARG(sesKey) LSIARG(userName) LSIARG(ipAddress)
//	   if (lsi->xArgs > 0)
//	    { UCstrcat(buf,UClit("\t(")) ;
//	      for(ix=0;ix<lsi->xArgs;ix++)
//	       { UCCHAR pbuf[V4DPI_UCVal_Max] ;
//	         if (ix > 0) UCstrcat(buf,UClit(" ")) ;
//	         v4dpi_PointToStringML(pbuf,lsi->xaPnt[ix],ctx,V4DPI_FormatOpt_Point,V4DPI_UCVal_Max-32) ;
//	         UCstrcat(buf,pbuf) ;
//	       } ;
//	      UCstrcat(buf,UClit(")")) ;
//	    } ;
//	 } ;
//	if (text != NULL) { UCstrcat(buf,UClit("\t")) ; UCstrcat(buf,text) ; } ;
//	udt = valUDTisNOW ; cpu = v_CPUTime() ; con = v_ConnectTime() ; ctxC = (ctx == NULL ? 0 : ctx->ContextAddCount) ; evalC = (ctx == NULL ? 0 : ctx->IsctEvalCount) ; errC = gpi->ErrCount ;
//#define SD(VAR) (VAR - lsi->VAR ## Last)
//#define SD2(VAR) lsi->VAR ## Last = VAR ;
//	if (delta)
//	 { v_Msg(ctx,UCTBUF1,"@%1s%2d\t%3g\t%4g\t%5d\t%6d\t%7d\t%8U",	  
//		V4_DeltaPrefix,udt,SD(cpu),SD(con),SD(ctxC),SD(evalC),SD(errC),buf) ;
//	   SD2(cpu) SD2(con) SD2(ctxC) SD2(evalC) SD2(errC)
//	 } else
//	 { v_Msg(ctx,UCTBUF1,"@%1s%2d\t%3g\t%4g\t%5d\t%6d\t%7d\t%8U",	  
//		V4_SummaryPrefix,udt,cpu,con,ctxC,evalC,errC,buf) ;
//	 } ;
//	if (respnt == NULL) { vout_UCText(VOUT_Trace,0,UCTBUF1) ; vout_NL(VOUT_Trace) ; }
//	 else { uccharPNTv(respnt,UCTBUF1) ; } ;
//}
//
//P *v4im_DoSummary(ctx,respnt,argpnts,argcnt,intmodx,trace)
//  struct V4C__Context *ctx ;
//  P *respnt,*argpnts[] ;
//  int argcnt,intmodx,trace ;
//{ 
//  INDEX ix ; LOGICAL ok ; UCCHAR text[V4LEX_BigText_Max] ;
//  P *cpt,pnt ;
//
//	if (lsi == NULL) lsi = (struct lcl__SummaryInfo *)v4mm_AllocChunk(sizeof *lsi,TRUE) ;
//	ZUS(text) ;
//	if (argcnt == 0)			/* If no arguments then return summary status line as string */
//	 { v4im_DoSummaryOutput(ctx,respnt,TRUE,NULL) ; return(respnt) ; } ;
//	for(ix=1,ok=TRUE;ok&&ix<=argcnt;ix++)
//	 { if (memcmp(argpnts[ix],&protoNone,V4PS_Int) == 0 || memcmp(argpnts[ix],&protoQNone,V4PS_Int) == 0) continue ;
//	   if (argpnts[ix]->PntType != V4DPI_PntType_TagVal)
//	    { if (lsi->xArgs >= MAX_XARGS) { v_Msg(ctx,NULL,"V4SpecADEntry",intmodx,MAX_XARGS) ; goto fail ; } ;
//	      lsi->xaPnt[lsi->xArgs] = (P *)v4mm_AllocChunk(argpnts[ix]->Bytes,FALSE) ; memcpy(lsi->xaPnt[lsi->xArgs],argpnts[ix],argpnts[ix]->Bytes) ;
//	      lsi->xArgs++ ; continue ;
//	    } ;
//	   switch (v4im_CheckPtArgNew(ctx,argpnts[ix],&cpt,&pnt))
//	    { default:			v_Msg(ctx,NULL,"TagBadUse",intmodx) ; goto fail ;
//	      case V4IM_Tag_Unk:	v_Msg(ctx,NULL,"TagUnknown",intmodx) ; goto fail ;
//	      case V4IM_Tag_IPAddress:	v4im_GetPointUC(&ok,lsi->ipAddress,sizeof lsi->ipAddress,cpt,ctx) ; break ;
//	      case V4IM_Tag_Job:	v4im_GetPointUC(&ok,lsi->jobId,sizeof lsi->jobId,cpt,ctx) ; break ;
//	      case V4IM_Tag_Module:	v4im_GetPointUC(&ok,lsi->module,sizeof lsi->module,cpt,ctx) ; break ;
//	      case V4IM_Tag_Session:	v4im_GetPointUC(&ok,lsi->sesKey,sizeof lsi->sesKey,cpt,ctx) ; break ;
//	      case V4IM_Tag_Text:	v4im_GetPointUC(&ok,text,V4LEX_BigText_Max,cpt,ctx) ; break ;
//	      case V4IM_Tag_User:	v4im_GetPointUC(&ok,lsi->userName,sizeof lsi->userName,cpt,ctx) ; break ;
//	    } ;
//	 } ;
//	if (!ok) { v_Msg(ctx,NULL,"ModInvArg",intmodx,ix-1) ; goto fail ; } ;
//	if (UCnotempty(text)) { v4im_DoSummaryOutput(ctx,NULL,TRUE,text) ; } ;
//	logPNTv(respnt,TRUE) ;
//	return(respnt) ;
//
//fail:	return(NULL) ;
//}
